let
// todo –°–¥–µ–ª–∞—Ç—å —Ç–∏–ø —Ñ—É–Ω–∫—Ü–∏–π Extract - –±—É–¥–µ—Ç –∏–∑–≤–ª–µ–∫–∞—Ç—å –∏–∑ —Ç–µ–∫—Å—Ç–∞ –Ω–∞–ø—Ä–∏–º–µ—Ä: –î–∞—Ç—ã, –§–∞–º–∏–ª–∏–∏, ... (–∫—É–¥–∞ –∏–∑–≤–ª–µ–∫–∞—Ç—å, –≤ –Ω–æ–≤—É—é –∫–æ–ª–æ–Ω–∫—É –∏–ª–∏ –æ—Å—Ç–∞–≤–ª—è—Ç—å —Ç—É—Ç)
// —Ç—É—Ç, –¥–ª—è –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏ —Å–æ—Å–ª–∞—Ç—å—Å—è –Ω–∞ —Ñ—É–Ω–∫—Ü–∏—é –∏–∑ —ç—Ç–æ–π –±–∏–±–ª–∏–æ—Ç–µ–∫–∏, –Ω–æ —Å –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å—é –≤—Å—Ç–∞–≤–∫–∏ –∫–æ–¥–∞ –≤ –ø—Ä–æ–µ–∫—Ç
//	= let path = "G:\=EXCEL BI - –º–æ–∏ –ø—Ä–æ–µ–∫—Ç—ã\= PQ - –±–∞–∑–∞ –∑–Ω–∞–Ω–∏–π =\F.pq" in 	Expression.Evaluate(Text.FromBinary(File.Contents(path)), #shared)
// 	F = Expression.Evaluate(Text.FromBinary(Binary.Buffer(Web.Contents("https://raw.githubusercontent.com/Medvedevav632/PQ_function/main/" & "F.pq"))), #shared)
	F      	= let path = "G:\=EXCEL BI - –º–æ–∏ –ø—Ä–æ–µ–∫—Ç—ã\= PQ - –±–∞–∑–∞ –∑–Ω–∞–Ω–∏–π =\F.pq" 
			  in 	Expression.Evaluate(Text.FromBinary(File.Contents(path)), #shared),
	F_Form 	= let path = "G:\=EXCEL BI - –º–æ–∏ –ø—Ä–æ–µ–∫—Ç—ã\2024.01 - –ê–Ω–∞–ª–∏–∑ –û—Ç—á–µ—Ç–Ω–æ—Å—Ç–∏\2. PQ –∑–∞–ø—Ä–æ—Å—ã\F_Form.pq" 
			  in Expression.Evaluate(Text.FromBinary(File.Contents(path)), #shared),	

–ü–∞—Ä–∞–º–µ—Ç—Ä—ã = [ //  
	GetParam       = // —É–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è. –ù–æ –∏ –≤ –¥—Ä—É–≥–∏—Ö —Ç–æ–∂–µ –µ—â–µ –µ—Å—Ç—å –ø–æ–ª–µ–∑–Ω—ã–µ –º–æ–º–µ–Ω—Ç—ã
		/*
			–û–ø–∏—Å–∞–Ω–∏–µ:
				–§—É–Ω–∫—Ü–∏—è –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –∏–∑ —Ç–∞–±–ª–∏—Ü—ã –Ω–∞ –ª–∏—Å—Ç–µ —Ñ–∞–π–ª–∞ Excel.
				–¢–∞–±–ª–∏—Ü–∞ –¥–æ–ª–∂–Ω–∞ –∏–º–µ—Ç—å –∏–º—è "Parameters", –∞ –∫–æ–ª–æ–Ω–∫–∏ "Parameter" –∏ "Value"

			–ê–ª–≥–æ—Ä–∏—Ç–º:
				–ë–µ–∑–æ–ø–∞—Å–Ω–æ –ø–æ–ª—É—á–∞–µ–º —Ç–∞–±–ª–∏—Ü—É –ø–æ –∏–º–µ–Ω–∏. –ï—Å–ª–∏ —Ç–∞–±–ª–∏—Ü–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞, –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç—Å—è null
				–ò—â–µ–º —Å—Ç—Ä–æ–∫—É, –≥–¥–µ –∑–Ω–∞—á–µ–Ω–∏–µ –≤ —Å—Ç–æ–ª–±—Ü–µ ParamColumn —Ä–∞–≤–Ω–æ parameterName
				–ï—Å–ª–∏ —Å—Ç—Ä–æ–∫–∞ –Ω–∞–π–¥–µ–Ω–∞, –∏–∑–≤–ª–µ–∫–∞–µ—Ç—Å—è –∑–Ω–∞—á–µ–Ω–∏–µ –∏–∑ —Å—Ç–æ–ª–±—Ü–∞ ValColumn
				–ï—Å–ª–∏ —Ç–∞–±–ª–∏—Ü–∞ –∏–ª–∏ —Å—Ç—Ä–æ–∫–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã, –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç—Å—è null

			–ü—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–∞:
				–ì–∏–±–∫–æ—Å—Ç—å 		–ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç –Ω–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º—ã–µ –∏–º–µ–Ω–∞ —Ç–∞–±–ª–∏—Ü –∏ —Å—Ç–æ–ª–±—Ü–æ–≤
				–ù–∞–¥–µ–∂–Ω–æ—Å—Ç—å 		–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç —Å–ª—É—á–∞–∏, –∫–æ–≥–¥–∞ —Ç–∞–±–ª–∏—Ü–∞ –∏–ª–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä –Ω–µ –Ω–∞–π–¥–µ–Ω—ã
				–ö–æ—Ä—Ä–µ–∫—Ç–Ω–æ—Å—Ç—å	–ò—Å–ø–æ–ª—å–∑—É–µ—Ç –≤—Å–µ –ø–µ—Ä–µ–¥–∞–Ω–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã, –≤–∫–ª—é—á–∞—è ValColumn
				–ü—Ä–æ—Å—Ç–æ—Ç–∞		–õ–æ–≥–∏–∫–∞ —Ñ—É–Ω–∫—Ü–∏–∏ –æ—Å—Ç–∞–ª–∞—Å—å –ø—Ä–æ—Å—Ç–æ–π –∏ –ø–æ–Ω—è—Ç–Ω–æ–π

			–ü—Ä–∏–º–µ—Ä 1: –≤—Å–µ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
				let
					FolderPath  = GetParam("FolderPath"),  // –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç "C:\Projects"
					FileName    = GetParam("FileName"),    // –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç "data.xlsx"
					NonExistent = GetParam("NonExistent")  // –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç null
				in
					[FolderPath = FolderPath, FileName = FileName, NonExistent = NonExistent]
			
			–ü—Ä–∏–º–µ—Ä 2: —Å–≤–æ–∏ –Ω–∞–∑–≤–∞–Ω–∏—è
				to = GetParam("ParameterName", "MyTable", "MyParameterColumn", "MyValueColumn") */

		(	parameterName as text,              // –ò–º—è –ø–∞—Ä–∞–º–µ—Ç—Ä–∞, –∫–æ—Ç–æ—Ä—ã–π –Ω—É–∂–Ω–æ –Ω–∞–π—Ç–∏
			optional tableName as text,         // –ò–º—è —Ç–∞–±–ª–∏—Ü—ã 				 (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é "Parameters")
			optional parameterColumn as text,   // –ò–º—è —Å—Ç–æ–ª–±—Ü–∞ —Å –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏ (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é "Parameter")
			optional valueColumn as text        // –ò–º—è —Å—Ç–æ–ª–±—Ü–∞ —Å–æ –∑–Ω–∞—á–µ–Ω–∏—è–º–∏ (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é "Value")
		) as any =>
		let
			// 	–£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∑–Ω–∞—á–µ–Ω–∏—è –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
				TABLE_NAME 	 = tableName 	  ?? "Parameters",
				PARAM_COLUMN = parameterColumn ?? "Parameter",
				VALUE_COLUMN = valueColumn 	  ?? "Value",

			// 	–ü–æ–ª—É—á–∞–µ–º —Ç–∞–±–ª–∏—Ü—É —Å –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏ (–∏—Å–ø–æ–ª—å–∑—É–µ–º ? –¥–ª—è –±–µ–∑–æ–ø–∞—Å–Ω–æ–≥–æ –¥–æ—Å—Ç—É–ø–∞)
				ParamTable = Excel.CurrentWorkbook() {[Name=TABLE_NAME]}? [Content],

			// 	–ò—â–µ–º —Å—Ç—Ä–æ–∫—É —Å –Ω—É–∂–Ω—ã–º –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–º
				ParamRow = 	if ParamTable is null 
							then null
							else Table.SelectRows(ParamTable, each Record.Field(_, PARAM_COLUMN) = parameterName),

			// 	–í–æ–∑–≤—Ä–∞—â–∞–µ–º –∑–Ω–∞—á–µ–Ω–∏–µ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ –∏–ª–∏ null, –µ—Å–ª–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä –Ω–µ –Ω–∞–π–¥–µ–Ω
				Value = if ParamRow is null or Table.IsEmpty(ParamRow) 
						then null
						else Record.Field(ParamRow{0}, VALUE_COLUMN) // –í–æ–∑–≤—Ä–∞—â–∞–µ–º –∑–Ω–∞—á–µ–Ω–∏–µ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ –∏–∑ –∫–æ–ª–æ–Ω–∫–∏ ValColumn
						// else Record.FieldValues(ParamRow{0}){1}   // –í–æ–∑–≤—Ä–∞—â–∞–µ–º –∑–Ω–∞—á–µ–Ω–∏–µ –∏–∑ –≤—Ç–æ—Ä–æ–≥–æ —Å—Ç–æ–ª–±—Ü–∞
			in
				Value,
	
	GetParameter   = // –ü–æ–ª—É—á–∏—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ –∏–∑ —Ç–∞–±–ª–∏—Ü—ã Parameters (–∫–æ–ª–æ–Ω–∫–∏: {"Parameter", "Value"})
		( getValue as text ) =>
			let
				ParamTable = Excel.CurrentWorkbook(){[Name="Parameters"]}[Content],
				Result 	   = ParamTable{[Parameter=getValue]}?[Value]?
			in
				Result,
	
	Read.Parameter = // –ü–æ–ª—É—á–∏—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ –∏–∑ —Ç–∞–±–ª–∏—Ü—ã –¥–∞–Ω–Ω—ã—Ö –≤ —Ç–µ–∫—É—â–µ–π –∫–Ω–∏–≥–µ
		/*
			! —á—Ç–æ —Ç–æ –Ω–µ —Ç–æ.
			–ü–æ–ª—É—á–∏—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ –∏–∑ —Ç–∞–±–ª–∏—Ü—ã –¥–∞–Ω–Ω—ã—Ö –≤ —Ç–µ–∫—É—â–µ–π –∫–Ω–∏–≥–µ
			–ü–∞—Ä–∞–º–µ—Ç—Ä—ã –¥–æ–ª–∂–Ω—ã —Ö—Ä–∞–Ω–∏—Ç—å—Å—è –≤ —Ç–∞–±–ª–∏—Ü–µ –¥–∞–Ω–Ω—ã—Ö —Å –¥–≤—É–º—è —Å—Ç–æ–ª–±—Ü–∞–º–∏ (–ø–∞—Ä—ã –∫–ª—é—á-–∑–Ω–∞—á–µ–Ω–∏–µ)
		*/
		(parameter as text, optional tablename as text) => 
			let
				/* 	–ò–º—è —Ç–∞–±–ª–∏—Ü—ã –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é */
					ParameterTable = if tablename is null then "–ü–∞—Ä–∞–º–µ—Ç—Ä—ã" else tablename,

				/* 	–ü–æ–ª—É—á–∏—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ */
					Source 		= Excel.CurrentWorkbook(){[Name=ParameterTable]}[Content],
					Transposed  = Table.Transpose(Source),
					Headers 	= Table.PromoteHeaders(Transposed, [PromoteAllScalars=true])
			in
				Table.Column(Headers, parameter){0},
	
	fnGetParameter = // –¥–µ–ª–∞–µ—Ç –≤ excel —É–º–Ω—É—é —Ç–∞–±–ª–∏—Ü—É —Å –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏: Folder Path, File Path, File Name
		/* 
			For more information, Or to purchase a copy of this add-in, visit https://monkeytools.ca
			Original source can be found at the following URL:
			http://www.excelguru.ca/blog/2014/11/26/building-a-parameter-table-for-power-query/

			=fnGetParameter("your_parameter_name")

			One useful sample to return the current folder:
			Parameter Name: File Path
			Parameter Value: =LEFT(CELL("filename",A1),FIND("[",CELL("filename",A1),1)-1)
			Call as  "fnGetParamater("File Path")
		*/
		let
			fnGetParameter     = (ParameterName as text) as any =>
				let
					ParamSource = Excel.CurrentWorkbook(){[Name="XLGQuery_Parameters"]}[Content],
					ParamRow    = Table.SelectRows(ParamSource, each (Text.From([Parameter])=ParameterName)),
					Value       = 	if Table.IsEmpty(ParamRow)=true
									then null
									else Record.Field(ParamRow{0},"Value")
				in
					Value,
			
			fnDocumentation    = 
				type function (
					ParameterName as ( type any meta [	Documentation.FieldCaption = "ParameterName", Documentation.SampleValues = "{}" ] )
				)
				as text meta [
					Documentation.Name = "fnGetParameter",
					Documentation.MTVersion = 2.2,
					Documentation.LongDescription = "This function looks up the provided value in the XLGQuery_Parameters table in your workbook, and returns the matching value.<br><br>"&
						"<b>NOTE:</b> If you are planning to integrate this into an existing query, we highly recommend you edit your M code and make your fnGetParameter call the first "&
						"step in your query. This will avoid potential formula firewall conflicts later.<br><br>"&
						"To learn more about how this function works, see https://monkeytools.ca/parameter-table-and-function/"
					,
					Documentation.Examples = {
						[   Description= "Assuming you have the text <i>Folder Path</i> in the Parameter column of your table, and it shows a Value of <i>C:\MyData\Sales\</i>, you would call this function as follows:",
							Code = "=fnGetParameter(""Folder Path"")",
							Result = "C:\MyData\Sales\"
						]}
				],
			DocumentedFunction = Value.ReplaceType( fnGetParameter,fnDocumentation)
		in
			DocumentedFunction		
	
	],

FinReport = [ // –æ—Å–æ–±–µ–Ω–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ –¥–ª—è –ø—Ä–æ–µ–∫—Ç–∞ "–ê–Ω–∞–ª–∏–∑ –æ—Ç—á–µ—Ç–Ω–æ—Å—Ç–∏"
	// —Ö–æ—Ä–æ—à–∏–µ —Ñ—É–Ω–∫—Ü–∏–∏ –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Ç–∞–±–ª–∏—Ü—ã
	Table.TransformContent 	= // #! –∑–∞–º–µ–Ω–∞ –∑–Ω–∞—á–µ–Ω–∏–π –≤ –ø–æ–¥—Ç–∞–±–ª–∏—Ü–∞—Ö –ø–æ —É—Å–ª–æ–≤–∏—é –≤ –¥—Ä—É–≥–∏—Ö —Å—Ç–æ–ª–±—Ü–∞—Ö // todo –Ω–µ –ø–æ–Ω—è–ª
		/*
			–ü—Ä–∏–º–µ—Ä —Ñ—É–Ω–∫—Ü–∏–π –∑–∞–º–µ–Ω—ã
				fx1 = (row) => /* –≤–∞—à–∞ –ª–æ–≥–∏–∫–∞ –¥–ª—è f1
				fx2 = (row) => /* –≤–∞—à–∞ –ª–æ–≥–∏–∫–∞ –¥–ª—è f2 

			–°–ø–∏—Å–æ–∫ —É—Å–ª–æ–≤–∏–π –∑–∞–º–µ–Ω—ã
				replaceConditions = { {"—É—Ö", fx1}, {"–∞–≤", fx2} },

			–ü—Ä–∏–º–µ—Ä –≤—ã–∑–æ–≤–∞ —Ñ—É–Ω–∫—Ü–∏–∏
				Result = MyFunction(
					tbl,                // –ò—Å—Ö–æ–¥–Ω–∞—è —Ç–∞–±–ª–∏—Ü–∞
					"Column1",          // –ò–º—è –∫–æ–ª–æ–Ω–∫–∏ –¥–ª—è –∑–∞–º–µ–Ω—ã –∑–Ω–∞—á–µ–Ω–∏–π
					"Column2"           // –ò–º—è –∫–æ–ª–æ–Ω–∫–∏ –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –Ω–∞–ª–∏—á–∏—è —Ç–µ–∫—Å—Ç–∞
					replaceConditions,  // –£—Å–ª–æ–≤–∏—è –∑–∞–º–µ–Ω—ã
				)
			in	Result
		*/
		(tbl as table, col1Name as text, col2Name as text, replaceConditions as list) =>
		let
			// 	–ü–æ–ª—É—á–∞–µ–º —Å–ø–∏—Å–æ–∫ –∏–º–µ–Ω –∫–æ–ª–æ–Ω–æ–∫
				nms = Table.ColumnNames(tbl),

			// 	–û–ø—Ä–µ–¥–µ–ª—è–µ–º –∏–Ω–¥–µ–∫—Å—ã –∫–æ–ª–æ–Ω–æ–∫ –ø–æ –∏—Ö –∏–º–µ–Ω–∞–º
				col1Index = List.PositionOf(nms, col1Name),
				col2Index = List.PositionOf(nms, col2Name),

			// 	–ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º —Ç–∞–±–ª–∏—Ü—É –≤ —Å–ø–∏—Å–æ–∫ —Å—Ç—Ä–æ–∫
				SourceList = Table.ToRows(tbl),

			// 	–ü—Ä–∏–º–µ–Ω—è–µ–º —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏—é –∫–æ –≤—Å–µ–º —Å—Ç—Ä–æ–∫–∞–º —Å–ø–∏—Å–∫–∞
				TransformedList = 
					List.Transform(SourceList, each 
						let
							// 	–ü–µ—Ä–µ–º–µ–Ω–Ω—ã–µ
								row = _,
								col1 = row{col1Index},
								col2 = row{col2Index},

							// 	–ü—Ä–∏–º–µ–Ω—è–µ–º —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â—É—é —Ñ—É–Ω–∫—Ü–∏—é –∑–∞–º–µ–Ω—ã
								newCol1 = List.Accumulate(
									replaceConditions, 
									col1,
									(current, condition) =>
										let
											txt  = condition{0},
											func = condition{1}
										in
											if Text.Contains(col2, txt) 
											then func(row) 
											else current
								),

							// 	–§–æ—Ä–º–∏—Ä—É–µ–º –Ω–æ–≤—É—é —Å—Ç—Ä–æ–∫—É —Å –æ–±–Ω–æ–≤–ª–µ–Ω–Ω—ã–º –∑–Ω–∞—á–µ–Ω–∏–µ–º –∏ –æ—Å—Ç–∞–≤—à–∏–º–∏—Å—è –Ω–µ–∏–∑–º–µ–Ω–Ω—ã–º–∏ –∫–æ–ª–æ–Ω–∫–∞–º–∏
								newRow = 
									List.Transform(
										List.Zip({nms, row}),
										each if _{0} = col1Name then newCol1 else _{1}
									)
						in	
							newRow
					),

			// 	–ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º —Å–ø–∏—Å–æ–∫ –æ–±—Ä–∞—Ç–Ω–æ –≤ —Ç–∞–±–ª–∏—Ü—É
				ResultTable = Table.FromRows(TransformedList, nms)
		in
			ResultTable,
	
	Table.AddedRows 		= // # —Ä—É—á–Ω–æ–µ —Ñ–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–∏–µ —Ç–∞–±–ª–∏—Ü—ã –∏–∑ –∑–∞–ø–∏—Å–µ–π —Å —Ç–∏–ø–∏–∑–∞—Ü–∏–µ–π —Å—Ç–æ–ª–±—Ü–æ–≤
		/*  
			–û–ø–∏—Å–∞–Ω–∏–µ:	—Ä—É—á–Ω–æ–µ —Ñ–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–∏–µ —Ç–∞–±–ª–∏—Ü—ã –∏—Ö –∑–∞–ø–∏—Å–µ–π —Å —Ç–∏–ø–∏–∑–∞—Ü–∏–µ–π —Å—Ç–æ–ª–±—Ü–æ–≤
			–ê—Ä–≥—É–º–µ–Ω—Ç—ã:	dataList - —Å–ø–∏—Å–æ–∫ –∑–∞–ø–∏—Å–µ–π, —Ñ–æ—Ä–º–∏—Ä—É—é—â–∏—Ö —Å—Ç—Ä–æ–∫–∏ —Ç–∞–±–ª–∏—Ü—ã
			–°—Å—ã–ª–∫–∞:		–ø—Ä–æ —Ç–∏–ø–∏–∑–∞—Ü–∏—é –æ–ø–∏—Å–∞–Ω–∏–µ –≤ —Ç–∞–Ω–∫–µ –ø–æ —Ç–µ–≥—É "–æ–±–Ω–æ–≤–ª—è–µ–º —Ç–∏–ø—ã –≤—Ä—É—á–Ω—É—é, –Ω–æ –ø–∞—á–∫–∞–º–∏"
		*/
		( dataList as list ) =>
		let 
			//	—Å–ø–∏—Å–æ–∫ –∑–∞–ø–∏—Å–µ–π —Ç–µ–ª–∞ —Ç–∞–±–ª–∏—Ü—ã
				// dataList = {
				// 	[Company = "–ù–µ—Ç –æ—Ç—á–µ—Ç–∞ —Å —Ç–∞–∫–∏–º –∫–æ–¥–æ–º", 	Date = #date(2022, 12, 1)							],
				// 	[Company = "1", 						Date = #date(2023, 12, 1)							],
				// 	[Name = "Sample", 						Value = 123, 				Date = #date(2023, 8, 7)]
				// },
			
			// 	1 –ø–æ–ª—É—á–µ–Ω–∏–µ –≤—Å–µ—Ö —É–Ω–∏–∫–∞–ª—å–Ω—ã—Ö –∏–º–µ–Ω –ø–æ–ª–µ–π –∏–∑ –≤—Å–µ—Ö –∑–∞–ø–∏—Å–µ–π –≤ —Å–ø–∏—Å–∫–µ dataList
				columnNames = 
					List.Distinct(
						List.Combine(
							List.Transform(
								dataList, 
								(rec as record) as list =>Record.FieldNames(rec)
							)
						)
					),

			// 	2 –ø—É—Å—Ç–∞—è —Ç–∞–±–ª–∏—Ü–∞ —Å –∑–∞–≥–æ–ª–æ–≤–∫–∞–º–∏ –∏–∑ columnNames
				tblBlank   = Table.FromColumns(List.Transform(columnNames, each {}), columnNames),
			
			// 	3 –ø—É—Å—Ç–∞—è —Ç–∞–±–ª–∏—Ü–∞ —Å –∑–∞–≥–æ–ª–æ–≤–∫–∞–º–∏ –∏–∑ columnNames
				funcAddRow = 
					List.Transform(
						dataList, 
						(rec as record) as record =>
							Record.FromList( 
								List.Transform(columnNames, (x)=> Record.FieldOrDefault(rec, x, null) ), 
								columnNames
							)
					),
			
			//	4 —Ñ–æ—Ä–º–∏—Ä—É–µ–º —Ç–∞–±–ª–∏—Ü—É –ø—É—Ç–µ–º –¥–æ–±–∞–≤–ª–µ–Ω–∏—è —Å—Ç—Ä–æ–∫ —Å –¥–∞–Ω–Ω—ã–º–∏
				insertRows = Table.InsertRows(tblBlank, 0, funcAddRow),

			//	5 —Ç–∏–ø–∏–∑–∞—Ü–∏—è —Å—Ç–æ–ª–±—Ü–æ–≤ –ø–æ –∏–º–µ–Ω–∏
				typedField = let
				 	nms = Table.ColumnNames(insertRows),
					lstDate   = {"Date"},
					lstNumber = {"–°—Ç—Ä–æ–∫–∞_ID", "–ó–Ω–∞—á–µ–Ω–∏–µ","–°—É–º–º–∞","Value",
								 "–ù–∞ –Ω–∞—á–∞–ª–æ","–ù–∞ –∫–æ–Ω–µ—Ü","–¢–µ–∫—É—â–∏–π –ø–µ—Ä–∏–æ–¥","–ü—Ä–æ—à–ª—ã–π –ø–µ—Ä–∏–æ–¥"},

					dlst = List.Select(nms,(i)=>List.Contains(lstDate,   i, (x,y)=>Text.Contains(y,x))),
					nlst = List.Select(nms,(i)=>List.Contains(lstNumber, i, (x,y)=>Text.Contains(y,x))),
					tlst = List.Difference(nms, dlst & nlst),

					f=(x,y)=>List.Transform(x,(i)=>{i,y}),
					transflst = f(dlst, Date.Type) & 
								f(nlst, Number.Type) & 
								f(tlst, Text.Type),
					
					to = Table.TransformColumnTypes(insertRows, transflst)	
				in  to
		in 
			typedField,

	Table.SkipUp  			= // # –∏—â–µ–º —Ç–µ–∫—Å—Ç –≤  –∏ —É–¥–∞–ª—è–µ–º —Å—Ç—Ä–æ–∫–∏ –≤—ã—à–µ –Ω–∞–π–¥–µ–Ω–Ω–æ–π —Å—Ç—Ä–æ–∫–∏
		(x, txt)=>
			(y)=>
				not Text.Contains(
					Text.Combine( 
						List.Select(
							Record.ToList(Record.SelectFields(y, txt)),
							(i)=>i is text
						)
					),
				x),

	Table.SkipUp2 			= // # —É–¥–∞–ª—è–µ—Ç —Å—Ç—Ä–æ–∫–∏ —Å–≤–µ—Ä—Ö—É, –¥–æ —Å—Ç—Ä–æ–∫–∏, –≤ –∫–æ—Ç–æ—Ä–æ–π –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –∏—Å–∫–æ–º—ã–π —Ç–µ–∫—Å—Ç
		/*
			–ü—Ä–∏–º–µ—Ä		Table.Skip(TransCol, F_Torg[Table.SkipUp]("–ö–æ–¥ –ø–æ –°–ö"))
			–†–µ–∑—É–ª—å—Ç–∞—Ç	
		*/
		(txt)=>
			(row)=> 
				List.Select( 
					Record.ToList(row), 
					(i)=>i is text and Text.Contains(i,txt)
				)={},
	
	Text.RemoveMulti  		= // —É–¥–∞–ª–µ–Ω–∏–µ —Ç–µ–∫—Å—Ç–∞ –∏–∑ —Å–ø–∏—Å–∫–∞ –≤ –∑–∞–¥–∞–Ω–Ω–æ–π –ö–û–õ–û–ù–ö–ï. –ü—Ä–æ–≤–µ—Ä–∏—Ç—å —Å–∫–æ—Ä–æ—Å—Ç—å –î–æ–±–∞–≤–∏—Ç—å —Ç–∏–ø
		/*
			–ü—Ä–∏–º–µ—Ä	F[Text.RemoveMulti](from,)
		*/
		(tbl as table, ColumnName as text, RemoveList as list) as table=>
			[	lst  = RemoveList,
				dict = List.Buffer(List.Zip({lst, List.Repeat({""}, List.Count(lst)) }) ),
				func = (txt)=>List.Accumulate(dict, txt, (s,c)=>Text.Replace(s, c{0}, c{1})),
				tr   = Table.TransformColumns(tbl, {ColumnName, func})
			]  [tr],

	// 1 –∏—Å–ø–æ–ª—å–∑—É–µ–º—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏
	Text.ContainsAny = (str, needles) as logical => List.Count(needles),
	// 	-----------------------------------
	//	–Ω–µ–¥–æ–¥–µ–ª–∞–Ω–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏
	//	-----------------------------------
	Table.TypesAllColumns = // –º–∞—Å—Å–æ–≤–∞—è –∑–∞–º–µ–Ω–∞ —Ç–∏–ø–æ–≤ —Å—Ç–æ–ª–±—Ü–æ–≤. –ü–æ–∫–∞ –Ω–µ —Ç–∞–∫ –≤—ã—Ö–æ–¥–∏—Ç. –Ω–µ —Ç–∞–∫ —Ä–∞–±–æ—Ç–∞–µ—Ç //! –µ—Å—Ç—å —É –ú–ò–®–ò
		(tbl as table) =>
		let
            // from = #table({"a".."e"},{{123,null,12.34,#date(2023,1,1),null},{null,"–º—ã–ª–∞",null,#date(2023,2,2),#time(2,3,4)},{345,"—Ä–∞–º—É",34.56,null,#time(3,4,5)}}),
            f=(x)=>List.Mode(List.Transform(List.RemoveNulls(x),Value.Type)),
			lst = List.Transform(Table.ToColumns(Table.Range(tbl,0,10)),f),
            tr  = List.Zip({Table.ColumnNames(tbl),lst}),
            to  = Table.TransformColumnTypes(tbl,tr)
        in
            to,
	fxJoinSpr =	// –¥–æ–±–∞–≤–ª—è–µ–º –∫–æ–ª–æ–Ω–∫–∏ –≤ —Ç–∞–±–ª–∏—Ü—É —á–µ—Ä–µ–∑ –æ–±—ä–µ–¥–∏–Ω–µ–Ω–∏–µ —Ç–∞–±–ª–∏—Ü –ø–æ ID_–§–æ—Ä–º–∞  
			/*
				–¥–æ–±–∞–≤–ª—è–µ–º –∫–æ–ª–æ–Ω–∫–∏ –≤ —Ç–∞–±–ª–∏—Ü—É —á–µ—Ä–µ–∑ –æ–±—ä–µ–¥–∏–Ω–µ–Ω–∏–µ —Ç–∞–±–ª–∏—Ü –ø–æ ID_–§–æ—Ä–º–∞
				to = fxJoinSpr(addColumns1, –°–ø—Ä–∞–≤–æ—á–Ω–∏–∫–∏[–°–ø—Ä_–§–æ—Ä–º—ã–û—Ç—á–µ—Ç–Ω–æ—Å—Ç–∏], "–ö–æ–¥–ë–ö–°", {"–ù–∞–∑–≤–∞–Ω–∏–µ", "Report_ID"}),
			*/	
		let 	
			
			func = (tblIn as table, 		// —Ç–∞–±–ª–∏—Ü–∞ –∫—É–¥–∞ —Ä–∞–∑–≤–æ—Ä–∞—á–∏–≤–∞–µ–º –Ω–æ–≤—ã–µ –∫–æ–ª–æ–Ω–∫–∏
					columnName1 as text, 	// –∏–º—è —Å—Ç–æ–ª–±—Ü–∞, –∫–æ—Ç–æ—Ä–æ–µ –µ—Å—Ç—å –≤ –¥–≤—É—Ö —Ç–∞–±–ª–∏—Ü–∞—Ö (–º–æ–≥—É—Ç –±—ã—Ç—å —Ä–∞–∑–Ω—ã–µ –Ω–∞–≤–∞–Ω–∏—è, –¥–æ—Ä–∞–±–æ—Ç–∞—Ç—å –∫–æ–¥)
					tblSpr as table, 		// —Ç–∞–±–ª–∏—Ü–∞ —Å–æ —Å–ø—Ä–∞–≤–æ—á–Ω–∏–∫–∞–º–∏
					columnName2 as text, 	// –∏–º—è —Å—Ç–æ–ª–±—Ü–∞, –∫–æ—Ç–æ—Ä–æ–µ –µ—Å—Ç—å –≤ –¥–≤—É—Ö —Ç–∞–±–ª–∏—Ü–∞—Ö (–º–æ–≥—É—Ç –±—ã—Ç—å —Ä–∞–∑–Ω—ã–µ –Ω–∞–≤–∞–Ω–∏—è, –¥–æ—Ä–∞–±–æ—Ç–∞—Ç—å –∫–æ–¥)
					lstLoadColumn as list) 	//
			as table => 
			
			let Sprav  = 1, // –°–ø—Ä–∞–≤–æ—á–Ω–∏–∫–∏[–°–ø—Ä_–§–æ—Ä–º—ã–û—Ç—á–µ—Ç–Ω–æ—Å—Ç–∏],
				Join   = Table.NestedJoin(tblIn, {columnName1}, tblSpr, {columnName2},"tmp"),
				Expand = Table.ExpandTableColumn(Join, "tmp", lstLoadColumn)
			in  Expand,

			typ = type function (tblIn as table, columnName1 as text, tblSpr as table, columnName2 as text, lstLoadColumn as list) as table 
					meta [ 	Documentation.Name            = "",
							Documentation.LongDescription = "–¥–æ–±–∞–≤–ª—è–µ–º –∫–æ–ª–æ–Ω–∫–∏ –≤ —Ç–∞–±–ª–∏—Ü—É —á–µ—Ä–µ–∑ –æ–±—ä–µ–¥–∏–Ω–µ–Ω–∏–µ —Ç–∞–±–ª–∏—Ü –ø–æ ID_–§–æ—Ä–º–∞" ],
			result = Value.ReplaceType(func,typ) 
		in result,
	
	//	-----------------------------------
	// –≤–æ–∑–º–æ–∂–Ω–æ –ø–æ–ª–µ–∑–Ω–æ–µ
	//	-----------------------------------
	fxRenameColumnsByIndices = 
		(Source as table, ColumnNamesNew as list, Indices as list) =>
		let
			ColumnNamesOld = List.Transform( Indices, each Table.ColumnNames(Source){_} ), 
			ZippedList     = List.Zip( { ColumnNamesOld, ColumnNamesNew } ),
			RenamedColumns = Table.RenameColumns( Source, ZippedList )
		in
			RenamedColumns,
			
	getHEX = // –¥–µ–∫–æ–¥–∏—Ä—É–µ—Ç —Ç–µ–∫—Å—Ç –≤ —Ç–∞–±–ª–∏—Ü—É. –ù–æ –ø–æ—á–µ–º—É —Ç–æ –Ω–µ –≤—Å—è–∫–∏–π —Ç–µ–∫—Å—Ç, –ø—Ä–æ–≤–µ—Ä–∏—Ç—å
		/*
			= get("bc8xSgRQDATQu/x6CckkmSR7FbFYbQVBxUb27v5qEfxFusfM5Olnfb5/fK3ruq3L+r69rSsDKoYMFsv24X75rzzpMsVRjVCi56SoWQJt5OgUYvKkIpPiqeY20f3XvDz6uk0KqCztYk8c1d4te45vh+hsnFS4QpgOxsyO9D6pjCnpHiOtM+F/s14fH1qVWCVbwXJ6nlQgKIxy5UyHzlGRbkJFRRFE1gm5eksU1Kemba+/P/8C")
			—Ä–∞–∑–Ω–∏—Ü–∞ —Å –¥–µ–∫–æ–¥–µ—Ä–æ–º Table.JsonDecode –≤ –Ω–∞–ª–∏—á–∏–µ —Ç–∞–º BinaryEncoding.Base64, –∞ —Ç—É—Ç –æ—Ç—Å—É—Ç—Å—Ç–≤–∏–∏
		*/

		(txt as text) as table =>[
			bin  = Binary.FromText(txt),
			dec  = Binary.Decompress(bin,Compression.Deflate),
			json = Json.Document(dec),
			tbl  = Table.FromRecords(json)]
		[tbl],
	findColumnByKeywords = // # –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∏–º—è –∫–æ–ª–æ–Ω–∫–∏ –≤ –∫–æ—Ç–æ—Ä–æ–π –Ω–∞–π–¥–µ–Ω—ã –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ –∫–ª—é—á–µ–≤—ã–µ —Å–ª–æ–≤–∞ //! fine
        /*
            –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: 
                1 –∏—â–µ–º –∫–æ–ª–æ–Ω–∫—É
                    colName = F2[findColumnByKeywords](selCol,{"–ì–æ—Å—É–¥–∞—Ä—Å—Ç–≤–µ–Ω–Ω—ã–π –∫–æ–º–ø–æ–Ω–µ–Ω—Ç"}),
                
                2 —Å—Å—ã–ª–∞–µ–º—Å—è –Ω–∞ –Ω–∞–π–¥–µ–Ω–Ω—É—é –∫–æ–ª–æ–Ω–∫—É (–≤–∞—Ä–∏–∞–Ω—Ç—ã):
                    GetColumnValue = (row) => Record.Field(row, colName),              //  –µ—Å–ª–∏ –∫–æ–ª–æ–Ω–∫–∞ —Ç–æ—á–Ω–æ –µ—Å—Ç—å
                    GetColumnValue = (row) => Record.Field(row, colName ?? ""),        //  –µ—Å–ª–∏ –∫–æ–ª–æ–Ω–∫–∏ –Ω–µ—Ç, —Ç–æ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º "" –∫–∞–∫ –∞–Ω–∞–ª–æ–≥ –±–µ–∑ ?? ""
                    GetColumnValue = (row) => Record.Field(row, colName ?? "Column1"), //  –µ—Å–ª–∏ –∫–æ–ª–æ–Ω–∫–∞ –Ω–µ—Ç, —Ç–æ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –∏–º—è –ª—é–±–æ–π –¥—Ä—É–≥–æ–π –∫–æ–ª–æ–Ω–∫–∏
                    GetColumnValue = (row) => Record.Field(row, colName ?? "–∫–æ–ª–æ–Ω–∫–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞"), //  "–∫–æ–ª–æ–Ω–∫–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞" —á–∏—Å—Ç–æ —Å–ø—Ä–∞–≤–æ—á–Ω–æ–¥–ª—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏
                
                3 –∏—Å–ø–æ–ª—å–∑—É–µ–º –≤ –∑–∞–ø—Ä–æ—Å–µ
                    to  = Table.SelectRows(selCol, each GetColumnValue(_) <> null),    //  –∏—Å–ø–æ–ª—å–∑—É–µ–º —Å—Å—ã–ª–∫—É –≤ –∑–∞–ø—Ä–æ—Å–µ

            –û–ø–∏—Å–∞–Ω–∏–µ:
                1 findColumnByKeywords:           –§—É–Ω–∫—Ü–∏—è –ø—Ä–∏–Ω–∏–º–∞–µ—Ç —Ç–∞–±–ª–∏—Ü—É –∏ —Å–ø–∏—Å–æ–∫ –∫–ª—é—á–µ–≤—ã—Ö —Å–ª–æ–≤.
                2 Table.TransformColumnTypes:     –í—Å–µ –∫–æ–ª–æ–Ω–∫–∏ –ø—Ä–∏–≤–æ–¥—è—Ç—Å—è –∫ —Ç–∏–ø—É text, —á—Ç–æ–±—ã –æ–±–µ—Å–ø–µ—á–∏—Ç—å –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π –ø–æ–∏—Å–∫ –ø–æ —Å—Ç—Ä–æ–∫–∞–º.
                3 Table.UnpivotOtherColumns:      –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ—Ç —Ç–∞–±–ª–∏—Ü—É –≤ —Ñ–æ—Ä–º–∞—Ç "–∫–ª—é—á-–∑–Ω–∞—á–µ–Ω–∏–µ", –≥–¥–µ –º–æ–∂–Ω–æ –∏—Å–∫–∞—Ç—å —Ç–µ–∫—Å—Ç–æ–≤—ã–µ —Å–æ–≤–ø–∞–¥–µ–Ω–∏—è –ø–æ –∫–ª—é—á–µ–≤—ã–º —Å–ª–æ–≤–∞–º.
                4 Table.SelectRows:               –í—ã–±–∏—Ä–∞–µ—Ç —Å—Ç—Ä–æ–∫–∏, —Å–æ–¥–µ—Ä–∂–∞—â–∏–µ –≤—Å–µ –∫–ª—é—á–µ–≤—ã–µ —Å–ª–æ–≤–∞ –∏–∑ —Å–ø–∏—Å–∫–∞.
                5 List.First(flt[ColumnNames]):   –ü–æ–ª—É—á–∞–µ—Ç –∏–º—è –ø–µ—Ä–≤–æ–π –∫–æ–ª–æ–Ω–∫–∏, –∫–æ—Ç–æ—Ä–∞—è —Å–æ–¥–µ—Ä–∂–∏—Ç –≤—Å–µ –∫–ª—é—á–µ–≤—ã–µ —Å–ª–æ–≤–∞.
                6 if colName <> null then:        –ï—Å–ª–∏ –∫–æ–ª–æ–Ω–∫–∞ –Ω–∞–π–¥–µ–Ω–∞, —Ñ–∏–ª—å—Ç—Ä—É–µ–º —Å—Ç—Ä–æ–∫–∏ –ø–æ —ç—Ç–æ–π –∫–æ–ª–æ–Ω–∫–µ. –ï—Å–ª–∏ –Ω–µ—Ç ‚Äî –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –∏—Å—Ö–æ–¥–Ω—É—é —Ç–∞–±–ª–∏—Ü—É –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π.
        */
        (tbl as table, keywords as list) =>
        let
            //  –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –≤—Å–µ –∫–æ–ª–æ–Ω–∫–∏ –≤ —Ç–µ–∫—Å—Ç –¥–ª—è –ø–æ–∏—Å–∫–∞ –∫–ª—é—á–µ–≤—ã—Ö —Å–ª–æ–≤
                typ = Table.TransformColumnTypes(tbl, List.Transform(Table.ColumnNames(tbl), (x) => {x, type text})),

            //  –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º —Ç–∞–±–ª–∏—Ü—É –≤ —Ñ–æ—Ä–º–∞—Ç "–∫–ª—é—á-–∑–Ω–∞—á–µ–Ω–∏–µ"
                unp = Table.UnpivotOtherColumns(typ, {}, "ColumnNames", "Values"),

            //  –§–∏–ª—å—Ç—Ä—É–µ–º —Å—Ç—Ä–æ–∫–∏, –≥–¥–µ –≤—Å–µ –∫–ª—é—á–µ–≤—ã–µ —Å–ª–æ–≤–∞ —Å–æ–¥–µ—Ä–∂–∞—Ç—Å—è –≤ –∑–Ω–∞—á–µ–Ω–∏–∏
                flt = Table.SelectRows(unp, each List.AllTrue(List.Transform(keywords, (k) => Text.Contains([Values], k)))),

            //  –ï—Å–ª–∏ –∫–æ–ª–æ–Ω–∫–∞ –Ω–∞–π–¥–µ–Ω–∞, –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –µ–µ –∏–º—è, –∏–Ω–∞—á–µ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º null
                colName = if Table.RowCount(flt) > 0 then List.First(flt[ColumnNames]) else null,

            //  –û–±—Ä–∞–±–æ—Ç–∫–∞: –µ—Å–ª–∏ –∫–æ–ª–æ–Ω–∫–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞, –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –∏—Å—Ö–æ–¥–Ω—É—é —Ç–∞–±–ª–∏—Ü—É
                result = if colName <> null then Table.SelectRows(tbl, each Record.Field(_, colName) <> null) else tbl
        in
            colName,
    
	fxSelectColumnsWord = // –≤—ã–±–æ—Ä —Å—Ç–æ–ª–±—Ü–æ–≤ –ø–æ –≤—Ö–æ–∂–¥–µ–Ω–∏—é —Ç–µ–∫—Å—Ç–∞ //? –Ω–µ –∞–∫—Ç—É–∞–ª—å–Ω–∞ –ø–æ—Å–ª–µ findColumnByKeywords
		/*
			–ü—Ä–∏–º–µ—Ä
				= F[fxSelectColumnsWord] (from,{"–ó–∞–ø–∞—Å—ã","–ê–∫—Ç–∏–≤—ã"})
			–£–ª—É—á—à–µ–Ω–∏–µ
				1	—Ñ—É–Ω–∫—Ü–∏—è –Ω–µ –æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–∞
				2 	–ø–æ–∏—Å–∫ –ø–æ —Ç–æ—á–Ω–æ–º—É —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏—é, —Å —É—á–µ—Ç–æ–º —Ä–µ–≥–∏—Å—Ç—Ä–∞
		*/
		(tbl as table, optional words as list) => 
			let from = tbl,
				lst  = if words <> null then words else {"–∞–∫—Ç–∏–≤—ã","–∑–∞–ø–∞—Å—ã"},
				typ  = Table.TransformColumnTypes(from, List.Transform(Table.ColumnNames(from), (x)=>{x,type text})),
				unp  = Table.UnpivotOtherColumns(typ, {}, "ColumnNames", "Filters"),
				flt  = Table.SelectRows(unp, each List.AnyTrue(List.Transform(lst, (x)=>Text.Contains([Filters], x)))),
				nms  = List.Sort(List.Distinct(flt[ColumnNames]), Order.Ascending),
				sel  = Table.SelectColumns(typ, nms)
			in  sel,

	fxKofPodobie 		= // –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç–æ–º –ø–æ–¥–æ–±–∏—è —Å—Ä–∞–≤–Ω–∏–≤–∞—è –¥–≤–µ —Å—Ç—Ä–æ–∫–∏
		/*
			–ü—Ä–∏–º–µ—Ä 
				= F[fxKofPodobie]("—Å–æ–±–∞–∫–∞", "—Å–∞–±–∞–∫–∞")		-> 0,83333333333333337
				= F[fxKofPodobie]([–°—Ç–∞—Ç—å—è], [–°—Ç–∞—Ç—å—è–ò–º—è])
				
				–î–æ–±–∞–≤–∏—Ç—å –∫–æ–ª–æ–Ω–∫—É —Å –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç–æ–º –ø–æ–¥–æ–±–∏—è		
				to = Table.AddColumn(from, "fxKofPodobie", each F[fxKofPodobie]([–°—Ç–∞—Ç—å—è], [–°—Ç–∞—Ç—å—è–ò–º—è]))
		*/
		(text1 as text, text2 as text) as number =>
			let text1 = Text.Upper(text1),
				text2 = Text.Upper(text2),
				matching_chars = List.Count(List.Intersect({Text.ToList(text1), Text.ToList(text2)})),
				average_length = (Text.Length(text1) + Text.Length(text2)) / 2,
				coef =  matching_chars / average_length
			in  coef,
	
	AllFieldNamesTables = // –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–ø–∏—Å–æ–∫ —Å—Ç–æ–ª–±—Ü–æ–≤ –≤–æ –≤—Å–µ—Ö –ø–æ–¥—Ç–∞–±–ª–∏—Ü–∞—Ö –≤ –∫–æ–ª–æ–Ω–∫–µ
		/* 
			nms = F[AllFieldNamesTables](from,"tmp"),
			exp = Table.ExpandTableColumn(from, "tmp", nms)
		*/
		(tbl, columnName) =>
			List.Distinct(
				List.Combine(
					List.Transform(
						Table.Column(tbl, columnName), 
						each Table.ColumnNames(_)
					)
				)
			),
	
	AllFieldNamesRecord = // –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–ø–∏—Å–æ–∫ —Å—Ç–æ–ª–±—Ü–æ–≤ –≤–æ –≤—Å–µ—Ö —Ç–∞–±–ª–∏—Ü–∞—Ö –≤ –ø–æ–ª–µ Value
		/* F[AllFieldNamesRecord](from,"tmp") */
		(tbl) =>
			List.Union(
				List.Transform(
					tbl[Value], 
					Record.FieldNames
				)
			),

	fxAddOtherRowColumn = 1// –¢–µ—Å—Ç–æ–≤—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏	
		// –ø–æ–ª—É—á–∞–µ–º –∑–Ω–∞—á–µ–Ω–∏—è –∏–∑ –ø—Ä–µ–¥—ã–¥—É—â–∏—Ö –∏–ª–∏ –ø–æ—Å–ª–µ–¥—É—é—â–∏—Ö —Å—Ç—Ä–æ–∫
		// –ü–æ –∞—Ä–≥—É–º–µ–Ω—Ç–∞–º –≤—Å—ë –¥—É–º–∞—é –ø–æ–Ω—è—Ç–Ω–æ ‚Äì —Ç–∞–±–ª–∏—Ü–∞, —Å—Ç–æ–ª–±–µ—Ü, –∏–º—è –Ω–æ–≤–æ–≥–æ —Å—Ç–æ–ª–±—Ü–∞ –∏ –Ω–∞ —Å–∫–æ–ª—å–∫–æ —Å—Ç—Ä–æ–∫ —Å–¥–≤–∏–Ω—É—Ç—å.
			//   let
			//         tbl = Table.FromColumns({{"a".."i"},{1..9}},{"a","b"}),
				
			//         fxAddOtherRowColumn = // —Å–¥–≤–∏–≥ 
			//             (tbl,col,newcol,index) =>
			//                 [   lst =   List.Buffer(Table.Column(tbl,col)),
			//                     add =   Table.AddIndexColumn(tbl,newcol,index,1),
			//                     f   =   if index <0 
			//                             then (x)=> if x<0 then null else lst{x}
			//                             else (x)=>lst{x}?,
			//                     to = Table.TransformColumns(add,{newcol,f})
			//                 ][to],

			//         to  = fxAddOtherRowColumn(tbl,"b","c",-1),
			//         to1 = fxAddOtherRowColumn(tbl,"b","c",-3),
			//         to2 = fxAddOtherRowColumn(tbl,"b","c",2)
			//     in
			//         to2
		,
	GetQueryValues 		= // —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –∑–Ω–∞—á–µ–Ω–∏–π –ø–æ –∏–º–µ–Ω–∏ –∏–∑ #shared, –Ω–∞–ø—Ä–∏–º–µ—Ä —Ç–∞–±–ª–∏—Ü. #sections[Section1] - –Ω–µ –≤–∏–¥–∏—Ç
		(queryName as text) as any =>
			Record.Field(#shared, queryName),
	
	AllQueryOneTable 	= 1 // –≤—Å–µ –∏–º–µ–Ω–Ω–æ —Ç–∞–±–ª–∏—Ü—ã –ø—Ä–æ–µ–∫—Ç–∞ –≤ –æ–¥–Ω–æ–º –º–µ—Å—Ç–µ. –ü—Ä–æ–≤–µ—Ä–∏—Ç—å
		// let
		// 	from = Record.ToTable(Record.RemoveFields(#sections[Section1],"Result")),
		// 	nms  = List.Distinct(List.Combine(List.Transform(from[Value],Table.ColumnNames))),
		// 	to   = Table.ExpandTableColumn(from,"Value",nms)
		// in
		// 	to

	], 

UTIL  	  = [ // –ú–æ–∏ —É—Ç–∏–ª–∏—Ç—ã 
	readme.UTIL = "// –£–¢–ò–õ–ò–¢–´",
	//  Read - —á—Ç–µ–Ω–∏–µ —Ñ–∞–π–ª–æ–≤ —Ä–∞–∑–Ω—ã—Ö —Ñ–æ—Ä–º–∞—Ç–æ–≤
	read_xlsx 	= // –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ —Ñ–∞–π–ª–æ–≤ —Ñ–æ—Ä–º–∞—Ç–∞ XLSX (—Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏—è bin —Ñ–æ—Ä–º–∞—Ç–∞) –¥–æ—Ä–∞–±–æ—Ç–∞—Ç—å
		(folderPath as text) as table =>
        let
			from  = Folder.Files(folderPath),
			
			nms	  = {"Name","Extension", "Attributes", "Date created", "Content"} & {"Folder Path"},
			Sel	  = Table.SelectColumns(from, nms),
			Trans = Table.TransformColumns(Sel, {
				{"Date created", (x)=> DateTime.Date(x), type date},
				{"Folder Path",  (x)=> Text.AfterDelimiter(x, "\", {2, RelativePosition.FromEnd}), type text}
			}),

		// 	3. —Ñ–∏–ª—å—Ç—Ä—É–µ–º —Å—Ç—Ä–æ–∫–∏
			FilteredRows 	= Table.SelectRows(Trans, each 
				(Text.Start([Extension], 5) = ".xlsx" and 	// –æ—Å—Ç–∞–≤–ª—è–µ–º —Ç–æ–ª—å–∫–æ .xlsx
				[Attributes][Hidden] = false ) and			// —É–±–∏—Ä–∞–µ–º —Å–∫—Ä—ã—Ç—ã–µ
				not Text.StartsWith([Name], "~$")			// —É–±–∏—Ä–∞–µ–º –≤—Ä–µ–º–µ–Ω–Ω—ã–µ
			),

		//  4. –ø—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –±–∏–Ω–∞—Ä–Ω–∏–∫–∏ –≤ —Ç–∞–±–ª–∏—Ü—ã –∏ —Ñ–∏–ª—å—Ç—Ä—É–µ–º —Å—Ç—Ä–æ–∫–∏ –≤ –ø–æ–¥—Ç–∞–±–ª–∏—Ü–∞—Ö
			TransformBinary = Table.TransformColumns(FilteredRows,         
				{"Content", each let 
					TransBinary  = Excel.Workbook(_),
					NoPrintAreas = Table.SelectRows(TransBinary, each not Text.Contains([Name], "$")),
					OnlySheets   = Table.SelectRows(NoPrintAreas, each [Kind]="Sheet")
					in OnlySheets
				} 
			),
			
			// –¥–æ–±–∞–≤–ª—è–µ–º –∫–æ–ª–æ–Ω–∫–∏ –∏ —Ñ–∏–ª—å—Ç—Ä—É–µ–º —Ç–∞–±–ª–∏—Ü—É
			AddTwoColumns = let 
				AddSize   = Table.AddColumn(TransformBinary, "Size", (x)=> F[fxSizeFile](x[Attributes][Size]), type text),
				AddShName = Table.AddColumn(AddSize, "SheetsName",   (x)=> Text.Combine(x[Content][Name],","), type text),
				nms	 	  = {"Name", "Content"} & {"Size"} & {"Folder Path","SheetsName"},
				SelCol	  = Table.SelectColumns(AddShName, nms)
			in  SelCol
		in  AddTwoColumns,
	
	read.word 	= // –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–ø–∏—Å–æ–∫ —Ç–∞–±–ª–∏—Ü –∏–∑ —Ñ–∞–π–ª–∞ Word —Ñ–æ—Ä–º–∞—Ç–∞ *.docx
		/*
			–û–ø–∏—Å–∞–Ω–∏–µ:		—Å–º Word.TablesList 
			–ü—Ä–∏–º–µ—Ä:			= F[Word.TablesList](File.Contents("F:\–ù–∞–∑–≤–∞–Ω–∏–µ –§–∞–π–ª–∞.docx"))
		*/
		(file) =>
			[	getTable = (xml)=> // —Ñ—É–Ω–∫—Ü–∏—è –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Ç–∞–±–ª–∏—Ü—ã –∏–∑ xml —Ä–∞–∑–º–µ—Ç–∫–∏
				[	f=(x)=>[a = Table.SelectRows(x,(r)=>r[Name]="tr")[Value],
							b = List.Max(List.Transform(a,Table.RowCount)),
							c = Table.FromList(a,g,b)
						]  [c],
						
					g=(x)=>List.Transform(x[Value],h),
						
					h=(x)=>Text.Combine(List.Transform(Table.SelectRows(x,(r)=>r[Name]="p")[Value],i),"#(lf)"),
						
					i=(x)=>[a = Table.SelectRows(x,(r)=>r[Name]="r")[Value],
							b = (x)=> Table.SelectRows(x,(r)=>r[Name]="t")[Value],
							c = List.Combine(List.Transform(a,b)),
							d = List.Select(c,(x)=>Value.Is(x,Text.Type)),
							f = Text.Combine(d)
						]  [f],
					to = f(xml)
				]  [to],
				
				from  = F[fxUnzip2016](file),
				xml   = Xml.Document(from{[FileName="word/document.xml"]}[Content]){[Name="document"]}[Value]{[Name="body"]}[Value],
				filtr = Table.SelectRows(xml, each ([Name] = "tbl"))[Value],
				to    = List.Transform(filtr, getTable)
			]  [to],
	Read.CSV 	= // –±–æ–ª—å—à–∞—è —Ñ—É–Ω–∫—Ü–∏—è, –Ω–µ —Ä–∞–∑–±–∏—Ä–∞–ª –∏ –Ω–µ –ø–µ—Ä–µ–≤–æ–¥–∏–ª –µ—â–µ, –∏–∑ LibPQ 
		/*
			–û–ø–∏—Å–∞–Ω–∏–µ	Load arbitrary CSV file with unknown number of columns (up to 1000)
						and unknown number of extra lines before the column names (first column name
						has to be known).
			–°—Å—ã–ª–∫–∞ 		https://github.com/sio/LibPQ/blob/master/Modules/Read.CSV.pq
			–ü—Ä–∏–º–µ—Ä

			Note: 		If last column name starts with underscore or is empty, please specify
						it in the parameters or that column will be lost.
		*/
		(	tsv_path,
			first_column_header,
			optional encoding,
			optional delimiter as text,
			optional lastcolumn_name as text
		) =>
			let
				/* Default parameter values */
				Delimiter = if delimiter is null then "#(tab)" else delimiter,
				Encoding  = if encoding  is null then 65001    else encoding,

				/* Load CSV */
				Source = Csv.Document(
							File.Contents(tsv_path),
							[
								Delimiter	= Delimiter,
								Columns		= 1000,
								Encoding	= Encoding,
								QuoteStyle	= QuoteStyle.None
							]),
				
				Skipped 	 = 	Table.RemoveFirstN(Source,each [Column1] <> first_column_header),
				WithHeaders  = 	Table.PromoteHeaders(Skipped, [PromoteAllScalars=true]),
				ValidColumns = 	List.Reverse(
									List.Skip(
										List.Reverse(Table.ColumnNames(WithHeaders)),
										each (_ = "" or Text.StartsWith(_, "_")) and _ <> lastcolumn_name
									)
								),
				
				Result = Table.SelectColumns(WithHeaders, ValidColumns)
			in
				Result,

	read_csv 	= // –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ —Ñ–∞–π–ª–æ–≤ —Ñ–æ—Ä–º–∞—Ç–∞ CSV (—Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏—è bin —Ñ–æ—Ä–º–∞—Ç–∞)
		/*
			–ü—Ä–∏–º–µ—Ä:		
				= Table.AddColumn(from, "tmp", (x)=> F[read_csv](x[Content]) )
			–£–ª—É—á—à–µ–Ω–∏–µ:	
				1 Delimiter –≤  –∞—Ä–≥—É–º–µ–Ω—Ç—ã
			–û—Å–æ–±–µ–Ω–Ω–æ—Å—Ç–∏: 
				headers ?? false - –ï—Å–ª–∏ headers –Ω–µ –∑–∞–¥–∞–Ω –∏–ª–∏ —Ä–∞–≤–µ–Ω null, –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –∑–Ω–∞—á–µ–Ω–∏–µ false
			–°–ø—Ä–∞–≤–∫–∞:
				QuoteStyle.Csv, –∫–æ–≥–¥–∞ –≤—Å—Ç—Ä–µ—á–∞–µ—Ç—Å—è –∫–∞–≤—ã—á–∫–∞, –≤–µ—Å—å –ø–æ—Å–ª–µ–¥—É—é—â–∏–π —Ç–µ–∫—Å—Ç –æ—Å—Ç–∞–≤–ª—è–µ—Ç—Å—è –≤ –Ω–µ–∏–∑–º–µ–Ω–Ω–æ–º –≤–∏–¥–µ, –ø–æ–∫–∞ –Ω–µ –≤—Å—Ç—Ä–µ—Ç–∏—Ç—Å—è —Å–ª–µ–¥—É—é—â–∞—è –∫–∞–≤—ã—á–∫–∞; —Å–∞–º–∏ –∫–∞–≤—ã—á–∫–∏ –ø—Ä–∏ —ç—Ç–æ–º —É–¥–∞–ª—è—é—Ç—Å—è
    			QuoteStyle.None –∫–∞–≤—ã—á–∫–∏ –≤–æ—Å–ø—Ä–∏–Ω–∏–º–∞—é—Ç—Å—è –∫–∞–∫ –æ–¥–∏–Ω –∏–∑ —Å–∏–º–≤–æ–ª–æ–≤ –∏ –µ—Å–ª–∏ –º–µ–∂–¥—É –Ω–∏–º–∏ –µ—Å—Ç—å –ø—Ä–æ–±–µ–ª—å–Ω—ã–µ —Å–∏–º–≤–æ–ª—ã ‚Äì –ø–æ –Ω–∏–º –ø—Ä–æ–∏–∑–æ–π–¥–µ—Ç —Ä–∞–∑–¥–µ–ª–µ–Ω–∏–µ
		*/
		(bin, optional headers as logical)=> 
			let
				from = Csv.Document(bin, [Delimiter = ";", Encoding = 65001, QuoteStyle = QuoteStyle.None]),
				to   = if headers ?? false then Table.PromoteHeaders(from, [PromoteAllScalars = true]) else from
			in
				to,
		
	// Load functions
	LoadF       = // –∑–∞–≥—Ä—É–∑–∫–∞ —Ñ—É–Ω–∫—Ü–∏–π —Å –ì–∏—Ç—Ö–∞–±–∞ / –†–∞–±–æ—Ç–∞–µ—Ç ‚ö°‚ö° / –Ω–∞ –≤—ã—Ö–æ–¥–µ –≤—Å–µ —Ñ—É–Ω–∫—Ü–∏–∏
		let GitHubPath  = "https://raw.githubusercontent.com/Medvedevav632/PQ_function/main/"
    	in  Expression.Evaluate(Text.FromBinary(Binary.Buffer(Web.Contents(GitHubPath & "F.pq"))), #shared),

	LoadGit     = // –∑–∞–≥—Ä—É–∑–∫–∞ —Ñ—É–Ω–∫—Ü–∏–π —Å –ì–∏—Ç—Ö–∞–±–∞ / –†–∞–±–æ—Ç–∞–µ—Ç ‚ö° / –Ω–æ–≤–∞—è —Ñ—É–Ω–∫—Ü–∏—è 
		/*  
			= fxLoad("F") 			 –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –≤–µ—Å—å —Å–ø–∏—Å–æ–∫ —Ñ—É–Ω–∫—Ü–∏–π –≤ —Ñ–∞–π–ª–µ F.pq
			= fxLoad("F", "LoadCSV") –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Ñ—É–Ω–∫—Ü–∏—é
		*/
		(FileName as text, optional FunctionName as text) =>
			let GitHubPath  = "https://raw.githubusercontent.com/Medvedevav632/PQ_function/main/",
    			FileContent = Expression.Evaluate(Text.FromBinary(Binary.Buffer(Web.Contents(GitHubPath & FileName & ".pq"))), #shared)
			in  if   FunctionName = null 
				then FileContent 
				else Record.Field(FileContent, FunctionName),	
		
	LoadLoc   	= // –∑–∞–≥—Ä—É–∑–∫–∞ –∑–∞–ø—Ä–æ—Å–æ–≤ —Å –ª–æ–∫–∞–ª—å–Ω–æ–≥–æ –¥–∏—Å–∫–∞
		let 
			from = 
				[ 	Folder =  {"G:\=EXCEL BI - –º–æ–∏ –ø—Ä–æ–µ–∫—Ç—ã\2024.01 - –ê–Ω–∞–ª–∏–∑ –û—Ç—á–µ—Ç–Ω–æ—Å—Ç–∏\2. PQ –∑–∞–ø—Ä–æ—Å—ã\"},
					Local  = 
						[	
							Global 		= Folder{0} & "F.pq",
							Form 		= Folder{0} & "F_Form.pq",
							Calerndar 	= Folder{0} & "F_Calerndar.pq",
							CreateFunc 	= Folder{0} & "F_CreateFunc.pq"
							
						],
					Web	   =
						[	
							FinAnalys			= "https://github.com/Medvedevav632/FinAnalys/",
							PowerQueryFunction 	= "https://github.com/Medvedevav632/PowerQueryFunction/",
							Test = "https://raw.githubusercontent.com/buchlotnik/buchlotnik_functions/main/UnZip.pq"
							/* 	Web.Contents ‚Äì –ø–æ–ª—É—á–∞–µ—Ç –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é —Å —Å–∞–π—Ç–∞ 
								(raw.githubusercontent.com ‚Äì –æ—á–µ–Ω—å —É–¥–æ–±–Ω–∞—è —à—Ç—É–∫–∞ ‚Äì —Å—Ä–∞–∑—É –æ—Ç–¥–∞–µ—Ç –Ω–µ–ø–æ—Å—Ä–µ–¥—Å—Ç–≤–µ–Ω–Ω–æ 
								—Ç–µ–∫—Å—Ç —Ñ—É–Ω–∫—Ü–∏–∏ ‚Äì —Ç–∞–º –Ω–µ —Ç—Ä–µ–±—É–µ—Ç—Å—è –≤—ã—Ü–∞—Ä–∞–ø—ã–≤–∞—Ç—å –µ—ë –∏–∑ —Ä–∞–∑–º–µ—Ç–∫–∏ —Å—Ç—Ä–∞–Ω–∏—Ü—ã). 
								–î–∞–ª–µ–µ Text.FromBinary –ø–µ—Ä–µ–≤–æ–¥–∏—Ç –ø–æ–ª—É—á–µ–Ω–Ω—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –≤ —Ç–µ–∫—Å—Ç, 
								–∞ Expression.Evaluate + #shared –ø—Ä–µ–≤—Ä–∞—â–∞—é—Ç —Ç–µ–∫—Å—Ç –≤ –∫–æ–¥ */

						]
				],
			
			// 	—Ñ—É–Ω–∫—Ü–∏—è –∑–∞–≥—Ä—É–∑–∫–∏ –∫–æ–¥–∞ –ú:
			 	/*	–∏–∑ —Ç–µ–∫—Å—Ç–æ–≤–æ–≥–æ —Ñ–∞–π–ª–∞ */
				func=(x as text)=> 
					Expression.Evaluate(Text.FromBinary(File.Contents( Record.Field(from[Local], x) ) ), #shared),
			
				/*	–∏–∑ –∏–Ω—Ç–µ—Ä–Ω–µ—Ç–∞ */
				func2=(x as text)=> 	
					Expression.Evaluate(Text.FromBinary(Web.Contents( Record.Field(from[Web], x))), #shared),

			// 	—Ç–∏–ø–∏–∑–∞—Ü–∏—è —Ñ—É–Ω–∫—Ü–∏–∏ –∏ –µ–µ –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤
				typ = type function(
					x as (type text meta [	Documentation.FieldCaption 		= "–£–∫–∞–∂–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ —Ñ–∞–π–ª–∞ (–ø–æ–ª—è) —Å –ø—É—Ç–µ–º –∫ —Å–∫—Ä–∏–ø—Ç–∞–º",
											Documentation.FieldDescription 	= "–ù–æ–º–µ—Ä —Å—Ç—Ä–æ–∫–∏ –Ω–∞—á–∏–Ω–∞–µ—Ç—Å—è —Å –µ–¥–∏–Ω–∏—Ü—ã",
											Documentation.SampleValues 		= {"PackCalendar"},
											Documentation.AllowedValues 	= Record.FieldNames(from[Local])
											//Documentation.AllowedValues = List.Transform(Record.FieldValues(from[Local]),(x)=>Text.AfterDelimiter(x,"\", {0, RelativePosition.FromEnd})) // –Ω–∞–∑–≤–∞–Ω–∏—è —Ñ–∞–π–ª–æ–≤
										])
					) as any meta [	Documentation.Name            = "Load",
									// Documentation.LongDescription = "<b> –ì—Ä—É–∑–∏–º –∫–æ–¥ –ú –∏–∑ –ø–∞–ø–∫–∏ </b> <br>" & Text.Combine(Record.ToList(from[Local]),"<br>"),
									Documentation.LongDescription = "<b> –ì—Ä—É–∑–∏–º –∫–æ–¥ –ú –∏–∑ –ø–∞–ø–∫–∏ </b> <br>" & from[Folder]{0},
									Documentation.Examples = {[ 
										Description = "–í–æ–∑–≤—Ä–∞—â—è–µ—Ç –∑–∞–ø–∏—Å—å —Å —Ñ—É–Ω–∫—Ü–∏—è–º–∏", 
										Code 		= "=Load(""PackCalendar"")", 
										Result 		= Lines.ToText(List.Transform(Record.FieldNames(from[Local]),(x)=> """" & x & """")) // –Ω–∞–∑–≤–∞–Ω–∏—è –ø–æ–ª–µ–π –∑–∞–ø–∏—Å–∏ Local —Ç–µ–∫—Å—Ç–æ–º, —á—Ç–æ–±—ã –∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å –∏—Ö –≤ –∞—Ä–≥—É–º–µ–Ω—Ç —Ñ—É–Ω–∫—Ü–∏–∏
									]} ],
			
			// 	–≤—ã–≤–æ–¥–∏–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç —Ñ—É–Ω–∫—Ü–∏–∏
				result = Value.ReplaceType(func, typ) 
		in 	
			result,
	
	LoadLocal 	= // –∑–∞–≥—Ä—É–∑–∫–∞ –∑–∞–ø—Ä–æ—Å–æ–≤ —Å –ª–æ–∫–∞–ª—å–Ω–æ–≥–æ —Ñ–∞–π–ª–∞ –æ–¥–Ω–æ–π —Å—Ç—Ä–æ–∫–æ–π 
		Expression.Evaluate(
			Text.FromBinary(
				Binary.Buffer(
					File.Contents("G:\=EXCEL BI - –º–æ–∏ –ø—Ä–æ–µ–∫—Ç—ã\2024.01 - –ê–Ω–∞–ª–∏–∑ –û—Ç—á–µ—Ç–Ω–æ—Å—Ç–∏\2. PQ –∑–∞–ø—Ä–æ—Å—ã\F.pq")
				)
			), #shared
		),
	LoadGitOld 	= // –∑–∞–≥—Ä—É–∑–∫–∞ —Ñ—É–Ω–∫—Ü–∏–π —Å –ì–∏—Ç—Ö–∞–±–∞ / –ª–æ–∫–∞–ª—å–Ω–æ–π –ø–∞–ø–∫–∏ / –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è
		[	func = (fnName as text, optional BasePath as text) as function => // as function  –∫ —á–µ–º—É –æ–±—è–∑—ã–≤–∞–µ—Ç?!
                let
                    DefaultPath = "G:\=EXCEL PQ\PQ-function-load\",
                    GitHubPath  = "https://raw.githubusercontent.com/hohlick/pquery/master/",
                        
                    BasePath = if (BasePath <> null) then BasePath else DefaultPath,
                    Path = BasePath & (if Text.End(BasePath, 1) <> "\" then "\" else ""),
                    File = Path & fnName & ".pq",
                    
                    // –µ—Å–ª–∏ –ø—É—Ç—å —É–∂–µ –∏–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω –≤ —Ä–∞–±–æ—á—É—é –∫–Ω–∏–≥—É, –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–π –ø—É—Ç—å
					// –µ—Å–ª–∏ –µ—â–µ –Ω–µ –∏–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –∑–∞–≥—Ä—É–∑–∏—Ç—å –µ–≥–æ –∏–∑ —Ç–µ–∫—Å—Ç–æ–≤–æ–≥–æ —Ñ–∞–π–ª–∞ –≤ –ø–∞–ø–∫–µ
					// –µ—Å–ª–∏ –ø–∞–ø–∫–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞ - –≤–∑—è—Ç—å –∏–∑ GitHubPath
					Function = try Expression.Evaluate(Text.Replace(fnName, ".", "_"), #shared)  
                    otherwise try  Expression.Evaluate(Text.FromBinary(Binary.Buffer(File.Contents(File))), #shared) 
                    otherwise      Expression.Evaluate(Text.FromBinary(Binary.Buffer(Web.Contents(GitHubPath & fnName & ".pq"))), #shared)
                in
                    Function
        ][func],
	
	LoadPq   	= // –∑–∞–≥—Ä—É–∑–∫–∞ —Ñ—É–Ω–∫—Ü–∏–π –∏–∑ —Ñ–∞–π–ª–∞. x - –ø–æ–ª–Ω—ã–π –ø—É—Ç—å + –∏–º—è —Ñ–∞–π–ª–∞ —Å —Ä–∞—Å—à–∏—Ä–µ–Ω–∏–µ–º
		(path)=>Expression.Evaluate(Text.FromBinary(Binary.Buffer(File.Contents(path))), #shared),
	
	// Load files
	LoadBinCSV  = // –∑–∞–≥—Ä—É–∑–∫–∞ —Ñ–∞–π–ª–∞ CSV 
		/*
			–ü—Ä–∏–º–µ—Ä:		
				= Table.AddColumn(from, "tmp", (x)=> F[LoadBinCSV](x[Content]) )
			–£–ª—É—á—à–µ–Ω–∏–µ:	
				1 Delimiter –≤  –∞—Ä–≥—É–º–µ–Ω—Ç—ã
			–°–ø—Ä–∞–≤–∫–∞:
				QuoteStyle.Csv, –∫–æ–≥–¥–∞ –≤—Å—Ç—Ä–µ—á–∞–µ—Ç—Å—è –∫–∞–≤—ã—á–∫–∞, –≤–µ—Å—å –ø–æ—Å–ª–µ–¥—É—é—â–∏–π —Ç–µ–∫—Å—Ç –æ—Å—Ç–∞–≤–ª—è–µ—Ç—Å—è –≤ –Ω–µ–∏–∑–º–µ–Ω–Ω–æ–º –≤–∏–¥–µ, –ø–æ–∫–∞ –Ω–µ –≤—Å—Ç—Ä–µ—Ç–∏—Ç—Å—è —Å–ª–µ–¥—É—é—â–∞—è –∫–∞–≤—ã—á–∫–∞; —Å–∞–º–∏ –∫–∞–≤—ã—á–∫–∏ –ø—Ä–∏ —ç—Ç–æ–º —É–¥–∞–ª—è—é—Ç—Å—è
    			QuoteStyle.None –∫–∞–≤—ã—á–∫–∏ –≤–æ—Å–ø—Ä–∏–Ω–∏–º–∞—é—Ç—Å—è –∫–∞–∫ –æ–¥–∏–Ω –∏–∑ —Å–∏–º–≤–æ–ª–æ–≤ –∏ –µ—Å–ª–∏ –º–µ–∂–¥—É –Ω–∏–º–∏ –µ—Å—Ç—å –ø—Ä–æ–±–µ–ª—å–Ω—ã–µ —Å–∏–º–≤–æ–ª—ã ‚Äì –ø–æ –Ω–∏–º –ø—Ä–æ–∏–∑–æ–π–¥–µ—Ç —Ä–∞–∑–¥–µ–ª–µ–Ω–∏–µ
		*/
		(x)=> let
			from = Csv.Document(x,[Delimiter=";", Encoding=65001, QuoteStyle=QuoteStyle.None]),
			to   = Table.PromoteHeaders(from, [PromoteAllScalars=true])
		in	to,

	LoadCSV  	= // –∑–∞–≥—Ä—É–∑–∫–∞ —Ñ–∞–π–ª–∞ CSV (–ø—É—Ç—å)
		/* 	–ü—Ä–∏–º–µ—Ä:	
				= F[LoadCSV]( "G:\=EXCEL BI - –º–æ–∏ –ø—Ä–æ–µ–∫—Ç—ã\2024.01 - –ê–Ω–∞–ª–∏–∑ –û—Ç—á–µ—Ç–Ω–æ—Å—Ç–∏\4. CSV –≤—ã–≥—Ä—É–∑–∫–∞\–ë–µ–ª–∫–æ–æ–ø—Å–æ—é–∑\_v_3.csv")
		*/
		(pathFile as text)=>
			Table.PromoteHeaders(
				Csv.Document(
					File.Contents(pathFile),
					[Delimiter=";", Encoding=65001, QuoteStyle=QuoteStyle.None]
				), 
				[PromoteAllScalars=true]
			),
	LoadPath 	= // –∑–∞–≥—Ä—É–∑–∫–∞ –ø—É—Ç–∏ —Å –ª–∏—Å—Ç–∞ —Ç–µ–∫—É—â–µ–π –∫–Ω–∏–≥–∏
			"Excel.CurrentWorkbook(){[Name=""Table1""]}[Content]{0}[Path]",				
	
	// —Ä–∞–∑–æ–±—Ä–∞—Ç—å –∏ –ø—Ä–æ–≤–µ—Ä–∏—Ç—å —Ñ—É–Ω–∫—Ü–∏–∏
	fxFillRightOrLeft = // –∑–∞–ø–æ–ª–Ω–µ–Ω–∏–µ –≤–ø—Ä–∞–≤–æ, –≤–ª–µ–≤–æ //todo –Ω–æ–≤–∞—è —Ñ—É–Ω–∫—Ü–∏—è
		/* 
			https://gist.github.com/m-dekorte/56b996be4f51a6eaab6132e1e46db30d
			–ü—Ä–∏–º–µ—Ä
			let
				Source = #table(
					type table [Entry = Text.Type, Category = Text.Type, SubCategory = Text.Type, Amount = Currency.Type], 
					{
						{"Expense", "Travel", null, 1500},
						{"Expense", null, "Airfare", 500},
						{"Expense", null, "Hotel", 1000},
						{"Expense", "Office Supplies", null, 300},
						{"Expense", null, "Stationery", 100},
						{"Expense", null, "Furniture", 200}
					}
				),
				FillRight = fillRightOrLeft(Source, null, 3),
				FillRightCollSelection = fillRightOrLeft(Source, {"Category", "SubCategory"}, 3),
				FillLeft = fillRightOrLeft(Source, null, null, true),
				FillLeftCollSelection = fillRightOrLeft(Source, {"Category", "SubCategory"}, 3, true),
				BreakDown = Table.AddColumn( Source, "break down", each 
					[
						recToTable = Record.ToTable(_),
						fillRight = Table.FillDown(recToTable, {"Value"}),
						fillLeft = Table.FillUp(recToTable, {"Value"})
					]
				),
				Review = BreakDown{0}[break down]
			in
				Review
		*/
		( 	tbl as table, 				 // —Ç–∞–±–ª–∏—Ü–∞ –∏—Å—Ç–æ—á–Ω–∏–∫
			optional fillCols as list, 	 // —Å–ø–∏—Å–æ–∫ –∫–æ–ª–æ–Ω–æ–∫ –¥–ª—è –∑–∞–ø–æ–ª–Ω–µ–Ω–∏—è. –ï—Å–ª–∏ –Ω–µ —É–∫–∞–∑–∞–Ω = null, —Ç–æ –≤—Å–µ –æ–±—Ä–∞–±–∞—ã–≤–∞—é—Ç—Å—è –∫–æ–ª–æ–Ω–∫–∏ (allCols)
			optional topRows  as number, // —Å–∫–æ–ª—å–∫–æ —Å—Ç—Ä–æ–∫ –∏–∑ –≤–µ—Ä—Ö–Ω–µ–π —á–∞—Å—Ç–∏ —Ç–∞–±–ª–∏—Ü—ã –±—É–¥—É—Ç –∑–∞–ø–æ–ª–Ω—è—Ç—å—Å—è. –ï—Å–ª–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä = null, —Ç–æ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç—Å—è –≤—Å—è —Ç–∞–±–ª–∏—Ü–∞
			optional fillLeft as logical // –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∑–∞–ø–æ–ª–Ω–µ–Ω–∏—è. true ‚Äî –∑–∞–ø–æ–ª–Ω–µ–Ω–∏–µ –≤–≤–µ—Ä—Ö FillUp, –µ—Å–ª–∏ false (–∏–ª–∏ –Ω–µ –∑–∞–¥–∞–Ω–æ) ‚Äî –∑–∞–ø–æ–ª–Ω–µ–Ω–∏–µ –≤–Ω–∏–∑ FillDown
		) as table => 
		
		let
			fillFunction = 
				if fillLeft ?? false 
				then Table.FillUp 
				else Table.FillDown,
			
			tableRows = if topRows = null 
				then tbl 
				else Table.FirstN(tbl, topRows),
			
			allCols = Table.ColumnNames( tbl ),
			
			// –ó–∞–ø–æ–ª–Ω–µ–Ω–∏–µ –∫ –≤—ã–±—Ä–∞–Ω–Ω—ã–º –∫–æ–ª–æ–Ω–∫–∞–º
			fillSideways = 
				Table.TransformRows( tableRows,
					(x)=> x & Record.FromTable(
						fillFunction( 
							Record.ToTable( 
								Record.SelectFields(x, fillCols ?? allCols, MissingField.Ignore)
							), 
							{"Value"}
						)
					)
				),
			
			// —Ä–µ–∑—É–ª—å—Ç–∞—Ç –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç—Å—è –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç—Å—è –≤ —Ç–æ–º –∂–µ —Ñ–æ—Ä–º–∞—Ç–µ, —á—Ç–æ –∏ –∏—Å—Ö–æ–¥–Ω–∞—è —Ç–∞–±–ª–∏—Ü–∞, —Å–æ—Ö—Ä–∞–Ω—è—è –µ–µ —Ç–∏–ø
			result = 
				if topRows = null 
				then Value.ReplaceType( 
						Table.FromRecords( fillSideways ), 
						Value.Type(tbl)
					)
				else Value.ReplaceType( 
						Table.FromRecords( fillSideways ) & Table.Skip( tbl, topRows ), 
						Value.Type(tbl)
					)
		in
			result,

	Table.ToMCode = // –ø—Ä–µ–≤—Ä–∞—â–∞–µ—Ç —Ç–∞–±–ª–∏—Ü—É –∏–∑ –∑–∞–ø—Ä–æ—Å–∞ –≤ —Ç–∞–±–ª–∏—Ü—É –≤ –∫–æ–¥–∏—Ä–æ–≤–∫–µ –ú. //? –ï—Å—Ç—å –ª—É—á—à–µ - CreateTable
		let
			func = (Table1 as table) =>
				let
					Table = Table1,
					ReplaceNulls 	= Table.ReplaceValue( Table, null, "", Replacer.ReplaceValue, Table.ColumnNames(Table) ),
					ListOfColumns 	= Table.ToRows( ReplaceNulls ),
					ConvertToTable 	= Table.FromList( ListOfColumns, Splitter.SplitByNothing(), null, null, ExtraValues.Error ),
					CoreString 		= Table.AddColumn( ConvertToTable, "Custom", each Text.Combine(List.Transform([Column1], each Text.From(_)), """ ,""")),
					FullString = "= #table( {"""
						& Text.Combine(Table.ColumnNames(Table), """, """)
						& """}, #(lf) { {"""
						& Text.Combine(CoreString[Custom], """}, #(lf) {""")
						& """} } ) ",
					ReplaceBlanks = Text.Replace(FullString, """""", "null")
				in
					ReplaceBlanks,
			documentation = [
				Documentation.Name = " Table.ToMCode ",
				Documentation.Description = " Transforms a  <code>Table</code>  to a string of M code that will create that table in the query editor. ",
				Documentation.LongDescription = " Transforms a  <code>Table</code>  to a string of M code that will create that table in the query editor. ",
				Documentation.Category 	= " Table ",
				Documentation.Source 	= "  ",
				Documentation.Version 	= " 1.0 ",
				Documentation.Author 	= " Imke Feldmann: www.TheBIccountant.com . ",
				Documentation.Examples 	= {[Description = "  ", Code = "  ", Result = "  "]}
			]
		in
			Value.ReplaceType(func, Value.ReplaceMetadata(Value.Type(func), documentation)),
	
	fxExportCSV   = // —ç–∫—Å–ø–æ—Ä—Ç –≤ —Ñ–æ—Ä–º–∞—Ç CSV. –ü—Ä–æ–≤–µ—Ä–∏—Ç—å —Ä–∞–±–æ—Ç—É. –ù–µ –≤—Å–µ –ø–æ–ª—É—á–∞–µ—Ç—Å—è!
		(	table_to_export as nullable table, 
			folder as text, 
			filename as text
		) as nullable table => 
		
		let
			_tbl = table_to_export, 
			
			p = [
				folder_normalized       = if Text.EndsWith(folder,"\") then folder else (folder & "\"),
				folder_web_format       = Text.Replace(folder_normalized, "\", "/"),
				filename_with_extension = if Text.EndsWith(Text.Lower(filename),".csv") then filename else filename & ".csv",
				full_filename           = folder_web_format & filename_with_extension,
				tblexport = ()=> 
					if _tbl = null 
					then #table(null,{}) 
					else _tbl
				],

			json = 
				Text.FromBinary
					(Json.FromValue(
					Table.ToRows( p[tblexport]() )
					), 
				1251
				),

			json2 =   
				Text.Replace(
					Text.FromBinary(
					Json.FromValue(
						Table.ToRows( p[tblexport]() )
					), 
					1251
					),",",";"
				),

			// objFile.WriteLine(arr.map(row => row.join(';')).join('\n'));
			
			// objFile.WriteLine(arr.join('\n'));
			// objFile.WriteLine(arr.join(';'));
			// var semicolonArr = arr.map(row => row.split(',').join(';'));
			// objFile.WriteLine(semicolonArr.join('\n'));
			// objFile.WriteLine(arr.join('\n'));
			export_csv = Web.Page("
				<script>
					var fso=new ActiveXObject('Scripting.FileSystemObject');
					var objFile=fso.OpenTextFile('" & p[full_filename] & "',2 , true);
					var arr=" & json & ";
					var arrWithSemicolon = arr.map(row => row.map(cell => cell.replace(/,/g, ';')).join(';')).join('\n');
					objFile.WriteBlankLines(0);
					objFile.Close(); 
				</script>"
				),
			
			to = 
				if export_csv=null
				then p[tblexport]() 
				else p[tblexport]() 
		in to
	],

MyPack    = [ // –º–æ—è –±–∏–±–ª–∏–æ—Ç–µ–∫–∞ —Ñ—É–Ω–∫—Ü–∏–π üî•
//	UNIVERSAL LOADER üîπ 
	Folder.LoadFiles 	 = // –ø–æ–¥–∫–ª—é—á–∞–µ–º—Å—è –∫ –ø–∞–ø–∫–µ (–æ—Ç 01.11.2025)	—É–±—Ä–∞—Ç—å –ø—Ä–æ–≤–µ—Ä–∫—É –Ω–∞ input null. –•–æ—Ç—å –æ–¥–∏–Ω –∞—Ä–≥—É–º–µ–Ω—Ç –≤—Å–µ–≥–¥–∞ –±—É–¥–µ—Ç/–¥–æ–ª–∂–µ–Ω –±—ã—Ç—å
	// üî•üî• todo  —Ä–∞–∑–¥–µ–ª–∏—Ç–µ–ª—å —Å–¥–µ–ª–∞—Ç—å –≤ —à–∞–≥–µ 5!! 
		/* 
			–û–ø–∏—Å–∞–Ω–∏–µ:
				1. –ø–æ–¥–∫–ª—é—á–∞–µ–º—Å—è –∫ –ø–∞–ø–∫–µ —Å —Ñ–∞–π–ª–∞–º–∏ –ø–æ –∏–º–µ–Ω–∏ –¥–∞—Ç–∞—Å–µ—Ç–∞ –∏–ª–∏ –ø–æ –ø–æ–ª–Ω–æ–º—É –ø—É—Ç–∏
				2. –≤—ã–±–∏—Ä–∞–µ–º –Ω–æ–º–µ—Ä —à–∞–≥–∞ –∑–∞–≥—Ä—É–∑–∫–∏. –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é –≤—ã–≥—Ä—É–∂–∞–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–π —à–∞–≥
				3. —á–∏—Å—Ç–∏–º –ø–∞–ø–∫—É –æ—Ç –≤—Ä–µ–º–µ–Ω–Ω—ã—Ö –∏ —Å–∫—Ä—ã—Ç—ã—Ö —Ñ–∞–π–ª–æ–≤, –æ—Å—Ç–∞–≤–ª—è–µ–º —Ñ–∞–π–ª—ã .xlsx –∏–ª–∏ .csv, –ø—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –±–∏–Ω–∞—Ä–Ω–∏–∫–∏
				4. –¥–ª—è csv —Ä–∞–∑–¥–µ–ª–∏—Ç–µ–ª—å —Å—Ç–æ–∏—Ç –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é - ","
				5. –≤ –∫–Ω–∏–≥–∞—Ö excel –æ—Å—Ç–∞–≤–ª—è–µ–º —Ç–æ–ª—å–∫–æ –ª–∏—Å—Ç—ã (Sheet), –≤ csv –ø–æ—Å–ª–µ —Å–∫—Ä–∏–ø—Ç–∞ –ø–∏—Ç–æ–Ω–∞ –æ–¥–∏–Ω –ª–∏—Å—Ç –±–µ—Ä–µ—Ç—Å—è, –ø–µ—Ä–≤—ã–π –≤–∏–¥–∏–º—ã–π
			
			–ü—Ä–∏–º–µ—Ä:	
				–†–∞–±–æ—á–∏–π –≤–∞—Ä–∏–∞–Ω—Ç –æ—Ç26.10.2025
				= F[Folder.LoadFiles]([Path = "G:\=EXCEL BI - –º–æ–∏ –ø—Ä–æ–µ–∫—Ç—ã\2000 - –ú–ò–ù–ò –ø—Ä–æ–µ–∫—Ç—ã\2025.10 - –ú–∏–Ω—Å–∫–æ–µ —Ä–∞–π–ø–æ\–ò—Å—Ö–æ–¥–Ω–∏–∫–∏\XLSX", 
					FileExtension = "xlsx", MaskNameFile = "–±–∞–ª", SubFolders = false, ExpandSheets = false, SheetNames = true, Step = 5, 
					FilterFunction = (x)=>Text.Contains(x[Item], "99")] )

				–í–∞—Ä–∏–∞–Ω—Ç 1. –ü—É—Ç—å –∑–∞–¥–∞–Ω, –≤—Å–µ –æ—Å—Ç–∞–ª—å–Ω–æ–µ –ø–æ false. "\" –≤ –∫–æ–Ω—Ü–µ –º–æ–∂–Ω–æ –ø—Ä–æ–ø—É—Å—Ç–∏—Ç—å, –Ω–µ –≤–∞–∂–Ω–æ
				= F[Folder.LoadFiles]([Path = "G:\=EXCEL BI\", 
				Extension = "xlsx", SubFolders = false, ExpandSheet = false, ShowSheet = false, Step = 0])
				
				–í–∞—Ä–∏–∞–Ω—Ç 1. –ü—É—Ç—å –∑–∞–¥–∞–Ω, –≤—Å–µ –æ—Å—Ç–∞–ª—å–Ω–æ–µ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
					to = F[Folder.LoadFiles]( [Path = "G:\=EXCEL BI - –º–æ–∏ –ø—Ä–æ–µ–∫—Ç—ã\"] ) 
				
				–í–∞—Ä–∏–∞–Ω—Ç 2. –ù–µ —Ä–∞–∑–≤–æ—Ä–∞—á–∏–≤–∞–µ–º –ø–æ–¥—Ç–∞–±–ª–∏—Ü—ã –∏ –ø–æ–∫–∞–∑—ã–≤–∞–º –∫–æ–ª–æ–Ω–∫—É —Å –∏–º–µ–Ω–∞–º–∏ –ª–∏—Å—Ç–æ–≤
					to = F[Folder.LoadFiles]( [Path = "G:\=EXCEL BI - –º–æ–∏ –ø—Ä–æ–µ–∫—Ç—ã", ShowSheet = true ])
				
				–í–∞—Ä–∏–∞–Ω—Ç 3. –†–∞–∑–≤–æ—Ä–∞—á–∏–≤–∞–µ–º –ø–æ–¥—Ç–∞–±–ª–∏—Ü—ã –∏ –ø–æ–∫–∞–∑—ã–≤–∞–º –∫–æ–ª–æ–Ω–∫—É —Å –∏–º–µ–Ω–∞–º–∏ –ª–∏—Å—Ç–æ–≤
					to = F[Folder.LoadFiles]( [Path = "G:\=EXCEL BI - –º–æ–∏ –ø—Ä–æ–µ–∫—Ç—ã", ExpandSheet = 1, ShowSheet = 1])
			
				0  —Å–¥–µ–ª–∞—Ç—å –ø–∞—Ä–∞–º–µ—Ç—Ä –∫–æ—Ç–æ—Ä—ã–π–±—É–¥–µ—Ç —Ñ–∏–ª—å—Ç—Ä–æ–≤–∞—Ç—å –ª–∏—Å—Ç—ã –≤–Ω—É—Ç–∏ —Ç–∞–±–ª–∏—Ü xlsx
				1  –≤ csv –ø–æ–¥–Ω–∏–º–∞—Ç—å –∏–ª–∏ –Ω–µ–ø–æ–¥–Ω–∏–º–∞—Ç—å –∑–∞–≥–æ–ª–æ–≤–∫–∏ –≤ –†–∞—Å–ø—Å–∏–∞–Ω–∏–µ –∂—ç—Ç–æ–≥–æ –Ω–µ–¥–∞–ª—Ç—å –Ω–µ –Ω–∞–¥–æ
			*/
		let
			func   = (input as record) => [ 	
				// 	–ê–†–ì–£–ú–ï–ù–¢–´ –®–∞–≥ 1. –ó–Ω–∞—á–µ–Ω–∏—è –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
					defaultOptions	= [
							Path		   = "", 	 // –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–π –ø–∞—Ä–∞–º–µ—Ç—Ä
							FileExtension  = "xlsx", // —Ä–∞—Å—à–∏—Ä–µ–Ω–∏—è —Ñ–∞–π–ª–∞
							FileMaskName   = "",     // –º–∞—Å–∫–∞ –∏–º–µ–Ω–∏ —Ñ–∞–π–ª–∞
							SubFolders 	   = false,	 // –±–µ—Ä–µ–º —Ñ–∞–π–ª—ã —Ç–µ–∫—É—â–µ–π –ø–∞–ø–∫–∏, –≤ –ø–æ–¥–ø–∞–ø–∫–∏ –Ω–µ —Å–º–æ—Ç—Ä–∏–º
							ExpandSheets   = false,	 // –ª–∏—Å—Ç—ã –∫–Ω–∏–≥ –Ω–µ —Ä–∞—Å–∫—Ä—ã–≤–∞–µ–º –≤ –æ—Ç–¥–µ–ª—å–Ω—ã–µ —Å—Ç—Ä–æ–∫–∏ // —É—Ç–æ—á–Ω–∏—Ç—å –ø—Ä–∏–º–µ—Ä—ã
							SheetNames     = false,	 // –∫–æ–ª–æ–Ω–∫—É —Å –∏–º–µ–Ω–∞–º–∏ –ª–∏—Å—Ç–æ–≤ –Ω–µ –ø–æ–∫–∞–∑—ã–≤–∞–µ–º
							Step		   = 0,		 // –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–π —à–∞–≥ —Ñ—É–Ω–∫—Ü–∏–∏
							FilterFunction = null    // —Ñ—É–Ω–∫—Ü–∏—è —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏ –ª–∏—Å—Ç–æ–≤ // –Ω–∞–∑–≤–∞–Ω–∏–µ –¥–æ–±–∞–≤–∏—Ç—å fSheetsFilter
													 // todo –¥–æ–±–∞–≤–∏—Ç—å —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏—é –ø–æ –∏–º–µ–Ω–∏ –ø–∞–ø–∫–∏, –µ—Å–ª–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä –≤–∫–ª—é—á–µ–Ω
						],
					
				// 	–ê–†–ì–£–ú–ï–ù–¢–´ –®–∞–≥ 2. –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ—Å—Ç—å
					// 	–≤–æ–∑–≤—Ä–∞—â–∞–µ–º —Å–ø–∏—Å–æ–∫ –Ω–µ–≤–µ—Ä–Ω—ã—Ö –∏–º–µ–Ω –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤
						invalidFields = List.Difference(
							if input = null then {} else Record.FieldNames(input),	// —Å–ø–∏—Å–æ–∫ –≤–≤–µ–¥–µ–Ω–Ω—ã—Ö –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤
							Record.FieldNames(defaultOptions) 						// —Å–ø–∏—Å–æ–∫ –¥–æ–ø—É—Å—Ç–∏–º—ã—Ö –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤
						),

					//  —Å–æ–≤–º–µ—â–∞–µ–º –æ–ø—Ü–∏–∏, –µ—Å–ª–∏ –Ω–µ—Ç –æ—à–∏–±–æ–∫ - —É checkArguments (input) –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç –Ω–∞ –ø–µ—Ä–µ–∑–∞–ø–∏—Å—å 
						finalOptions = 
							if List.Count(invalidFields) > 0 
							then error 	"–ù–µ–≤–µ—Ä–Ω—ã–π –∞—Ä–≥—É–º–µ–Ω—Ç(—ã): "   & Text.Combine(invalidFields, ", ") & 
										". –î–æ–ø—É—Å—Ç–∏–º—ã–µ –∞—Ä–≥—É–º–µ–Ω—Ç—ã: " & Text.Combine(Record.FieldNames(defaultOptions), ", ")
							else Record.Combine({defaultOptions, input ?? defaultOptions}), // –æ–ø–µ—Ä–∞—Ç–æ—Ä ?? –ø—Ä–æ–≤–µ—Ä—è–µ—Ç input –Ω–∞ null

				//	–ê–†–ì–£–ú–ï–ù–¢–´ –®–∞–≥ 3. –¢–∏–ø–∏–∑–∞—Ü–∏—è –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤
					GetValue  	= // —Ñ—É–Ω–∫—Ü–∏—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è —Ç–∏–ø–∞ –≤—Ö–æ–¥–Ω—ã—Ö –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤
						// todo –í–ù–ò–ú–ê–ù–ò–ï! –ó–Ω–∞—á–µ–Ω–∏–µ 0 (–Ω–æ–ª—å) –±—É–¥–µ—Ç —Å—á–∏—Ç–∞—Ç—å—Å—è "–Ω–µ–≤–∞–ª–∏–¥–Ω—ã–º" –∏ –∑–∞–º–µ–Ω—è—Ç—å—Å—è –Ω–∞ null. 
						// todo –≠—Ç–æ –∫—Ä–∏—Ç–∏—á–Ω–æ –¥–ª—è —á–∏—Å–ª–æ–≤—ã—Ö –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ (–Ω–∞–ø—Ä–∏–º–µ—Ä, kodStart –∏–ª–∏ kodEnd), –≥–¥–µ 0 ‚Äî –¥–æ–ø—É—Å—Ç–∏–º–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ.
						// 	–ü—É—Å—Ç–∞—è —Å—Ç—Ä–æ–∫–∞ "" —Ç–∞–∫–∂–µ –±—É–¥–µ—Ç –º–µ–Ω—è—Ç—å—Å—è –Ω–∞ null, —á—Ç–æ –Ω–µ–≤–µ—Ä–Ω–æ –¥–ª—è —Ç–µ–∫—Å—Ç–æ–≤—ã—Ö –ø–æ–ª–µ–π, –Ω–∞–ø—Ä–∏–º–µ—Ä Extension
						(options as record, fieldName as text, typeConverter as function) =>
							let value  = Record.FieldOrDefault(options, fieldName, null)
							in	if List.Contains({null, 0, ""}, value) then null else typeConverter(value),

					FULLPATH	= GetValue(finalOptions, "Path", 			Text.From	),	// "C:\" –∏–ª–∏ "C:", –µ—Å—Ç—å –ø—Ä–æ–≤–µ—Ä–∫–∞
					EXTENSION 	= GetValue(finalOptions, "FileExtension",	Text.From	),	// xls, csv, xlsx, –¥—Ä.
					MASKNAME    = GetValue(finalOptions, "FileMaskName", 	Text.From	),  // –º–∞—Å–∫–∞ –∏–º–µ–Ω–∏ —Ñ–∞–π–ª–∞ "–±–∞–ª"
					SUBFOLDERS	= GetValue(finalOptions, "SubFolders",		Logical.From),	// –æ–±—Ä–∞–±–æ—Ç–∫–∞ –ø–æ–¥–ø–∞–ø–æ–∫
					EXPANDSHEET	= GetValue(finalOptions, "ExpandSheets",   	Logical.From),	// —Ä–∞–∑–≤–æ—Ä–∞—á–∏–≤–∞—Ç—å –ª–∏—Å—Ç—ã
					SHOWSHEET	= GetValue(finalOptions, "SheetNames", 		Logical.From),	// –ø–æ–∫–∞–∑—ã–≤–∞—Ç—å –∫–æ–ª–æ–Ω–∫—É —Å –ª–∏—Å—Ç–∞–º–∏ –≤ –∫–æ–Ω—Ü–µ
					STEP     	= GetValue(finalOptions, "Step", 		   	Number.From	),	// –Ω–æ–º–µ—Ä —à–∞–≥–∞ 
					FUNC	    = GetValue(finalOptions, "FilterFunction", 	Function.From),
					
										
				//	1. path				—Ñ–æ—Ä–º–∏—Ä—É–µ–º –ø–æ–ª–Ω—ã–π –∏ –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω—ã–π path –∫ –ø–∞–ø–∫–µ –∏–ª–∏ –ø–æ–¥–ø–∞–ø–∫–∞–º
					/* –û–ø–∏—Å–∞–Ω–∏–µ —à–∞–≥–∞:
					   FullFolderPath:	–ú–µ–Ω—è–µ–º –≤—Å–µ —Å–∏–º–≤–æ–ª—ã / –Ω–∞ \ –≤ –¥–ª—è –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–≥–æ —É–∫–∞–∑–∞–Ω–∏—è –ø—É—Ç–∏ –≤ Windows
					   FolderPath:	 	C—Ç–∞–≤–∏–º "\" –≤ –∫–æ–Ω—Ü–µ —Å—Ç—Ä–æ–∫–∏, –µ—Å–ª–∏ –µ–≥–æ –Ω–µ—Ç
					   Source:			–ï—Å–ª–∏ SUBFOLDERS = true, —Ç–æ –∏–∑–≤–ª–µ–∫–∞–µ–º —Ç–æ–ª—å–∫–æ —Ñ–∞–π–ª—ã –∏–∑ —ç—Ç–æ–π –ø–∞–ø–∫–∏, false -  –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –≤—Å–µ —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ –ø–∞–ø–∫–∏ —Å –ø–æ–¥–∫–∞—Ç–∞–ª–æ–≥–∞–º–∏
					   ChildFolder:		–£–±–∏—Ä–∞–µ–º –∏–∑ —Å—Ç–æ–ª–±—Ü–∞ "Folder Path" –ø—É—Ç—å FolderPath –¥–µ–ª–∞—è –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω—ã–π –ø—É—Ç—å –∫ —Ñ–∞–π–ª–∞–º */
					FullFolderPath 	= Text.Replace(FULLPATH,"/","\"),
					FolderPath 		= if Text.EndsWith(FullFolderPath,"\") then FULLPATH else FULLPATH & "\",
					Source 			= if SUBFOLDERS = true then Folder.Files(FolderPath) else Folder.Contents(FolderPath),
					ChildFolder 	= Table.ReplaceValue(Source, FolderPath, "", Replacer.ReplaceText, {"Folder Path"}),
					
				//	2. Output			–≤–æ–∑–≤—Ä–∞—â–∞–µ–º —Ç–∞–±–ª–∏—Ü—É —Å "Extension" –≤ –Ω–∏–∂–Ω–µ–º —Ä–µ–≥–∏—Å—Ç—Ä–µ –µ—Å–ª–∏ path —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
					/* –û–ø–∏—Å–∞–Ω–∏–µ —à–∞–≥–∞:
					   DesiredOutput	–º–µ–Ω—è–µ–º –≤—Å–µ —Å–∏–º–≤–æ–ª—ã / –Ω–∞ \ –≤ —Å—Ç–æ–ª–±—Ü–µ "Folder Path" –¥–ª—è –µ–¥–∏–Ω–æ–æ–±—Ä–∞–∑–∏—è —Ñ–æ—Ä–º–∞—Ç–∞ –ø—É—Ç–∏
					   BlankTable		—Å–æ–∑–¥–∞–µ–º –ø—É—Å—Ç—É—é —Ç–∞–±–ª–∏—Ü—É, –µ—Å–ª–∏ –≤ —à–∞–≥ DesiredOutput –Ω–µ —É–¥–∞–ª—Å—è - –ø—É—Ç—å –ø—É—Å—Ç –∏–ª–∏ –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
					   ActiveTable		–≤–æ–∑–≤—Ä–∞—â–∞–µ–º –∏–ª–∏ —Ç–∞–±–ª–∏—Ü—É —Å –¥–∞–Ω–Ω—ã–º–∏ –∏–ª–∏ –ø—É—Å—Ç—É—é, –µ—Å–ª–∏ –ø—É—Ç–∏ DesiredOutput –Ω–µ—Ç
					   Output:			–ø—Ä–∏–≤–æ–¥–∏–º —Ä–∞—Å—à–∏—Ä–µ–Ω–∏—è –≤ —Å—Ç–æ–ª–±—Ü–µ "Extension" –∫ –Ω–∏–∂–Ω–µ–º—É —Ä–µ–≥–∏—Å—Ç—Ä—É, –¥–µ–ª–∞—è –∏—Ö –µ–¥–∏–Ω–æ–æ–±—Ä–∞–∑–Ω—ã–º–∏ */
					DesiredOutput 	  = Table.ReplaceValue(ChildFolder,"/","\",Replacer.ReplaceText,{"Folder Path"}),
					BlankTable 		  = Table.FromRows({},{"Content","Name","Extension","Date accessed","Date modified","Date created","Attributes","Folder Path"}),
					ActiveTable 	  = try DesiredOutput otherwise BlankTable,
					Output 			  = Table.TransformColumns(ActiveTable,{{"Extension", Text.Lower, type text}}),

				// 	3. FilteredRows		—Ñ–∏–ª—å—Ç—Ä—É–µ–º —Å—Ç—Ä–æ–∫–∏: –æ—Å—Ç–∞–≤–ª—è–µ–º —Ñ–∞–π–ª—ã –Ω—É–∂–Ω–æ–≥–æ —Ñ–æ—Ä–º–∞—Ç–∞, —É–±–∏—Ä–∞–µ–º —Å–∫—Ä—ã—Ç—ã–µ –∏ –≤—Ä–µ–º–µ–Ω–Ω—ã–µ —Ñ–∞–π–ª—ã
					// –æ–±—Ä–µ–∑–∞–µ–º –ø–æ–ª–Ω—ã–π –ø—É—Ç—å // TruncateNames 	= Table.TransformColumns(Output, {{"Folder Path", each Text.Start(_, 250), type text}}),
					FilteredRows 	= Table.SelectRows(Output, each 
							// Text.Length([Folder Path] & [Name]) <= 250 		// –µ—Å–ª–∏ —Å–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω—ã–π –ø—É—Ç—å, –Ω–∞–¥–æ –ª–∏, –ø—Ä–æ–≤–µ—Ä–∏—Ç—å
							Text.AfterDelimiter([Extension], ".") = EXTENSION 	// –æ—Å—Ç–∞–≤–ª—è–µ–º –Ω—É–∂–Ω—ã–µ —Ñ–æ—Ä–º–∞—Ç—ã —Ñ–∞–π–ª–æ–≤
							and [Attributes][Hidden] = false 				 	// —É–±–∏—Ä–∞–µ–º —Å–∫—Ä—ã—Ç—ã–µ
							and not Text.StartsWith([Name], "~$")			 	// —É–±–∏—Ä–∞–µ–º –≤—Ä–µ–º–µ–Ω–Ω—ã–µ
							and (try Text.Contains([Name], MASKNAME) otherwise true) // —Ñ–∏–ª—å—Ç—Ä—É–µ–º —Ñ–∞–π–ª—ã –ø–æ –º–∞—Å–∫–µ –∏–º–µ–Ω–∏. try –ø—Ä–∏ "" —Ç–∞–∫ –∫–∞–∫ –≤ GetValue –º–µ–Ω—è–µ–º "" –Ω–∞ null
					),
				
				//  4. Trans			—Ñ–∏–ª—å—Ç—Ä—É–µ–º –∫–æ–ª–æ–Ω–∫–∏ + –º–µ–Ω—è–µ–º —Ñ–æ—Ä–º–∞—Ç –∫–æ–ª–æ–Ω–æ–∫ 
					nms   = {"Folder Path","Name","Extension","Content","Date accessed","Date modified","Date created","Attributes"},
					Sel	  = Table.SelectColumns(FilteredRows, nms),
					Trans = Table.TransformColumns(Sel, {
								{"Date created", (x)=> DateTime.Date(x), type date},
								{"Folder Path",  (x)=> Text.AfterDelimiter(x, "\", {2, RelativePosition.FromEnd}), type text}
							}),
				
				//  5. TransformBinary	–ø—Ä–µ–æ–±—Ä–∞–∑—É–µ–º binary –≤ —Ç–∞–±–ª–∏—Ü—É, —Ñ–∏–ª—å—Ç—Ä—É–µ–º —Å—Ç—Ä–æ–∫–∏ –≤ –ø–æ–¥—Ç–∞–±–ª–∏—Ü–∞—Ö // –æ—Å—Ç–∞–≤–ª—è–µ–º –æ–¥–∏–Ω –ª–∏—Å—Ç
					TransformBinary = [
						//	—Ñ—É–Ω–∫—Ü–∏–∏ —Ñ–∏–ª—å—Ç—Ä–æ–≤–∫–∏ –ª–∏—Å—Ç–æ–≤ –≤ –∫–Ω–∏–≥–∞—Ö XLSX –≤ –ø–æ–¥—Ç–∞–±–ª–∏—Ü–∞—Ö 
						 	fxAllSheets	= (x)=> Text.Length(x[Name]) > 1, // –∏–º—è –±–æ–ª—å—à–µ 1 —Å–∏–º–≤–æ–ª–∞
							fxBKS1		= (x)=> Text.Length(x[Name]) = 1, // –∏–º—è 1 —Å–∏–º–≤–æ–ª
							fxBKSOPO 	= (x)=> try Value.Is(Number.From(x[Name]), type number) and Number.From(x[Name]) <= 6 otherwise null, // 1-6 –∫–æ–¥—ã –û–ü–û
							fxBKS15chr	= (x)=> Text.Length(x[Name]) = 15, // –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏–∏ 
							fxBKSsvod 	= (x)=> x[Name] = "–°–í–û–î –í –†–ê–ó–†–ï–ó–ï",
													
						//  fXLS    –ø–æ–¥–ª—é—á–∞–µ–º—Å—è –∫ –ø–∞–ø–∫–µ (–æ—Å—Ç–∞–≤–ª—è–µ–º XLS, —Ñ–∏–ª—å—Ç—Ä—É–µ–º –ø–æ–¥—Ç–∞–±–ª–∏—Ü—ã –ø–æ –ø–æ–ª—é "Name")
							fXLS = 	Table.TransformColumns(Trans, {"Content", (x)=> 
										let Binary 	= 	Excel.Workbook(x),
											Select	= 	Table.SelectRows(Binary,  each 
															not Text.Contains([Name], "$")	// —É–±–∏—Ä–∞–µ–º –∏–º–µ–Ω–æ–≤–∞–Ω–Ω—ã–µ –¥–∏–∞–ø–∞–∑–æ–Ω—ã
														),
											Select2	= 	Table.SelectRows(Select,  each 
														// 	—Ñ–∏–ª—å—Ç—Ä—É–µ–º –ª–∏—Å—Ç—ã –≤ —Ñ–∞–π–ª–∞—Ö xlsx —Ñ—É–Ω–∫—Ü–∏–µ–π –∏–∑ –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤. –ï—Å–ª–∏ –Ω–µ –∑–∞–¥–∞–Ω–∞, —Ç–æ –≤—Å–µ –ª–∏—Å—Ç—ã
														// 	–±–µ–∑ Record.HasFields(input, {"FilterFunction"}) –µ—Å–ª–∏ –Ω–µ—Ç –≤ –∞—Ä–≥—É–º–µ–Ω—Ç–∞—Ö –æ—à–∏–±–∫–∞
															if Record.HasFields(input, {"FilterFunction"}) and (input[FilterFunction] <> null)
															then input[FilterFunction](_)
															else fxAllSheets(_)
														)
										in	Select2 	// [Data]{0} –æ—Å—Ç–∞–≤–ª—è–µ–º –ø–µ—Ä–≤—ã–π –ª–∏—Å—Ç
									}),

						//  fXLSX   –ø–æ–¥–ª—é—á–∞–µ–º—Å—è –∫ –ø–∞–ø–∫–µ (–æ—Å—Ç–∞–≤–ª—è–µ–º XLSX, —Ñ–∏–ª—å—Ç—Ä—É–µ–º –ø–æ–¥—Ç–∞–±–ª–∏—Ü—ã –ø–æ –ø–æ–ª—é "Name")
							fXLSX = 	
								Table.TransformColumns(Trans, {"Content", (x)=> 
									let Binary 	= 	Excel.Workbook(x),
										Select	= 	Table.SelectRows(Binary,  each 
														not Text.Contains([Name], "$")	// —É–±–∏—Ä–∞–µ–º –∏–º–µ–Ω–æ–≤–∞–Ω–Ω—ã–µ –¥–∏–∞–ø–∞–∑–æ–Ω—ã
														and [Kind]="Sheet"				// –æ—Å—Ç–∞–≤–ª—è–µ–º –ª–∏—Å—Ç—ã
													),
										Select2	= 	Table.SelectRows(Select,  each 
													// 	—Ñ–∏–ª—å—Ç—Ä—É–µ–º –ª–∏—Å—Ç—ã –≤ —Ñ–∞–π–ª–∞—Ö xlsx —Ñ—É–Ω–∫—Ü–∏–µ–π –∏–∑ –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤. –ï—Å–ª–∏ –Ω–µ –∑–∞–¥–∞–Ω–∞, —Ç–æ –≤—Å–µ –ª–∏—Å—Ç—ã
													// 	–µ—Å–ª–∏ Record —Å–æ–¥–µ—Ä–∂–∏—Ç –ø–æ–ª–µ —Å —Ç–∞–∫–∏–º –∏–º–µ–Ω–µ–º –∏ –∑–Ω–∞—á–µ–Ω–∏–µ –ø–æ–ª—è –Ω–µ null, —Ç–æ 
														if Record.HasFields(input, {"FilterFunction"}) and (input[FilterFunction] <> null)
														then input[FilterFunction](_) // true –∏–ª–∏ false. FilterFunction = (x)=>true
														else Text.Length(_[Name]) > 1 // true –∏–ª–∏ fxAllSheets(_) –∏–ª–∏ Text.Contains(_[Name], "04")
													)
									in	Select2 	// [Data]{0} –æ—Å—Ç–∞–≤–ª—è–µ–º –ø–µ—Ä–≤—ã–π –ª–∏—Å—Ç
								}),
						
						//  fCSV    //! –ø–∞–ø–∫–∞ –∫–∞–∂–µ—Ç—Å—è –Ω–µ —Ç–∞ Trans –∑–∞–≥—Ä—É–∑–∫–∞ —Ñ–∞–π–ª–æ–≤ –∏–∑ –ø–∞–ø–∫–∏ —Å CSV —Ñ–∞–π–ª–∞–º–∏ (–ø–∞—Ä–∞–º–µ—Ç—Ä Columns=... –ø—Ä–æ–ø—É—Å–∫–∞—é? —Å–µ–ø–µ—Ä–∞—Ç–æ—Ä ",")
							fCSV =  Table.TransformColumns(FilteredRows, {"Content", (file)=>
										Table.PromoteHeaders(
											Csv.Document(file, 
												[	
													Columns     = null, 			// –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –∏–ª–∏ –∏–º–µ–Ω–∞ —Å—Ç–æ–ª–±—Ü–æ–≤ {"A","B","C"}
													Delimiter	= ";", 				// –†–∞–∑–¥–µ–ª–∏—Ç–µ–ª—å, –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é ","
													QuoteStyle	= QuoteStyle.None, 	// –µ—Å–ª–∏ QuoteStyle.Csv
													Encoding	= 65001 			// –ö–æ–¥–∏—Ä–æ–≤–∫–∞ UTF-8
													
												]
											)
										), type table}
									),
						//  fPAR    –∑–∞–≥—Ä—É–∑–∫–∞ —Ñ–∞–π–ª–æ–≤ –∏–∑ –ø–∞–ø–∫–∏ —Å .parquet —Ñ–∞–π–ª–∞–º–∏
							fPAR =  Table.TransformColumns(Trans, 
										{"Content", (file) =>
											try 
												let tbl = 1 // Parquet.Document(file)
												in Table.PromoteHeaders(tbl)
											otherwise 
												#table({"Error"}, {{"Parquet not supported in this environment"}})
											, type table
										}
									),

						//  return  –≤–æ–∑–≤—Ä–∞—â–∞–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç –æ–±—Ä–∞–±–æ—Ç–∫–∏
							return = Record.FieldOrDefault(
										[ 
											xlsx = fXLSX, 
											xls  = fXLS, 
											csv  = fCSV,
											parquet  = fPAR
										], 
											Text.From(EXTENSION), "Error"
									)
					][return],
					
				// 	6. AddTwoColumns	–¥–æ–±–∞–≤–ª—è–µ–º –∫–æ–ª–æ–Ω–∫–∏ –∏ —Ñ–∏–ª—å—Ç—Ä—É–µ–º —Ç–∞–±–ª–∏—Ü—É
					AddTwoColumns = let 
						AddSize   = Table.AddColumn(TransformBinary, "Size", (x)=> Number.Round(x[Attributes][Size]/1024,0) ),
						AddShName = Table.AddColumn(AddSize, "SheetNames",   (x)=> try Text.Combine(x[Content][Name],",") otherwise null, type text),
						SelCol	  = Table.SelectColumns(AddShName, {"Folder Path", "Name", "Content"} & {"Size","SheetNames"}),
						SelRow    = Table.SelectRows(SelCol, each ([SheetNames] <> "")) // –µ—Å–ª–∏ –Ω–∞ –ø—Ä–µ–¥—ã–¥—É—â–µ–º —à–∞–≥–µ —Ñ–∏–ª—å—Ç—Ä—É—è —Å—Ç—Ä–æ–∫–∏ –≤ –ø–æ–¥—Ç–∞–±–ª–∏—Ü–∞—Ö –Ω–µ –æ—Å—Ç–∞–ª–æ—Å—å –Ω–∏ –æ–¥–Ω–æ–≥–æ –ª–∏—Å—Ç–∞
					in  SelRow,

				// 	7. SelColumns		–ª–∏—à–Ω–∏–π —à–∞–≥ –Ω–∞–≤–µ—Ä–Ω–æ–µ
					Rename 		= Table.RenameColumns(AddTwoColumns, {{"Content", "Data"}}),
					SelColumns 	= Table.SelectColumns(Rename, {"Folder Path", "Name", "Data"}),
				
				//  8. Result			–≥–æ—Ç–æ–≤–∏–º —Ç–∞–±–ª–∏—Ü—É –¥–ª—è –≤—ã–≤–æ–¥–∞ (–ø–∞—Ä–∞–º–µ—Ç—Ä —Å–¥–µ–ª–∞—Ç—å –¥–ª—è —Å—Ç–∏–ª—è –º–æ–∂–µ—Ç —Å —É—Å–ª–æ–≤–∏—è–º–∏)
					Result 	= 	Record.Field([
							tbl  = SelColumns,
							xls  = let 
								// 	—Ä–∞–∑–≤–æ—Ä–∞—á–∏–≤–∞–µ–º –ª–∏—Å—Ç—ã  - –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é –Ω–µ —Ä–∞–∑–≤–æ—Ä–∞—á–∏–≤–∞–µ–º (–µ—Å–ª–∏ null –∏–ª–∏ –Ω–µ —É–∫–∞–∑–∞–Ω) //* —Ç–∏–ø —Ç–∞–±–¥–ª–µ —Å–ª–µ—Ç–∞–µ—Ç!
									exp = 	if   not EXPANDSHEET
											then Table.AddColumn(tbl, "SheetNames", (x) => Text.Combine(x[Data]?[Name]?, ",")?? "", type text)
											else Table.ExpandTableColumn(tbl, "Data", {"Data", "Name"},{"Data", "SheetNames"}),
								
								//  –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –∫–æ–ª–æ–Ω–∫—É "SheetNames" - –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é –Ω–µ –ø–æ–∫–∞–∑—ã–≤–∞–µ–º
									sh = 	if  SHOWSHEET = false or SHOWSHEET = null
											then Table.RemoveColumns(exp,{"SheetNames"})
											else exp,

								//  –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –∫–æ–ª–æ–Ω–∫—É "Folder Path" —Å –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω—ã–º –ø—É—Ç–µ–º - –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é –Ω–µ –ø–æ–∫–∞–∑—ã–≤–∞–µ–º
									sub = 	if SUBFOLDERS = false or SUBFOLDERS = null
											then Table.RemoveColumns(sh,{"Folder Path"})
											else sh
								in  sub,
							
							xlsx = let 
								// —Ä–∞–∑–≤–æ—Ä–∞—á–∏–≤–∞–µ–º –ª–∏—Å—Ç—ã  - –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é –Ω–µ —Ä–∞–∑–≤–æ—Ä–∞—á–∏–≤–∞–µ–º (–µ—Å–ª–∏ null –∏–ª–∏ –Ω–µ —É–∫–∞–∑–∞–Ω) //* —Ç–∏–ø —Ç–∞–±–¥–ª–µ —Å–ª–µ—Ç–∞–µ—Ç!
								// 		–±—ã–ª–æ (x)=> try Text.Combine(x[Data][Name],",") otherwise null
								// 		x[Data]? ‚Äî –±–µ–∑–æ–ø–∞—Å–Ω–æ –ø—Ä–æ–≤–µ—Ä—è–µ—Ç, —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –ª–∏ –ø–æ–ª–µ Data –≤ x. –ï—Å–ª–∏ –Ω–µ—Ç, –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç null
								// 		–æ–ø–µ—Ä–∞—Ç–æ—Ä ?? –∏–∑–±—ã—Ç–æ—á–µ–Ω, —Ç–∞–∫ –∫–∞–∫ Text.Combine —É–∂–µ –≤–µ—Ä–Ω–µ—Ç null –≤ —Å–ª—É—á–∞–µ null –Ω–∞ –≤—Ö–æ–¥–µ
								// 		–º–æ–∂–Ω–æ —Ç–∞–∫ ?? null –∏–ª–∏ ?? "–Ω–µ—Ç –ª–∏—Å—Ç–æ–≤"
								exp = 	if EXPANDSHEET = false or EXPANDSHEET = null
										then Table.AddColumn(tbl, "SheetNames", (x) => Text.Combine(x[Data]?[Name]?, ",")?? "", type text)
										else Table.ExpandTableColumn(tbl, "Data", {"Data", "Item"},{"Data", "SheetNames"}), 
										// –º–æ–∂–µ—Ç –≤–º–µ—Å—Ç–æ {"Data", "Item"} —Å–¥–µ–ª–∞—Ç—å {"Data", "Name"}. –í xls Item –Ω–µ—Ç. –í xlsx –≤—Å–µ–≥–¥–∞ –ª–∏ –æ–¥–∏–Ω–∞–∫–æ–≤—ã "Item" –∏ "Name"
								
								//  –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –∫–æ–ª–æ–Ω–∫—É "SheetNames" - –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é –Ω–µ –ø–æ–∫–∞–∑—ã–≤–∞–µ–º
								// todo –µ—Å–ª–∏ SheetNames=0 —Ç–æ EXPANDSHEET=1 –≤—ã–¥–∞–µ—Ç –æ—à–∏–±–∫—É
								// todo –§–∏–ª—å—Ç—Ä–∞—Ü–∏—è —Å—Ç–æ–ª–±—Ü–æ–≤ —Å Table.SelectColumns –≤–º–µ—Å—Ç–æ Table.RemoveColumns
								// sh = if SHOWSHEET ?? false then exp else Table.RemoveColumns(exp, {"SheetNames"})
								// sh = try if SHOWSHEET then exp else Table.RemoveColumns(exp, {"SheetNames"}) otherwise exp 
								// –≠—Ç–æ –ø–æ–ª–µ–∑–Ω–æ, –µ—Å–ª–∏ SHOWSHEET –º–æ–∂–µ—Ç —Å–æ–¥–µ—Ä–∂–∞—Ç—å –Ω–µ–æ–∂–∏–¥–∞–Ω–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è.
								sh = 	if SHOWSHEET = false or SHOWSHEET = null
										then Table.RemoveColumns(exp,{"SheetNames"})
										else exp,

								//  –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –∫–æ–ª–æ–Ω–∫—É "Folder Path" —Å –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω—ã–º –ø—É—Ç–µ–º - –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é –Ω–µ –ø–æ–∫–∞–∑—ã–≤–∞–µ–º
								sub = 	if SUBFOLDERS = false or SUBFOLDERS = null
										then Table.RemoveColumns(sh,{"Folder Path"})
										else sh
								in  sub,
						
							csv  = 	// Table.RenameColumns(tbl, {{"Data", "Content"}})
									if SUBFOLDERS = false or SUBFOLDERS = null
									then Table.RemoveColumns(tbl,{"Folder Path"})
									else tbl,
							
							parquet  = 	if SUBFOLDERS = false or SUBFOLDERS = null
									then Table.RemoveColumns(tbl,{"Folder Path"})
									else tbl			
						], 
							EXTENSION),
				// 	9. Result2			–ø—Ä–∏–º–µ–Ω–µ–Ω–∏–µ —Ñ—É–Ω–∫—Ü–∏–∏ —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏, –µ—Å–ª–∏ —Ñ—É–Ω–∫—Ü–∏—è –∑–∞–¥–∞–Ω–∞
					/*	Result2 = 
							if Record.HasFields(input, {"FilterFunction"}) and (input[FilterFunction] <> null)
							then Table.SelectRows(Result, input[FilterFunction]) // Table.SelectRows(Result, input[FilterFunction])
							else Result,*/

				// 	Return 				–≤–æ–∑–≤—Ä–∞—â–∞–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã —à–∞–≥–æ–≤ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ –ø–∞–ø–∫–µ
					Return = Record.FieldOrDefault(
						[	99 = finalOptions, // –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –∞–∫—Ç–∏–≤–Ω—ã–µ –æ–ø—Ü–∏–∏
							1 = ChildFolder,
							2 = Output,		
							3 = FilteredRows,
							4 = Trans,
							5 = TransformBinary,
							6 = AddTwoColumns,
							7 = SelColumns,
							8 = Result
						], 	
							if   STEP = null 
							then Text.From(8) 		// –ø–æ—Å–ª–µ–¥–Ω–∏–π —à–∞–≥
							else Text.From(STEP)	// –∑–∞–¥–∞–Ω–Ω—ã–π —à–∞–≥
						, 	
							"Error. –ù–µ—Ç —Ç–∞–∫–æ–≥–æ –Ω–æ–º–µ—Ä–∞ —à–∞–≥–∞ –≤ —Ñ—É–Ω–∫—Ü–∏–∏ LoadFolder")
				][Return],
				
			fnType = [ // –ø—Ä–æ–ø–∏—Å–∞—Ç—å –æ—Å—Ç–∞–ª—å–Ω—ã–µ –∞—Ä–≥—É–º–µ–Ω—Ç—ã. –ï—Å–ª–∏ optional —Ç–æ –µ—Å–ª–∏–∏–∑–º–µ–Ω—è—Ç—å –ø–æ –∑–≤–µ–∑–¥–æ—á–∫–µ, —Ç–æ –Ω–µ –±—É–¥–µ—Ç –æ—à–∏–±–∫–∏
					   // –ü—Ä–∏ –Ω–∞–ª–∏—á–∏–∏ AllowedValues SampleValues –Ω–µ –Ω—É–∂–µ–Ω, —ç—Ç–æ—Ç —Ç–µ–∫—Å—Ç –Ω–µ –≤–∏–¥–µ–Ω, —Ç–∞–∫ –∫–∞–∫ –µ—Å—Ç—å —Å–ø–∏—Å–æ–∫ –≤—ã–±–æ—Ä–∞
					inputType	= 
						type [	
							Path				    = (type nullable text  meta [Documentation.FieldCaption = "–ü—É—Ç—å –∫ –ø–∞–ø–∫–µ", Documentation.SampleValues = {"C:\DataFiles\SubFolder"}]),
							optional FileExtension  = (type nullable text  meta [Documentation.FieldCaption = "–¢–∏–ø–§–∞–π–ª–∞", Documentation.SampleValues = {"csv"}, Documentation.AllowedValues = { "xlsx", "csv" } ]),
							optional FileMaskName   = (type nullable text  meta [Documentation.FieldCaption = "–ú–∞—Å–∫–∞ –∏–º–µ–Ω–∏ —Ñ–∞–π–ª–∞", Documentation.SampleValues = {"–±–∞–ª–∞–Ω—Å"} ]),
							optional SubFolders     = (type logical 	   meta [Documentation.FieldCaption = "–û–±—Ä–∞–±–∞—Ç—ã–≤–∞—Ç—å –ø–æ–¥—Ç–∞–±–ª–∏—Ü—ã, true / false", Documentation.SampleValues = {"true / false"}, Documentation.AllowedValues = {true,false} ]),
							optional ExpandSheets   = (type logical 	   meta [Documentation.FieldCaption = "–ò–∑–≤–ª–µ–∫–∞—Ç—å –ª–∏—Å—Ç—ã, true / false", Documentation.SampleValues = {"true / false"},Documentation.AllowedValues = {true,false} ]),
							optional SheetNames     = (type logical 	   meta [Documentation.FieldCaption = "–ü–æ–∫–∞–∑—ã–≤–∞—Ç—å –∫–æ–ª–æ–Ω–∫—É —Å –∏–º–µ–Ω–∞–ª–∏ –ª–∏—Å—Ç–æ–≤, true / false", Documentation.SampleValues = {"true / false"}, Documentation.AllowedValues = {true,false} ]),
							optional Step		    = (type number 	       meta [Documentation.FieldCaption = "–ù–æ–º–µ—Ä–®–∞–≥–∞ (–æ—Ç 1 –¥–æ 8)", Documentation.SampleValues = {"9"}, Documentation.AllowedValues = {0..9}]),
							optional FilterFunction = (type nullable function meta [Documentation.FieldCaption = "–§—É–Ω–∫—Ü–∏—è —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏ —Ñ–∞–π–ª–æ–≤", Documentation.SampleValues = {"..."}])
						],

					inputMeta	= 
						[ 	Documentation.Name = "LoadFolder",
							Documentation.LongDescription = 
							"	<b> –ü–æ–¥–∫–ª—é—á–∞–µ–º—Å—è –∫ –ø–∞–ø–∫–µ, –ø–æ–ª—É—á–∞–µ–º —Å–ø–∏—Å–æ–∫ —Ñ–∞–π–ª–æ–≤ XLSX –∏–ª–∏ CSV </b> <br>
									= F[Folder.LoadFiles]( [Path = ""G:\=EXCEL BI - –º–æ–∏ –ø—Ä–æ–µ–∫—Ç—ã\""] ) <br>
									= F[Folder.LoadFiles]( [Path = ""G:\=EXCEL BI - –º–æ–∏ –ø—Ä–æ–µ–∫—Ç—ã\"", FileExtension = ""xlsx""] ) <br>
									= F[Folder.LoadFiles]( [Path = ""G:\=EXCEL BI - –º–æ–∏ –ø—Ä–æ–µ–∫—Ç—ã\"", FileExtension = ""xlsx"", SubFolders = false, ExpandSheets = false, SheetNames = true, Step = 0])
									= F[Folder.LoadFiles]( [Path = ""G:\=EXCEL BI - –º–æ–∏ –ø—Ä–æ–µ–∫—Ç—ã\"", FileExtension = ""xlsx"", SubFolders = true, Step = 1]) - –ø–æ—Å–º–æ—Ç—Ä–µ—Ç—å –∫–∞—Ç–∞–ª–æ–≥–∏
								",
							Documentation.Examples = {
								[	Description = "", 
									Code 		= "=F[Folder.LoadFiles]( [Path = ""G:\=EXCEL BI - –º–æ–∏ –ø—Ä–æ–µ–∫—Ç—ã\""] )",
									Result		= "—Ç–∞–±–ª–∏—Ü–∞ —Å —Ñ–∞–π–ª–∞–º–∏ xls"], 
								[	Description = "", 
									Code 		= "= F[Folder.LoadFiles]([Path = ""G:\=EXCEL BI - –º–æ–∏ –ø—Ä–æ–µ–∫—Ç—ã\"", FileExtension = ""xlsx""])",
									Result		= "—Ç–∞–±–ª–∏—Ü–∞"],
								[	Description = "", 
									Code 		= "= F[Folder.LoadFiles]([Path = ""G:\=EXCEL BI - –º–æ–∏ –ø—Ä–æ–µ–∫—Ç—ã\"", FileExtension = ""xlsx"", SubFolders = false, ExpandSheets = false, SheetNames = true, Step = 0])",
									Result		= "—Ç–∞–±–ª–∏—Ü–∞"]
							}
						],

					return 	    = type function (input as inputType) as table meta inputMeta
				][return],

			result = Value.ReplaceType(func,fnType)
		in 	result,

//	FOLDER 
	Files.SmartFolder    = // –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Ç–∞–±–ª–∏—Ü—É —Å –¥–∞–Ω–Ω—ã–º–∏ –æ —Ñ–∞–π–ª–∞—Ö –≤ –ø–∞–ø–∫–µ –∏–ª–∏ SharePoint –∏—Å–ø–æ–ª—å–∑—É—è Folder.Files –∏–ª–∏ Folder.Contents (Monky,"–ü—Ä–∏—Ä—É—á–∏ –¥–∞–Ω–Ω—ã–µ")
		/*
			For more information, Or to purchase a copy of this add-in, visit https://monkeytools.ca
		
			To use this function you must pass it the path to either a local folder or the equivalent
			path for Office 365's SharePoint url.  The easiest way to acquire this information is to place
			the following formula in a cell in the Excel Workbook:
			=IFERROR(LEFT(@CELL("filename",A1),FIND("[",@CELL("filename",A1),1)-1),"Workbook needs to be saved!")
		*/
		let 
			fnSmartFolder = (FullFolderPath as text, optional IncludeSubfolders as logical) as table =>
				let
					IncludeSubfolders = if IncludeSubfolders = null then true else IncludeSubfolders,
					BlankTable 		  = Table.FromRows({},{"Content","Name","Extension","Date accesssed","Date modified","Date created","Attributes","Folder Path"}),
					Source 		      = 
						if Text.StartsWith(FullFolderPath,"https://") 
						then
							let
								FullFolderPath  = Text.Replace(FullFolderPath,"\","/"),
								FolderPath      = 
									if Text.EndsWith(FullFolderPath,"/") 
									then Text.Start(FullFolderPath,Text.Length(FullFolderPath)-1) 
									else FullFolderPath,
								SharePointSite  = Text.BeforeDelimiter(FolderPath,"/",4),
								SharePointFiles = 
									if IncludeSubfolders = true 
									then
										let
											Source = SharePoint.Files(Text.BeforeDelimiter(FolderPath,"/",4), [ApiVersion = 15]),
											Select = Table.SelectRows(Source, each Text.StartsWith([Folder Path], FolderPath))
										in
											Select
									else
										let
											Source  = SharePoint.Contents(Text.BeforeDelimiter(FolderPath,"/",4), [ApiVersion = 15]),
											Folders = Text.Split(Text.AfterDelimiter(FolderPath,"/",4),"/"),
											NavigateToFolder = 
												List.Accumulate(
													{0..List.Count(Folders) -1 },
													Source,
													(state, current) => state{[Name=Folders{current}]}[Content]
												)
										in
											NavigateToFolder,
								
								StripRootFolder = Table.ReplaceValue(SharePointFiles,FolderPath & "/","",Replacer.ReplaceText,{"Folder Path"})
							in 
								StripRootFolder
						else
							let
								FullFolderPath = Text.Replace(FullFolderPath,"/","\"),
								
								FolderPath = 
									if   Text.EndsWith(FullFolderPath,"\") 
									then FullFolderPath 
									else FullFolderPath & "\",
								
								Source = 
									if   IncludeSubfolders = true 
									then Folder.Files(FolderPath)
									else Folder.Contents(FolderPath),

								StripRootFolder = Table.ReplaceValue(Source,FolderPath ,"",Replacer.ReplaceText,{"Folder Path"})
							in 
								StripRootFolder,

					DesiredOutput 	  = Table.ReplaceValue(Source,"/","\",Replacer.ReplaceText,{"Folder Path"}),
					ActiveTable 	  = try DesiredOutput otherwise BlankTable,
					Output 			  = Table.TransformColumns(ActiveTable,{{"Extension", Text.Lower, type text}})
				in
					Output,

			fnDocumentation = type function
				(
					FullFolderPath as (type text meta [
						Documentation.FieldCaption 		= "FullFolderPath",
						Documentation.FieldDescription 	= "Enter full path to local or SharePoint (sub)folder",
						Documentation.SampleValues 		= {"C:\DataFiles\SubFolder"}
					]),
					optional IncludeSubfolders as (type logical meta [
						Documentation.FieldCaption 		= "IncludeSubfolders",
						Documentation.FieldDescription 	= "Would you like to include files in subfolders?",
						Documentation.SampleValues 		= {"true (default), false"}
					])
				) as table meta
					[
						Documentation.Name = "fnSmartFolder",
						Documentation.MTVersion = 2.1,
						Documentation.LongDescription = "The <code>fnSmartFolder</code> function will accept a <i>full folder path</i> (local or SharePoint hosted) and display all files contained within it. It also:"
							& "<ul>"
							& "<li>-Removes the folder path from the beginning of the Folder column (to allow easier location of subfolders)</li>"
							& "<li>-Replaces all / separators with \ (to allow for filters that work when dynamically switch from local to SharePoint folders)</li>"
							& "<li>-Contains an optional <code>true</code> or <code>false</code> parameter to display files in subfolders (true) or not (false)</li>"
							& "</ul>"
							& "Technical info you may not care about: This function dynamically switches between the <code>SharePoint.Files()</code> and <code>Folder.Files()</code> connections by default, or <code>SharePoint.Contents()</code> and <code>Folder.Contents()</code> if you set the optional <code>IncludeSubfolders</code> parameter to <code>false</code>.",
						Documentation.Examples = 
							{
								[
									Description = "Working with a local file path to retrieve files in folder and subfolders (using the Folder.Files() function).",
									Code = "=fnSmartFolder(""C:\Users\<username>\<companyname>\MonkeyTools - General\Demos"",true)",
									Result = "| Content  |   Name     | Extension | Date accesssed   | Date modified    | Date created     | Attributes | Folder Path | #(lf)"
											&"------------------------------------------------------------------------------------------------------------------------- #(lf)"
											&"| [Binary] | File1.xlsx | .xlsx     | 2023-08-01 23:02 | 2023-08-01 23:02 | 2023-08-01 23:02 | [Record]   |             | #(lf)"
											&"| [Binary] | Csv1.csv   | .csv      | 2023-08-01 23:02 | 2023-08-01 23:02 | 2023-08-01 23:02 | [Record]   | CSVs\       | #(lf)"
											&"-------------------------------------------------------------------------------------------------------------------------"
								],
								[
									Description = "Working with a local file path to retrieve files in selected folder only (using the Folder.Contents() function).",
									Code = "=fnSmartFolder(""C:\Users\<username>\<companyname>\MonkeyTools - General\Demos"",false)",
									Result = "| Content  |   Name     | Extension | Date accesssed   | Date modified    | Date created     | Attributes | Folder Path | #(lf)"
											&"------------------------------------------------------------------------------------------------------------------------- #(lf)"
											&"| [Binary] | File1.xlsx | .xlsx     | 2023-08-01 23:02 | 2023-08-01 23:02 | 2023-08-01 23:02 | [Record]   |             | #(lf)"
											&"-------------------------------------------------------------------------------------------------------------------------"
								],
								[
									Description = "Working with a SharePoint file path to retrieve files in folder and subfolders (using the SharePoint.Files() function).",
									Code = "=fnSmartFolder(""https://domain.sharepoint.com/sites/MonkeyTools/Shared Documents/General/Demos/"",true)",
									Result = "| Content  |   Name     | Extension | Date accesssed   | Date modified    | Date created     | Attributes | Folder Path | #(lf)"
											&"------------------------------------------------------------------------------------------------------------------------- #(lf)"
											&"| [Binary] | File1.xlsx | .xlsx     | 2023-08-01 23:02 | 2023-08-01 23:02 | 2023-08-01 23:02 | [Record]   |             | #(lf)"
											&"| [Binary] | Csv1.csv   | .csv      | 2023-08-01 23:02 | 2023-08-01 23:02 | 2023-08-01 23:02 | [Record]   | CSVs\       | #(lf)"
											&"-------------------------------------------------------------------------------------------------------------------------"
								]
								,
								[
									Description = "Working with a SharePoint file path to retrieve files in selected folder only (using the SharePoint.Contents() function).",
									Code = "=fnSmartFolder(""https://domain.sharepoint.com/sites/MonkeyTools/Shared Documents/General/Demos/"",false)",
									Result = "| Content  |   Name     | Extension | Date accesssed   | Date modified    | Date created     | Attributes | Folder Path | #(lf)"
											&"------------------------------------------------------------------------------------------------------------------------- #(lf)"
											&"| [Binary] | File1.xlsx | .xlsx     | 2023-08-01 23:02 | 2023-08-01 23:02 | 2023-08-01 23:02 | [Record]   |             | #(lf)"
											&"-------------------------------------------------------------------------------------------------------------------------"
								]
							}
					],
			DocumentedFunction = Value.ReplaceType( fnSmartFolder, fnDocumentation )
		in
			DocumentedFunction,

	Files.SheetsInFolder = // –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Ç–∞–±–ª–∏—Ü—É —Å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–µ–π –æ–±–æ –í–°–ï–• –ª–∏—Å—Ç–∞—Ö –≤–æ –í–°–ï–• —Ñ–∞–π–ª–∞—Ö Excel –≤ –ø–∞–ø–∫–µ
        /*
            Description –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Ç–∞–±–ª–∏—Ü—É —Å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–µ–π –æ–±–æ –≤—Å–µ—Ö –ª–∏—Å—Ç–∞—Ö –≤ –ª—é–±—ã—Ö —Ñ–∞–π–ª–∞—Ö Excel –≤ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω–æ–π –ø–∞–ø–∫–µ.
            Usage		=F [ Files.SheetsInFolder ] ( "C:\path\to\my\folder\" )
            Result 		–¢–∞–±–ª–∏—Ü–∞, —Å–æ–¥–µ—Ä–∂–∞—â–∞—è —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ –¥–≤–æ–∏—á–Ω–æ–≥–æ —Ñ–∞–π–ª–∞, –∏–º–µ–Ω–∞ —Ñ–∞–π–ª–æ–≤, —Ç–∞–±–ª–∏—Ü –ª–∏—Å—Ç–æ–≤ –∏ –Ω–∞–∑–≤–∞–Ω–∏—è –ª–∏—Å—Ç–æ–≤ –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –ª–∏—Å—Ç–∞ –≤ –∫–∞–∂–¥–æ–π —ç–ª–µ–∫—Ç—Ä–æ–Ω–Ω–æ–π —Ç–∞–±–ª–∏—Ü–µ –≤ –¥–∞–Ω–Ω–æ–π –ø–∞–ø–∫–µ
        */

        (folderPath as text) as table =>
        let
            Source 			= Folder.Files(folderPath),
            FilteredRows 	= Table.SelectRows(Source, each Text.Start([Extension],5) = ".xlsx"),
            RemovedOtherColumns = Table.SelectColumns(FilteredRows,{"Content", "Name"}),
            NoTemps 		= Table.SelectRows(RemovedOtherColumns, each not Text.StartsWith([Name], "~$")),
            InsertedCustom 	= Table.AddColumn(NoTemps, "Sheets", each Excel.Workbook([Content])),
            Expanded 		= Table.ExpandTableColumn(InsertedCustom, "Sheets", {"Data", "Name","Kind"}, {"D","N","K"}),
            NoPrintAreas 	= Table.SelectRows(Expanded, each not Text.Contains([N], "$")),
            OnlySheets 		= Table.SelectRows(NoPrintAreas, each Text.Contains([K], "Sheet"))
        in
            OnlySheets,
	
	Folder.Latest 		 = // –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –ø—É—Ç—å –∫ —Å–∞–º–æ–º—É –Ω–æ–≤–æ–º—É —Ñ–∞–π–ª—É –≤ –∫–∞—Ç–∞–ª–æ–≥–µ, –ø–æ –∫—Ä–∏—Ç–µ—Ä–∏—é
		/*
			–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –ø—É—Ç—å –∫ —Å–∞–º–æ–º—É –Ω–æ–≤–æ–º—É —Ñ–∞–π–ª—É –≤ –∫–∞—Ç–∞–ª–æ–≥–µ, —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–µ–º —É–∫–∞–∑–∞–Ω–Ω–æ–º—É —Ç—Ä–µ–±–æ–≤–∞–Ω–∏—è. 
			–í–æ–∑–≤—Ä–∞—â–∞–π—Ç–µ –∑–Ω–∞—á–µ–Ω–∏–µ null, –µ—Å–ª–∏ –Ω–∏ –æ–¥–∏–Ω —Ñ–∞–π–ª –∏–ª–∏ –ø–æ–¥–∫–∞—Ç–∞–ª–æ–≥ –Ω–µ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É–µ—Ç —Ç—Ä–µ–±–æ–≤–∞–Ω–∏—è–º.

			–ü–æ —É–º–æ–ª—á–∞–Ω–∏—é –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç—Å—è —Å–∞–º—ã–π –Ω–æ–≤—ã–π –ø–æ–¥–∫–∞—Ç–∞–ª–æ–≥.

			–¢—Ä–µ–±–æ–≤–∞–Ω–∏—è —É–∫–∞–∑–∞–Ω—ã –∫–∞–∫ —Ñ—É–Ω–∫—Ü–∏—è, –ø—Ä–∏–Ω–∏–º–∞—é—â–∞—è –æ–¥–∏–Ω –∞—Ä–≥—É–º–µ–Ω—Ç ‚Äî —Å—Ç—Ä–æ–∫—É.–∑–∞–ø–∏—Å—å –∏–∑ –≤—ã–≤–æ–¥–∞ Folder.Contents. 
			–ï—Å–ª–∏ —ç—Ç–∞ —Ñ—É–Ω–∫—Ü–∏—è –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç true, —Ñ–∞–π–ª –≤ –≤–æ–ø—Ä–æ—Å —Å—á–∏—Ç–∞–µ—Ç—Å—è —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏–º —Ç—Ä–µ–±–æ–≤–∞–Ω–∏—è–º. 
			–°–º. —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—é DefaultFilter –¥–ª—è –ø—Ä–∏–º–µ—Ä–∞.

			–ü–æ —É–º–æ–ª—á–∞–Ω–∏—é –≤—ã–≤–æ–¥ Folder.Contents —Å–æ—Ä—Ç–∏—Ä—É–µ—Ç—Å—è –ø–æ –¥–∞—Ç–µ –∏–∑–º–µ–Ω–µ–Ω–∏—è. 
			–í—ã –º–æ–∂–µ—Ç–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –Ω–µ–æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–π —Ç—Ä–µ—Ç–∏–π –∞—Ä–≥—É–º–µ–Ω—Ç –¥–ª—è —É–∫–∞–∑–∞–Ω–∏—è –¥—Ä—É–≥–æ–≥–æ –ø–æ—Ä—è–¥–∫–∞ —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∏:
				- –¢–µ–∫—Å—Ç–æ–≤—ã–π –∞—Ä–≥—É–º–µ–Ω—Ç —Ä–∞—Å—Å–º–∞—Ç—Ä–∏–≤–∞–µ—Ç—Å—è –∫–∞–∫ –∏–º—è –ø–æ–ª—è;
				- –°–ø–∏—Å–æ–∫ —Å–ø–∏—Å–∫–æ–≤ —Ä–∞—Å—Å–º–∞—Ç—Ä–∏–≤–∞–µ—Ç—Å—è –∫–∞–∫ —Å–ø–∏—Å–æ–∫ –∏–º–µ–Ω –ø–æ–ª–µ–π –≤ –ø–∞—Ä–µ —Å Order.* –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏—è;
				- –¢–∞–∫–∂–µ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –æ–¥–Ω–∞ –ø–∞—Ä–∞ {field_name, order_enum} –±–µ–∑ –∑–∞–∫—Ä—ã–≤–∞—é—â–µ–≥–æ —Å–ø–∏—Å–∫–∞.
				–ø—Ä–∏–µ–º–ª–µ–º—ã–π
		*/
		(directory as text, optional requirements as function, optional sort_field) =>
		let
			DefaultFilter = each [Attributes][Kind] = "Folder",
			
			Filter 	= 	if requirements is null 
						then DefaultFilter 
						else requirements,

			SortOrder =
					 if	sort_field is null then {{"Date modified", Order.Descending}}
				else if sort_field is text then {{sort_field, Order.Descending}}
				else if sort_field is list and sort_field{0} is list then sort_field
				else if	sort_field is list then {sort_field}
				else	error "unsupported argument type for sort_field",

			Candidates 	= Table.SelectRows( Folder.Contents(directory), Filter),
			Sorted 		= Table.Sort(Candidates, SortOrder),
			Chosen 		= List.First(Table.ToRecords(Sorted)),
			Return 		= if   Chosen is null
						  then null
						  else Chosen[#"Folder Path"] & Chosen[Name]
		in
			Return,
//	FILE (–Ω–∞ –≤—Ö–æ–¥–µ –ø—É—Ç—å –∫ —Ñ–∞–π–ª—É)
	Files.ExtensionFile	 = // –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Ä–∞—Å—à–∏—Ä–µ–Ω–∏–µ —Ñ–∞–π–ª–∞
		(FilePath)=>Text.Lower(List.Reverse(Splitter.SplitTextByDelimiter(".")(FilePath)){0}),
	Files.ContentInFile  = // –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å—Ç—Ä—É–∫—Ç—É—Ä—É —Ñ–∞–π–ª–∞ xlsx 
		/* 
		*/
		let
			fnSmartFile = (FilePath as text) as any =>
			let
				BlankTable_Excel  = Table.FromRows( {}, { "Name", "Data", "Item", "Kind", "Hidden" } ),
				BlankTable_Access = Table.FromRows( {}, { "Name", "Data", "Schema", "Item", "Kind" } ),
				FileExtension     = Text.Lower(List.Reverse(Splitter.SplitTextByDelimiter(".")(FilePath)){0}),
				Source = 
					if Text.StartsWith( FilePath, "https://" ) 
					then 
						let FilePath = Text.Replace( Text.Replace( FilePath, "\", "/" ), " ", "%20" ),  
							Source   = Web.Contents(FilePath)
						in 	Source 
					else 
						let Source = File.Contents(FilePath) 
						in  Source,
				
				Output = 
					if Text.StartsWith(FileExtension,"xls")
					then try Excel.Workbook( Source, null, true) otherwise BlankTable_Excel
					else if FileExtension = "accdb" or FileExtension = "mdb"
					then try Access.Database( Source ) otherwise BlankTable_Access
					else Source
			in
				Output,
			fnDocumentation = type function (
				FilePath as (
					type text meta [
						Documentation.FieldCaption = "FilePath",
						Documentation.SampleValues = "{C:\DataFiles\Filename.xlsx}"
						]
					)
				)
				as any meta [
					Documentation.Name = "fnSmartFile",
					Documentation.MTVersion = 1.1,
					Documentation.LongDescription = "The <code>fnSmartFile</code> function will accept a <i>the full path</i> to a local or SharePoint hosted file and is designed to 'smart switch' between the Web and Local required connectors should the file path dynamically change.<br>"
							&"Note that the behaviour of the connector depends on the type of files you connect to:<br>"
							&"<ul>"
							&"<li>Excel: Displays a table including the standard columns found when connecting to an external Excel file.</li>"
							&"<li>Access: Excel: Displays a table including the standard columns found when connecting to an external Access database.</li>"
							&"<li>All others: Due to the fact that each file needs to be interpreted differently by Power Query, our Monkey displays the file itself. Double click the file to allow Power Query to interpret it, or right click it and tell Power Query what type of file it is that you are looking at.</li>"
							&"</ul>"
							&"To learn more about how this function works, see https://monkeytools.ca/smartfile-function/",
					Documentation.Examples =
					{
						[   Description= "Working with an Excel file",
							Code = "fnSmartFile(""C:\DataFiles\Filename.xlsx"")",
							Result = "|  Name     |  Data     |  Item     |  Kind         |  Hidden    |#(lf)"
									&"------------------------------------------------------------------#(lf)"
									&"|  Summary  |  [Table]  |  Summary  |  Sheet        |  FALSE     |#(lf)"
									&"|  Data     |  [Table]  |  Data     |  Sheet        |  FALSE     |#(lf)"
									&"|  Table1   |  [Table]  |  Table    |  Sheet        |  FALSE     |#(lf)"
									&"|  Sales    |  [Table]  |  Sales    |  Sheet        |  FALSE     |#(lf)"
									&"|  rngHome  |  [Table]  |  rngHome  |  Named Range  |  FALSE     |"
						],
						[   Description= "Working with an Access database",
							Code = "=fnSmartFile(""C:\DataFiles\Access.accdb"")",
							Result = "|  Name       |  Data     |   Schema    |  Item        |  Kind    |#(lf)"
									&"-------------------------------------------------------------------#(lf)"
									&"|  tblBudgets |  [Table]  |             |  tblBudgets  |  Table   |#(lf)"
									&"|  tblSales   |  [Table]  |             |  tblSales    |  Table   |"
						],
						[   Description= "Working with a csv, text, json or other file type",
							Code = "=fnSmartFile(""C:\DataFiles\Data.csv"")",
							Result = "Data.csv file (with logo)"
						]
					}
				],
			DocumentedFunction = Value.ReplaceType(fnSmartFile,fnDocumentation)
		in
			DocumentedFunction,
// 	ADDS_COLUMNS
	fxAddMultiColumns 	 = // —Å–æ–∑–¥–∞–Ω–∏–µ –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö —Å—Ç–æ–ª–±—Ü–æ–≤
		/*
			? –º–æ–∂–Ω–æ —Å—Ä–∞–∑—É –∑–∞–¥–∞–≤–∞—Ç—å –ø–æ–ª–æ–∂–µ–Ω–∏–µ —Å—Ç–æ–ª–±—Ü–∞?! –ø—Ä–æ–≤–µ—Ä–∏—Ç—å
			
			* –æ–¥–Ω–æ–π —Å—Ç—Ä–æ–∫–æ–π	—Å–∞–º—ã–π –∫–æ—Ä–æ—Ç–∫–∏–π –≤–∞—Ä–∏–∞–Ω—Ç
			fxAddMultiColumns = (tbl,lst) as table => List.Accumulate(lst, tbl, (s,c)=>Table.AddColumn(s,c{0},c{1},c{2}?))
			
			* –ö–∞–∫ –≤–∞—Ä–∏–∞–Ω—Ç —ç—Ç–æ–π —Ñ—É–Ω–∫—Ü–∏–∏:
				–∫ —Ç–∞–±–ª–∏—Ü–µ "–ò–º—è" + "–ó–Ω–∞—á–µ–Ω–∏–µ", –¥–æ–±–∞–≤–ª—è–µ—Ç —Ç—Ä–∏ —Å—Ç–æ–ª–±—Ü–∞ (—ç–ª–µ–º–µ–Ω—Ç–æ–≤ –≤ —Å–ø–∏—Å–∫–µ), –≤ –∫–∞–∂–¥–æ–º —É–º–Ω–æ–∂–∞–µ—Ç 10 –Ω–∞ –ó–Ω–∞—á–µ–Ω–∏–µ, 20 –Ω–∞ –∑–Ω–∞—á–µ–Ω–∏–µ –∏ —Ç.–¥.
				t = List.Accumulate(
						{10,20,30}, // {10,20,30,40} - –µ—Å–ª–∏ 4 —Å—Ç–æ–ª–±—Ü–∞ –¥–æ–±–∞–≤–∏—Ç—å –Ω—É–∂–Ω–æ
						–ò—Å—Ç–æ—á–Ω–∏–∫,
						(state,cur)=>Table.AddColumn(state, "–í–∞—Ä–∏–∞–Ω—Ç " & Text.From(cur), each cur * [Cost 2023]) // –í–∞—Ä–∏–∞–Ω—Ç 10, –í–∞—Ä–∏–∞–Ω—Ç 20 ...
					)
		*/
		[ 	
			func = (table as table, addedColumns as list) as table =>
				List.Accumulate(
					addedColumns, 	// —Å–ø–∏—Å–æ–∫ –∫–æ–ª–æ–Ω–æ–∫ –≤–∏–¥–∞ (–∏–º—è + —Ñ—É–Ω–∫—Ü–∏—è + —Ç–∏–ø)
					table, 			// —Å—Ç–∞—Ä—Ç–æ–≤–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ
					(s, c) => Table.AddColumn(s, c{0}, c{1}, c{2}?) // –µ—Å–ª–∏ –ø—É—Å—Ç—ã–µ –∫–æ–ª–æ–Ω–∫–∏, —Ç–æ d{2} –∑–∞–º–µ–Ω—Ç—å –Ω–∞ each null
				),
			
			typ  = type function (table as table, addedColumns as list) as table 
					meta [ 	Documentation.Name            = "fxAddMultiColumns",
							Documentation.LongDescription = "—Ñ—É–Ω–∫—Ü–∏—è, —Å–æ–∑–¥–∞—é—â–∞—è —Å—Ä–∞–∑—É –Ω–µ—Å–∫–æ–ª—å–∫–æ —Å—Ç–æ–ª–±—Ü–æ–≤. –ù–∞–ø—Ä–∏–º–µ—Ä = fxAddMultiColumns(tbl,{'–¥–∞—Ç–∞', each 1})",
							Documentation.Examples = {
								[	
									Description = "–¥–æ–±–∞–≤–∏—Ç—å –æ–¥–∏–Ω —Å—Ç–æ–ª–±–µ—Ü", 
									Code 		= "=fxAddMultiColumns(#table({""a"",""b"",""c""},{}),{1,""–ø–µ—Ä–≤—ã–π""})",
									Result		= "#table({""–ø–µ—Ä–≤—ã–π"",""b"",""c""},{})"
								], 
								[	
									Description = "–¥–æ–±–∞–≤–∏—Ç—å –¥–≤–∞ —Å—Ç–æ–ª–±—Ü–∞", 
									Code 		= "=fxAddMultiColumns(#table({""a"",""b"",""c""},{}),{-1,""–ø–µ—Ä–≤—ã–π —Å –∫–æ–Ω—Ü–∞""})",
									Result		= "#table({""a"",""b"",""–ø–µ—Ä–≤—ã–π —Å –∫–æ–Ω—Ü–∞""},{})"
								]
							}
						],
			
			typ2 = [ 
				optionsMeta	= 
					[ 	Documentation.Name            = "fxAddMultiColumns",
						Documentation.LongDescription = "—Ñ—É–Ω–∫—Ü–∏—è, —Å–æ–∑–¥–∞—é—â–∞—è —Å—Ä–∞–∑—É –Ω–µ—Å–∫–æ–ª—å–∫–æ —Å—Ç–æ–ª–±—Ü–æ–≤. –ù–∞–ø—Ä–∏–º–µ—Ä = fxAddMultiColumns(tbl,{'–¥–∞—Ç–∞', each 1})",
						Documentation.Examples 		  = {
							[	
								Description = "–¥–æ–±–∞–≤–∏—Ç—å –æ–¥–∏–Ω —Å—Ç–æ–ª–±–µ—Ü", 
								Code 		= "=fxAddMultiColumns(#table({""a"",""b"",""c""},{}),{1,""–ø–µ—Ä–≤—ã–π""})",
								Result		= "#table({""–ø–µ—Ä–≤—ã–π"",""b"",""c""},{})"
							], 
							[	
								Description = "–¥–æ–±–∞–≤–∏—Ç—å –¥–≤–∞ —Å—Ç–æ–ª–±—Ü–∞", 
								Code 		= "=fxAddMultiColumns(#table({""a"",""b"",""c""},{}),{-1,""–ø–µ—Ä–≤—ã–π —Å –∫–æ–Ω—Ü–∞""})",
								Result		= "#table({""a"",""b"",""–ø–µ—Ä–≤—ã–π —Å –∫–æ–Ω—Ü–∞""},{})"
							]
						}
					],

				return 	    = type function (table as table, addedColumns as list) as table meta optionsMeta
				]  [return],

			result = Value.ReplaceType(func,typ)
		]  [result],
		
//	SKIP
	Table.SkipUp   	  	= // —É–¥–∞–ª—è–µ–º —Å—Ç—Ä–æ–∫–∏ —Å–≤–µ—Ä—Ö—É –¥–æ —Å—Ç—Ä–æ–∫–∏, –≤ –∫–æ—Ç–æ—Ä–æ–π –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –∏—Å–∫–æ–º—ã–π —Ç–µ–∫—Å—Ç
		/* 
			–û–ø–∏—Å–∞–Ω–∏–µ:
				—É–¥–∞–ª—è–µ—Ç —Å—Ç—Ä–æ–∫–∏ —Å–≤–µ—Ä—Ö—É, –¥–æ —Å—Ç—Ä–æ–∫–∏, –≤ –∫–æ—Ç–æ—Ä–æ–π –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –∏—Å–∫–æ–º—ã–π —Ç–µ–∫—Å—Ç

			–ê–ª–≥–æ—Ä–∏—Ç–º:
				1. C—Ç—Ä–æ–∫–∏ –∑–∞–≥–æ–Ω—è–µ–º –≤ —Å–ø–∏—Å–æ–∫, –æ—Ç–±–∏—Ä–∞–µ–º –∏—Ö –ø–æ Text.Contains –∏ —Å—Ä–∞–≤–Ω–∏–≤–∞–µ–º —Å –ø—É—Å—Ç—ã–º —Å–ø–∏—Å–∫–æ–º
				2. –ï—Å–ª–∏ —Å–ø–∏—Å–æ–∫ –Ω–µ –ø—É—Å—Ç–æ–π = False, —Ç.–µ. –Ω–µ—Ç —Å–æ–≤–ø–∞–¥–µ–Ω–∏–π, —Ç–æ–≥–¥–∞ —É–¥–∞–ª—è–µ–º
			
			–ü—Ä–∏–º–µ—Ä:	
				1. = Table.Skip(from, Table.SkipUp("–ö–æ–¥")) 
				2. = [ 	
						g  = (txt)=>(row)=> List.Select( Record.ToList(row), (i)=>i is text and Text.Contains(i,txt))={},
						to = Table.PromoteHeaders( Table.Skip(from, g("–ö–æ–¥"))) 
					]  [to]
			
			–†–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç—Å—è:
				–∞) 	–ù–∞–∑–≤–∞–Ω–∏—è –∫–æ–ª–æ–Ω–æ–∫ –ø–æ—Å–ª–µ —Å–¥–≤–∏–≥–∞ –≤–≤–µ—Ä—Ö –¥–µ–ª–∏—Ç—å –ø–æ –Ω–µ–ø–µ—á–∞—Ç–Ω—ã–º —Å–∏–º–≤–æ–ª–∞–º (25 —à—Ç.), 
					—Ç.–∫. –º–æ–≥—É—Ç –±—ã—Ç—å –ø—Ä–æ–±–µ–ª—ã –≤–µ–∑–¥–µ, –ø—Ä–æ–ø—É—Å–∫–∏, –ø–µ—Ä–µ–Ω–æ—Å—ã
						= List.Buffer(
							List.Transform(
								Table.ColumnNames(to), 
								(x)=>Text.Combine(Splitter.SplitTextByWhitespace()(x)," ")
							)
						)
				–±) 	–û—Ç–±–∏—Ä–∞–µ–º –Ω—É–∂–Ω—ã–µ –∫–æ–ª–æ–Ω–∫–∏
					= List.Select(
						Table.ColumnNames(to), 
						(str)=>	List.ContainsAny(
									{str},
									{"–ê–ö","–ö–æ–¥","–ù–∞1","–ù–∞31"}, // —Å–ø–∏—Å–æ–∫–æ –Ω–∞–∑–≤–∞–Ω–∏–π –∫–æ–ª–æ–Ω–æ–∫, –ø–æ–ª–Ω–æ—Å—Ç—å—é –∏–ª–∏ —á–∞—Å—Ç–∏—á–Ω–æ
									(txt, word) => 
										Text.Contains( 
											Text.Upper( Text.Remove(txt," ") ),
											Text.Upper( Text.Remove(word," ") )
										)
								)
					)
				–≤) –ø–æ—Ç–æ–º –æ—Ç–±–∏—Ä–∞–µ–º –∫–æ–ª–æ–Ω–∫–∏ = Table.SelectColumns(to, nms)
		*/
			(txt)=>
				(row)=> 
					List.Select( 
						Record.ToList(row), 
						(i)=>i is text and Text.Contains(i,txt)
					)={},
	

	Skip.AllMulti 	  	= // –æ—Ç—Å–µ—á–µ–Ω–∏–µ —Å—Ç—Ä–æ–∫ —Å–≤–µ—Ä—Ö—É –∏ —Å–Ω–∏–∑—É —Ç–∞–±–ª–∏—Ü—ã –ø–æ –∫–ª—é—á–µ–≤—ã–º —Å–ª–æ–≤–∞–º - –ø–æ –≤—Å–µ–π —Ç–∞–±–ª–∏—Ü–µ + –º—É–ª—å—Ç–∏ –≤—ã–±–æ—Ä, //!—Å—Ç—Ä–æ–∫–∞ –∏–ª–∏ –ø–æ–¥—Å—Ç—Ä–æ–∫–∞?
		/*
		 	–û–ø–∏—Å–∞–Ω–∏–µ 	–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç ?
			
			–ü—Ä–∏–º–µ—Ä		= 	Table.RemoveLastN(
								Table.RemoveLastN(a, 
									SkipAllMulti({"–ù–∞—á–∞–ª—å–Ω–∏–∫ —É—á–µ–±–Ω–æ-–º–µ—Ç–æ–¥–∏—á–µ—Å–∫–æ–≥–æ –æ—Ç–¥–µ–ª–∞","–°–ø–µ—Ü–∏–∞–ª–∏—Å—Ç 1 –∫–∞—Ç–µ–≥–æ—Ä–∏–∏"}) 
								), 
							2)
			skip = [
        		–≤–µ—Ä—Ö
					a = Table.PromoteHeaders(Table.Skip(from, fx[fxSkipAllMulti]({"–î–Ω–∏"}) )),
        		–Ω–∏–∑
					b = Table.RemoveLastN(Table.RemoveLastN(a, fx[fxSkipAllMulti]({"–°–ø–µ—Ü–∏–∞–ª–∏—Å—Ç","–ù–∞—á–∞–ª—å–Ω–∏–∫","–ü–ï–†–ï–°–î–ê–ß–ê"}) ), 2)
    		][b],

			–û—Å–æ–±–µ–Ω–Ω–æ—Å—Ç–∏
				1 –°—Ä–∞–≤–Ω–∏–≤–∞—Ç—å —Ç–µ–∫—Å—Ç –±–µ–∑ —É—á–µ—Ç–∞ –ø—Ä–æ–±–µ–ª–æ–≤. –£–±–∏—Ä–∞—Ç—å –¥–≤–æ–π–Ω—ã–µ. –ò–Ω–æ–≥–¥–∞ —Å—Ç–∞–≤—è—Ç "–°–ø–µ—Ü–∏–∞–ª–∏—Å—Ç 1 –∫–∞—Ç–µ–≥–æ—Ä–∏–∏" –∏ "–°–ø–µ—Ü–∏–∞–ª–∏—Å—Ç  1 –∫–∞—Ç–µ–≥–æ—Ä–∏–∏"
		*/
		(txt)=>(row)=> 
			not List.ContainsAny(
				{ Text.Combine( List.Select( Record.ToList(row), (i)=>i is text)) },
				txt,
				Text.Contains
			),
		
	Skip.RowsUpDown   	= // –ø–æ –∫–æ–ª–æ–Ω–∫–µ + –æ–¥–Ω–æ —Å–ª–æ–≤–æ
		/*
		
		*/
		(x, txt)=>(y)=>
			not Text.Contains( 
					Text.Combine( List.Select( Record.ToList( Record.SelectFields(y, txt) ), (i)=>i is text) ),
					x
				),


//	NAMES 
	listNames 			= // —Å–ø–∏—Å–æ–∫ —É–Ω–∏–∫–∞–ª—å–Ω—ã—Ö –∏–º–µ–Ω —Å—Ç–æ–ª–±—Ü–æ–≤ –≤ –∫–æ–ª–æ–Ω–∫–µ —Å –ø–æ–¥—Ç–∞–±–ª–∏—Ü–∞–º–∏ (–Ω–∞ –≤—Ö–æ–¥–µ —Ç–∞–±–ª–∏—Ü–∞). –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –¥–ª—è —Ä–∞–∑–≤–æ—Ä–∞–≤–∏—á–∞–Ω–∏—è
		(tbl as table, colName as text)=>
			List.Buffer(List.Distinct(List.Combine(List.Transform(List.RemoveNulls(Table.Column(tbl, colName)), Table.ColumnNames)))),
//	CLEAN TABLE
	// –æ—à–∏–±–∫–∏
	Table.ReplaceErr 	= // # –º–µ–Ω—è–µ–º –≤—Å–µ –æ—à–∏–±–∫–∏ –≤–æ –≤—Å–µ–π —Ç–∞–±–ª–∏—Ü–µ –Ω–∞ null
        /*
			–û–ø–∏—Å–∞–Ω–∏–µ:
				–æ–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–æ–∫ errors –≤ —Ç–∞–±–ª–∏—Ü–µ

			–ê–ª–≥–æ—Ä–∏—Ç–º:
				1 –ï—Å–ª–∏ –∞—Ä–≥—É–º–µ–Ω—Ç nms –Ω–µ —É–∫–∞–∑–∞–Ω (—Ç.–µ. —Ä–∞–≤–µ–Ω null), —Ç–æ –±–µ—Ä—ë–º –≤—Å–µ –∫–æ–ª–æ–Ω–∫–∏, –∏–Ω–∞—á–µ - –ø–æ —Å–ø–∏—Å–∫—É
				2 –ó–∞–º–µ–Ω—è–µ–º –æ—à–∏–±–∫–∏ –≤ —É–∫–∞–∑–∞–Ω–Ω—ã—Ö –∫–æ–ª–æ–Ω–∫–∞—Ö –Ω–∞ null

			–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ:
				Table.ReplaceErrorsNull(myTable)
				Table.ReplaceErrorsNull(myTable, {"Column1", "Column2"})
		*/
		(tbl as table, optional nms as list) => 
			let 
				columnsToReplace = nms ?? Table.ColumnNames(tbl)
			in 	
				Table.ReplaceErrorValues(
					tbl, 
					List.Transform(columnsToReplace, (x) => {x, null})
				),
	// —á–∏—Å—Ç–∞ —Ç–µ–∫—Å—Ç–∞
	Table.SuperTrim 	= // —É–¥–∞–ª—è–µ—Ç –ª–∏—à–Ω–∏–µ –ø—Ä–æ–±–µ–ª—ã —Å–Ω–∞—Ä—É–∂–∏ –∏ –≤–Ω—É—Ç—Ä–∏ —Ç–µ–∫—Å—Ç–∞
		/* 
			https://t.me/pbi_pq_from_tank/197
			–ù—É–∂–Ω–æ —Ä–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å —Ñ—É–Ω–∫—Ü–∏—é –°–ñ–ü–†–û–ë–ï–õ–´. –ü—Ä–æ–±–ª–µ–º–∞ –≤ —Ç–æ–º, —á—Ç–æ Text.Trim, Text.TrimStart –∏ Text.TrimEnd –Ω–µ —É–¥–∞–ª—è—é—Ç –ª–∏—à–Ω–∏–µ –ø—Ä–æ–±–µ–ª—ã –≤ —Å–µ—Ä–µ–¥–∏–Ω–µ —Ç–µ–∫—Å—Ç–∞, –∞ –°–ñ–ü–†–û–ë–ï–õ–´ ‚Äì —É–¥–∞–ª—è–µ—Ç. –ß—Ç–æ –∂, —Ä–µ—à–∏–º —ç—Ç—É –ø—Ä–æ–±–ª–µ–º—É

			–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ:
				tbl = #table({"txt"},{{"   –º–∞–º–∞   –º—ã–ª–∞     —Ä–∞–º—É"},{"   –º–∞–º–∞     #(lf)     –º—ã–ª–∞   #(tab)#(tab)#(lf)  —Ä–∞–º—É"}}),

				to3 = Table.TransformColumns( tbl, {"txt", f} ),
				to4 = Table.TransformColumns( tbl, {"txt", (i)=>f(i," ")} ),
				to5 = Table.TransformColumns( tbl, {"txt", (i)=>f(i,null,"#(lf)")} )
				
			superTrim = 
				let f=(txt, optional splitby,optional combby)=> try Text.Combine(List.Select(Text.SplitAny( txt, "" & (splitby??"")),(x)=> x <> "" ), combby??" ") otherwise null,
				to = Table.TransformColumns(Replace, {}, f)
				in  to
		 			
			–ü–æ —à–∞–≥–∞–º:
			to  ‚Äì –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤—ã–≤–∞–µ–º —Ç–µ–∫—Å—Ç–æ–≤—ã–π —Å—Ç–æ–ª–±–µ—Ü. –õ–æ–≥–∏–∫–∞ –ø—Ä–æ—Å—Ç–∞—è: 
					- 1  —Ä–∞–∑–¥–µ–ª—è–µ–º —Ç–µ–∫—Å—Ç –ø–æ –ø—Ä–æ–±–µ–ª—É (Text.Split), –ø—Ä–∏ —ç—Ç–æ–º –ø–æ–ª—É—á–∞–µ–º —Å–ø–∏—Å–æ–∫, –¥–≤–∞ –ø—Ä–æ–±–µ–ª–∞ –ø–æ–¥—Ä—è–¥ —Ç–∞–∫–∂–µ –±—É–¥—É—Ç —Ä–∞–∑–¥–µ–ª–µ–Ω—ã –∏ –≤ —Å–ø–∏—Å–æ–∫ –ø–æ–ø–∞–¥—ë—Ç "" (–ø—É—Å—Ç–∞—è —Å—Ç—Ä–æ–∫–∞), 
					‚Äì 2! —Å–Ω–æ–≤–∞ –∏—Å–ø–æ–ª—å–∑—É–µ–º Text.SplitAny, –ø—Ä–æ—Å—Ç–æ –≤ —ç—Ç–æ—Ç —Ä–∞–∑ –≤—Ç–æ—Ä—ã–º –∞—Ä–≥—É–º–µ–Ω—Ç–æ–º –ø–µ—Ä–µ–¥–∞—ë–º –ø—É—Å—Ç—É—é —Å—Ç—Ä–æ–∫—É ‚Äì –∏ –≤ —ç—Ç–æ–π —Å–∏—Ç—É–∞—Ü–∏–∏ –æ–Ω–∞ —Å–∞–º–∞ –ø—Ä–µ–∫—Ä–∞—Å–Ω–æ –¥–µ–ª–∏—Ç —Ç–µ–∫—Å—Ç –ø–æ –ø—Ä–æ–±–µ–ª—å–Ω—ã–º —Å–∏–º–≤–æ–ª–∞–º –∏ –Ω–µ–ø–µ—á–∞—Ç–Ω—ã–º —Å–∏–º–≤–æ–ª–∞–º, —á—Ç–æ –Ω–∞ –º–æ–π –≤–∫—É—Å —É–¥–æ–±–Ω–æ
					- —É–±–∏—Ä–∞–µ–º –ø—É—Å—Ç—ã–µ —Å—Ç—Ä–æ–∫–∏ (List.Select) –∏ 
					- —Å–æ–±–∏—Ä–∞–µ–º –æ–±—Ä–∞—Ç–Ω–æ —Ç–µ–∫—Å—Ç —á–µ—Ä–µ–∑ –ø—Ä–æ–±–µ–ª (Text.Combine). 
			
			f   ‚Äì 	–Ω—É –∏ –ø–æ–¥—ã—Ç–æ–∂–∏–º –Ω–∞–ø–∏—Å–∞–Ω–∏–µ–º —É—Å–ª–æ–≤–Ω–æ —É–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω–æ–π —Ñ—É–Ω–∫—Ü–∏–∏. 
					–û–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–π –∞—Ä–≥—É–º–µ–Ω—Ç txt ‚Äì –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º—ã–π —Ç–µ–∫—Å—Ç, –Ω–µ–æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–µ ‚Äì splitby –∏ combby ‚Äì —Ä–∞–∑–¥–µ–ª–∏—Ç–µ–ª–∏ –ø–æ –∫–æ—Ç–æ—Ä—ã–º
					–Ω–∞–¥–æ –¥–µ–ª–∏—Ç—å —Ç–µ–∫—Å—Ç –∏ —Ä–∞–∑–¥–µ–ª–∏—Ç–µ–ª—å, —á–µ—Ä–µ–∑ –∫–æ—Ç–æ—Ä—ã–π –Ω–∞–¥–æ –æ–±—Ä–∞—Ç–Ω–æ —Å–æ–±—Ä–∞—Ç—å —Ç–µ–∫—Å—Ç —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ. 
			to3 ‚Äì –ø—Ä–æ—Å—Ç–æ –∏—Å–ø–æ–ª—å–∑—É–µ–º —Ñ—É–Ω–∫—Ü–∏—é
			to4 ‚Äì –¥–µ–ª–∏–º —Ç–æ–ª—å–∫–æ –ø–æ –ø—Ä–æ–±–µ–ª—É
			to5 ‚Äì –¥–µ–ª–∏–º –ø–æ –ø—Ä–æ–±–µ–ª—å–Ω—ã–º –∏ –Ω–µ—á–∏—Ç–∞–µ–º—ã–º —Å–∏–º–≤–æ–ª–∞–º, –∞ —Å–æ–±–∏—Ä–∞–µ–º —á–µ—Ä–µ–∑ —Ä–∞–∑—Ä—ã–≤ —Å—Ç—Ä–æ–∫–∏ (–æ–±—Ä–∞—â–∞—é –≤–Ω–∏–º–∞–Ω–∏–µ –Ω–∞ —Å–∏–Ω—Ç–∞–∫—Å–∏—Å ‚Äì –≤—Ç–æ—Ä–æ–π –∞—Ä–≥—É–º–µ–Ω—Ç –ø–µ—Ä–µ–¥–∞–Ω –∫–∞–∫ null)
		*/
		(txt, optional splitby, optional combby)=>
			Text.Combine(
				List.Select(
					Text.SplitAny(txt,"" & (splitby??"")), 
					(x)=>x<>""), 
				combby??" "
			),

	// —á–∏—Å—Ç–∫–∞ —Ç–∞–±–ª–∏—Ü—ã
	Table.ClearX    	= // # –æ—á–∏—Å—Ç–∫–∞ —Ç–µ–∫—Å—Ç–∞ –æ —Å–∏–º–≤–æ–ª–æ–≤, –ø—É—Å—Ç—ã—Ö —Å—Ç–æ–ª–±—Ü–æ–≤, –ø—É—Å—Ç—ã—Ö —Å—Ç—Ä–æ–∫ //* –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é —Å–¥–µ–ª–∞—Ç—å, –µ—Å–ª–∏ –Ω–∏—á–µ–≥–æ –Ω–µ –≤–≤–µ–¥–µ–Ω–æ –∏–∑ –æ–ø—Ü –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤
		/*
			–û–ø–∏—Å–∞–Ω–∏–µ:
				1 	–æ—á–∏—Å—Ç–∫–∞ —Ç–µ–∫—Å—Ç–∞ –æ —Å–∏–º–≤–æ–ª–æ–≤ + –ø—É—Å—Ç—ã—Ö (= null) —Å—Ç–æ–ª–±—Ü–æ–≤ –∏ —Å—Ç—Ä–æ–∫
				2	–∫–æ–ª–æ–Ω–∫–∏: —É–¥–∞–ª—è—é—Ç—Å—è –µ—Å–ª–∏ = null. –ö–æ–ª–æ–Ω–∫–∏ —Å "" –Ω–µ —É–¥–∞–ª—è—é—Ç—Å—è 
				3	—Å—Ç—Ä–æ–∫–∏:  —É–¥–∞–ª—è—é—Ç—Å—è –µ—Å–ª–∏ = –∏–ª–∏ "" –∏–ª–∏ null –∏–ª–∏ –∏ —Ç–æ –∏ –¥—Ä—É–≥–æ–µ
				4	–Ω–µ —É–¥–∞–ª—è—é—Ç—Å—è –¥–≤–æ–π–Ω—ã–µ –ø—Ä–æ–±–µ–ª—ã –∏ —Å–∏–º–≤–æ–ª—ã " " –≤ –Ω–∞—á–∞–ª–µ –∏ –∫–æ–Ω—Ü–µ —Å—Ç—Ä–æ–∫–∏

			–ü—Ä–∏–º–µ—Ä—ã:
				= F[Table.ClearX] (from)	
					–≤—Å–µ –∑–Ω–∞—á–µ–Ω–∏—è –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é: 	ClearChars 	= " #(lf)#(00A0)#(tab)#(cr)", 
												ClearColumn = true, 
												ClearRows 	= true.
				
				= F[Table.ClearX] (from, [ClearChars = " #(lf)#(00A0)", ClearColumn = false, ClearRows = false]) 
					—É–¥–∞–ª—è–µ–º: —Å–∏–º–≤–æ–ª—ã, –ø—É—Å—Ç—ã–µ –∫–æ–ª–æ–Ω–∫–∏, –ø—É—Å—Ç—ã–µ —Å—Ç—Ä–æ–∫–∏ 

				= F[Table.ClearX] (from, [ClearChars = " #(lf)#(00A0)", ClearColumn = false])
					–ø–∞—Ä–∞–º–µ—Ç—Ä—ã ClearChars –∏ ClearColumn –±—É–¥—É—Ç –æ–±–Ω–æ–≤–ª–µ–Ω—ã, –∞ 
					ClearRows –æ—Å—Ç–∞–Ω–µ—Ç—Å—è —Å–æ –∑–Ω–∞—á–µ–Ω–∏–µ–º –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é (true).

			–°–ø—Ä–∞–≤–∫–∞:
					#(lf) 	–ø–µ—Ä–µ–Ω–æ—Å —Å—Ç—Ä–æ–∫–∏		-	–ö–æ–¥ 10 (–¥–µ—Å—è—Ç–∏—á–Ω—ã–π) –∏–ª–∏ 0A (—à–µ—Å—Ç–Ω–∞–¥—Ü–∞—Ç–µ—Ä–∏—á–Ω—ã–π)
					#(00A0) –Ω–µ—Ä–∞–∑—Ä—ã–≤–Ω—ã–π –ø—Ä–æ–±–µ–ª	-	–ö–æ–¥ U+00A0 (Unicode) –∏–ª–∏ 160 (–¥–µ—Å—è—Ç–∏—á–Ω—ã–π) –∏–ª–∏ 00A0 (—à–µ—Å—Ç–Ω–∞–¥—Ü–∞—Ç–µ—Ä–∏—á–Ω—ã–π)
					#(tab)	—Ç–∞–±—É–ª—è—Ü–∏—è
					#(cr)	–≤–æ–∑–≤—Ä–∞—Ç –∫–∞—Ä–µ—Ç–∫–∏
				1	–¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è —Å–∏–º–≤–æ–ª–æ–≤ –µ—Å—Ç—å —Ñ—É–Ω–∫—Ü–∏—è F[Text.RemoveSymbols]("a,b,c")
				2	–Ω–µ–ø–µ—á–∞—Ç–Ω—ã–µ —Å–∏–º–≤–æ–ª—ã –º–æ–∂–Ω–æ –¥–µ–ª–∞—Ç—å –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å—é
				3	CharsToRemove = List.Transform({33..45,47,58..126}, each Character.FromNumber(_)) // –∫—Ä–æ–º–µ —á–∏—Å–µ–ª
					–í–º–µ—Å—Ç–æ  " #(lf)#(00A0)" —Å–¥–µ–ª–∞—Ç—å
							=> Text.Combine(List.Transform({33..45,47,58..126}, each Character.FromNumber(_)))
							=> !"#$%&'()*+,-/:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~
					
					–∑–∞–º–µ–Ω–∞ –Ω–µ—Ä–∞–∑—Ä—ã–≤–Ω–æ–≥–æ –ø—Ä–æ–±–µ–ª–∞, –Ω–∞–ø—Ä–∏–º–µ—Ä –∏–º–∑ PDF —Ñ–∞–π–ª–æ–≤
					Text.Replace(_, Character.FromNumber(10), " ")})

					–°–º –Ω–æ–º–µ—Ä–∞ –≤ –∫–æ–ª–æ–Ω–∫–µ dex –ø–æ https://autoit-script.ru/docs/appendix/ascii.htm
				4 	–¢–∞–±–ª–∏—Ü–∞ —Å–∏–º–≤–æ–ª–æ–≤ ASCII + Windows 1251 
					https://snipp.ru/handbk/table-ascii - –∫–æ–ª–æ–Ω–∫–∞ –°–∏–º–≤–æ–ª, –Ω–æ –¥–æ–±–∞–≤–∏—Ç—å #()


			–û—Å–æ–±–µ–Ω–Ω–æ—Å—Ç–∏:
				1 –µ—Å–ª–∏ –æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–µ clearColumn –∏ clearRows –Ω–µ —É–∫–∞–∑–∞–Ω—ã, —Ç–æ –ù–ï —É–¥–∞–ª—è–µ–º –ø—É—Å—Ç—ã–µ —Å—Ç—Ä–æ–∫–∏ –∏ —Å—Ç–æ–ª–±—Ü—ã
				2 –µ—Å–ª–∏ —Å—Ç–æ–∏—Ç –õ–Æ–ë–û–ï –∑–Ω–∞—á–µ–Ω–∏–µ, –∑–Ω–∞—á–µ–Ω–∏–µ <> null, —Ç–æ —É–¥–∞–ª—è–µ–º –ø—É—Å—Ç—ã–µ —Å—Ç—Ä–æ–∫–∏ –∏ —Å—Ç–æ–ª–±—Ü—ã
			
			–£–ª—É—á—à–µ–Ω–∏–µ:
				! 1 –∑–∞–º–µ–Ω–∏—Ç—å —É—Å–ª–æ–≤–∏–µ –Ω–∞–æ–±–æ—Ä–æ—Ç, –µ—Å–ª–∏ –Ω–∏—á–µ–≥–æ –Ω–µ —É–∫–∞–∑–∞–Ω–æ, –Ω–æ —É–¥–∞–ª—è–µ–º, –µ—Å–ª–∏ —É–∫–∞–∑–∞–Ω–æ, –Ω–æ –Ω–µ —É–¥–∞–ª—è–µ–º
				! 2 —É–±—Ä–∞—Ç—å –ø–µ—Ä–≤—ã–µ –∏ –ø–æ—Å–ª–µ–¥–Ω–∏–µ –ø—Ä–æ–±–µ–ª—ã
			–ü—Ä–æ–≤–µ—Ä–∫–∞:
				let
					SourceTable = Table.FromRows({
							{"A", "B", "C", null},				// –∫–æ–ª–æ–Ω–∫–∞ 4 –ø—É—Å—Ç–∞—è
							{"Hello", " ", "World", null},   	// –í—Ç–æ—Ä–∞—è –∫–æ–ª–æ–Ω–∫–∞ –ø—É—Å—Ç–∞—è (—Å –ø—Ä–æ–±–µ–ª–æ–º)
							{"Power", null, "Query", null}, 	// –í—Ç–æ—Ä–∞—è –∫–æ–ª–æ–Ω–∫–∞ —Å–æ–¥–µ—Ä–∂–∏—Ç null
							{"", "", "", ""},             		// –ü–æ–ª–Ω–æ—Å—Ç—å—é –ø—É—Å—Ç–∞—è —Å—Ç—Ä–æ–∫–∞
							{"", "", null, null},             	// –ü–æ–ª–Ω–æ—Å—Ç—å—é –ø—É—Å—Ç–∞—è —Å—Ç—Ä–æ–∫–∞
							{null, null, null, null},          	// –ü–æ–ª–Ω–æ—Å—Ç—å—é –ø—É—Å—Ç–∞—è —Å—Ç—Ä–æ–∫–∞
							{"Test", "1#(lf)–∞", "Data", null}, 	// –¢—Ä–µ—Ç—å—è —Å—Ç—Ä–æ–∫–∞ —Å –Ω–µ–ø–µ—á–∞—Ç–Ω—ã–º —Å–∏–º–≤–æ–ª–æ–º #(lf)
							{null, "Value", "", null}       	// –ü—É—Å—Ç—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è –∏ null
						}, 
						{"Col1", "Col2", "Col3", "Col4"}
					),

					CleanedTable = F[Table.ClearX](SourceTable, [ClearChars = "#(lf)", ClearColumn = true, ClearRows = true])
				in
					CleanedTable

		*/
		[ 
	        func   = (tbl as table, optional options as record) => [
                // 	–ê–†–ì–£–ú–ï–ù–¢–´ –®–∞–≥ 0. –ó–Ω–∞—á–µ–Ω–∏—è –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é –¥–ª—è options //! –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é False –∏–ª–∏ True ??? —Å–º–æ—Ç—Ä–∏ –ø—Ä–∏–º–µ—Ä—ã
					defaultOptions	= [ClearChars = " #(lf)#(00A0)#(tab)#(cr)", ClearColumn = true, ClearRows = true],
					finalOptions    = if options = null then defaultOptions else Record.Combine({defaultOptions, options}),

				//	–ê–†–ì–£–ú–ï–ù–¢–´ –®–∞–≥ 0. –°–ø–∏—Å–æ–∫ –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤
				    GetValue  	= // —Ñ—É–Ω–∫—Ü–∏—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è —Ç–∏–ø–∞ –æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω—ã—Ö –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤
                        (options as record, fieldName as text, typeConverter as function) =>
                            let value  = Record.FieldOrDefault(options, fieldName, null)
                            in  if List.Contains({null, 0, ""}, value) then null else typeConverter(value),

                    clearChars 	= GetValue(finalOptions, "ClearChars", 	Text.From),		// —Å–ø–∏—Å–æ–∫ —É–¥–∞–ª—è–µ–º—ã—Ö –Ω–µ–ø–µ—á–∞—Ç–Ω—ã—Ö —Å–∏–º–≤–æ–ª–æ–≤
                    clearColumn = GetValue(finalOptions, "ClearColumn",	Logical.From),	// true/false - —É–¥–∞–ª–∏—Ç—å –ø—É—Å—Ç—ã–µ —Å—Ç–æ–ª–±—Ü—ã //* –º–æ–∂–Ω–æ —É–±—Ä–∞—Ç—å, —Ç–æ–≥–¥–∞ –ª—é–±–æ–π —Å–∏–º–≤–æ–ª –Ω–µ null —Å—Ä–∞–±–æ—Ç–∞–µ—Ç
					clearRows 	= GetValue(finalOptions, "ClearRows", 	Logical.From),  // true/false - —É–¥–∞–ª–∏—Ç—å –ø—É—Å—Ç—ã–µ —Å—Ç—Ä–æ–∫–∏
        
				// 	0 tr	–¥–µ–ª–∞–µ–º –≤—Å–µ –∫–æ–ª–æ–Ω–∫–∏ —Ç–µ–∫—Å—Ç–æ–≤—ã–º–∏	//* 
					// –µ—Å–ª–∏ –æ—à–∏–±–∫–∏ —Ñ–æ—Ä–º—É–ª –∫–æ–≥–¥–∞ —Å –ª–∏—Å—Ç–∞ Excel, —Ç–æ–≥–¥–∞  tr = Table.ReplaceErrorValues(tr1, List.Transform(Table.ColumnNames(tr1),(x)=>{x,null})),
					tr = Table.TransformColumns(tbl, {}, Text.From),
							
				// 	1 p		—É–¥–∞–ª—è–µ–º –Ω–µ–ø–µ—á–∞—Ç–Ω—ã–µ —Å–∏–º–≤–æ–ª—ã		//* –æ–ø–∏—Å–∞—Ç—å —Å–ª–æ–≤–∞–º–∏ —É—Å–ª–æ–≤–∏–µ. –ë—É—Ñ–µ—Ä–∏–∑–∞—Ü–∏—è –Ω–µ –Ω—É–∂–Ω–∞ —Ç—É—Ç!
					p =	if clearChars is null then tr else 
						let f = (x) => 
								if x = null then x 
								else Text.Combine(List.RemoveMatchingItems(Text.SplitAny(Text.Clean(x), clearChars), {""}), " ")
						in 	Table.TransformColumns(tr, {}, f),
				
				// 	2 cl	—É–¥–∞–ª—è–µ–º –ø—É—Å—Ç—ã–µ –∫–æ–ª–æ–Ω–∫–∏ 			
					// –±–æ–ª–µ–µ –±—ã—Å—Ç—Ä—ã–π –≤–∞—Ä–∏–∞–Ω—Ç, –ø–æ–¥ –Ω–æ–≤—ã–µ –≤–µ—Ä—Å–∏–∏ Excel
					cl2 = 	if clearColumn = false then p else 
								let a = List.Sort(Table.ColumnNames(p)),
									b = Table.Profile(p, {{"tmp", (x) => true, List.NonNullCount}}) [tmp],
									c = List.PositionOf(b, 0, Occurrence.All),
									d = List.Transform(c, (x) => a{x})
								in  Table.RemoveColumns(p, d),
					
					// –±–æ–ª–µ–µ –º–µ–¥–ª–µ–Ω–Ω—ã–π –≤–∞—Ä–∏–∞–Ω—Ç, –Ω–æ –ø–æ–¥—Ö–æ–¥–∏—Ç –ø–æ–¥ —Å—Ç–∞—Ä—ãx –≤–µ—Ä—Å–∏–π Excel
					cl =	if clearColumn = false then p else 
								let tbl =	p,
									nms = 	Table.ColumnNames(tbl),
									lst = 	List.Select(nms, (colName) =>
												let	values = List.ReplaceValue(Table.Column(tbl, colName), "", null, Replacer.ReplaceValue)
												in	List.NonNullCount(values) > 0
											)
								in Table.SelectColumns(tbl, lst),

				// 	3 to	—É–¥–∞–ª—è–µ–º –ø—É—Å—Ç—ã–µ —Å—Ç—Ä–æ–∫–∏ 			//* –Ω–∞—Å–∫–æ–ª—å–∫–æ –ø—É—Å—Ç—ã–µ?
					to = 	if clearRows = false 
							then cl 
							else Table.SelectRows(cl, 
									each not List.IsEmpty(List.RemoveMatchingItems(Record.FieldValues(_), {"", null}))
								),

				// 	4 w		—É–¥–∞–ª—è–µ–º –¥–≤–æ–π–Ω—ã–µ –ø—Ä–æ–±–µ–ª—ã 		//* –Ω–µ –∏—Å–ø–æ–ª—å–∑—É—é –ø–æ–∫–∞, –æ—à–∏–±–∫–∞ –∏ –¥–æ–ª–≥–æ–≤–∞—Ç–æ. –°–º–æ—Ç—Ä–∏ –Ω–æ–≤—É—é Table.SuperTrim
					w = [	f = (txt) => Text.Combine(List.Select(Text.Split(txt, " "), each _ <> ""), " "),
							m = Table.TransformColumns(to, {}, f)
						]  [m]
				] [to],
			
			typ    = [ 
				optionsType	= type [ 
						// tbl			= (type 		 table   meta [Documentation.FieldCaption = "Table"]),
						ClearChars	= (type nullable text    meta [Documentation.FieldCaption = "ClearChars",	Documentation.SampleValues = {"—Å–∏–º–≤–æ–ª—ã # (...)"}]),
						ClearColumn = (type nullable logical meta [Documentation.FieldCaption = "ClearColumn",	Documentation.SampleValues = {"true"}]),
						ClearRows	= (type nullable logical meta [Documentation.FieldCaption = "ClearRows",	Documentation.SampleValues = {"false"}])
					],

				optionsMeta	= [ 
						Documentation.Name = "Table.ClearX",
						Documentation.LongDescription = "...",
						Documentation.Examples = {
							[Description = "", Code = "=F[Table.ClearX] (from, [ClearChars = "" #(lf)#(00A0)"", ClearColumn = true, ClearRows = true])",		Result="—Å–ø–∏—Å–æ–∫ —Ñ–∞–π–ª–æ–≤ xls"], 
							[Description = "", Code = "=F[LoadFolder](""Homel"", 3)",	Result="—Å–ø–∏—Å–æ–∫ —Ñ–∞–π–ª–æ–≤ xls –Ω–∞ —à–∞–≥–µ 3"], 
							[Description = "", Code = "=F_Form[LoadFolder](""Homel"", 123)",Result="—Å–æ–æ–±—â–µ–Ω–∏–µ –æ–± –æ—à–∏–±–∫–µ"]
						}
					],
				return 	    = type function (tbl as table, optional options as optionsType) as table meta optionsMeta
				][return],
			
			result = Value.ReplaceType(func,typ)
		] [result],

	Table.ClearAll    	= // # –æ—á–∏—Å—Ç–∫–∞ —Ç–µ–∫—Å—Ç–∞ –æ —Å–∏–º–≤–æ–ª–æ–≤ + –ø—É—Å—Ç—ã—Ö —Å—Ç–æ–ª–±—Ü–æ–≤ –∏ —Å—Ç—Ä–æ–∫
		/*
			–û–ø–∏—Å–∞–Ω–∏–µ:
				–æ—á–∏—Å—Ç–∫–∞ —Ç–µ–∫—Å—Ç–∞ –æ —Å–∏–º–≤–æ–ª–æ–≤ + –ø—É—Å—Ç—ã—Ö (= null) —Å—Ç–æ–ª–±—Ü–æ–≤ –∏ —Å—Ç—Ä–æ–∫

			–ü—Ä–∏–º–µ—Ä:
				F[Table.ClearAll](i," #(lf)#(00A0)")		-	—É–¥–∞–ª—è–µ–º —Ç–æ–ª—å–∫–æ —Å–∏–º–≤–æ–ª—ã
				F[Table.ClearAll](i," #(lf)#(00A0)", 1)		-	—É–¥–∞–ª—è–µ–º —Å–∏–º–≤–æ–ª—ã + –ø—É—Å—Ç—ã–µ —Å—Ç–æ–ª–±—Ü—ã
				F[Table.ClearAll](i," #(lf)#(00A0)", 1, 1)	-	—É–¥–∞–ª—è–µ–º —Å–∏–º–≤–æ–ª—ã + –ø—É—Å—Ç—ã–µ —Å—Ç–æ–ª–±—Ü—ã + –ø—É—Å—Ç—ã–µ —Å—Ç—Ä–æ–∫–∏

			–°–ø—Ä–∞–≤–∫–∞:
					#(lf) 	–ø–µ—Ä–µ–Ω–æ—Å —Å—Ç—Ä–æ–∫–∏		-	–ö–æ–¥ 10 (–¥–µ—Å—è—Ç–∏—á–Ω—ã–π) –∏–ª–∏ 0A (—à–µ—Å—Ç–Ω–∞–¥—Ü–∞—Ç–µ—Ä–∏—á–Ω—ã–π)
					#(00A0) –Ω–µ—Ä–∞–∑—Ä—ã–≤–Ω—ã–π –ø—Ä–æ–±–µ–ª	-	–ö–æ–¥ U+00A0 (Unicode) –∏–ª–∏ 160 (–¥–µ—Å—è—Ç–∏—á–Ω—ã–π) –∏–ª–∏ 00A0 (—à–µ—Å—Ç–Ω–∞–¥—Ü–∞—Ç–µ—Ä–∏—á–Ω—ã–π)
					#(tab)	—Ç–∞–±—É–ª—è—Ü–∏—è
					#(cr)	–≤–æ–∑–≤—Ä–∞—Ç –∫–∞—Ä–µ—Ç–∫–∏
				1	–¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è —Å–∏–º–≤–æ–ª–æ–≤ –µ—Å—Ç—å —Ñ—É–Ω–∫—Ü–∏—è F[Text.RemoveSymbols]("a,b,c")
				2	–Ω–µ–ø–µ—á–∞—Ç–Ω—ã–µ —Å–∏–º–≤–æ–ª—ã –º–æ–∂–Ω–æ –¥–µ–ª–∞—Ç—å –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å—é
				3	CharsToRemove = List.Transform({33..45,47,58..126}, each Character.FromNumber(_)) // –∫—Ä–æ–º–µ —á–∏—Å–µ–ª
					–°–º –Ω–æ–º–µ—Ä–∞ –≤ –∫–æ–ª–æ–Ω–∫–µ dex –ø–æ https://autoit-script.ru/docs/appendix/ascii.htm
				4 	–¢–∞–±–ª–∏—Ü–∞ —Å–∏–º–≤–æ–ª–æ–≤ ASCII + Windows 1251 
					https://snipp.ru/handbk/table-ascii - –∫–æ–ª–æ–Ω–∫–∞ –°–∏–º–≤–æ–ª, –Ω–æ –¥–æ–±–∞–≤–∏—Ç—å #()

			–û—Å–æ–±–µ–Ω–Ω–æ—Å—Ç–∏:
				1 –µ—Å–ª–∏ –æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–µ clearColumn –∏ clearRows –Ω–µ —É–∫–∞–∑–∞–Ω—ã, —Ç–æ –ù–ï —É–¥–∞–ª—è–µ–º –ø—É—Å—Ç—ã–µ —Å—Ç—Ä–æ–∫–∏ –∏ —Å—Ç–æ–ª–±—Ü—ã
				2 –µ—Å–ª–∏ —Å—Ç–æ–∏—Ç –õ–Æ–ë–û–ï –∑–Ω–∞—á–µ–Ω–∏–µ, –∑–Ω–∞—á–µ–Ω–∏–µ <> null, —Ç–æ —É–¥–∞–ª—è–µ–º –ø—É—Å—Ç—ã–µ —Å—Ç—Ä–æ–∫–∏ –∏ —Å—Ç–æ–ª–±—Ü—ã
			
			–£–ª—É—á—à–µ–Ω–∏–µ:
				1 –∑–∞–º–µ–Ω–∏—Ç—å —É—Å–ª–æ–≤–∏–µ –Ω–∞–æ–±–æ—Ä–æ—Ç, –µ—Å–ª–∏ –Ω–∏—á–µ–≥–æ –Ω–µ —É–∫–∞–∑–∞–Ω–æ, –Ω–æ —É–¥–∞–ª—è–µ–º, –µ—Å–ª–∏ —É–∫–∞–∑–∞–Ω–æ, –Ω–æ –Ω–µ —É–¥–∞–ª—è–µ–º
		*/
		
		[func = (
			tbl, 						// —Ç–∞–±–ª–∏—Ü–∞
			optional clearData, 		// —Å–ø–∏—Å–æ–∫ —É–¥–∞–ª—è–µ–º—ã—Ö –Ω–µ–ø–µ—á–∞—Ç–Ω—ã—Ö —Å–∏–º–≤–æ–ª–æ–≤
			optional clearColumn, 		// true/false - —É–¥–∞–ª–∏—Ç—å –ø—É—Å—Ç—ã–µ —Å—Ç–æ–ª–±—Ü—ã
			optional clearRows			// true/false - —É–¥–∞–ª–∏—Ç—å –ø—É—Å—Ç—ã–µ —Å—Ç—Ä–æ–∫–∏
		) =>

		[ 	// 	–¥–µ–ª–∞–µ–º –≤—Å–µ –∫–æ–ª–æ–Ω–∫–∏ —Ç–µ–∫—Å—Ç–æ–≤—ã–º–∏
				tr = Table.TransformColumns(tbl, {}, Text.From),
				// –µ—Å–ª–∏ –æ–ª—à–∏–±–∫–∏ —Ñ–æ—Ä–º—É–ª –∫–æ–≥–¥–∞ —Å –ª–∏—Å—Ç–∞ Excel
				// tr = Table.ReplaceErrorValues(tr1, List.Transform(Table.ColumnNames(tr1),(x)=>{x,null})),
		
			// 	—É–¥–∞–ª—è–µ–º –Ω–µ–ø–µ—á–∞—Ç–Ω—ã–µ —Å–∏–º–≤–æ–ª—ã
				p = 	if clearData is null 
						then tr 
						else [ 	k = (x) => 
									if x = null 
									then x 
									else Text.Combine( List.RemoveMatchingItems(Text.SplitAny(Text.Clean(x), clearData), {""}), " "),
								to = Table.TransformColumns(tr, {}, k)
							][to],

			// 	—É–¥–∞–ª—è–µ–º –ø—É—Å—Ç—ã–µ –∫–æ–ª–æ–Ω–∫–∏
				cl = 	if clearColumn is null 
						then p 
						else [ 	a = List.Sort(Table.ColumnNames(p)),
								b = Table.Profile(p, {{"tmp", (x) => true, List.NonNullCount}})[tmp],
								c = List.PositionOf(b, 0, Occurrence.All),
								d = List.Transform(c, (x) => a{x}),
								e = Table.RemoveColumns(p, d)
							][e],

			// 	—É–¥–∞–ª—è–µ–º –ø—É—Å—Ç—ã–µ —Å—Ç—Ä–æ–∫–∏
				to = 	if clearRows is null 
						then cl 
						else Table.SelectRows(cl, each not List.IsEmpty(List.RemoveMatchingItems(Record.FieldValues(_), {"", null})))
		] [to],
			
		typ = type function (tbl as table, optional clearData as text, optional clearColumn as text, optional clearRows as text) as table 
				meta [  Documentation.Name              = "Table.ClearAll",
						Documentation.LongDescription   = " "],

		result = Value.ReplaceType(func,typ)
		] [result],
		
	Table.ClearAll2   	= // –æ—á–∏—Å—Ç–∫–∞ —Ç–µ–∫—Å—Ç–∞ –æ—Ç —Å–∏–º–≤–æ–ª–æ–≤ + –ø—É—Å—Ç—ã—Ö —Å—Ç–æ–ª–±—Ü–æ–≤ –∏ —Å—Ç—Ä–æ–∫ + –±–µ–∑ –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤!
		  	(tbl) =>
			[ 	tr = Table.TransformColumns(tbl, {}, Text.From),
				
				// —É–¥–∞–ª—è–µ–º —Å–∏–º–≤–æ–ª—ã
				ch = 
					let clearData = " #(lf)#(00A0)",
						f=(x)=>Text.Combine(List.RemoveMatchingItems(Text.SplitAny(Text.Clean(x), clearData), {""}), " ")
					in Table.TransformColumns(tr, {}, f),

				// —É–¥–∞–ª—è–µ–º –ø—É—Å—Ç—ã–µ –∫–æ–ª–æ–Ω–∫–∏
				cc = 	Table.SelectColumns(ch, 
							List.Select(
								Table.ColumnNames(ch),
								(colName) =>
									let	columnValues = List.ReplaceValue(Table.Column(ch, colName), "", null, Replacer.ReplaceValue)
									in	List.NonNullCount(columnValues) > 0
							)
						),

				// —É–¥–∞–ª—è–µ–º –ø—É—Å—Ç—ã–µ —Å—Ç—Ä–æ–∫–∏
				rw = Table.SelectRows(ch, each not List.IsEmpty(List.RemoveMatchingItems(Record.FieldValues(_), {"", null})))
			] [ch],

	fxCleanColumnNames  = // —á–∏—Å—Ç–∫–∞ –Ω–∞–∑–≤–∞–Ω–∏–π –∫–æ–ª–æ–Ω–æ–∫ —á–µ—Ä–µ–∑ Text.Clean –∏ Text.Trim
		(Source as table) as table =>
			Table.RenameColumns(Source,
				List.Zip({
					Table.ColumnNames(Source),
					List.Transform(
						Table.ColumnNames(Source), 
						each Text.Clean(Text.Trim(_)) 
					)
				})
			),
	// —É–¥–∞–ª–µ–Ω–∏–µ –∫–æ–ª–æ–Ω–æ–∫
	Table.RemoveEmptyColumns   = // —É–¥–∞–ª–µ–Ω–∏–µ –ø—É—Å—Ç—ã—Ö —Å—Ç–æ–ª–±—Ü–æ–≤ 
			[ func = (table, optional options) =>
				let	tbl = Table.Buffer(Table.Profile(table)),
					lst = Table.SelectRows(tbl,(x)=>x[Count]=x[NullCount])[Column],
					to  = Table.RemoveColumns(table,lst)
				in  to,
			
				typ = type function (table as table, optional options as record) as table 
						meta [  Documentation.Name            = "fxTableRemoveEmptyColumns (@buchlotnik)",
								Documentation.LongDescription = "—Ñ—É–Ω–∫—Ü–∏—è, —É–¥–∞–ª—è—é—â–∞—è –ø—É—Å—Ç—ã–µ —Å—Ç–æ–ª–±—Ü—ã –∏–∑ —Ç–∞–±–ª–∏—Ü—ã"],
				
				result = Value.ReplaceType(func,typ)
			][result],
				
	Column.RemoveToName 	   = // 1. –£–¥–∞–ª—è–µ–º –∫–æ–ª–æ–Ω–∫–∏ –ø–æ –º–∞—Å–∫–µ –∏–º–µ–Ω–∏ (–Ω–∞—á–∏–Ω–∞–µ—Ç—Å—è —Å ...) 
		[ 	func = 
			(
				tbl as table, 
				optional txt as text	// –Ω–∞—á–∞–ª—å–Ω—ã–µ —Å–∏–º–≤–æ–ª—ã –∏–º–µ–Ω–∏ –∫–æ–ª–æ–Ω–∫–∏
			)=> 
			let 
				from = 	if txt = null 
						then "Column" 
						else txt,
				
				to = Table.RemoveColumns(
						tbl, 
						List.Select(
							Table.ColumnNames(tbl), 
							(x)=>Text.StartsWith(x,from)
						) 
					)
			in to,
				
			fnType = type function (tbl as table, optional txt as text) as table
				meta [ 	Documentation.Name            = "Column.RemoveNameWithColumn - fxRemoveColumnsNameColumn",
						Documentation.LongDescription = " "
				],
	
		result = Value.ReplaceType(func, fnType)
		] [result],

	Column.RemoveNull   	   = // 2. –£–¥–∞–ª—è–µ–º –ø—É—Å—Ç—ã–µ –∫–æ–ª–æ–Ω–∫–∏ (–≤–µ–∑–¥–µ null) 
		(table as table, optional options) => [
			tbl = Table.Buffer(Table.Profile(table)), 
			lst = Table.SelectRows(tbl,(x)=>x[Count]=x[NullCount])[Column], 
			to  = Table.RemoveColumns(table,lst) 
		] [to],
   
	Column.RemoveEmptyColumns  = // 2. –£–¥–∞–ª—è–µ–º –ø—É—Å—Ç—ã–µ –∫–æ–ª–æ–Ω–∫–∏ (null + "") –±–µ–∑ profile
		(tbl as table) =>
		let
			// –ó–∞–º–µ–Ω—è–µ–º –ø—É—Å—Ç—ã–µ —Å—Ç—Ä–æ–∫–∏ –Ω–∞ null –∏ —Ñ–∏–ª—å—Ç—Ä—É–µ–º —Å—Ç–æ–ª–±—Ü—ã –∑–∞ –æ–¥–∏–Ω –ø—Ä–æ—Ö–æ–¥
			lstNonEmptyColumns = 
				List.Select(
					Table.ColumnNames(tbl),
						(colName) =>
							let	columnValues = List.ReplaceValue(Table.Column(tbl, colName), "", null, Replacer.ReplaceValue)
							in	List.NonNullCount(columnValues) > 0
				)
			// –û—Å—Ç–∞–≤–ª—è–µ–º —Ç–æ–ª—å–∫–æ –Ω–µ–ø—É—Å—Ç—ã–µ –∫–æ–ª–æ–Ω–∫–∏
		in  Table.SelectColumns(tbl, lstNonEmptyColumns),

	// —É–¥–∞–ª–µ–Ω–∏–µ —Å—Ç—Ä–æ–∫	
	Table.RemoveEmptyRows      = 1, // –£–¥–∞–ª–µ–Ω–∏–µ –ø—É—Å—Ç—ã—Ö —Å—Ç—Ä–æ–∫ 
	Table.EmptyRow 			   = // —É–¥–∞–ª–µ–Ω–∏–µ –ø–æ–ª–Ω–æ—Å—Ç—å—é –ø—É—Å—Ç–æ–π —Å—Ç—Ä–æ–∫–∏ (–≤–µ–∑–¥–µ null)
		(tbl)=>
			Table.SelectRows(tbl, 
				each not List.IsEmpty(List.RemoveMatchingItems(Record.FieldValues(_), {"", null}))
			),

	Row.RemoveNull  		   = // —É–¥–∞–ª–µ–Ω–∏–µ –ø–æ–ª–Ω–æ—Å—Ç—å—é –ø—É—Å—Ç—ã—Ö —Å—Ç—Ä–æ–∫
		(tbl as table)=> 
			Table.SelectRows(tbl, each not 
				List.IsEmpty(
					List.RemoveMatchingItems(
						List.Transform(
							List.RemoveMatchingItems( Record.FieldValues(_), {"", null} ),
							each try Text.Clean( Text.Trim(_) ) otherwise _ ), {""}
					)
				)
			),

	Row.RemoveNullColumns  	   = // —É–¥–∞–ª–µ–Ω–∏–µ —Å—Ç—Ä–æ–∫, –µ—Å–ª–∏ –≤ –∑–∞–¥–∞–Ω–Ω—ã—Ö –∫–æ–ª–æ–Ω–∫–∞—Ö –ø—É—Å—Ç–æ –∏–ª–∏ null //! –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ?
		/* 
			= Row.RemoveNullColumns (from, {"–ù–∞ –Ω–∞—á–∞–ª–æ","–ù–∞ –∫–æ–Ω–µ—Ü"})
		*/
		(tbl as table, lst as list)=> 
			Table.SelectRows(tbl, each not 
				List.IsEmpty(
					List.RemoveMatchingItems(
						Record.ToList(	Record.SelectFields(_, lst)	),
						{null, ""}
					)
				)
			),
					
//	–ó–ê–ú–ï–ù–ê
	NumOrZero 			   = // # —Ñ—É–Ω–∫—Ü–∏—è –∑–∞–º–µ–Ω—è–µ—Ç –∑–Ω–∞—á–µ–Ω–∏–µ null –Ω—É–ª—ë–º –∏ –ø—Ä–∏–≤–æ–¥–∏—Ç –∑–Ω–∞—á–µ–Ω–∏–µ –∫ —á–∏—Å–ª–æ–≤–æ–º—É —Ç–∏–ø—É  
		/* 
			–û–ø–∏—Å–∞–Ω–∏–µ:
				—á–∏—Å–ª–∞ –æ—Å—Ç–∞—é—Ç—Å—è —á–∏—Å–ª–∞–º–∏, —á–∏—Å–ª–æ –∫–∞–∫ —Ç–µ–∫—Å—Ç —Å—Ç–∞–Ω–æ–≤–∏—Ç—Å—è —á–∏—Å–ª–æ–º, –∞ null –ø—Ä–µ–≤—Ä–∞—â–∞–µ—Ç—Å—è –≤ –Ω–æ–ª—å
			
			–ü—Ä–∏–º–µ—Ä 1:
				"—á–∏—Å–ª–∞ –æ—Å—Ç–∞—é—Ç—Å—è —á–∏—Å–ª–∞–º–∏"           	= NumOrZero(5) 		Result = "5" 
				"—á–∏—Å–ª–æ –∫–∞–∫ —Ç–µ–∫—Å—Ç —Å—Ç–∞–Ω–æ–≤–∏—Ç—Å—è —á–∏—Å–ª–æ–º" = NumOrZero("5")	Result = "5" 
				"null –ø—Ä–µ–≤—Ä–∞—â–∞–µ—Ç—Å—è –≤ –Ω–æ–ª—å"          = NumOrZero(null)	Result = "0"

			–ü—Ä–∏–º–µ—Ä 2:
				let
					from = Table.FromRecords({
						[A = null, B = 2,    C = 3,    D = "4"],
						[A = "5",  B = 6,    C = null, D = 8  ],
						[A = 9,    B = null, C = "10", D = 11 ]
					}),
				
					to1 = Table.TransformColumns(from, {}, NumOrZero) 			// –≤–æ –≤—Å–µ—Ö –∫–æ–ª–æ–Ω–∫–∞—Ö
					to2 = Table.TransformColumns(from, {"A", (x)=>x}, NumOrZero) // –≤–æ –≤—Å–µ—Ö –∫–æ–ª–æ–Ω–∫–∞—Ö –∫—Ä–æ–º–µ "–ê"
				in  
					to2
			–°—Å—ã–ª–∫–∞:
				–í —Ç–∞–Ω–∫–µ / –°–ª–æ–∂–Ω–æ –æ —Ñ—É–Ω–∫—Ü–∏—è—Ö 1 - –¢–∏–ø–∏–∑–∞—Ü–∏—è 	  / #–ê–Ω–∞—Ç–æ–º–∏—è–§—É–Ω–∫—Ü–∏–π - Type.ForFunction
				–í —Ç–∞–Ω–∫–µ / –°–ª–æ–∂–Ω–æ –æ —Ñ—É–Ω–∫—Ü–∏—è—Ö 2 - –î–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è  / #–ê–Ω–∞—Ç–æ–º–∏—è–§—É–Ω–∫—Ü–∏–π - Type.ForFunction
		*/
		[ 	func   = (x as any)=> if x=null then 0 else Number.From(x),
			typ    = Value.Type(func),
			params = Type.FunctionParameters(typ),
			min    = Type.FunctionRequiredParameters(typ),
			ftyp   = Type.ForFunction([ReturnType = Int64.Type, Parameters = params], min),
			doc    = 
				[
					Documentation.Name            = "NumOrZero", 
					Documentation.Description     = "—Ñ—É–Ω–∫—Ü–∏—è –∑–∞–º–µ–Ω—è–µ—Ç –∑–Ω–∞—á–µ–Ω–∏–µ <i><b>null</b></i> –Ω—É–ª—ë–º –∏ –ø—Ä–∏–≤–æ–¥–∏—Ç –∑–Ω–∞—á–µ–Ω–∏–µ –∫ —á–∏—Å–ª–æ–≤–æ–º—É —Ç–∏–ø—É", 
					Documentation.LongDescription = "—Ñ—É–Ω–∫—Ü–∏—è –∑–∞–º–µ–Ω—è–µ—Ç –∑–Ω–∞—á–µ–Ω–∏–µ <i><b>null</b></i> –Ω—É–ª—ë–º –∏ –ø—Ä–∏–≤–æ–¥–∏—Ç –∑–Ω–∞—á–µ–Ω–∏–µ –∫ —á–∏—Å–ª–æ–≤–æ–º—É —Ç–∏–ø—É", 
					Documentation.Examples        = 
						{
							[Description = "—á–∏—Å–ª–∞ –æ—Å—Ç–∞—é—Ç—Å—è —á–∏—Å–ª–∞–º–∏",            Code = "=NumOrZero(5)", 	Result = "5"], 
							[Description = "—á–∏—Å–ª–æ –∫–∞–∫ —Ç–µ–∫—Å—Ç —Å—Ç–∞–Ω–æ–≤–∏—Ç—Å—è —á–∏—Å–ª–æ–º", Code = "=NumOrZero(""5"")",	Result = "5"], 
							[Description = "null –ø—Ä–µ–≤—Ä–∞—â–∞–µ—Ç—Å—è –≤ –Ω–æ–ª—å",          Code = "=NumOrZero(null)",	Result = "0"]
						}
				],
			ftypwithmeta = Value.ReplaceMetadata(ftyp, doc), 
			fres         = Value.ReplaceType(func, ftypwithmeta)
		]  [fres],

	Text.DeletBracket      = // —É–¥–∞–ª–µ–Ω–∏–µ —Ç–µ–∫—Å—Ç–∞ –≤ —Å—Ç–æ–ª–±—Ü–µ —Ç–∞–±–ª–∏—Ü–µ –≤–Ω—É—Ç—Ä–∏ —Å–∫–æ–±–æ–∫ + —Å–∞–º–∏ —Å–∫–æ–±–∫–∏ (–±—ã—Å—Ç—Ä–µ–µ)
		/*
			–û–ø–∏—Å–∞–Ω–∏–µ:	
			–ü—Ä–∏–º–µ—Ä:		= F[Text.DeletBracket](tbl,"Column1")
			–†–µ–∑—É–ª—å—Ç–∞—Ç:	
		*/
		(tbl as table, columnName as text) =>
			let
				f=(x)=>
					let a = Text.PositionOf(x,"("),
						b = if a = -1 
							then x 
							else @f(Text.RemoveRange(x,a,Text.PositionOf(x,")")-a+1))
					in  b,
				to   = Table.TransformColumns(tbl, {columnName,f})
			in
				to,

	Text.RemoveIntoBracket = // —É–¥–∞–ª–µ–Ω–∏–µ —Ç–µ–∫—Å—Ç–∞ –≤–Ω—É—Ç—Ä–∏ —Å–∫–æ–±–æ–∫ + —Å–∞–º–∏ —Å–∫–æ–±–∫–∏ –∫—Ä–æ–º–µ —Å–ø–∏—Å–∫–∞ —Å–ª–æ–≤ –∏—Å–∫–ª—é—á–µ–Ω–∏–π (–º–µ–¥–ª–µ–Ω–Ω–µ–µ)
		/*
			–ü—Ä–∏–º–µ—Ä:		= F[Text.RemoveIntoBracket](tbl,"Column1", {"–£–ë","—Å—á–µ—Ç","–ø–æ–∫—É–ø"})
			–†–µ–∑—É–ª—å—Ç–∞—Ç:	
		*/
		(tbl as table, columnName as text, optional masks as list) =>
		let
			// 	–ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ –º–∞—Å–æ–∫ –≤ –Ω–∏–∂–Ω–∏–π —Ä–µ–≥–∏—Å—Ç—Ä
				masksLower = List.Transform(masks ?? {}, Text.Lower),

			// 	–§—É–Ω–∫—Ü–∏—è –≤–æ–∑–≤—Ä–∞—â—è–µ—Ç —Å–ø–∏—Å–æ–∫ —Å–æ–¥–µ—Ä–∂–∏–º–æ–≥–æ 3-—Ö —Å–∫–æ–±–æ–∫. –ù–∞–ø—Ä–∏–º–µ—Ä: (x)=>fBrackets(x[Column1])
				fBrackets = (txt as text) as list =>
					let fBetween = (x as number) as list =>
							{"(" & Text.BetweenDelimiters(txt, "(", ")", x, {0, RelativePosition.FromStart}) & ")"},
						combine = List.Combine({fBetween(0),fBetween(1),fBetween(2)}),
						remove  = List.RemoveItems(combine, {"()"})
					in  remove,

			//  –°–ø–∏—Å–æ–∫ —Å–æ–¥–µ—Ä–∂–∏–º–æ–≥–æ —Å–∫–æ–±–æ–∫ –≤ –∫–æ–ª–æ–Ω–∫–µ + —Å–∫–æ–±–∫–∏
				GetID = (x) as list => fBrackets(Record.Field(x, columnName)),
				
			//  –§—É–Ω–∫—Ü–∏—è –≤–æ–∑–≤—Ä–∞—â—è–µ—Ç —Å–ø–∏—Å–æ–∫ —É–¥–∞–ª—è–µ–º—ã—Ö –∏–ª–∏ –æ—Å—Ç–∞–≤–ª—è–µ–º—ã—Ö —Å–∫–æ–±–æ–∫. –ù–∞ –≤—Ö–æ–¥–µ —Å–ø–∏—Å–æ–∫?!
				fRemove = (x, useNot as logical) as list =>
					let	filterFunction = 
							if 	 useNot 
							then each     List.AnyTrue(List.Transform(masksLower, (y) => Text.Contains(Text.Lower(_), y)))
							else each not List.AnyTrue(List.Transform(masksLower, (y) => Text.Contains(Text.Lower(_), y))),
						resultList = List.Select(GetID(x), filterFunction)
					in 	resultList,

			// 	–§—É–Ω–∫—Ü–∏—è –¥–æ–±–∞–≤–ª—è–µ—Ç –∫–æ–ª–æ–Ω–∫—É —Å –æ—á–∏—â–µ–Ω–Ω—ã–º —Ç–µ–∫—Å—Ç–æ–º
				fAddColumns=(x)=>
					try List.Accumulate(
							fRemove(x, false),
							Record.Field(x, columnName), 
							(s,c)=>Text.Replace(s,c,"")
					) otherwise GetID,

			//  –î–æ–±–∞–≤–ª—è–µ–º –ø—Ä–æ–≤–µ—Ä–æ—á–Ω—ã–µ –∫–æ–ª–æ–Ω–∫–∏	
				AddColumn = fxAddMultiColumns(tbl, {
					{"–í—Å–µ —Å–∫–æ–±–∫–∏", GetID},
					{"–û—Å—Ç–∞–≤–ª—è–µ–º",  each fRemove(_, true )},
					{"–£–¥–∞–ª—è–µ–º",    each fRemove(_, false)}
					//{"–†–µ–∑—É–ª—å—Ç–∞—Ç1",  fAddColumns}
				}),

			// 	–§—É–Ω–∫—Ü–∏—è –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –æ—á–∏—â–µ–Ω–Ω—ã–π –ø–æ —Å–ª–æ–≤–∞—Ä—é –∏—Å–∫–ª—é—á–µ–Ω–∏–π —Ç–µ–∫—Å—Ç
				fUpdate =
					let	listAll =
							let allRows  = Table.ToRecords(Table.SelectColumns(tbl, columnName)), // –∫–æ–ª–æ–Ω–∫–∞ –∫–∞–∫ –∑–∞–ø–∏—Å—å
								extrList = List.Transform(allRows, each fRemove(_, false)), // –ø—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –≤ —Å–ø–∏—Å–æ–∫
								combine  = List.Combine(extrList) // –æ–±—ä–µ–¥–∏–Ω—è–µ–º —Å–ø–∏—Å–∫–∏
							in  combine,
						dict = List.Buffer(List.Zip({listAll, List.Repeat({""}, List.Count(listAll)) }) ),
						func = (txt)=>List.Accumulate(dict, txt, (s,c)=>Text.Replace(s, c{0}, c{1}))
					in  func,
				
			// 	–û–±–Ω–æ–≤–ª—è–µ–º –∫–æ–ª–æ–Ω–∫—É —Å —Ç–µ–∫—Å—Ç–æ–º, —É–¥–∞–ª—è—è —Ç–µ–∫—Å—Ç –≤ —Å–∫–æ–±–∫–∞—Ö	
				// UpdateText2 = Table.TransformColumns(
				// 		Table.DuplicateColumn(AddColumn, columnName, "–†–µ–∑—É–ª—å—Ç–∞—Ç2"), 
				// 		{"–†–µ–∑—É–ª—å—Ç–∞—Ç2", fUpdate}), 
				UpdateText = Table.TransformColumns(tbl, {columnName, fUpdate} ),

			// 	–£–¥–∞–ª—è–µ–º –ª–∏—à–Ω–∏–µ –∫–æ–ª–æ–Ω–∫–∏ –µ—Å–ª–∏ –æ–Ω–∏ –µ—Å—Ç—å
				Result = try Table.RemoveColumns(UpdateText, {"–í—Å–µ —Å–∫–æ–±–∫–∏","–û—Å—Ç–∞–≤–ª—è–µ–º","–£–¥–∞–ª—è–µ–º"}) 
							otherwise UpdateText
		in
			Result,
	
//	–ü–†–û–í–ï–†–ö–ê —Å–æ–¥–µ—Ä–∂–∏–º–æ–≥–æ
	fxContainsKeyWord 	= // —Å–æ–¥–µ—Ä–∂–∏—Ç –ª–∏ —Ç–∞–±–ª–∏—Ü–∞ –∫–ª—é—á–µ–≤–æ–µ —Å–ª–æ–≤–æ –≤–æ –≤—Å–µ—Ö —Å—Ç–æ–ª–±—Ü–∞—Ö –≤ –ª—é–±–æ–º –º–µ—Å—Ç–µ
		/*
			–û–ø–∏—Å–∞–Ω–∏–µ:

			–ü—Ä–∏–º–µ—Ä:

			–î–∞—Ç–∞—Å–µ—Ç:


			*/
		(table as table, keyword as text) as logical =>
			let f = (x) => List.RemoveNulls(List.RemoveItems(x,{""})),
				g = (row as list) => List.ContainsAny(row, {keyword}, Text.Contains),
				b = List.Transform(Table.ToColumns(table), f),
				h = List.AnyTrue(List.Transform(b, (x)=> g(x) )) 
			in  h,
	
	Text.CompareText 	= // # –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç true, –µ—Å–ª–∏ –ª–∏ –≤ –ø–æ–¥—Å—Ç—Ä–æ–∫–µ –µ—Å—Ç—å —Å–∏–º–≤–æ–ª—ã –∏–∑ —Å–ø–∏—Å–∫–∞ 
		/* 
			–ü—Ä–∏–º–µ—Ä: 
				1. 	–°–æ–∑–¥–∞–µ–º –Ω—É–∂–Ω—ã–π —Å–ø–∏—Å–æ–∫ (–≥—Ä—É–ø–ø–∞) –∫–ª—é—á–µ–π –∏ –ø—Ä–æ–≤–µ—Ä—è–µ–º —Ç–∞–∫–∏–º –æ–±—Ä–∞–∑–æ–º –∏ –æ—Ç–±–∏—Ä–∞–µ–º —Å—Ç—Ä–æ–∫–∏:
					to = Table.SelectRows(from, (x)=>Text.CompareText(–ö–ª—é—á–∏1, x[–¢–µ–∫—Å—Ç]) 
					to = if Text.CompareText(lst, x) = true then 
				2.  
			*/
		(keys as list, text as text) as logical =>
			List.AnyTrue( 
				List.Transform( 
					keys, 
					(key)=> Text.Contains(text, key, Comparer.OrdinalIgnoreCase)
				)
			),
		
	
	fxIsNumber 			= // —è–≤–ª—è–µ—Ç—Å—è –ª–∏ –ø–µ—Ä–≤—ã–π —Å–∏–º–≤–æ–ª —á–∏—Å–ª–æ–º as //todo logical?
		(txt)=>List.ContainsAny ({ Text.Start(txt,1) }, {"0".."9"}, Text.Contains),
	
//	HEADERS
//	RENAME COLUMNS
	TableRenameColumnsByPositions = // –ø–µ—Ä–µ–∏–º–µ–Ω–æ–≤–∞–Ω–∏–µ —Å—Ç–æ–ª–±—Ü–∞ –ø–æ –Ω–æ–º–µ—Ä—É –ø–æ–∑–∏—Ü–∏–∏
			(table,list) =>
				[   a = List.Buffer(Table.ColumnNames(table)),
					b = List.Count(a),
					c = (x) =>{a{if x{0}>0 then x{0}-1 else b+x{0}},x{1}},
					d = if list{0} is list then List.Transform(list,c) else c(list),
					e = Table.RenameColumns(table,d)
				]  [e],
		
	fxRenameColumns 	= // –ø–µ—Ä–µ–∏–º–µ–Ω–æ–≤–∞—Ç—å –≤—Å–µ —Å—Ç–æ–ª–±—Ü—ã, —Å—Ç–∞—Ä—ã–π —Å–ø–∏—Å–æ–∫ -> –Ω–æ–≤—ã–π —Å–ø–∏—Å–æ–∫
		(table,listOld,listNew) => 
			Table.RenameColumns(
				table, 
				List.Zip({ List.Buffer( listOld ), listNew })
			),
		
// 	REORDER COLUMNS
	Reorder.AllColumns  =  	// # –ø–µ—Ä–µ–≥—Ä—É–ø–ø–∏—Ä–æ–≤–∫–∞ —Å—Ç–æ–ª–±—Ü–æ–≤ —Ç–∞–±–ª–∏—Ü—ã —Å–æ–≥–ª–∞—Å–Ω–æ –Ω–æ–≤–æ–≥–æ —Å–ø–∏—Å–∫–∞ lst
		/*  
			–ê—Ä–≥—É–º–µ–Ω—Ç—ã: 
				tbl		- 	–∏—Å—Ö–æ–¥–Ω–∞—è —Ç–∞–±–ª–∏—Ü–∞ 
				lst 	- 	–ù–æ–≤—ã–π —Å–ø–∏—Å–æ–∫ —Ä–∞—Å–ø–æ–ª–æ–∂–µ–Ω–∏—è –≤—Å–µ—Ö —Å—Ç–æ–ª–±—Ü–æ–≤ –∏–ª–∏ –æ—Ç–¥–µ–ª—å–Ω—ã–π —Å—Ç–æ–ª–±–µ—Ü/—Å—Ç–æ–ª–±—Ü—ã
							–ò–º–µ–Ω–∞ —Å—Ç–æ–ª–±—Ü–æ–≤ –¥–æ–ª–∂–Ω—ã —Å–æ–≤–ø–∞–¥–∞—Ç—å —Å –∏—Å—Ö–æ–¥–Ω—ã–º–∏, –º–µ–Ω—è–µ—Ç—Å—è —Ç–æ–ª—å–∫–æ –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å.
							–ï—Å–ª–∏ –∏–º–µ–Ω –∫–∞–∫–∏—Ö-—Ç–æ —Å—Ç–æ–ª–±—Ü–æ–≤ –≤ –Ω–æ–≤–æ–º —Å–ø–∏—Å–∫–µ –Ω–µ –±—É–¥–µ—Ç –∏–ª–∏ –æ—à–∏–±–∫–∞ –≤ –Ω–∞–∑–≤–∞–Ω–∏–∏, 
							—Ç–æ Expression.Error: –°—Ç–æ–ª–±–µ—Ü "..." —Ç–∞–±–ª–∏—Ü—ã –Ω–µ –Ω–∞–π–¥–µ–Ω.
				offset 	- 	—Å–¥–≤–∏–≥ –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ –Ω–∞—á–∞–ª–∞: 
							0 - –±–µ–∑ —Å–¥–≤–∏–≥–∞ (—Å—Ç–∞–Ω–æ–≤–∏—Ç—Å—è —Å—Ç–æ–ª–±—Ü–æ–º 1), 
							1 - –ø–µ—Ä–≤—ã–π —Å—Ç–æ–ª–±–µ—Ü –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π, –≤—Ç–æ—Ä–æ–π –ø–µ—Ä–µ–º–µ—â–∞–µ–º—ã–π
			–ü—Ä–∏–º–µ—Ä: 
				1	= F[Table.ReorderSubsetOfColumns](from, {"–°—Ç—Ä–æ–∫–∞", "–ö–æ–¥"}, 0)	// 	–∫–æ–ª–æ–Ω–∫–∏ {"–°—Ç—Ä–æ–∫–∞", "–ö–æ–¥"}   –ø–µ—Ä–µ–º–µ—â–∞—é—Ç—Å—è –Ω–∞ –ø–æ–∑–∏—Ü–∏–∏ 0 –∏ 1 
				2 	= F[Reorder.AllColumns](from, {"–ù–∞—á–∞–ª–æ", "–ö–æ–Ω–µ—Ü"}, 1)			// 	–∫–æ–ª–æ–Ω–∫–∏ {"–ù–∞—á–∞–ª–æ", "–ö–æ–Ω–µ—Ü"} –ø–µ—Ä–µ–º–µ—â–∞—é—Ç—Å—è –Ω–∞ –ø–æ–∑–∏—Ü–∏–∏ 2 –∏ 3
				3 	= F[Reorder.AllColumns](from,{"a","b"}, 2)						// 	–Ω–∞ –≤—Ö–æ–¥–µ 4 –∫–æ–ª–æ–Ω–∫–∏ abcd. –ù–∞ –≤—ã—Ö–æ–¥–µ –∫–æ–ª–æ–Ω–∫–∏ a –∏ b –ø–æ—Å—Ç–∞–≤–∏—Ç –≤ –∫–æ–Ω–µ—Ü
																						Result: {"c", "d", "a", "b"}
		*/
		[	
			func1  = // –í–∞—Ä–∏–∞–Ω—Ç 1. –ï—Å–ª–∏ –∏–º–µ–Ω–∞ —Å—Ç–æ–ª–±—Ü–æ–≤ tbl –∏ lst —Å–æ–≤–ø–∞–¥–∞—é—Ç!
				(	tbl as table, 				// —Ç–∞–±–ª–∏—Ü–∞ 
					lst as list,				// —Å–ø–∏—Å–æ–∫ —Å—Ç–æ–ª–±—Ü–æ–≤ –∏–∑ –æ–¥–Ω–æ–≥–æ –∏–ª–∏ –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö
					optional offset as number	// —Å–¥–≤–∏–≥ –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ –ø–µ—Ä–≤–æ–≥–æ —Å—Ç–æ–ª–±—Ü–∞
				) => 
					let offset = if offset <> null then offset else 0
					in	Table.ReorderColumns(tbl,
							List.InsertRange(
								List.Difference(
									Table.ColumnNames(tbl),
									lst
								),
							offset, lst)
					),
			
			func2  = // –í–∞—Ä–∏–∞–Ω—Ç 2. –ï—Å–ª–∏ –∏–º–µ–Ω–∞ —Å—Ç–æ–ª–±—Ü–æ–≤ tbl –∏ lst –ù–ï —Å–æ–≤–ø–∞–¥–∞—é—Ç! –ù–∞–≤–µ—Ä–Ω–æ–µ –∑–∞–º–µ–Ω—è–µ—Ç –ø–µ—Ä–≤—ã–π!!!
				(tbl as table, lst as list, optional offset as number) =>
				let
					// 	–ü–æ–ª—É—á–µ–Ω–∏–µ –∏–º–µ–Ω —Å—Ç–æ–ª–±—Ü–æ–≤ –∏–∑ —Ç–∞–±–ª–∏—Ü—ã
						columnNames = Table.ColumnNames(tbl),
					
					// 	–§–∏–ª—å—Ç—Ä–∞—Ü–∏—è —Å–ø–∏—Å–∫–∞ lst, —á—Ç–æ–±—ã –≤–∫–ª—é—á–∏—Ç—å —Ç–æ–ª—å–∫–æ —Ç–µ —Å—Ç–æ–ª–±—Ü—ã, –∫–æ—Ç–æ—Ä—ã–µ —Å—É—â–µ—Å—Ç–≤—É—é—Ç –≤ —Ç–∞–±–ª–∏—Ü–µ
						validColumns = List.Intersect({lst, columnNames}),
					
					// 	–£—Å—Ç–∞–Ω–æ–≤–∫–∞ –∑–Ω–∞—á–µ–Ω–∏—è offset –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é, –µ—Å–ª–∏ –æ–Ω –Ω–µ –∑–∞–¥–∞–Ω
						offsetValue = if offset <> null then offset else 0,
					
					// 	–°–æ–∑–¥–∞–Ω–∏–µ –Ω–æ–≤–æ–≥–æ –ø–æ—Ä—è–¥–∫–∞ —Å—Ç–æ–ª–±—Ü–æ–≤
						reorderedColumns = 
							List.InsertRange(
								List.Difference(columnNames, validColumns),
								offsetValue, 
								validColumns
							),
					
					// 	–ü–µ—Ä–µ—É–ø–æ—Ä—è–¥–æ—á–∏–≤–∞–Ω–∏–µ —Å—Ç–æ–ª–±—Ü–æ–≤ –≤ —Ç–∞–±–ª–∏—Ü–µ
						result = Table.ReorderColumns(tbl, reorderedColumns)
				in	result,
					// try result otherwise tbl,

			typ    = type function (tbl as table, lst as list, optional offset as number) as table 
					meta [ 	Documentation.Name            = "Reorder.AllColumns (fxReorderAllColumns)",
							Documentation.LongDescription = "–ü–µ—Ä–µ–≥—Ä—É–ø–ø–∏—Ä–æ–≤–∫–∞ –≤—Å–µ—Ö —Å—Ç–æ–ª–±—Ü–æ–≤ —Ç–∞–±–ª–∏—Ü—ã —Å–æ–≥–ª–∞—Å–Ω–æ –Ω–æ–≤–æ–≥–æ —Å–ø–∏—Å–∫–∞ lst.
																–°–ø–∏—Å–æ–∫ –Ω–æ–≤—ã—Ö –∑–∞–≥–æ–ª–æ–≤–∫–æ–≤, —á–∏—Å–ª–æ –∏ –Ω–∞–∑–≤–∞–Ω–∏—è –∫–æ–ª–æ–Ω–æ–∫ –¥–æ–ª–∂–Ω—ã —Å–æ–≤–ø–∞–¥–∞—Ç—å. <br>
																–ü—Ä–∏–º–µ—Ä: lst = Value.Metadata(–°–ø—Ä–∞–≤–æ—á–Ω–∏–∫–°—Ç–æ–ª–±—Ü–æ–≤)[balance][–ò–º—è] <br>
																		F[Reorder.AllColumns](from,{""a"",""b""},2)"],
			result = Value.ReplaceType(func2,typ) 
		]  [result],
		
	Table.ReorderSubsetOfColumns = // # –ø–µ—Ä–µ—É–ø–æ—Ä—è–¥–æ—á–∏–≤–∞–µ–Ω–∏–µ —Å—Ç–æ–ª–±—Ü–æ–≤ –±–µ–∑ –ø—Ä–∏–≤—è–∑–∫–∏ –∫ –Ω–∞–∑–≤–∞–Ω–∏—é –¥—Ä—É–≥–∏—Ö //!  –∞–Ω–∞–ª–æ–≥ –ø—Ä–µ–¥—ã–¥—É—â–µ–≥–æ AllColumns –ø–æ—Ç–æ–º —É–±—Ä–∞—Ç—å
		/*  
			–û–ø–∏—Å–∞–Ω–∏–µ 
				–ü–µ—Ä–µ—É–ø–æ—Ä—è–¥–æ—á–µ–Ω–∏–µ —Å—Ç–æ–ª–±—Ü–æ–≤ –Ω–∞–¥–µ–∂–Ω—ã–º —Å–ø–æ—Å–æ–±–æ–º, –±–µ–∑ —Å—Å—ã–ª–æ–∫ –Ω–∞ –∏–º–µ–Ω–∞ –¥—Ä—É–≥–∏—Ö —Å—Ç–æ–ª–±—Ü–æ–≤, –ø–æ –Ω–æ–º–µ—Ä—É

			–ê—Ä–≥—É–º–µ–Ω—Ç—ã:
				tbl 			 - —Ç–∞–±–ª–∏—Ü–∞ 
				reorderedColumns - –ø–æ–¥–º–Ω–æ–∂–µ—Å—Ç–≤–æ –ø–µ—Ä–µ—É–ø–æ—Ä—è–¥–æ—á–µ–Ω–Ω—ã—Ö –∏–º–µ–Ω —Å—Ç–æ–ª–±—Ü–æ–≤ –≤ –≤–∏–¥–µ —Å–ø–∏—Å–∫–∞ –∏ 
				offset 			 - –∏–Ω–¥–µ–∫—Å (–Ω–æ–º–µ—Ä –∫–æ–ª–æ–Ω–∫–∏ –∫—É–¥–∞ –≤—Å—Ç–∞–≤–ª—è—Ç—å –ø–æ–ª–æ–Ω–∫–∏ –ø–æ —Å–ø–∏—Å–∫—É), –Ω–∞—á–∏–Ω–∞—é—â–∏–π—Å—è —Å –Ω—É–ª—è
			
			–ü—Ä–∏–º–µ—Ä: 
				= F[Table.ReorderSubsetOfColumns](from, {"–°—Ç—Ä–æ–∫–∞", "–ö–æ–¥"}, 0)
			
			–û–¥–Ω–æ–π —Å—Ç—Ä–æ–∫–æ–π:
				func = (tbl, lst, offset) => Table.ReorderColumns(tbl,List.InsertRange(List.Difference(Table.ColumnNames(tbl),lst),offset,lst)),
		*/
		[
			func   = (tbl as table, reorderedColumns as list, offset as number) as table =>
					Table.ReorderColumns(
						tbl,
						List.InsertRange(
							List.Difference(
								Table.ColumnNames(tbl),
								reorderedColumns
							),
							offset,
							reorderedColumns
						)
					),
		
			typ    = type function (tbl as table, reorderedColumns as list, offset as number) as table 
					meta [  Documentation.Name              = "Table.ReorderSubsetOfColumns",
							Documentation.LongDescription   = "–§—É–Ω–∫—Ü–∏—è –ø–æ–ª—É—á–∞–µ—Ç:
								tbl                 - —Ç–∞–±–ª–∏—Ü—É, 
								reorderedColumns    - –ø–æ–¥–º–Ω–æ–∂–µ—Å—Ç–≤–æ –ø–µ—Ä–µ—É–ø–æ—Ä—è–¥–æ—á–µ–Ω–Ω—ã—Ö –∏–º–µ–Ω —Å—Ç–æ–ª–±—Ü–æ–≤ –≤ –≤–∏–¥–µ —Å–ø–∏—Å–∫–∞ –∏ 
								offset              - –∏–Ω–¥–µ–∫—Å (–Ω–æ–º–µ—Ä –∫–æ–ª–æ–Ω–∫–∏ –∫—É–¥–∞ –≤—Å—Ç–∞–≤–ª—è—Ç—å –ø–æ–ª–æ–Ω–∫–∏ –ø–æ —Å–ø–∏—Å–∫—É), –Ω–∞—á–∏–Ω–∞—é—â–∏–π—Å—è —Å –Ω—É–ª—è. 
								–ó–∞—Ç–µ–º –≤—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è –ø–µ—Ä–µ—É–ø–æ—Ä—è–¥–æ—á–µ–Ω–∏–µ –æ—á–µ–Ω—å –Ω–∞–¥–µ–∂–Ω—ã–º —Å–ø–æ—Å–æ–±–æ–º, –±–µ–∑ —Å—Å—ã–ª–æ–∫ –Ω–∞ –∏–º–µ–Ω–∞ –¥—Ä—É–≥–∏—Ö —Å—Ç–æ–ª–±—Ü–æ–≤"
				],
			
			result = Value.ReplaceType(func,typ)
		][result],
// 	FAQ
	Document 	= // —Ñ—É–Ω–∫—Ü–∏—è –¥–æ–∫—É–º–µ–Ω—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –¥—Ä—É–≥–∏—Ö —Ñ—É–Ω–∫—Ü–∏–π
		/*
			–û–ø–∏—Å–∞–Ω–∏–µ
				—Ñ—É–Ω–∫—Ü–∏—è –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –≤ –¥—Ä—É–≥–∏—Ö —Ñ—É–Ω–∫—Ü–∏—è—Ö, –¥–æ–∫—É–º–µ–Ω—Ç–∏—Ä—É—è –∏—Ö

			–ê—Ä–≥—É–º–µ–Ω—Ç—ã:
				name as text					- "List.Items"
				description as text				- "–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–ø–∏—Å–æ–∫ –∑–Ω–∞—á–µ–Ω–∏–π –ø–æ –ø–æ–∑–∏—Ü–∏–∏ —ç–ª–µ–º–µ–Ω—Ç–æ–≤" 
				valueOrExample as any			- "{[Description = "–û–ø–∏—Å–∞–Ω–∏–µ", Code = "= F[List.Items]({1,2,3},{1,3})", Result= "{2,6}" ]},
				optional valueIfExample as any 	- (x)=> x + 1

			–ü—Ä–∏–º–µ—Ä:
				Document(
					"List.ToText",
					"–ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ—Ç —Å–ø–∏—Å–æ–∫ –≤ —Ç–µ–∫—Å—Ç. –û–±—Ä–∞—Ç–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è List.From",
					{[Description = "–ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ—Ç —Ç–µ–∫—Å—Ç –≤ —Å–ø–∏—Å–æ–∫", Code = "List.ToText({1,2,""abc"",1+2})", Result = """{12abc3}"""]},
					(list as list) => List.Accumulate(list, "{", (state, current) => state & Text.From(current)) & "}"
				),

		*/
		( name as text, description as text,  valueOrExample as any, optional valueIfExample as any ) =>
		let 
			value 	 = if valueIfExample is null then valueOrExample else valueIfExample,
			examples = if valueIfExample is null then {} else valueOrExample
		in
			Value.ReplaceType(value, Value.Type(value) 
				meta [	Documentation.Name = name,
						Documentation.Description = description,
						// [Description = "", Code="", Result =""]
						Documentation.Examples = examples
				]
		),
	fxSizeFile  = // –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ —Ä–∞–∑–º–µ—Ä–∞ —Ñ–∞–π–ª–∞
		(sizeInBytes as number) as text =>
			let
				// 	–û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –µ–¥–∏–Ω–∏—Ü –∏–∑–º–µ—Ä–µ–Ω–∏—è –∏ –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç–∞ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏—è
					SizeUnits = {"–ë", "–ö", "–ú", "–ì–±", "–¢–±"},
					Byte	  = 1024.0,
				
		        //  –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –∏–Ω–¥–µ–∫—Å–∞ –µ–¥–∏–Ω–∏—Ü—ã –∏–∑–º–µ—Ä–µ–Ω–∏—è –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Ä–∞–∑–º–µ—Ä–∞ —Ñ–∞–π–ª–∞ (Number.Power - —Å—Ç–µ–ø–µ–Ω—å)
			        /*  –∞–Ω–∞–ª–æ–≥ –µ—Å–ª–∏
						Index1 = List.NonNullCount(
								List.Transform(
									{0..4}, 
									(i) => if sizeInBytes >= Number.Power(Byte, i) then i else null)
								) - 1,
					*/
					Index = 
						if      sizeInBytes < Byte   				then 0 
						else if sizeInBytes < Number.Power(Byte, 2) then 1	//! 1 –µ—Å–ª–∏ –ö–± —á—Ç–æ–±—ã –±—ã–ª–∏ 
						else if sizeInBytes < Number.Power(Byte, 3) then 2 
						else if sizeInBytes < Number.Power(Byte, 4) then 3 
						else 4,
				
        		// 	–í—ã—á–∏—Å–ª–µ–Ω–∏–µ –∑–Ω–∞—á–µ–Ω–∏—è —Ä–∞–∑–º–µ—Ä–∞ –≤ –≤—ã–±—Ä–∞–Ω–Ω–æ–π –µ–¥–∏–Ω–∏—Ü–µ –∏–∑–º–µ—Ä–µ–Ω–∏—è
					SizeValue = sizeInBytes / Number.Power(Byte, Index),
				
        		// 	–§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –∑–Ω–∞—á–µ–Ω–∏—è —Ä–∞–∑–º–µ—Ä–∞ —Å –æ–¥–Ω–æ–π –¥–µ—Å—è—Ç–∏—á–Ω–æ–π —Ü–∏—Ñ—Ä–æ–π
					FormattedSize = 
						Text.From(
							if   Index = 1 
								then Number.RoundDown(SizeValue, 0) // –¥–ª—è –ö–± –∏—Å–ø–æ–ª—å–∑—É–µ–º —Ü–µ–ª–æ–µ —á–∏—Å–ª–æ
								else Number.Round(SizeValue, 1)		// –¥–ª—è –æ—Å—Ç–∞–ª—å–Ω–æ–≥–æ –æ–∫—Ä—É–≥–ª—è–µ–º –¥–æ –æ–¥–Ω–æ–π –¥–µ—Å—è—Ç–∏—á–Ω–æ–π —Ü–∏—Ñ—Ä—ã
							// ,"en-EN"								// –µ—Å–ª–∏ –≤–º–µ—Å—Ç–æ –∑–∞–ø—è—Ç–æ–π —Ç–æ—á–∫—É –Ω–∞–¥–æ –∫–∞–∫ —Ä–∞–∑–¥–µ–ª–∏—Ç–µ–ª—å
							) 
							& " " 
							& SizeUnits{Index}
							// & " / " & Text.From(sizeInBytes) & " / " & Text.From(Index)
			in
				FormattedSize,

	fxFAQ 		= // —Å–ø—Ä–∞–≤–∫–∞ –ø–æ —Ñ—É–Ω–∫—Ü–∏—è–º. –ù–∞–ø—Ä–∏–º–µ—Ä to = fxFAQ("list") 

		/*
			–û–ø–∏—Å–∞–Ω–∏–µ	—Å–ø—Ä–∞–≤–∫–∞ –ø–æ —Ñ—É–Ω–∫—Ü–∏—è–º —è–∑—ã–∫–∞ M
			–ü—Ä–∏–º–µ—Ä—ã 	= F[fxFAQ]("list") 
						= [ text   = F[fxFAQ]("text"), 
							list   = F[fxFAQ]("list"), 
							table  = F[fxFAQ]("table"), 
							record = F[fxFAQ]("record")]
			Link		–ø–æ –æ—Å–Ω–æ–≤–∞–º PQ –ù–∞–∑–∞—Ä–æ–≤ - https://www.youtube.com/watch?v=cPT2jLrGOXE
		*/
			[func = (txt as text) =>
                let	list_1      = Record.ToTable(#shared), 
                    rows_select = Table.SelectRows( list_1, each Text.Contains(Text.Lower([Name]), txt) and Text.Contains([Name], ".") ), 
                    tab_add_col = Table.AddColumn( rows_select, "Meta", each Value.Metadata(Value.Type([Value])) ), 
                    cols_select = Table.SelectColumns(tab_add_col, {"Meta"}), 
                    col_colu_1 = 
                        Table.ExpandRecordColumn( cols_select, "Meta", 
                            {
                                "Documentation.Name", 
                                "Documentation.Description", 
                                "Documentation.LongDescription", 
                                "Documentation.Examples"
                            }, 
                            {"Name", "Description", "LongDescription", "Examples"}
                        ), 
                    col_expand_2 = 
						Table.ExpandListColumn(
							col_colu_1, 
							"Examples"
						), 
                    
                    col_expand_3 = 
                        Table.ExpandRecordColumn(
                            col_expand_2, 
                            "Examples", 
                            {"Description", "Code", "Result"}, 
                            {"Example Description", "Example Code", " Example Result"}
                        ),
                    Sort    = Table.Sort(col_expand_3,{{"Name", Order.Ascending}}),
                    Filtr   = Table.SelectRows(Sort, each ([Name] <> null))
                in 
					Filtr,
				
			// 	–≤–æ–∑–≤—Ä–∞—â–∞–µ–º –∑–∞–ø–∏—Å—å
				rec = 
					[ 	text 	= func("text"), 
						list 	= func("list"), 
						table 	= func("table"), 
						record 	= func("record"), 
						date 	= func("date"),
						splitter= func("splitter")
					]
		] [rec],
//  –ü–ê–†–°–ò–ù–ì HTML
	/*  
	    –ü—Ä–∏–º–µ—Ä:
			1. —Å—Å—ã–ª–∫–∏ –Ω–∞ —Ñ–∞–π–ª—ã xls —Å –ø–æ–¥–∞—á–µ–π –¥–æ–∫—É–º–µ–Ω—Ç–æ–≤ –ë–¢–≠–£–ü–ö  
				Source = Text.FromBinary(Web.Contents("http://abiturient.i-bteu.by/priyomnaya-kampaniya/informatsiya-o-hode-priyoma/")),
				HTML   = Table.Distinct(Html.Table(Source,{ {"–°—Å—ã–ª–∫–∞", "a[href*='download']", each [Attributes][href]?} })),
		
			–í—Å—Ç—Ä–æ–µ–Ω–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è Html.Table 
                    function (html as any, columnNameSelectorPairs as list, optional options as nullable record) as table
                    –∞—Ä–≥—É–º–µ–Ω—Ç—ã: {{–ù–∞–∑–≤–∞–Ω–∏–µ–ö–æ–ª–æ–Ω–∫–∏, CSS-—Å–µ–ª–µ–∫—Ç–æ—Ä, –§—É–Ω–∫—Ü–∏—è–ò–∑–≤–ª–µ—á–µ–Ω–∏—è}}
                    
                    –ü—Ä–∏–º–µ—Ä: 
                        Source = Text.FromBinary(Web.Contents("http://abiturient.i-bteu.by/priyomnaya-kampaniya/informatsiya-o-hode-priyoma/")),
                        HTML   = Html.Table(              // –ü–∞—Ä—Å–∏–º HTML –≤ —Ç–∞–±–ª–∏—Ü—É
                            Source,                       // –ò—Å—Ö–æ–¥–Ω—ã–π HTML-–∫–æ–¥
                            { {                           // –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –∫–æ–ª–æ–Ω–æ–∫ —Ç–∞–±–ª–∏—Ü—ã
                                "–°—Å—ã–ª–∫–∞",                 // –∏–º—è –∫–æ–ª–æ–Ω–∫–∏
                                "a[href*='download']",    // CSS-—Å–µ–ª–µ–∫—Ç–æ—Ä: –∏—â–µ–º –≤—Å–µ —Ç–µ–≥–∏ <a> —Å–æ–¥–µ—Ä–∂–∞—â–∏–µ "download" –≤ href [ ]
                                each [Attributes][href]?  // –§—É–Ω–∫—Ü–∏—è –∏–∑–≤–ª–µ—á–µ–Ω–∏—è: –∏–∑–≤–ª–µ–∫–∞–µ–º URL –∏–∑ –∞—Ç—Ä–∏–±—É—Ç–∞ href
                            } },
                            [RowSelector = "a"],          // —É–∫–∞–∑—ã–≤–∞–µ—Ç, —á—Ç–æ —Å—Ç—Ä–æ–∫–∏ —Ç–∞–±–ª–∏—Ü—ã –¥–æ–ª–∂–Ω—ã 
                                                             —Ñ–æ—Ä–º–∏—Ä–æ–≤–∞—Ç—å—Å—è –Ω–∞ –æ—Å–Ω–æ–≤–µ –∫–∞–∂–¥–æ–≥–æ –Ω–∞–π–¥–µ–Ω–Ω–æ–≥–æ —ç–ª–µ–º–µ–Ω—Ç–∞ <a>. 
                                                             –ï—Å–ª–∏ –æ–ø—É—Å—Ç–∏—Ç—å, —Ç–æ —Å—Ç—Ä–æ–∫ —Å null –Ω–µ –±—É–¥–µ—Ç!
                        )
                    */
            // 2. –ü–∞—Ä—Å–∏–Ω–≥ HTML –∏ –∏–∑–≤–ª–µ—á–µ–Ω–∏–µ –≤ —Ç–∞–±–ª–∏—Ü—É —É–Ω–∏–∫–∞–ª—å–Ω—ã—Ö —Å—Å—ã–ª–æ–∫ –Ω–∞ —Å–∫–∞—á–∏–≤–∞–Ω–∏–µ
                // Html.Table()             - –ø–∞—Ä—Å–∏–Ω–≥ HTML –∏ –ø–æ–ª—É—á–µ–Ω–∏–µ —Ç–∞–±–ª–∏—Ü—ã —Å —Å—Å—ã–ª–∫–∞–º–∏
                // "a[href*='download']"    - –Ω–∞—Ö–æ–¥–∏—Ç –≤—Å–µ —Å—Å—ã–ª–∫–∏ <a>, –≥–¥–µ –∞—Ç—Ä–∏–±—É—Ç href —Å–æ–¥–µ—Ä–∂–∏—Ç —Å–ª–æ–≤–æ "download"
                // each [Attributes][href]? - –∏–∑–≤–ª–µ–∫–∞–µ—Ç –∏–∑ Record –∑–Ω–∞—á–µ–Ω–∏–µ –∞—Ç—Ä–∏–±—É—Ç–∞ href –¥–ª—è –∫–∞–∂–¥–æ–π –Ω–∞–π–¥–µ–Ω–Ω–æ–π —Å—Å—ã–ª–∫–∏ 
                // Table.Distinct()         - —É–¥–∞–ª—è–µ—Ç –¥—É–±–ª–∏—Ä—É—é—â–∏–µ—Å—è —Å—Ç—Ä–æ–∫–∏, –æ—Å—Ç–∞–≤–ª—è—è —Ç–æ–ª—å–∫–æ —É–Ω–∏–∫–∞–ª—å–Ω—ã–µ —Å—Å—ã–ª–∫–∏ (–∏—Ö –ø–æ —Ç—Ä–∏ —à—Ç—É–∫–∏)
	
	
	fxGetAllLinks = // —Ñ—É–Ω–∫—Ü–∏—è –∏–∑–≤–ª–µ—á–µ–Ω–∏—è —Å—Å—ã–ª–æ–∫ –∏–∑ –¥–≤–æ–∏—á–Ω–æ–≥–æ —Ñ–∞–π–ª–∞ HTML —Å—Ç—Ä–∞–Ω–∏—Ü—ã. –ú–æ–∂–Ω–æ —á–µ—Ä–µ–∑ Html.Table
		// fxGetAllLinks("www.Bteu.by","""")
		(URL as text, Delimiter as text) =>
			let Source  = Text.FromBinary(Web.Contents(URL)),
				GetLink = (i as number) =>
					let Link = Text.BetweenDelimiters(Source, "href=" & Delimiter, Delimiter, i)
					in  if Link = "" then {} else List.Combine({{Link}, @GetLink(i + 1)})
			in  GetLink(0),
// 	TEXT
	Text.Clear 	= // —É–¥–∞–ª—è–µ–º –∑–∞–¥–∞–Ω–Ω—ã–µ —Å–∏–º–≤–æ–ª—ã –∏–∑ —Ç–µ–∫—Å—Ç–æ–≤–æ–π —Å—Ç—Ä–æ–∫–∏ //!
		/*
			–ü—Ä–∏–º–µ—Ä
				= F[Text.Clear](txt)
			–û–¥–Ω–æ–π —Å—Ç—Ä–æ–∫–æ–π
				Text.Combine(List.RemoveMatchingItems(Text.SplitAny(Text.Clean(x)," #(lf)#(00A0)"),{""} )," ")

		*/
		(txt as text)=>
			let char = " #(lf)#(00A0)#(tab)",
				to 	 = 	Text.Combine( List.RemoveMatchingItems( Text.SplitAny( Text.Clean(txt), char), {""} ), " ")
			in  to,
			
	Text.Clear2 = // —É–¥–∞–ª—è–µ–º –æ–ø—Ä–µ–¥–µ–ª—è–µ–º—ã–µ —Å–∏–º–≤–æ–ª—ã –∏–∑ —Ç–µ–∫—Å—Ç–æ–≤–æ–π —Å—Ç—Ä–æ–∫–∏ 
		/*
			–ü—Ä–∏–º–µ—Ä:	Table.TransformColumns(from, {"tmp", each F[Text.Clear2](_," #(lf)#(00A0)")} )
		*/
		(x, char)=>
			Text.Combine(List.RemoveMatchingItems( Text.SplitAny( Text.Clean(x), char), {""} )," "),

	Text.ReplaceBetweenDelimiters    = // —É–¥–∞–ª—è–µ—Ç —Ç–µ–∫—Å—Ç –º–µ–∂–¥—É —Ä–∞–∑–¥–µ–ª–∏—Ç–µ–ª—è–º–∏ + —Å–∞–º–∏ —Ä–∞–∑–¥–µ–ª–∏—Ç–µ–ª–∏ + –≤—Å–µ –≤—Ö–æ–∂–¥–µ–Ω–∏—è
		/* 
			–ü—Ä–∏–º–µ—Ä:	
				f=(x)=> F[Text.ReplaceBetweenDelimiters](x,"()",")")
			
			–†–µ–∑—É–ª—å—Ç–∞—Ç:
		*/
		[func = 
			(txt as text, StartDelimiter as text, EndDelimiter as text) =>
				[fnRemoveFirstTag = 
					(DELIM as text)=>
						let	OpeningTag = Text.PositionOf(DELIM, StartDelimiter),
							ClosingTag = Text.PositionOf(DELIM, EndDelimiter),
							Output 	   = if OpeningTag = -1 
											then DELIM 
											else Text.RemoveRange(DELIM, OpeningTag, ClosingTag - OpeningTag + 1)
						in Output,
								
				fnRemoveDELIM = 
					(y as text)=>
						if fnRemoveFirstTag(y) = y
						then y 
						else @fnRemoveDELIM(fnRemoveFirstTag(y)),
						
				Output = @fnRemoveDELIM(txt)
			][Output],
			
		typ = type function (txt as text, StartDelimiter as text, EndDelimiter as text) as table 
						meta [ 	Documentation.Name            = "Text.ReplaceBetweenDelimiters",
								Documentation.LongDescription = "–£–¥–∞–ª—è–µ—Ç —Ç–µ–∫—Å—Ç –º–µ–∂–¥—É —Ä–∞–∑–¥–µ–ª–∏—Ç–µ–ª—è–º–∏" ],
					
		res = Value.ReplaceType(func, typ)
		][res],

	Text.ReplaceBetweenDelimitersOne = // —É–¥–∞–ª—è–µ—Ç —Ç–µ–∫—Å—Ç –º–µ–∂–¥—É —Ä–∞–∑–¥–µ–ª–∏—Ç–µ–ª—è–º–∏ + 6 –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ + –æ–¥–Ω–æ –≤—Ö–æ–∂–¥–µ–Ω–∏–µ
		/*

		*/
		let
			fun_ReplaceTextBetweenDelimiters = 
				(   Text as text, 
					StartDelimiter as text, 
					EndDelimiter as text, 
					optional ReplaceDelimiters as nullable logical, 
					optional NewText as nullable text, 
					optional TrimResult as nullable logical, 
					optional FixDoubleSpaces as nullable logical
				) as text => 
				
			let
				// –¥–æ–±–∞–≤–ª—è–µ–º –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
				Default_ReplaceDelimiters   = if ReplaceDelimiters is null then true else ReplaceDelimiters,
				Default_NewText             = if NewText is null then "" else NewText,
				Default_TrimResult          = if TrimResult is null then true else TrimResult,
				Default_FixDoubleSpaces     = if FixDoubleSpaces is null then true else FixDoubleSpaces,
				
				// —Ä–∞–±–æ—Ç–∞–µ–º
				TextBetweenDelimiters       = Text.BetweenDelimiters(Text, StartDelimiter, EndDelimiter),
				TextToReplace               = if Default_ReplaceDelimiters then Text.Combine({StartDelimiter,TextBetweenDelimiters,EndDelimiter}) else TextBetweenDelimiters,
				ReplacedText                = Text.Replace(Text, TextToReplace, Default_NewText),
				
				// –æ—á–∏—â–∞–µ–º
				TrimmedText                 = if Default_TrimResult then Text.Trim(ReplacedText) else ReplacedText,
				FixedSpaces                 = if Default_FixDoubleSpaces then Text.Replace(TrimmedText, "  ", " ") else TrimmedText
			in
				FixedSpaces
		in
			fun_ReplaceTextBetweenDelimiters,

	Text.BetweenDelimitersOccAll     = // –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Ç–µ–∫—Å—Ç –º–µ–∂–¥—É —Ä–∞–∑–¥–µ–ª–∏—Ç–µ–ª—è–º–∏
			/* 	Returns  all occurrances of text strings between a delimiter pair. Optional
				parameter Alternative_Dummy can be used if Dummy shall not be *+*.
			*/
			let
				func = (
					InputText as text,
					StartDelimiter as text,
					EndDelimiter as text,
					optional Alternative_Dummy as text
				) =>
				let
				// If the end delimiter contains the same characters than the start delimiter then that portion has to be replaced in the end parameter by a dummy. Otherwise the query fails.
					AlternativeDummy = Alternative_Dummy,
					Dummy            = if AlternativeDummy is null then "*+*" else AlternativeDummy,
					String           = InputText,
					ParaStart        = StartDelimiter,
					ParaEnd          = EndDelimiter,
				
				// 	If the delimiters are identical, a different logic has to be applied.
					IdenticalDelimiters = ParaEnd = ParaStart,
				
				// Start of logic for identical delimiters
					SplitText = Text.Split(String, ParaStart),
					ResultIdenticalDelimiters = List.Alternate(SplitText, 1, 1),
				
				// Start of logic for different start- and end-delimiters: Create dummy end-delimiter.
					DummyParaEnd     = Text.Replace(ParaEnd, ParaStart, Dummy),
					DummyString      = Text.Replace(String, ParaEnd, DummyParaEnd),
					SplitByParaStart = List.Skip(Text.Split(DummyString, ParaStart), 1),
					ConvertToTable   = Table.FromList(
						SplitByParaStart,
						Splitter.SplitByNothing(),
						null,
						null,
						ExtraValues.Error
					),
					ExtractBeforeParaEnd = Table.AddColumn(
						ConvertToTable,
						"Result",
						each Text.BeforeDelimiter([Column1], DummyParaEnd)
					),
					Cleanup = Table.RemoveColumns(ExtractBeforeParaEnd, {"Column1"})[Result],
					Result = 
						if Text.Contains(String, ParaStart) and Text.Contains(String, ParaEnd) 
						then (if IdenticalDelimiters then ResultIdenticalDelimiters else Cleanup)
						else error Error.Record("At least one of the delimiters is not found in the string")
				in
					Result,
				
				documentation = [
					Documentation.Name = " Text.BetweenDelimitersOccAll ",
					Documentation.Description = " Returns  all occurrances of text strings between a delimiter pair.  ",
					Documentation.LongDescription = " Returns  all occurrances of text strings between a delimiter pair. Optional parameter Alternative_Dummy can be used if Dummy shall not be *+*. ",
					Documentation.Category = " Text ",
					Documentation.Source   = " https://wp.me/p6lgsG-Y5 ",
					Documentation.Version  = " 1.0 ",
					Documentation.Author   = " Imke Feldmann: www.TheBIccountant.com: https://wp.me/p6lgsG-Y5  . ",
					Documentation.Examples = {
						[	Description = " See this blogpost: https://wp.me/p6lgsG-Y5 ",
							Code 		= " TextBetweenDelimitersOccAll(""Meanwhile I prefer *Python!* to *R!*"", ""*"", ""!*"") ",
							Result 		= " {""Python"", ""R""} " ]
					}
				]
			in
				Value.ReplaceType(func, Value.ReplaceMetadata(Value.Type(func), documentation)),

// 	TYPE üìå 
	Type.AllColumnText = // –¥–µ–ª–∞–µ–º –≤—Å–µ —Å—Ç–æ–ª–±—Ü—ã —Ç–µ–∫—Å—Ç–æ–≤—ã–º–∏
		/*
		 	–ü—Ä–∏–º–µ—Ä:	
				F[Type.AllColumnText](Source)
			–û–¥–Ω–æ–π —Å—Ç—Ä–æ–∫–æ–π:
				(tbl as table) => Table.TransformColumnTypes(tbl, List.Transform(Table.ColumnNames(tbl), (x)=>{x, type text}))
		*/
		(tbl as table) => 
			Table.TransformColumnTypes(
				tbl, 
				List.Transform(
					Table.ColumnNames(tbl), 
					(x)=>{x, type text}
				) 
			),
	Table.TypedField   = // #! —Ç–∏–ø–∏–∑–∏—Ä—É–µ—Ç —Å—Ç–æ–ª–±—Ü—ã –ø–æ –∏–º–µ–Ω–∏ –∫–æ–ª–æ–Ω–∫–∏. –•–æ—Ä–æ—à–∞—è —Ñ—É–Ω–∫—Ü–∏—è !
		/*
			= —Å–¥–µ–ª–∞—Ç—å –∞—Ä–≥—É–º–µ–Ω—Ç—ã –∏ —Å–ø–∏—Å–æ–∫ –ø–æ —Ç–∏–ø–∞–º –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–º –ø–µ—Ä–µ–¥–∞–≤–∞—Ç—å
			= F[Table.TypedField](from)
		*/
		(tbl as table)=>
		let
			nms = Table.ColumnNames(tbl),
			lstDate   = {"Date"},
			lstNumber = {"–°—Ç—Ä–æ–∫–∞_ID", "–ó–Ω–∞—á–µ–Ω–∏–µ","–°—É–º–º–∞","Value", "DataSet",
						 "Index",
						 "–ù–∞ –Ω–∞—á–∞–ª–æ","–ù–∞ –∫–æ–Ω–µ—Ü",
						 "–¢–µ–∫—É—â–∏–π –ø–µ—Ä–∏–æ–¥","–ü—Ä–æ—à–ª—ã–π –ø–µ—Ä–∏–æ–¥"},

			dlst = List.Select(nms,(i)=>List.Contains(lstDate,   i, (x,y)=>Text.Contains(y,x))),
			nlst = List.Select(nms,(i)=>List.Contains(lstNumber, i, (x,y)=>Text.Contains(y,x))),
			tlst = List.Difference(nms, dlst & nlst),

			f=(x,y)=>List.Transform(x,(i)=>{i,y}),

			transflst = f(dlst, DateTime.Type) & // –±—ã–ª–æ Date.Type, –Ω–æ –ø–æ–∫–∞ –Ω–µ –æ–±—Ä–∞–±–æ—Ç–∞–ª —Å–∏—Ç—É–∞—Ü–∏—é, –∫–æ–≥–¥–∞ data —Ñ–æ—Ä–º–∞—Ç–∞ 31.12.2017 0:00:00
						f(nlst, Number.Type) & 
						f(tlst, Text.Type),
			
			to = Table.TransformColumnTypes(tbl, transflst)	
		in  
			to,
	
	Type.FromText2 	   = // –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Ç–∏–ø –¥–∞–Ω–Ω—ã—Ö –ø–æ —Ç–µ–∫—Å—Ç–æ–≤–æ–º—É –æ–ø–∏—Å–∞–Ω–∏—é (—Å–æ–∫—Ä–∞—â–µ–Ω–Ω—ã–π –≤–∞—Ä–∏–∞–Ω—Ç)
			(TypeAsText as text) =>
					 if TypeAsText = "Text.Type" 	then type text
				else if TypeAsText = "Int64.Type" 	then type number
				else if TypeAsText = "Number.Type" 	then type number
				else if TypeAsText = "Date.Type" 	then type datetime
				else if TypeAsText = "Logical.Type" then type logical
				else type any,

	Type.FromText  	   = // –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Ç–∏–ø –¥–∞–Ω–Ω—ã—Ö –ø–æ —Ç–µ–∫—Å—Ç–æ–≤–æ–º—É –æ–ø–∏—Å–∞–Ω–∏—é (–ø–æ–ª–Ω—ã–π –≤–∞—Ä–∏–∞–Ω—Ç)
		/*
			Code 	= Type.FromText("type number")
			Result 	= number (as type)
		*/
		let func = (TypeAsText as text) =>
			Record.Field(
				[type null 		= Expression.Evaluate( "type null", 	[ type null = type null] ), 
				type logical 	= Expression.Evaluate( "type logical", 	[ type logical = type logical] ), 
				type decimal 	= Expression.Evaluate( "type number", 	[ type number = type number] ), 
				type time 		= Expression.Evaluate( "type time", 	[ type time = type time] ), 
				type date 		= Expression.Evaluate( "type date", 	[ type date = type date] ), 
				type datetime 	= Expression.Evaluate( "type datetime", [ type datetime = type datetime] ), 
				type datetimezone = Expression.Evaluate( "type datetimezone", [ type datetimezone = type datetimezone] ), 
				type duration 	= Expression.Evaluate( "type duration", [ type duration = type duration] ), 
				type text 		= Expression.Evaluate( "type text", 	[ type text = type text] ), 
				type binary 	= Expression.Evaluate( "type binary", 	[ type binary = type binary] ), 
				type type 		= Expression.Evaluate( "type type", 	[ type type = type type] ), 
				type list 		= Expression.Evaluate( "type list", 	[ type list = type list] ), 
				type record 	= Expression.Evaluate( "type record", 	[ type record = type record] ), 
				type table 		= Expression.Evaluate( "type table", 	[ type table = type table] ), 
				type function 	= Expression.Evaluate( "type function", [ type function = type function] ), 
				type anynonnull = Expression.Evaluate( "type anynonnull", [ type anynonnull = type anynonnull] )],
			TypeAsText) ,
				
				documentation = [
					Documentation.Name =  " Type.FromText ",
					Documentation.Description = " Returns a type from its textual representation. ",
					Documentation.LongDescription = " Returns a type from its textual representation. Only primitive types will be returned",
					Documentation.Category = " Type ",
					Documentation.Source = " www.TheBIccountant.com https://wp.me/p6lgsG-2dd .   ",
					Documentation.Version = " 2.1: Added different number types ",
					Documentation.Author = " Imke Feldmann: www.TheBIccountant.com.  ",
					Documentation.Examples = {
						[	Description =  "  ",
							Code = " Type.FromText(""type number"") ",
							Result = " number (as type) "]}
					]
			in  
				Value.ReplaceType(
					func, 
					Value.ReplaceMetadata(
						Value.Type(func),
						documentation)
				),
// 	REMOVE CHAR/TEXT
	Text.RemoveMulti  = // —É–¥–∞–ª–µ–Ω–∏–µ —Ç–µ–∫—Å—Ç–∞ –∏–∑ —Å–ø–∏—Å–∫–∞ –≤ –∑–∞–¥–∞–Ω–Ω–æ–π –ö–û–õ–û–ù–ö–ï. –ü—Ä–æ–≤–µ—Ä–∏—Ç—å —Å–∫–æ—Ä–æ—Å—Ç—å –î–æ–±–∞–≤–∏—Ç—å —Ç–∏–ø 
			/*  
				–ü—Ä–∏–º–µ—Ä:
					to = F[Text.RemoveMulti](RESULT, "–°—Ç–∞—Ç—å—è", {"–≤—Å–µ–≥–æ", "–ò–∑ —Å—Ç—Ä"} ) 
				–û—Å–æ–±–µ–Ω–Ω–æ—Å—Ç—å
					Text.Remove –Ω–µ –ø–æ–¥—Ö–æ–¥–∏—Ç, —Ç.–∫. —Ä–∞–±–æ—Ç–∞–µ—Ç —Å –æ–¥–µ–ª—å–Ω—ã–º–∏ —Å–∏–º–≤–æ–ª–∞–º–∏, –∞ –Ω–µ –ø–æ–¥—Å—Ç—Ä–æ–∫–∞–º–∏			
				–£–ª—É—á—à–µ–Ω–∏–µ
					lst = lst1 & lst2 & lst3, // List.Buffer —Ç—É—Ç –Ω–µ –Ω—É–∂–µ–Ω
					f = (x)=> List.Accumulate(lst, x, (state, remove) => Text.Replace(state, remove, "")), //!
					tr = Table.TransformColumns(typed, {"–ó–Ω–∞—á–µ–Ω–∏–µ", f})
			*/
			(tbl as table, ColumnName as text, RemoveList as list) as table=> 
				[	lst  = RemoveList,
					dict = List.Buffer(List.Zip({lst, List.Repeat({""}, List.Count(lst)) }) ),
					func = (txt)=>List.Accumulate(dict, txt, (state,remove)=>Text.Replace(state, remove{0}, remove{1})),
					tr   = Table.TransformColumns(tbl, {ColumnName, func})
				]  [tr],
	
// 	REPLACE + –¥–æ–¥–µ–ª–∞—Ç—å –¥–ª—è —á–∏—Å–µ–ª: —á–µ—Ä–µ–∑ –∞–∫—É–º—É–ª—è—Ç–æ—Ä –∏–ª–∏ —Å–ª–æ–≤–∞—Ä—å
	//? –∑–∞–º–µ–Ω–∞ –≤ —Ç–∞–±–ª–∏—Ü–µ —è—á–µ–π–∫—É —Ü–µ–ª–∏–∫–æ–º
	fxRaplaceMulti = 1,// –∑–∞–º–µ–Ω–∞ —Å–ø–∏—Å–∫–æ–º –≤ –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö –∫–æ–ª–æ–Ω–∫–∞—Ö - —Å–∞–º—ã–π –ø—Ä–æ—Å—Ç–æ–π –≤–∞—Ä–∏–∞–Ω—Ç –≤ –≤–∏–¥–µ –æ–±—ã—á–Ω–æ–π —Ñ—É–Ω–∫—Ü–∏–∏ List.Accumulate
		// List.Accumulate(
		// 	{"-", "0", "–§–∏–æ–Ω–∞"}, // –µ—Å–ª–∏ –Ω–µ—Å–∫–æ–ª—å–∫–æ —Å–ø–∏—Å–∫–æ–≤ —Ç–æ   List.Combine({page, {"-", "–§–∏–æ–Ω–∞"}}), 
		// 	from, 
		// 	(state, currentValue) => Table.ReplaceValue(state, currentValue, null, Replacer.ReplaceValue, Table.ColumnNames(from))
		// ),
		
	fxReplaceValues   = // üìå –º–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω–∞—è –∑–∞–º–µ–Ω–∞ –≤ –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö —Å—Ç–æ–ª–±—Ü–∞—Ö (Gorilla) —á–µ—Ä–µ–∑ List.Accumulate - –º–µ–¥–ª–µ–Ω–Ω–µ–µ
		/* ----------------------- –ü—Ä–∏–º–µ—Ä -----------------------------------
			Source —ç—Ç–æ –≤–∞—à–∞ –∏—Å—Ö–æ–¥–Ω–∞—è —Ç–∞–±–ª–∏—Ü–∞ –¥–∞–Ω–Ω—ã—Ö.
			–≠—Ç–æ—Ç —à–∞–≥ ReplaceValues –≤—ã–∑—ã–≤–∞–µ—Ç fxReplaceValues, –ø–µ—Ä–µ–¥–∞–≤–∞—è:
				1 –ò—Å—Ö–æ–¥–Ω–∞—è —Ç–∞–±–ª–∏—Ü–∞ (Source).
				2 –°–ø–∏—Å–æ–∫ –ø–∞—Ä –∑–∞–º–µ–Ω—ã, –Ω–∞–ø—Ä–∏–º–µ—Ä, {" (GDR)", ""} –∑–∞–º–µ–Ω–∏—Ç—å ‚Äù(GDR)‚Äù –ø—É—Å—Ç–æ–π —Å—Ç—Ä–æ–∫–æ–π.
				3 –°–ø–∏—Å–æ–∫, –æ–ø—Ä–µ–¥–µ–ª—è—é—â–∏–π —Å—Ç–æ–ª–±—Ü—ã, –∫ –∫–æ—Ç–æ—Ä—ã–º —Å–ª–µ–¥—É–µ—Ç –ø—Ä–∏–º–µ–Ω–∏—Ç—å —ç—Ç–∏ –∑–∞–º–µ–Ω—ã (–≤ –¥–∞–Ω–Ω–æ–º —Å–ª—É—á–∞–µ, {"country_txt"}).

				–í–∞—Ä–∏–∞–Ω—Ç 1. –°–∞–º—ã–π –ø—Ä–æ—Å—Ç–æ–π
				to = 
					let dict = #table({"—á—Ç–æ", "–Ω–∞—á—Ç–æ"}, {{"–∞","–ê"}, {"—è","–Ø"}}),
					in fxReplaceValues(from, List.Transform(Table.ToRows(dict),(x)=>{x{0},x{1}}), Table.ColumnNames(from))
				 
				
				–ï—Å–ª–∏ –Ω–∞ –≤—Ö–æ–¥–µ —Å–ª–æ–≤–∞—Ä—å –∑–∞–º–µ–Ω –≤ –≤–∏–¥–µ —Ç–∞–±–ª–∏—Ü—ã, —Ç–æ –ø–µ—Ä–µ–¥–∞—Ç—å –≤ dict —á–µ—Ä–µ–∑ Table.ToRows()
                    = fxReplaceValues(Select, Table.ToRows(dict), {"–û–±–ª–∞—Å—Ç—å"})

                –ï—Å–ª–∏ –∫–æ–ª–æ–Ω–æ–∫ –Ω–µ—Å–∫–æ–ª—å–∫–æ –≤ —Å–ª–æ–≤–∞—Ä–µ, —Ç–æ –≤—ã–±–∏—Ä–∞–µ–º –Ω–æ–º–µ—Ä –∫–æ–ª–æ–Ω–æ–∫ –¥–ª—è —Ä–∞–±–æ—Ç—ã
					= fxReplaceValues(
						Select, 
						List.Transform(Table.ToRows(dict), (x)=>{x{0},x{2}}), // –∏–∑ –∫–æ–ª–æ–Ω–∫–∏ 1 –º–µ–Ω—è–µ–º –Ω–∞ 3
						{"–û–±–ª–∞—Å—Ç—å"}
					)

			–ò—Å—Ç–æ—á–Ω–∏–∫ https://gorilla.bi/power-query/replace-multiple-substrings/
			Source = MyData,
			ReplaceValues = 
				fxReplaceValues( 
					Source, 
					{ 
						{" (GDR)",""},
						{ " (FRG)","" }, 
						{ "People's Republic of the Congo","Congo" }, 
						{ "Republic of the Congo","Congo" }, 
						{ "-"," " } 
					}, 
					{"country_txt"}   
				)
		in
			ReplaceValues 
		*/
		// --------------------Function Definition ------------------------------
		( Table as table, listOfReplacements as list, listOfColumns as list ) =>
			let
				myFunction =
					List.Accumulate (
						listOfReplacements, 
						Table, 
						( state, current ) =>
							Table.ReplaceValue ( 
								state, 
								current{0}, 
								current{1}, 
								Replacer.ReplaceText, 
								listOfColumns
							)
					)
			in
				myFunction,
	
  	fxReplaceValues2  = // –º–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω–∞—è –∑–∞–º–µ–Ω–∞ –≤ –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö —Å—Ç–æ–ª–±—Ü–∞—Ö (Gorilla) —á–µ—Ä–µ–∑ List.Generate - –±—ã—Å—Ç—Ä–µ–µ
		/*
			–ù–∞—á–∏–Ω–∞–µ—Ç—Å—è 		—Å –Ω–∞—á–∞–ª—å–Ω–æ–≥–æ —Å–æ—Å—Ç–æ—è–Ω–∏—è: [ myTable = Table, Index = 0, Replacements = listOfReplacements ].
			–ü–æ–≤—Ç–æ—Ä—è–µ—Ç—Å—è		–¥–æ —Ç–µ—Ö –ø–æ—Ä, –ø–æ–∫–∞ [Index] —á–∏—Å–ª–æ –ø–æ–¥—Å—Ç—Ä–æ–∫ –º–µ–Ω—å—à–µ [Replacements].
			–ü—Ä–∏–º–µ–Ω—è–µ—Ç 		–∫–∞–∂–¥—É—é –∑–∞–º–µ–Ω—É —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º Table.ReplaceValue –¥–ª—è —Ç–µ–∫—É—â–µ–≥–æ –∑–Ω–∞—á–µ–Ω–∏—è –∏–Ω–¥–µ–∫—Å–∞, –∑–∞—Ç–µ–º –æ–±–Ω–æ–≤–ª—è–µ—Ç —Å–æ—Å—Ç–æ—è–Ω–∏–µ –ø—É—Ç–µ–º —É–≤–µ–ª–∏—á–µ–Ω–∏—è Index.
			–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç		–∏—Ç–æ–≥–æ–≤—É—é —Ç–∞–±–ª–∏—Ü—É –ø–æ—Å–ª–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –≤—Å–µ—Ö –∑–∞–º–µ–Ω, –∏—Å–ø–æ–ª—å–∑—É—è List.Last(myFunction).
			
			–≠—Ç–∞ —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ –ø–æ–∑–≤–æ–ª—è–µ—Ç List.Generate –≤—ã–ø–æ–ª–Ω—è—Ç—å –∑–∞–º–µ–Ω—ã –¥–æ —Ç–µ—Ö –ø–æ—Ä, –ø–æ–∫–∞ –≤—Å–µ —É–∫–∞–∑–∞–Ω–Ω—ã–µ –∑–∞–º–µ–Ω—ã –Ω–µ –±—É–¥—É—Ç –ø—Ä–∏–º–µ–Ω–µ–Ω—ã –∫ –Ω—É–∂–Ω—ã–º —Å—Ç–æ–ª–±—Ü–∞–º.
		*/
		( Table as table, listOfReplacements as list, listOfColumns as list ) =>
			let
				myFunction =
					List.Generate( 
						() => 
							[ 
								myTable = Table, 
								Index = 0, 
								Replacements = listOfReplacements 
							],
						each [Index] <= List.Count( [Replacements] ), 
						each 
							[ 
								myTable = 
									Table.ReplaceValue( 
									[myTable], 
									Replacements{ [Index] }{0},
									Replacements{ [Index] }{1},
									Replacer.ReplaceText, 
									listOfColumns
									), 
								Index = [Index] + 1,
								Replacements = [Replacements]
							],
						each [myTable]
					),
					Result = List.Last( myFunction )
			in
				Result,
	
	Text.MultiReplace = // –º–µ–Ω—è–µ—Ç –ø–æ —Å–ª–æ–≤–∞—Ä—é as record –∑–Ω–∞—á–µ–Ω–∏—è –≤ –æ–¥–Ω–æ–π –∫–æ–ª–æ–Ω–∫–µ –ø–æ –∑–Ω–∞—á–µ–Ω–∏—é –¥—Ä—É–≥–æ–π –∫–æ–ª–æ–Ω–∫–∏ 
		/*
			–ü—Ä–∏–º–µ—Ä:
				MultiReplace =
					F[Text.MultiReplace](MultiReplace1, "–°—Ç—Ä–æ–∫–∞_ID", "–°—Ç–∞—Ç—å—è", 
						[	10 = "–û—Å—Ç–∞—Ç–æ–∫ –Ω–∞ –Ω–∞—á–∞–ª–æ",
							40 = "–°–∫–æ—Ä—Ä–µ–∫—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –æ—Å—Ç–∞—Ç–æ–∫",
							200 = "–û—Å—Ç–∞—Ç–æ–∫ –Ω–∞ –∫–æ–Ω–µ—Ü"	]
					),

			–ë—ã–ª–æ —Ç–∞–∫: —Ä–∞–±–æ—á–∏–π –≤–∞—Ä–∏–∞–Ω—Ç
				MultiReplace3 =
					Table.ReplaceValue(MultiReplace1,
						(x)=>x[–°—Ç–∞—Ç—å—è], // –≤ –∫–∞–∫–æ–º —Å—Ç–æ–ª–±—Ü–µ –º–µ–Ω—è—Ç—å. –ò –≤ –∫–æ–Ω—Ü–µ. –ê –µ—Å–ª–∏ –Ω–µ—Å–∫–æ–ª—å–∫–æ —Ç—É—Ç –Ω–∞–¥–æ?!
						each Record.Field([
								10 = "–û—Å—Ç–∞—Ç–æ–∫ –Ω–∞ –Ω–∞—á–∞–ª–æ+",
								40 = "–°–∫–æ—Ä—Ä–µ–∫—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –æ—Å—Ç–∞—Ç–æ–∫",
								200 = "–û—Å—Ç–∞—Ç–æ–∫ –Ω–∞ –∫–æ–Ω–µ—Ü"
							], Text.From([–°—Ç—Ä–æ–∫–∞_ID])),
						Replacer.ReplaceValue,
						{"–°—Ç–∞—Ç—å—è"}
					)
				1	–µ—Å–ª–∏ –≤ –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö —Å—Ç–æ–ª–±—Ü–∞—Ö - columnToReplace as list –∏ –≤–≤–æ–¥–∏—Ç—å –∫–∞–∫ –ª–∏—Å—Ç —Ç–æ–≥–¥–∞ –Ω–∞–¥–æ –±—É–¥–µ—Ç
		*/ 
		(tbl as table, columnID as text, columnToReplace as text, replacements as record) =>
			Table.ReplaceValue(
				tbl,
				each Record.Field(_, columnToReplace), 
				each Record.Field(replacements, Text.From(Record.Field(_, columnID))),
				Replacer.ReplaceValue,
				{columnToReplace}
			)
		,
	Text.ReplaceFull  = // –≤ —Ç–∞–±–ª–∏—Ü–µ —Ç–∞–±–ª–∏—Ü–∞ –¢–ï–°–¢ –∏–ª–∏ –ß–ò–°–õ–ê –∑–∞–º–µ–Ω—è–µ—Ç —è—á–µ–π–∫—É —Ü–µ–ª–∏–∫–æ–º –Ω–∞ –æ—Å–Ω–æ–≤–∞–Ω–∏–∏ —Å–ª–æ–≤–∞—Ä—è –∑–∞–º–µ–Ω. Table.ToRows –∏–ª–∏ Table.ToList
		/*
			–ü—Ä–∏–º–µ—Ä:	
				transform = let
					f=(txt)=> // –∑–Ω–∞—á–µ–Ω–∏—è –∫–æ–ª–æ–Ω–∫–∏ 1 —Å–ª–æ–≤–∞—Ä—è, –∑–∞–º–µ–Ω—è—é –Ω–∞ –∫–æ–ª–æ–Ω–∫—É 0
						let dict = Table.ToRows(F_Form[spr.REPORT][–°–ø—Ä_–§–æ—Ä–º—ã–û—Ç—á–µ—Ç–Ω–æ—Å—Ç–∏]), // —Å–ø–∏—Å–æ–∫ —Å–ø–∏—Å–∫–æ–≤
							to   = List.First(List.Select(dict, (col)=>col{1}=txt)){0}
						in 	to,
					to = Table.TransformColumns(addColumns, {"form_ID", f, type text})
				in  to,
				1	—Å–¥–µ–ª–∞—Ç—å –Ω–æ–º–µ—Ä–∞ –∫–æ–ª–æ–Ω–æ–∫ –∞—Ä–≥—É–º–µ–Ω—Ç–∞–º–∏
		*/
			(tbl as table, input) =>
				List.First(
					List.Select(
						Table.ToRows(tbl), 	// –ø–µ—Ä–µ–≤–æ–¥–∏–º –≤ —Å–ø–∏—Å–æ–∫ —Å–ø–∏—Å–∫–æ–≤ —Ç–∞–±–ª–∏—Ü—É, —Ç.–µ. –∫–æ–ª–æ–Ω–∫–∏ —Å—Ç–∞–Ω—É—Ç —Å—Ç—Ä–æ–∫–∞–º–∏ —Å –Ω–æ–º–µ—Ä–∞–º–∏
						each _{0}=input)	// –ø–µ—Ä–≤–∞—è —Å—Ç—Ä–æ–∫–∞ –∫–∞–∂–¥–æ–≥–æ —Å–ø–∏—Å–∫–∞ - —ç—Ç–æ –∫–æ–ª–æ–Ω–∫–∞ 1 —Ç–∞–±–ª–∏—Ü—ã
				){1},						// –≤—Ç–æ—Ä–∞—è —Å—Ç—Ä–æ–∫–∞ —Ç–∞–±–ª–∏—Ü—ã –∑–∞–º–µ–Ω - –Ω–∞ —á—Ç–æ –º–µ–Ω—è—Ç—å. –ï—Å–ª–∏ –∏–∑ –∫–æ–ª–æ–Ω–∫–∏ 3 –Ω–∞–¥–æ –≤–∑—è—Ç—å, —Ç–æ 2 –∏ —Ç.–¥.
		
	Text.ReplaceMulti = // –∑–∞–º–µ–Ω–∞ —Ç–µ–∫—Å—Ç–∞ –í –ö–û–õ–û–ù–ö–ï —á–µ—Ä–µ–∑ —Å–ª–æ–≤–∞—Ä—å. –û–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ —Å–¥–≤–∏–≥ –¥–æ–¥–µ–ª–∞—Ç—å (—á–µ—Ä–µ–∑ List.Accumulate)
			/*
				–û–ø–∏—Å–∞–Ω–∏–µ:
					1	–º–µ–Ω—è–µ–º —Ç–µ–∫—Å—Ç –≤ —Å—Ç–æ–ª–±—Ü–µ 1 –Ω–∞ —Ç–µ–∫—Å—Ç –≤ —Å—Ç–æ–ª–±—Ü–µ 2
					2	–∏—â–µ–º —á–∞—Å—Ç—å —Å—Ç—Ä–æ–∫–∏, –Ω–µ –ø–æ–ª–Ω–æ—Å—Ç—å—é –∑–Ω–∞—á–µ–Ω–∏–µ
				
				–ü—Ä–∏–º–µ—Ä:
					= F[Text.ReplaceMulti](tbl, "–°—Ç–∞—Ç—å—è", {{"(","["}, {")","]"}} )
					= F[Text.ReplaceMulti](tbl, "–°—Ç–∞—Ç—å—è", {{"a","–±"}, {"–ê","–ë"}} )
				
				–£–ª—É—á—à–µ–Ω–∏–µ:
					1	–∏–∑–º–µ–Ω–µ–Ω–∏–µ –≤ –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö –∫–æ–ª–æ–Ω–∫–∞—Ö
						to = Table.TransformColumns(from, List.Transform({"Column1","Column2"}, each {_,f}) )
						–∞—Ä–≥—É–º–µ–Ω—Ç –Ω–∞–¥–æ –≤–≤–æ–¥–∏—Ç—å –≤ {} —Ç–æ–≥–¥–∞

			*/
			(tbl as table, ColumnName as text, dictionary as list) as table=> 
				[ 	dict = List.Buffer(dictionary),
					func = (txt)=> List.Accumulate(dict, txt, (s,x)=>Text.Replace(s,x{0},x{1})), // —Å—Ç–æ–ª–±–µ—Ü 1 –º–µ–Ω—è–µ–º –Ω–∞ —Å—Ç–æ–ª–±–µ—Ü 2
					to   = Table.TransformColumns(tbl, {ColumnName, func})
				][to],
	//? –∑–∞–º–µ–Ω–∞ –≤ —Ç–µ–∫—Å—Ç–æ–≤–æ–π –ø–æ–¥—Å—Ç—Ä–æ–∫–µ 
	Text.ReplaceAll_  = // —á–µ—Ä–µ–∑ List.Accumulate. –ë–µ–∑ –ª–∏—à–Ω–µ–≥–æ, —Ç–æ–ª—å–∫–æ —Ç–µ–∫—Å—Ç –Ω–∞ –≤—Ö–æ–¥–µ –∏ —Å–ø–∏—Å–æ–∫ —Å–ø–∏—Å–∫–æ–≤, —á—Ç–æ-–Ω–∞—á—Ç–æ
		/*
			Do multiple text replacements in one function call, passing the replacements as a list of lists
			Usage:
				Text.ReplaceAll = Load("Text.ReplaceAll"),
				Text.ReplaceAll("(test)", {
					{"(", "["},
					{")", "]"}
				})
			Result: "[test]"
			*/
		(str as text, Replacements as list) as text => 
			List.Accumulate(Replacements, str, (s, x) => Text.Replace(s, x{0}, x{1})),
		
	Text.ReplaceList  = // —á–µ—Ä–µ–∑ —Ä–µ–∫—É—Ä—Å–∏—é. –ó–∞–º–µ–Ω—è–µ—Ç —Å–∏–º–≤–æ–ª—ã –ø–æ —Å–ø–∏—Å–∫—É. –ü—Ä–æ–≤–µ—Ä–∏—Ç—å —Å–∫–æ—Ä–æ—Å—Ç—å
			/*  –§—É–Ω–∫—Ü–∏—è : fxTextReplaceList    –û—Ç–ª–∏—á–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è!!!
				–û–ø–∏—Å–∞–Ω–∏–µ: –ó–∞–º–µ–Ω—è–µ—Ç –≤ –ª—é–±–æ–º –º–µ—Å—Ç–µ —Ç–µ–∫—Å—Ç–µ —Å–∏–º–≤–æ–ª—ã –ø–æ —Å–ø–∏—Å–∫—É, —á—Ç–æ –Ω–∞ —á—Ç–æ
				–ü—Ä–∏–º–µ—Ä:  
					1. 	–ï—Å–ª–∏ —Ñ—É–Ω–∫—Ü–∏—è –æ–±—ä—è–≤–ª–µ–Ω–∞ –≤ —Ç–µ–ª–µ –∑–∞–ø—Ä–æ—Å–∞ Text.ReplaceList = (InputText as text, ...) =>
						to = Text.ReplaceList("–º–∞–º–∞ –º—ã–ª–∞ —Ä–∞–º—É", {"–º–∞–º–∞","–º—ã–ª–∞"}, {"–ø–∞–ø–∞","—á–∏—Å—Ç–∏–ª"}), 
					
					2.	–ï—Å–ª–∏ –æ—Ç–¥–µ–ª—å–Ω–æ–π —Ñ—É–Ω–∫—Ü–∏–µ–π (—Ç—É—Ç –∏—Å—Ç–æ—á–Ω–∏–∫–æ–º –¥—Ä—É–≥–æ–π –∑–∞–ø—Ä–æ—Å - –≤ –≤–∏–¥–µ —Ç–µ–∫—Å—Ç–∞ HTML –∫–æ–¥ —Å—Ç—Ä–∞–Ω–∏—Ü—ã - –Ω–µ —Å–ø–∏—Å–æ–∫ –∏ –Ω–µ —Ç–∞–±–ª–∏—Ü–∞!)
						to = Text.ReplaceList(#"HTML-–∫–æ–¥_All", {"scripts","<",">"}, {"","(",")"}, null)
						to = Text.ReplaceList("–º–∞–º–∞ –º—ã–ª–∞ —Ä–∞–º—É",{"–º–∞–º–∞","–º—ã–ª–∞","—Ä–∞–º—É"},{"–ø–∞–ø–∞","—á–∏—Å—Ç–∏–ª","–∫–∞—Ä—Ç–æ—à–∫—É"}, 1)
					
					3. 	–ï—Å–ª–∏ –∑–∞–º–µ–Ω–∏—Ç—å –Ω–∞–¥–æ –≤ –∫–æ–ª–æ–Ω–∫–µ, —Ç–æ —á–µ—Ä–µ–∑ Table.TransformColumns
						f=(x)=> Text.ReplaceList(x,
								{"–ê","–ë","–í"},
								{"1","2","3"}),
						tr = Table.TransformColumns(Transform3,{"–ò–º—è–ö–û–ª–æ–Ω–∫–∏", f})
				
				OldList –∏  NewList –ª—É—á—à–µ —Å–¥–µ–ª–∞—Ç—å —Ç–∞–±–ª–∏—Ü–µ–π –∑–∞–º–µ–Ω –∏–ª–∏ —Å–ª–æ–≤–∞—Ä–µ–º –∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∫–∞–∫ Data[–ß—Ç–æ] –∏ Data[–ù–∞–ß—Ç–æ] */
			[ func = (
				InputText as text,	// —Ç–µ–∫—Å—Ç, –≤ –∫–æ—Ç–æ—Ä–æ–º –Ω—É–∂–Ω–æ –º–µ–Ω—è—Ç—å
				OldList   as list, 	// —Å–ø–∏—Å–æ–∫ —Å–∏–º–≤–æ–ª–æ–≤ —á—Ç–æ –º–µ–Ω—è—Ç—å    	{...} = > {"–∫–æ—Ç","+","1"}    / Data[Column1]{1} / {Source} / Data[Column1]
				NewList   as list,	// —Å–ø–∏—Å–æ–∫ —Å–∏–º–≤–æ–ª–æ–≤ –Ω–∞ —á—Ç–æ –º–µ–Ω—è—Ç—å	{...} = > {"—Å–æ–±–∞–∫–∞","-","2"}
				optional Index as nullable number	// —Å –∫–∞–∫–æ–≥–æ –≤—Ö–æ–∂–¥–µ–Ω–∏—è –Ω–∞—á–∏–Ω–∞—Ç—å
			  ) => 
			
				let	ActualRow = if Index = null then 0 else Index,
					Result    = Text.Replace(InputText, OldList{ActualRow}, NewList{ActualRow}),
					NextRow   = ActualRow + 1,
					Output    = if   NextRow > (List.Count(OldList) - 1) 
								then Result          
								else @Text.ReplaceList(Result, OldList, NewList, NextRow)
				in 	Output,

			typ = type function (InputText as text, OldList as list, NewList as list, optional Index as nullable number) as table 
					meta [ 	Documentation.Name            = "fxTextReplaceList",
							Documentation.LongDescription = "–ó–∞–º–µ–Ω—è–µ—Ç –≤ –ª—é–±–æ–º –º–µ—Å—Ç–µ —Ç–µ–∫—Å—Ç–µ —Å–∏–º–≤–æ–ª—ã –ø–æ —Å–ø–∏—Å–∫—É, —á—Ç–æ –Ω–∞ —á—Ç–æ <br>
									–ü—Ä–∏–º–µ—Ä: <br> 
									1. 	–ï—Å–ª–∏ —Ñ—É–Ω–∫—Ü–∏—è –æ–±—ä—è–≤–ª–µ–Ω–∞ –≤ —Ç–µ–ª–µ –∑–∞–ø—Ä–æ—Å–∞ Text.ReplaceList = (InputText as text, ...) => <br>
										<i> to = Text.ReplaceList(""–º–∞–º–∞ –º—ã–ª–∞ —Ä–∞–º—É"",{""–º–∞–º–∞"",""–º—ã–ª–∞""},{""–ø–∞–ø–∞"",""—á–∏—Å—Ç–∏–ª""}), </i><br>
									
									2. 	–ï—Å–ª–∏ –æ—Ç–¥–µ–ª—å–Ω–æ–π —Ñ—É–Ω–∫—Ü–∏–µ–π (—Ç—É—Ç –∏—Å—Ç–æ—á–Ω–∏–∫–æ–º –¥—Ä—É–≥–æ–π –∑–∞–ø—Ä–æ—Å - –≤ –≤–∏–¥–µ —Ç–µ–∫—Å—Ç–∞ HTML –∫–æ–¥ —Å—Ç—Ä–∞–Ω–∏—Ü—ã - –Ω–µ —Å–ø–∏—Å–æ–∫ –∏ –Ω–µ —Ç–∞–±–ª–∏—Ü–∞!) <br>
										to = fxTextReplaceList(#""HTML-–∫–æ–¥_All"", {""scripts"",""<"","">""}, {"",""("","")""}, null) <br>
										to = fxTextReplaceList(""–º–∞–º–∞ –º—ã–ª–∞ —Ä–∞–º—É"",{""–º–∞–º–∞"",""–º—ã–ª–∞"",""—Ä–∞–º—É""},{""–ø–∞–ø–∞"",""—á–∏—Å—Ç–∏–ª"",""–∫–∞—Ä—Ç–æ—à–∫—É""}, 1) <br>
									
									3. 	–ï—Å–ª–∏ –∑–∞–º–µ–Ω–∏—Ç—å –Ω–∞–¥–æ –≤ –∫–æ–ª–æ–Ω–∫–µ, —Ç–æ —á–µ—Ä–µ–∑ Table.TransformColumns <br>
										f=(x)=> fxTextReplaceList(x, <br>
												{""–ê"",""–ë"",""–í""}, <br>
												{""1"",""2"",""3""}), <br>
										tr = Table.TransformColumns(Transform3,{""–ò–º—è–ö–û–ª–æ–Ω–∫–∏"", f}) <br>
									
									OldList –∏  NewList –ª—É—á—à–µ —Å–¥–µ–ª–∞—Ç—å —Ç–∞–±–ª–∏—Ü–µ–π –∑–∞–º–µ–Ω –∏–ª–∏ —Å–ª–æ–≤–∞—Ä–µ–º –∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∫–∞–∫ Data[–ß—Ç–æ] –∏ Data[–ù–∞–ß—Ç–æ]",
									
							Documentation.Examples = {
								[	Description = 	"–ï—Å–ª–∏ —Ñ—É–Ω–∫—Ü–∏—è –æ–±—ä—è–≤–ª–µ–Ω–∞ –≤ —Ç–µ–ª–µ –∑–∞–ø—Ä–æ—Å–∞ Text.ReplaceList = (InputText as text, ...) =>", 
									Code 		= 	"to = Text.ReplaceList(""–º–∞–º–∞ –º—ã–ª–∞ —Ä–∞–º—É"",{""–º–∞–º–∞"",""–º—ã–ª–∞""},{""–ø–∞–ø–∞"",""—á–∏—Å—Ç–∏–ª""})",
									Result		=	".."
								], 
								[	Description = "–ï—Å–ª–∏ –æ—Ç–¥–µ–ª—å–Ω–æ–π —Ñ—É–Ω–∫—Ü–∏–µ–π (—Ç—É—Ç –∏—Å—Ç–æ—á–Ω–∏–∫–æ–º –¥—Ä—É–≥–æ–π –∑–∞–ø—Ä–æ—Å - –≤ –≤–∏–¥–µ —Ç–µ–∫—Å—Ç–∞ HTML –∫–æ–¥ —Å—Ç—Ä–∞–Ω–∏—Ü—ã - –Ω–µ —Å–ø–∏—Å–æ–∫ –∏ –Ω–µ —Ç–∞–±–ª–∏—Ü–∞!)",
									Code 		= "to = fxTextReplaceList(#""HTML-–∫–æ–¥_All"", {""scripts"",""<"","">""}, {"",""("","")""}, null) <br> 
									               to = fxTextReplaceList(""–º–∞–º–∞ –º—ã–ª–∞ —Ä–∞–º—É"",{""–º–∞–º–∞"",""–º—ã–ª–∞"",""—Ä–∞–º—É""},{""–ø–∞–ø–∞"",""—á–∏—Å—Ç–∏–ª"",""–∫–∞—Ä—Ç–æ—à–∫—É""}, 1)",
									Result		=".."
								]
							}
						],
			
			res = Value.ReplaceType(func,typ)
			][res],

	Table.MultipleReplacementInMultipleColumns = // –º–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω–∞—è –∑–∞–º–µ–Ω–∞ –≤ —Ä–∞–∑–Ω—ã—Ö –∫–æ–ª–æ–Ω–∫–∞—Ö (—á–µ—Ä–µ–∑ —Ä–µ–∫—É—Ä—Å–∏—é) //! –ø—Ä–æ–≤–µ—Ä–∏—Ç—å
			/*
				–ü—Ä–æ–≤–µ—Ä–∏—Ç—å + –ø—Ä–∏–º–µ—Ä—ã —Å–¥–µ–ª–∞—Ç—å

				–§—É–Ω–∫—Ü–∏—è –º–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω–æ–π –∑–∞–º–µ–Ω—ã –≤ —Ä–∞–∑–Ω—ã—Ö –∫–æ–ª–æ–Ω–∫–∞—Ö
					to = F[fMultipleReplacementInMultipleColumns](–°–ø—Ä–∞–≤–æ—á–Ω–∏–∫–ó–∞–º–µ–Ω—ã, –ò—Å—Ç–æ—á–Ω–∏–∫)

				–°–ø—Ä–∞–≤–æ—á–Ω–∏–∫ –∑–∞–º–µ–Ω—ã (—Ç–∞–±–ª–∏—Ü–∞) –≤—ã–≥–ª–∞–¥–∏—Ç —Ç–∞–∫:
					--------------------------------------------
					Search Text 	Replacement Text 	Column
					--------------------------------------------	
					Ivan 			–°–µ—Ä–≥–µ–π 				–ò–º—è
					Tovar 6			–¢–æ–≤–∞—Ä 6 			–¢–æ–≤–∞—Ä
					Homel 			–ì–æ–º–µ–ª—å 				–ì–æ—Ä–æ–¥
					--------------------------------------------
				
				–ò—Å—Ç–æ—á–Ω–∏–∫
					–û–±—ã—á–Ω–∞—è —Ç–∞–±–ª–∏—Ü–∞, –≥–¥–µ –µ—Å—Ç—å —Å—Ç–æ–ª–±—Ü—ã –ò–º—è, –¢–æ–≤–∞—Ä, –ì–æ—Ä–æ–¥ –∏ –¥—Ä—É–≥–∏–µ

				*/

			(aRepTable as table, aSource as table)=>
				let
					fRecursion= (i, Table) => 
						if 		i > Table.RowCount(aRepTable)-1 
						then 	Table 
						else	@fRecursion(i + 1,
									Table.ReplaceValue(Table,
											aRepTable{i}[Search Text],
											aRepTable{i}[Replacement Text],
											Replacer.ReplaceText,
											{aRepTable{i}[Column]}
										)
								),

					Result= fRecursion(0, aSource)
				in
					Result
	
	], // –∫–æ–Ω–µ—Ü –±–∏–±–ª–∏–æ—Ç–µ–∫–∏ MyPack

extLibrary = [
	readme._extensionLibrary = "// extensionLibrary",
	Document = // —Ñ—É–Ω–∫—Ü–∏—è –¥–æ–∫—É–º–µ–Ω—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –¥—Ä—É–≥–∏—Ö —Ñ—É–Ω–∫—Ü–∏–π
		/*
			–ü—Ä–∏–º–µ—Ä:
				Document(
					"List.Items", 
					"–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–ø–∏—Å–æ–∫ –∑–Ω–∞—á–µ–Ω–∏–π –ø–æ –ø–æ–∑–∏—Ü–∏–∏ —ç–ª–µ–º–µ–Ω—Ç–æ–≤",
					{ [ Description = "–û–ø–∏—Å–∞–Ω–∏–µ —Ñ—É–Ω–∫—Ü–∏–∏", Code = "= F[List.Items]({10,20,30},{1,3})", Result= "{11, 30}" ]},
					(x)=> x + 1
				),
		*/
		(name as text, description as text, valueOrExample as any, optional valueIfExample as any) =>
		let
			value    = if valueIfExample is null then valueOrExample else valueIfExample,
			examples = if valueIfExample is null then {} else valueOrExample
		in
			Value.ReplaceType(
				value, 
				Value.Type(value) meta 
					[	Documentation.Name = name, 
						Documentation.Description = description,  
						// [Description = "", Code="", Result =""]
						Documentation.Examples = examples	]
			),
	
	//======================== 
	// Load (–∏—Å–ø–æ–ª—å–∑—É—é—Ç—Å—è —á–∞—Å—Ç–æ Load(), –Ω–∞–¥–æ –ª–∏ –º–µ–Ω—è—Ç—å?!
	//========================
    // FF = 
    //     /*
    //         F (short for function), like Load(), provides one calling interface to access functions either imported (faster) or loaded (fallback), so code could be left agnostic to whether the queries are available locally, though whether this is really necessary is left up to the user to decide. One reasonable use case would be allowing many workbooks to access a shared library of queries from their files without needing to import them to each workbook after every change.

    //         F (—Å–æ–∫—Ä–∞—â–µ–Ω–∏–µ –æ—Ç function), –∫–∞–∫ –∏ Load(), –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª—è–µ—Ç –æ–¥–∏–Ω –≤—ã–∑—ã–≤–∞—é—â–∏–π –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å –¥–ª—è –¥–æ—Å—Ç—É–ø–∞ –∫ —Ñ—É–Ω–∫—Ü–∏—è–º, –∏–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–º (–±—ã—Å—Ç—Ä–µ–µ) –∏–ª–∏ –∑–∞–≥—Ä—É–∂–µ–Ω–Ω—ã–º (—Ä–µ–∑–µ—Ä–≤–Ω—ã–π), –ø–æ—ç—Ç–æ–º—É –∫–æ–¥ –º–æ–∂–µ—Ç –æ—Å—Ç–∞–≤–∞—Ç—å—Å—è –Ω–µ–∑–∞–≤–∏—Å–∏–º—ã–º –æ—Ç —Ç–æ–≥–æ, –¥–æ—Å—Ç—É–ø–Ω—ã –ª–∏ –∑–∞–ø—Ä–æ—Å—ã –ª–æ–∫–∞–ª—å–Ω–æ, —Ö–æ—Ç—è –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ –ª–∏ —ç—Ç–æ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ. –æ—Å—Ç–∞–µ—Ç—Å—è –Ω–∞ —É—Å–º–æ—Ç—Ä–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è. –û–¥–Ω–∏–º –∏–∑ —Ä–∞–∑—É–º–Ω—ã—Ö –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –±—ã–ª–æ –±—ã –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª–µ–Ω–∏–µ –º–Ω–æ–≥–∏–º –∫–Ω–∏–≥–∞–º –¥–æ—Å—Ç—É–ø–∞ –∫ –æ–±—â–µ–π –±–∏–±–ª–∏–æ—Ç–µ–∫–µ –∑–∞–ø—Ä–æ—Å–æ–≤ –∏–∑ —Å–≤–æ–∏—Ö —Ñ–∞–π–ª–æ–≤ –±–µ–∑ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏ –∏–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å –∏—Ö –≤ –∫–∞–∂–¥—É—é –∫–Ω–∏–≥—É –ø–æ—Å–ª–µ –∫–∞–∂–¥–æ–≥–æ –∏–∑–º–µ–Ω–µ–Ω–∏—è.

    //         Imported or loadable functions could be referenced as any of the following:
    //             Load("Text.ReplaceAll")
    //             Load("Text_ReplaceAll")
    //             F[Text.ReplaceAll]
    //             F[Text_ReplaceAll]

    //         Intended benefits of F over Load():
    //             - shorter
    //             - may help avoiding duplicate executions of file imports (if applicable) -- needs further testing though.

    //         Record.Rename = Load("Record.Rename"),
    //         Record.Rename = Record_Rename,

    //             Record.Rename = (Rec as record, Lambda as function) as record =>
    //             let
    //                 Keys     = Record.FieldNames(Rec),
    //                 Values   = Record.FieldValues(Rec),
    //                 Renamed  = List.Transform(Keys, each Lambda(_, Record.Field(Rec, _))),
    //                 Recorded = Record.FromList(Values, Renamed)
    //             in
    //                 Recorded,

    //         cyclic reference...?
    //         SharedPeriods = Record.Rename(Shared, (k,v) => Text.Replace(k, "_", ".")),
    //     */

    //     let
    //         Shared = #shared,

    //         SharedPeriods = Record.FromList(Record.FieldValues(Shared), List.Transform(Record.FieldNames(Shared), each Text.Replace(_, "_", "."))),

    //         SharedMerged = Record.Combine({Shared, SharedPeriods}),
    //         //If I can make a wrapper function to enable profiling/persistence, wrap these as well

    //         Files  = Folder.Files(LoadPath),
    //         MFiles = Table.SelectRows(Files, each Text.Lower([Extension]) = ".m"
    //         // and [Folder Path] = LoadPath    // non-recursive
    //         ),
    //         NoExt           = Table.TransformColumns(MFiles, {"Name", each Text.Start(_, Text.Length(_)-2)}),
    //         CustomNames     = Table.Column(NoExt, "Name"),
    //         Underscored     = List.Transform(CustomNames, each Text.Replace(_, ".", "_")),
    //         CustomBoth      = List.Union({CustomNames, Underscored}),
    //         CustomLoaded    = Record.FromList(List.Transform(CustomBoth, Load), CustomBoth),
    //         SharedAndLoaded = Record.Combine({CustomLoaded, SharedMerged}),

    //         Return = SharedAndLoaded
    //     in
    //         Return,

	LoadPath 	= "", // –Ω–µ–∫–æ—Ç–æ—Ä—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ —Ç—Ä–µ–±—É—é—Ç –Ω–∞–ª–∏—á–∏—è –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π
	Load        = 
        /*
            Usage:
                loads the function Type.ToText from file 'Type.ToText.pq' in the load path
            let
                Type.ToText = Load("Type.ToText")
            in
                Type.ToText(type {number})

            Result: "list"
        */

        (fnName as text, optional BasePath as text) as function =>
        let
            //If you wish to hardcode the path to load the queries from, you can edit the following line:
            DefaultPath = "g:\=EXCEL PQ\PQ-function-load\–í—Å–µ —Ñ—É–Ω–∫—Ü–∏–∏\",
            GitHubPath  = "https://raw.githubusercontent.com/hohlick/pquery/master/",
            
            BasePath = if (BasePath <> null) then BasePath else DefaultPath,
            Path = BasePath & (if Text.End(BasePath, 1) <> "\" then "\" else ""),
            File = Path & fnName & ".pq",
            
            Function = try Expression.Evaluate(Text.Replace(fnName, ".", "_"), #shared)  //if already imported into the workbook just use the existing one
            otherwise try Expression.Evaluate(Text.FromBinary(Binary.Buffer(File.Contents(File))), #shared) //if not imported yet try loading it from the text file in the folder
            otherwise Expression.Evaluate( Text.FromBinary(Binary.Buffer(Web.Contents(GitHubPath & fnName & ".pq"))), #shared) // if folder not found - take from GitHubPath
        in
            Function,

    LoadFunctionFromGithub = 
        /*
            Allows dynamically loading an M function from a text file (extension: .pq) for use in Power Query. 
            This allows you to easily reuse a set of functions in multiple workbooks without having to sync each change to
            all files using it.

            The point here is that by separating universally useful functions from an individual workbook, 
            you will feel encouraged to use more modular code, solving each common sub-problem only once, 
            rather than remaining stuck in 'vanilla' M and resolving the same problems repeatedly.

            Moreover, coding this way will also further facilitate sharing code with other Power Query users, 
            allowing for a more collaborative environment, gradually pushing forward the Power Query community as a whole.

            Nevertheless, if the function in question has already been imported into the workbook, 
            the local copy will be used. This would allow you to either call the function locally right away, 
            or Load() the existing function again.

            Using Load() would not only allow you to use functions in their intended naming conventions 
            (i.e. Text.ReplaceAll rather than with the period replaced by an underscore), but would technically 
            also allow you to add additional wrapper functions around your code, which could be used to enable 
            persistent memoization (using say Redis) or code profiling calls... though presumably no-one has done this so far yet.

            Parameters:
                fnName: name of the text file you wish to load without the .pq extension
                optional BasePath: the file path to look in for the text file; default path hardcoded

            Usage:
                loads the function Type.ToText from file 'Type.ToText.pq' in the load path
            let
                Type.ToText = Load("Type.ToText")
            in
                Type.ToText(type {number})

            Result: "list"

            Warning: this function may triggers a Formula.Firewall error for referencing both an external query 
                (LoadPath) as well as external files.

            If you run into this, you can get around this by enabling the FastCombine option, in Power Query Options -> 
            Privacy -> Fast Combine -> 'Ignore the Privacy levels and potentially improve performance'.

            If you'd prefer not to do this however, you could also just replace the LoadPath reference below with a static
            absolute path reference.

        */

        (fnName as text, optional BasePath as text) as function =>
        let
            //If you wish to hardcode the path to load the queries from, you can edit the following line:
            DefaultPath = "C:\PQuery\",
            GitHubPath = "https://raw.githubusercontent.com/IvanBond/pquery/master/",
            
            BasePath = if (BasePath <> null) then BasePath else DefaultPath,
            Path = BasePath & (if Text.End(BasePath, 1) <> "\" then "\" else ""),
            File = Path & fnName & ".pq",
            
            Function = 
				try 	  Expression.Evaluate(Text.FromBinary(Binary.Buffer(File.Contents(File))), #shared)
            	otherwise Expression.Evaluate(Text.FromBinary(Binary.Buffer(Web.Contents(GitHubPath & fnName & ".pq"))), #shared)
        in
            Function,

    LoadPath.example = "", 
    //     // Excel.CurrentWorkbook(){[Name="Table1"]}[Content]{0}[Path]
        
    //     // Copy this file to `LoadPath.pq`, and replace its contents with your query path, like this:
    //     // "D:\pquery\"

    LoadTrace   = 
        /*
            Original made by Chris Webb:
            http://blog.crossjoin.co.uk/2014/12/11/reading-the-power-query-trace-filewith-power-query/
        */
        (Path as text) as table =>
        let
            Source   = Table.FromColumns({Lines.FromBinary(File.Contents(Path))}),
            Json     = Table.TransformColumns(Source, {{"Column1", each Json.Document(Text.Split(_, " : "){1})}}),
            Expanded = Table.ExpandRecordColumn(Json, "Column1", {"Start","Action","Duration","Exception","CommandText","ResponseFieldCount","PackageReference","ProductVersion","ActivityId","Process","Pid","Tid"}),
            Typed    = Table.TransformColumnTypes(Expanded, {{"Start", type datetime}, {"Duration", type duration}})
        in
            Typed,
    //======================== 
	// M
	//========================
	// —Å–ø–∏—Å–æ–∫ —Ñ—É–Ω–∫—Ü–∏–π —Å–∞–π—Ç https://querypower.com/2017/05/01/navigating-600-m-functions/
	Signature = 
		(placeholder as function)=>				
			let
			//Serialize type to text  
			TypeAsText = (value as any) => 
				let
					prefix = if Type.IsNullable(value) then "nullable " else ""
				in
					prefix & (
						if Type.Is(value, type binary) then "binary" else
						if Type.Is(value, type date) then "date" else
						if Type.Is(value, type datetime) then "datetime" else
						if Type.Is(value, type datetimezone) then "datetimezone" else
						if Type.Is(value, type duration) then "duration" else
						if Type.Is(value, type function) then "function" else
						if Type.Is(value, type list) then "list" else
						if Type.Is(value, type logical) then "logical" else
						if Type.Is(value, type none) then "none" else
						if Type.Is(value, type null) then "null" else
						if Type.Is(value, type number) then "number" else
						if Type.Is(value, type record) then "record" else
						if Type.Is(value, type table) then "table" else
						if Type.Is(value, type text) then "text" else
						if Type.Is(value, type time) then "time" else
						if Type.Is(value, type type) then "type" else
						if Type.Is(value, type any) then "any"
					else error "unknown"),
			
			//	if parameter is Optional set prefix
				OptionalPrefix = (_)=>if Type.IsNullable(_) then "optional " else "",
			
			//	get list of function parameters
				parameters = Type.FunctionParameters(Value.Type(placeholder)),
			
			//create a text list of parameters and associate types "[optional] paramname as type"
				parametersWithTypes = 
					List.Accumulate(
						Record.FieldNames(parameters),
						{},
						(state,cur)=>state & 
								{OptionalPrefix(Record.Field(parameters,cur)) &
								 cur & " as " & 
								 TypeAsText(Record.Field(parameters,cur))}
					)
			in 
			//merge parameter list and prefix with "function (" and suffix with function return type
			"function (" & Text.Combine(parametersWithTypes,", ") & ") as " & 
			TypeAsText(Type.FunctionReturn(Value.Type(placeholder))),
	
	NavigateShared = 
		let    
			sharedTab = Record.ToTable(#shared),
		
		//	select only functions from #shared
			functions = Table.SelectRows(sharedTab, each Type.Is(Value.Type([Value]),type function)),
		
		//	parse Module from function name
			modules = Table.AddColumn(functions, "Module", each Text.Split([Name], "."){0}, type text),
			functionNames = Table.AddColumn(modules, "FunctionName", each List.Last(Text.Split([Name], ".")), type text),
		
		//	get category from documentation
			categories = Table.AddColumn(functionNames, "Category", each 
							try Value.Metadata(Value.Type(Record.Field(#shared,[Name])))[Documentation.Category] otherwise ""),
		
		//	parse only the first code example from documentation
			examples = 
				Table.AddColumn(categories, "Examples", each 
					let 
						eg = Value.Metadata(Value.Type(Record.Field(#shared,[Name])))[Documentation.Examples]? 
					in 
						if Type.Is(Value.Type(eg),type record) then eg[Code] else eg{0}?[Code]?
				),
		
		//	get the short description from the documentation
			descriptions = Table.AddColumn(examples, "Description", each Value.Metadata(Value.Type(Record.Field(#shared,[Name])))[Documentation.Description]?),
		
		//	parse subcategories
			subcategories = Table.AddColumn(descriptions, "DotCategory", each List.Last(Text.Split([Category],"."))),
		
		//	adding the signature of the functions
			out = Table.AddColumn(subcategories, "Signature", each F[Signature](Record.Field(#shared,[Name])))
		in
			out,		
	M.library     = "", // * —Å–ø–∏—Å–æ–∫ —Ñ—É–Ω–∫—Ü–∏–π #shared —Ä–∞–∑–¥–µ–ª–µ–Ω–Ω—ã–π –ø–æ –∫–∞—Ç–µ–≥–æ—Ä—è–º, –≤—Å—Ç—Ä–æ–µ–Ω–Ω—ã–µ/–ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–µ (–º–∞–ª–æ–ø–æ–ª–µ–∑–Ω–∞—è)
		//! –Ω–∞–¥–æ –∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å –≤ –ø—Ä–æ–µ–∫—Ç, —Ç.–∫. –æ—Å—é–¥–∞ –ø—Ä–∏ –∫–∞–∂–¥–æ–º –∏—Å–ø–æ–ª—å—Ö–∑–æ–≤–∞–Ω–∏–∏ —Ñ—É–Ω–∫—Ü–∏–∏–π –±—É–¥—É—Ç –æ–±–Ω–æ–≤–ª—è—Ç—å—Å—è UDF —Ç–∞–±–ª–∏—Ü—ã –∏–∑ –ø—Ä–æ–µ–∫—Ç–∞
        // let
        //     Source      = 	Table.Sort(Record.ToTable(#shared),{{"Name", Order.Ascending}}),
        //     // 	–æ—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ —á–µ—Ä–µ–∑ F[M.library] –∏–∑ –ø—Ä–æ–µ–∫—Ç–∞.
		// 		Categorized = 	Table.AddColumn(Source, "Status", each
		// 							if Record.HasFields(#sections[Section1], [Name]) 
		// 							then "User defined" 
		// 							else "Built in"
		// 						),
		// 	// 	–Ω—É–∂–Ω–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–µ –¥–∞–Ω–Ω—ã–µ, 
		// 	// 	–Ω–æ —ç—Ç–æ —É—Å—Ç—Ä–∞–Ω—è–µ—Ç —Ü–∏–∫–ª–∏—á–µ—Å–∫—É—é —Å—Å—ã–ª–∫—É, –≤–æ–∑–Ω–∏–∫–∞—é—â—É—é, –µ—Å–ª–∏ –∏ F, –∏ this –æ—Ç–Ω–æ—Å—è—Ç—Å—è 
		// 	// 	–∫–æ –≤—Å–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–º —Ñ—É–Ω–∫—Ü–∏—è–º (–∫–æ—Ç–æ—Ä—ã–µ –≤–∫–ª—é—á–∞—é—Ç –¥—Ä—É–≥ –¥—Ä—É–≥–∞)
        //     	Filtered    = Table.SelectRows(Categorized, each [Status] = "Built in"),
		// 	//	! –æ—à–∏–±–∫–∏ –≤ Value_TypeToText. –ü–∞–¥–∞–µ—Ç –ò–∑ –∑–∞ —ç—Ç–æ–≥–æ –ø–∞–¥–∞–µ—Ç –∑–∞–≥—Ä—É–∑–∫–∞ –≤ PBID
		// 	// 	AddType     = Table.AddColumn(Filtered, "Type", 	 each F[Value.TypeToText]([Value]) ), 
        //     // 	AddTypeRec  = Table.AddColumn(AddType, "TypeRecurs", each F[Value.TypeToText]([Value], true) ),
		// 	AddCat = Table.AddColumn(Filtered, "Category", each
		// 		let
		// 			cut = Text.Split(Text.Replace([Name],"_","."),".")
		// 		in
		// 			(try
		// 				if   List.Contains({"Database", "Type"}, cut{1})
		// 				then cut{1}
		// 				else cut{0}
		// 			otherwise
		// 				"Custom"
		// 			)
		// 		),
        //     Return = AddCat
        // in
        //     Source,
   
	M.constants   = "", // * —Å–ø–∏—Å–æ–∫ –∫–æ–Ω—Å—Ç–∞–Ω—Ç –≤ –ú 
        // // –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ –æ–±–Ω–æ–≤–ª—è—é—Ç—Å—è –≤—Å–µ —Ñ—É–Ω–∫—Ü–∏–∏, –≤ —Ç–æ–º —á–∏—Å–ª–µ UDF. –í M.library –Ω–∞–¥–æ UDF –ø–æ—á–∏—Å—Ç–∏—Ç—å. –ù–µ–¥–æ–¥–µ–ª–∞–ª
		// let
        //     Source 	  = M.library,
        //     Constants = Table.SelectRows(Source, each 
		// 					not Value.Is([Value], type type) and 
		// 					not Value.Is([Value], type function)
		// 				),
        //     Return 	  = Constants
        // in
        //     Return,

    M.UDFs        = "", // * —Å–ø–∏—Å–æ–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏—Ö —Ñ—É–Ω–∫—Ü–∏–π 
        // let
        //     Source  = Record.FieldNames(#shared),
        //     UDFs    = List.Select(Source, each Record.HasFields(#sections[Section1], _)),
        //     Return  = UDFs
        // in
        //     Source,
	
    M.functions   = "", // * —Å–ø–∏—Å–æ–∫ —Ñ—É–Ω–∫—Ü–∏–π, —Ä–∞–∑–¥–µ–ª–µ–Ω–Ω—ã–π –ø–æ –∫–∞—Ç–µ–≥–æ—Ä—è–º. –ú–∞–ª–æ–ø–æ–ª–µ–∑–Ω–∞—è —à—Ç—É–∫–∞ 
		//     let
		//         Type.ToText  = Load("Type.ToText"),
		//         Value.ToText = Load("Value.ToText"),
		//         Text.Count   = Load("Text.Count"),
		//         Source       = M.library,
				
		//         Functions    = Table.SelectRows(Source, each Value.Is([Value], type function)),

		//         AddFType    = Table.AddColumn(Functions,    "FType",        each Value.Type([Value])),
		//         AddReturn   = Table.AddColumn(AddFType,     "Returns",      each Type.FunctionReturn([FType])),
		//         AddRetTxt   = Table.AddColumn(AddReturn,    "RetText",      each Type.ToText([Returns])),
		//         AddRetRec   = Table.AddColumn(AddRetTxt,    "RetRecursive", each Type.ToText([Returns], true)),
		//         AddRetNull  = Table.AddColumn(AddRetRec,    "RetNullable",  each Type.IsNullable([Returns])),
		//         AddRetType  = Table.AddColumn(AddRetNull,   "RetType",      each let Type = Type.ToText(Type.NonNullable([Returns])) in if Type = "anynonnull" and [RetNullable] then "any" else Type),
		//         AddParams   = Table.AddColumn(AddRetType,   "Parameters",   each Type.FunctionParameters([FType])),
		//         AddNumPars  = Table.AddColumn(AddParams,    "NumParams",    each Record.FieldCount([Parameters])),
		//         AddReqd     = Table.AddColumn(AddNumPars,   "Required",     each Type.FunctionRequiredParameters([FType])),
		//         AddSig      = Table.AddColumn(AddReqd,      "Signature",    each Value.ToText([Value])), //! Value_ToText
		//         AddSigRec   = Table.AddColumn(AddSig,       "SigRecursive", each [Name] & " => " & Value.ToText([Value], true)), //! Value_ToText
		//         AddTally    = Table.AddColumn(AddSigRec,    "Times Used",   each Text.Count(Text.Queries, [Name])), //! Text_Queries
		//         GoodCols    = Table.RemoveColumns(AddTally, {"Type", "TypeRecurs"}),
		//         Return = GoodCols
		//     in
		//         Return,

    M.types       = "", // * –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Ç–∏–ø—ã —Ñ—É–Ω–∫—Ü–∏–π ()
        // let
        //     Source = M.library,
        //     Types  = Table.SelectRows(Source, each Value.Is([Value], type type)),
        //     Return = Types
        // in
        //     Return,

    getUdfContent = "", // * –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–≥–æ —Ñ–∞–π–ª–∞ —Å UDF —Ñ—É–Ω–∫—Ü–∏–µ–π –Ω–∞ M (–ò–º—è–§—É–Ω–∫—Ü–∏–∏.pq)
		// (fnName as text) => 
        // let
        //  	LoadPath = "",	// –ø—É—Ç—å –∫ –ø–∞–ø–∫–µ —Å —Ñ—É–Ω–∫—Ü–∏—è–º–∏
        //     Path    = LoadPath & (if Text.End(LoadPath, 1) <> "\" then "\" else ""),
        //     File    = Path & Text.Replace(fnName, "_", ".") & ".pq",
        //     AltFile = Path & fnName & ".m",  //just in case...
        //     Source  = Text.FromBinary(Binary.Buffer(
        //                 try File.Contents(File)
        //                 otherwise File.Contents(AltFile)
        //                 ))
        // in
        //     Source,

    UdfContents   = "", // * –æ—à–∏–±–∫–∞ –∫–æ–º–ø–∏–ª—è—Ü–∏–∏ –∏–∑-–∑–∞ M_UDFs. –í—Å–µ –º–µ–Ω—è–ª –Ω–µ –≤—ã—Ö–æ–¥–∏—Ç
        /* –≤—ã–¥–∞–µ—Ç –æ—à–∏–±–∫—É –ø—Ä–∏ –∫–æ–º–ø–∏–ª—è—Ü–∏–∏ –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –≤ 2-—Ö —Ñ—É–Ω–∫—Ü–∏—è—Ö –µ—â–µ*/
        // let
        //	   UdfTable     = Table.RenameColumns(Table.FromList(F[M.UDFs]), {"Column1", "Name"}),
        //     WithContents = Table.AddColumn(UdfTable, "Contents", each getUdfContent([Name]))
        // in
        //     WithContents,

	//======================== 
	// Date
	//========================
	Date.Today          = // —Ç–µ–∫—É—â–∞—è –¥–∞—Ç–∞
        () =>
            Date.From(DateTime.FixedLocalNow()),
    
    Date.Tomorrow       = // –¥–∞—Ç–∞ –∑–∞–≤—Ç—Ä–∞ 
        () =>
            Date.AddDays(Date.From(DateTime.FixedLocalNow()), 1),

    Date.Yesterday      = // –¥–∞—Ç–∞ –≤—á–µ—Ä–∞
        () =>
            Date.AddDays(Date.From(DateTime.FixedLocalNow()), -1),

    Date.Calendar  	  	= // –æ—Å–Ω–æ–≤–Ω–æ–π –∫–∞–ª–µ–Ω–¥–∞—Ä—å
		Document(
			// Basic calendar
			"Date.Calendar",
			"Generate a calendar table for a given date span - can be text or proper dates. Current columns are Date, DayOfWeek, Month, MonthNum, WeekStartData, WeekStart, Year, YearMonth",
			{[ 	Description = "2016 calendar", 
				Code 		= "PBI[Date.Calendar](""1/1/2016"", ""12/31/2016""", 
				Result 		= "2016 calendar"]},

			(start as any, end as any) => 
				let
					StartDate 	= Date.From(start),
					EndDate 	= Date.From(end),
					Source 		= Date.DatesBetween(StartDate, EndDate),
					FromList 	= Table.FromList(Source, Splitter.SplitByNothing(), null, null, ExtraValues.Error),
					Date 		= Table.RenameColumns(FromList,{{"Column1", "Date"}}),
					DayOfWeek 	= Table.AddColumn(Date, "Day of Week", each Date.DayName([Date])),
					Month 		= Table.AddColumn(DayOfWeek, "Month", each Date.MonthName([Date])),
					MonthNum 	= Table.AddColumn(Month, "MonthNumber", each Date.Month([Date])),
					WeekStartDate = Table.AddColumn(MonthNum, "WeekStartDate", each Date.StartOfWeek([Date])),
					WeekStart	= Table.AddColumn(WeekStartDate, "Week Start", each [Month] & " " & Text.From(Date.Day([WeekStartDate]))),
					Year 		= Table.AddColumn(WeekStart, "Year", each Date.Year([Date])),
					YearMonth	= Table.AddColumn(Year, "YearMonth", each Number.From(Text.From([Year]) & (if [MonthNumber] < 10 then "0" else "") & Text.From([MonthNumber]))),
					Result 		= YearMonth
			in
					Result 
		),

	Date.DatesBetween 	= // –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–ø–∏—Å–æ–∫ –¥–∞—Ç –º–µ–∂–¥—É –¥–∞—Ç–∞–º–∏ 
		Document(
			"Date.DatesBetween",
			"Returns a list of dates in a given span (inclusive). Start and end parameters can be any order",
			{[	Description = "Date range", 
				Code 		= "PBI[Date.DatesBetween](""1/1/2016"", ""1/3/2016"")", 
				Result		= "{""1/1/2016"", ""1/2/2016"", ""1/3/2016""}" ]},
			
			(start as any, end as any) => 
			let 
				StartDate 	= Date.From(start), 
				EndDate 	= Date.From(end),
				adjustedStart = List.Min({StartDate, EndDate}),
				adjustedEnd = List.Max({StartDate, EndDate}),
				GetDates 	= (start as date, end as date, dates as list)=> if start > end then dates else @GetDates(Date.AddDays(start, 1), end, List.Combine({dates, {start}})),
				Dates 		= GetDates(adjustedStart, adjustedEnd, {})
			in 
				Dates 
		),

	Date.DayName   	  	= // –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –Ω–∞–∑–≤–∞–Ω–∏–µ –¥–Ω—è –Ω–µ–¥–µ–ª–∏ –ø–æ –µ–≥–æ –Ω–æ–º–µ—Ä—É 
		Document(
			"Date.DayName",
			"Returns the English day of the week name for a date",
			{[ Description = "Get the day name", Code="Date.DayName(""9/9/2016"")", Result="Friday"]},
			
			(date as any) => 
				Switch(
					Date.DayOfWeek(DateTime.From(date)), 
					{0, 1, 2, 3, 4, 5, 6}, 
					{"Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"}, 
					null
				)
		),

	Date.MonthName 	  	= // –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –Ω–∞–∑–≤–∞–Ω–∏–µ –º–µ—Å—è—Ü–∞ –ø–æ –µ–≥–æ –Ω–æ–º–µ—Ä—É 
		Document(
			"Date.MonthName",
			"Returns the English month name for a date",
			{[ Description = "Get the month name", Code="PBI[Date.MonthName](""9/9/2016"")", Result = "September" ]},
		
			(date as any) => 
				let 
					monthNumber = if date is number then date else Date.Month(DateTime.From(date))
				in 
					Switch(
						monthNumber,
						{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12}, 
						{"January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"},
						null
					)
		),

	Date.EndOfLastMonth = // –¥–∞—Ç–∞ –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ –¥–Ω—è —Ç–µ–∫—É—â–µ–≥–æ –º–µ—Å—è—Ü–∞
        () =>
			Date.EndOfMonth(Date.AddMonths(Date.From(DateTime.FixedLocalNow()), -1)) ,

    Date.EpochToDate    = // –ø—Ä–µ–æ–±—Ä–∞–∑—É–µ—Ç –¥–∞—Ç—É —Ñ–æ—Ä–º–∞—Ç–∞ SAP –≤ –Ω–æ—Ä–º–∞–ª—å–Ω—É—é
        /*
            Description:
                convert date from SAP ByDesign into normal date
                SAP JSON response shows date as "/Date(1357084800000)/"
            
            Usadge:
                Table.TransformColumns(Expand,{{"Posting Date", EpochToDate}})
        */
    
        let EpochToDateTime = (epoch as nullable text ) =>
            let res = if epoch = null then null else
                let remove_word      = Text.Replace(epoch, "Date", ""),
                    remove_slash     = Text.Replace(remove_word, "/", ""),
                    remove_left_par  = Text.Replace(remove_slash, "(", ""),
                    remove_right_par = Text.Replace(remove_left_par, ")", ""),
                    calc =  #datetime(1970, 1, 1, 0, 0, 0) + 
                            #duration(0, 0, 0, Number.FromText(Text.Start(remove_right_par,Text.Length(remove_right_par)-3)))
                in calc
            in res
        in EpochToDateTime,
    
    Date.FormatSQL      = // –ø—Ä–µ–æ–±—Ä–∞–∑—É–µ—Ç –Ω–æ—Ä–º–∞–ª—å–Ω—É—é –¥–∞—Ç—É –≤ —Ñ–æ—Ä–º–∞—Ç SQL (2024-01-01T00:00:00)
        (DateValue as any) =>
        let  
            FormattedDate = DateTime.ToText(DateTime.From(DateValue), "yyyy-MM-ddT00:00:00", "en-US")
        in
            FormattedDate,

    Date.NDaysAgo       = // –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –¥–∞—Ç—É, –æ—Ç—Å—Ç–æ—è—é—â—É—é –æ—Ç —Ç–µ–∫—É—â–µ–π –Ω–∞ n –¥–Ω–µ–π –≤ —Ñ–æ—Ä–º–∞—Ç–µ (2024-07-15T11:22:22.0204864)
        /*
            return date of N days ago from Today
            usage: 	Date.NDaysAgo(3)
            Result: depends on Today 
        */

        (N as number) => 
            Date.AddDays(DateTime.FixedLocalNow(), -N),

    Date.NDaysInFuture  = // –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –¥–∞—Ç—É, –ø–æ—Å–ª–µ —Ç–µ–∫—É—â–µ–π –Ω–∞ n –¥–Ω–µ–π –≤ —Ñ–æ—Ä–º–∞—Ç–µ (2024-07-15)
        (N as number) => 
            Date.AddDays(Date.From(DateTime.FixedLocalNow()), N),

    Date.StartOfCurrentYear = // –¥–∞—Ç–∞ –Ω–∞—á–∞–ª–∞ —Ç–µ–∫—É—â–µ–≥–æ –≥–æ–¥–∞
        // –ü—Ä–∏–º–µ—Ä: F[Date.StartOfCurrentYear]()
		() =>
            Date.StartOfYear(Date.From(DateTime.FixedLocalNow())),

    Date.StartOfLastYear 	= // –¥–∞—Ç–∞ –Ω–∞—á–∞–ª–∞ –ø—Ä–æ—à–ª–æ–≥–æ –≥–æ–¥–∞
        () =>
            Date.AddYears(Date.StartOfYear(Date.From(DateTime.FixedLocalNow())), -1),
    
    Date.StartOfMonth12MAgoExcCurMonth = // –¥–∞—Ç–∞ –Ω–∞—á–∞–ª–∞ –º–µ—Å—è—Ü–∞ = 12 –º–µ—Å—è—Ü–µ–≤ –Ω–∞–∑–∞–¥
        // 	–ü—Ä–∏–º–µ—Ä (–µ—Å–ª–∏ —Å–µ–π—á–∞—Å 15.08.2024) 
		//	= F[Date.StartOfMonth12MAgoExcCurMonth]() = "01.08.2023"
		() =>
            Date.StartOfMonth(Date.AddMonths(Date.From(DateTime.FixedLocalNow()), -12)),
    
    Date.StartOfMonth12MAgoIncCurMonth = // –¥–∞—Ç–∞ –Ω–∞—á–∞–ª–∞ —Å–ª–µ–¥—É—é—â–µ–≥–æ –º–µ—Å—è—Ü–∞ = 12 –º–µ—Å—è—Ü–µ–≤ –Ω–∞–∑–∞–¥
        // 	–ü—Ä–∏–º–µ—Ä (–µ—Å–ª–∏ —Å–µ–π—á–∞—Å 15.08.2024) 
		//	= F[Date.StartOfMonth12MAgoIncCurMonth]() = "01.09.2023"

		() =>
            Date.StartOfMonth(Date.AddMonths(Date.From(DateTime.FixedLocalNow()), -11)),

    DateTime.FormatSQL  = // –¥–∞—Ç–∞/–≤—Ä–µ–º—è —Ñ–æ—Ä–º–∞—Ç–∞ SQL (2024-01-01T12:00:00)
        (DateTimeValue as any) =>
            DateTime.ToText(DateTime.From(DateTimeValue), "yyyy-MM-ddThh:mm:ss", "en-US"),

    DateTime.UnixTime   = // –¥–∞—Ç–∞/–≤—Ä–µ–º—è —Ñ–æ—Ä–º–∞—Ç–∞ Unix (20.05.2018 7:15:25)
        /*
            Convert unix timestamp into Power Query datetime formart
            Usage: DateTime_UnixTime(1526800525) = 20.05.2018 7:15:25
        */
        (unixtime as number) as datetime => 
            #datetime(1970, 01 , 01, 0, 0, 0) + #duration(0,0,0,unixtime),
	// –≤–∑–∞–∏–º–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ (—Ä–µ–¥–∫–∏–µ)
	Date.Parse 				= // 1 –∑–∞–º–µ–Ω—è–µ—Ç —Ç–µ–∫—Å—Ç–æ–≤—É—é –¥–∞—Ç—É –Ω–∞ –¥–∞—Ç—É –≤ –Ω–æ—Ä–º–∞–ª—å–Ω–æ–º —Ñ–æ—Ä–º–∞—Ç–µ 
		/*
			–û–ø–∏—Å–∞–Ω–∏–µ
				1 –£–ª—É—á—à–µ–Ω –∞–Ω–∞–ª–∏–∑–∞—Ç–æ—Ä –¥–∞—Ç –¥–ª—è —Å—Ç—Ä–æ–∫, —Å–æ–¥–µ—Ä–∂–∞—â–∏—Ö –¥–∞—Ç—ã –≤ –Ω–µ–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω–æ–º —Ñ–æ—Ä–º–∞—Ç–µ
				2 –ï—Å—Ç—å —Å–ø–∏—Å–æ–∫ –∞–≤—Ç–æ–∑–∞–º–µ–Ω

			–ü—Ä–∏–º–µ—Ä		= F[Date.Parse]("—è–Ω–≤–∞—Ä—å 2017")
						= F[Date.Parse]("—è–Ω–≤–∞—Ä—å 2017 –≥")
						= F[Date.Parse]("—è–Ω–≤–∞—Ä—å 2017 –≥–æ–¥.")
			
			–†–µ–∑—É–ª—å—Ç–∞—Ç	"01.01.2017"
		*/
		(datetext as text) =>
			let
			/* 	–°–ø–∏—Å–æ–∫ –≤–∫–ª—é—á–µ–Ω–Ω—ã—Ö –ª–æ–∫–∞–ª–µ–π –≤ –ø–æ—Ä—è–¥–∫–µ –ø—Ä–µ–¥–ø–æ—á—Ç–µ–Ω–∏—è */
				Locales = {
					null,  // system default
					"en",
					"en-US",
					"en-GB",
					"ru",
					"ru-RU",
					"ru-UA",
					"ru-BY",
					"de",
					"de-DE",
					"de-BE"
				},

			/* 	–†–∞—Å–ø—Ä–æ—Å—Ç—Ä–∞–Ω–µ–Ω–Ω—ã–µ –∑–∞–º–µ–Ω—ã, –∫–æ—Ç–æ—Ä—ã–µ –ø—Ä–µ–≤—Ä–∞—â–∞—é—Ç —Å—Ç—Ä–æ–∫—É –≤ —á–∏—Ç–∞–µ–º—É—é –¥–∞—Ç—É */
				Substitutions = {
					{"–≥–æ–¥–∞", "–≥"},
					{"–≥–æ–¥", "–≥"}
				},

			/* 	–ü—Ä–æ–±—É–µ–º –≤—Å–µ –∑–∞–º–µ–Ω—ã, –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–Ω—ã–µ –≤—ã—à–µ, –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –ø–µ—Ä–≤—ã–π —É—Å–ø–µ—à–Ω—ã–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç */
				TryAllSubstitutions = (datetext as text, reader as function) =>
					let
						Result = List.Last(
							List.Generate(
								() => [i=-1, date=null],
								each [i] < List.Count(Substitutions),
								each [
									i = [i] + 1,
									date =
										if
											[date] is null
										then
											try reader(
													Text.Replace(
														datetext,
														Substitutions{i}{0},
														Substitutions{i}{1}
													)
												)
											otherwise null
										else
											[date]
								],
								each [date]
							)
						),
						Return =
							if   Result is null
							then error "Could not read date with substitutions: " & datetext
							else Result
					in
						Return,

			/* 	–ü—Ä–æ–±—É–µ–º –≤—Å–µ –ª–æ–∫–∞–ª–∏, –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–Ω—ã–µ –≤—ã—à–µ, –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –ø–µ—Ä–≤—ã–π —É—Å–ø–µ—à–Ω—ã–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç */
				TryAllLocales = (datetext as text) =>
					let
						Result = List.Last(
							List.Generate(
								() => [i=-1, date=null],
								each [i] < List.Count(Locales),
								each [
									i = [i] + 1,
									date =
										if
											[date] is null
										then
											try Date.FromText(datetext, Locales{i})
											otherwise null
										else
											[date]
								],
								each [date]
							)
						),
						Return =
							if   Result is null
							then error "Could not read date with locales: " & datetext
							else Result
					in
						Return,

				/* –í—ã–ø–æ–ª–Ω—è–µ–º –≤—Å–µ —à–∞–≥–∏ */
				CleanDateText = Text.Lower(Text.Trim(datetext)),
				Return = TryAllSubstitutions(CleanDateText, TryAllLocales)
			in
				Return,

	Date.IntervalFromText 	= // 2 –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–ø–∏—Å–æ–∫ –∏–∑ –¥–≤—É—Ö –¥–∞—Ç, —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏—Ö –Ω–∞—á–∞–ª—É –∏ –∫–æ–Ω—Ü—É –ø–æ —Ç–µ–∫—Å—Ç–æ–≤–æ–º—É –æ–ø–∏—Å–∞–Ω–∏—é
		/*
			–û–ø–∏—Å–∞–Ω–∏–µ
				1 	–ø–æ —Å—Ç—Ä–æ–∫–µ —Ç–µ–∫—Å—Ç–∞, –Ω–∞–ø—Ä–∏–º–µ—Ä ¬´—è–Ω–≤–∞—Ä—å 2024¬†–≥.¬†‚Äì –¥–µ–∫–∞–±—Ä—å 2024¬†–≥."
					–≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–ø–∏—Å–æ–∫ –∏–∑ –¥–≤—É—Ö –¥–∞—Ç, —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏–µ –Ω–∞—á–∞–ª—É –∏ –∫–æ–Ω—Ü—É –∏–Ω—Ç–µ—Ä–≤–∞–ª–∞
				2 	–û—Å–Ω–æ–≤—ã–≤–∞–µ—Ç—Å—è –Ω–∞ —Ñ—É–Ω–∫—Ü–∏–∏ Date.Parse
			
			–û—Å–æ–±–µ–Ω–Ω–æ—Å—Ç—å
				1 	–º–µ—Å—è—Ü—ã –º–æ–∂–Ω–æ –ø–∏—Å–∞—Ç—å: –ø–æ–ª–Ω–æ—Å—Ç—å—é, —Å–æ–∫—Ä–∞—â–µ–Ω–Ω–æ, –≤ –ø–∞–¥–µ–∂–µ
				2	–≥–æ–¥—ã –º–æ–∂–Ω–æ –ø–∏—Å–∞—Ç—å: –≥, –≥., –≥–æ–¥, –≥–æ–¥–∞ (–º–æ–∂–Ω–æ –∏–∑–º–µ–Ω–∏—Ç—å –≤ Date.Parse —Å–ø–∏—Å–æ–∫ –∞–≤—Ç–æ–∑–∞–º–µ–Ω)
			
			–ü—Ä–∏–º–µ—Ä		= F[Date.IntervalFromText]("—è–Ω–≤–∞—Ä—å 2023 - 10 —è–Ω–≤–∞—Ä—å 2024")
			–†–µ–∑—É–ª—å—Ç–∞—Ç	= { 01.01.2023, 10.01.2024 } —Ç–∏–ø Date

			–ü—Ä–∏–º–µ—Ä		= F[Date.IntervalFromText]("10 —è–Ω–≤–∞—Ä—å 2024 –≥–æ–¥–∞ - 30 –¥–µ–∫–∞–±—Ä—è 2024 –≥.")
			–†–µ–∑—É–ª—å—Ç–∞—Ç	= { 10.01.2024, 30.12.2024 } —Ç–∏–ø Date

			–ü—Ä–∏–º–µ—Ä		= F[Date.IntervalFromText]("—è–Ω–≤–∞—Ä—å 23 –≥–æ–¥–∞ - –¥–µ–∫–∞–±—Ä—å 24 –≥.")
			–†–µ–∑—É–ª—å—Ç–∞—Ç	= { 01.01.2024, 31.12.2024 } —Ç–∏–ø Date

		*/

		(date_interval as text,
		optional delimiter as text,
		optional full_months as logical) =>
		
		let
			Date.Parse = try Date.Parse otherwise Date.FromText,

			/* 	–ü—Ä–µ–¥–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω—ã–µ –∏–Ω—Ç–µ—Ä–≤–∞–ª—ã */
				Presets = #table(
					{"interval", "start", "end"},
					{
						{"1 –∫–≤–∞—Ä—Ç–∞–ª", "—è–Ω–≤–∞—Ä—å", "–º–∞—Ä—Ç"},
						{"2 –∫–≤–∞—Ä—Ç–∞–ª", "–∞–ø—Ä–µ–ª—å", "–∏—é–Ω—å"},
						{"3 –∫–≤–∞—Ä—Ç–∞–ª", "–∏—é–ª—å", "—Å–µ–Ω—Ç—è–±—Ä—å"},
						{"4 –∫–≤–∞—Ä—Ç–∞–ª", "–æ–∫—Ç—è–±—Ä—å", "–¥–µ–∫–∞–±—Ä—å"},
						{"1 –ø–æ–ª—É–≥–æ–¥–∏–µ", "—è–Ω–≤–∞—Ä—å", "–∏—é–Ω—å"},
						{"2 –ø–æ–ª—É–≥–æ–¥–∏–µ", "–∏—é–ª—å", "–¥–µ–∫–∞–±—Ä—å"},
						{"9 –º–µ—Å—è—Ü–µ–≤", "—è–Ω–≤–∞—Ä—å", "—Å–µ–Ω—Ç—è–±—Ä—å"}
					}
				),
			
			PresetFullYear = [
				trim = {",","."," ",";"},
				remove = {"–≥", "–≥–æ–¥"}
			],

		/* 	–ó–Ω–∞—á–µ–Ω–∏—è –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é */
			Delimiter = if delimiter is null then " - " else delimiter,
			FullMonth = if full_months is null
						then if	 EndStrings{1} is null
							 then Date.Day(DateStart) = 1
							 else Date.Day(DateEndParsed) = 1 and Date.Day(DateStart) = 1
						else full_months,

		/* 	–ü—Ä–æ–≤–µ—Ä—è–µ–º, –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è–µ—Ç –ª–∏ date_interval –ø–æ–ª–Ω—ã–π –≥–æ–¥ */
			YearCandidates =
				List.Transform(
					PresetFullYear[remove],
					each
						try
							Number.FromText(
								Text.Trim(
									Text.Replace(Text.Lower(date_interval), _, ""),
									PresetFullYear[trim]
								)
							)
						otherwise
							null
				),
			YearDetected = List.Select(YearCandidates, each _ <> null){0},
			YearText =
				try
					Text.From(#date(YearDetected, 1, 1)) &
					Delimiter &
					Text.From(#date(YearDetected, 12, 31))
				otherwise
					null,

		/* 	–ü—Ä–∏ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏ –ø—Ä–∏–º–µ–Ω–∏—Ç—å –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –∑–∞–º–µ–Ω—ã */
			SelectedPreset =
				try
					Table.ToRecords(
						Table.SelectRows(
							Table.AddColumn(
								Presets,
								"match",
								each Text.Contains(
									Text.Lower(date_interval),
									[interval]
								)
							),
							each [match] = true
						)
					){0}
				otherwise
					null,

			ApplyPreset = 
				(interval as text, preset as record) =>
					let
						input = Text.Lower(interval),
						start = Text.Replace(input, preset[interval], preset[start]),
						end   = Text.Replace(input, preset[interval], preset[end])
					in
						start & Delimiter & end,

			InputWithPresetsApplied =
				if	 SelectedPreset is null
				then date_interval
				else ApplyPreset(date_interval, SelectedPreset),

			/* –ü–∞—Ä—Å–∏–Ω–≥ */
			EndStrings = List.Combine({
				Text.Split(
					if	YearText is null
						then InputWithPresetsApplied
						else YearText,
					Delimiter),
				{null}
			}),
			DateStart 	  = Date.Parse(EndStrings{0}),
			DateEndParsed = try Date.Parse(EndStrings{1}) otherwise null,
			DateEndGuess  =
				if	 EndStrings{1} is null
				then DateStart
				else DateEndParsed,
			
			DateEnd = 
				if FullMonth 
				then Date.EndOfMonth(DateEndGuess) 
				else DateEndGuess
		in
			{DateStart, DateEnd}
		,
	// TimeZone
	DateTimeZoneToDateTime_SwitchZone = //
		(TimeZone as number) as function =>
			(DateTimeZone as nullable datetimezone) as nullable datetime=>
			let
				SwitchedZone = DateTimeZone.SwitchZone(DateTimeZone,TimeZone),
				DateTime 	 = DateTime.Date(SwitchedZone) & DateTime.Time(SwitchedZone)
			in
				if DateTimeZone is null then null else DateTime,

	DateTimeZoneToDate_SwitchTimeZone = // ...‚Ä¶te_SwitchTimeZone
		(TimeZone as number) as function =>
			(DateTimeZone as nullable datetimezone) as nullable date=>
			let
				SwitchedZone = DateTimeZone.SwitchZone(DateTimeZone,TimeZone),
				Date = DateTime.Date(SwitchedZone) // & DateTime.Time(DateTimeZone)
			in
				if DateTimeZone is null then null else Date,
	
	
	//======================== 
	// List
	//========================
	// –æ—Å–Ω–æ–≤–Ω—ã–µ
	List.Flatten  		= // –æ–±—ä–µ–¥–∏–Ω—è–µ—Ç –Ω–µ—Å–∫–æ–ª—å–∫–æ —Å–ø–∏—Å–∫–æ–≤, –≤ —Ç–æ–º —á–∏—Å–ª–µ –≤–ª–æ–∂–µ–Ω–Ω—ã—Ö! –≤ –æ–¥–∏–Ω
		/*
			–û–ø–∏—Å–∞–Ω–∏–µ	–æ–±—ä–µ–¥–∏–Ω—è–µ—Ç —Å–ø–∏—Å–∫–∏ –≤ –æ–¥–∏–Ω, —Å–æ—Ö—Ä–∞–Ω—è—è –¥—Ä—É–≥–∏–µ —Ç–∏–ø—ã –¥–∞–Ω–Ω—ã—Ö, —Ç—É—Ç –æ–¥–∏–Ω
			–ü—Ä–∏–º–µ—Ä		= F[List.Flatten] ({1, 2, Table.FromRecords({[x=1]}), {{3,4},5} })
			–†–µ–∑—É–ª—å—Ç–∞—Ç 	= {1, 2, Table.FromRecords({[x=1]}), 3, 4, 5}
		*/
		Document(
			"List.Flatten",
			"Recursively flattens list elements. The end result is a single list",
			{ [ Description = "Flattening nested lists into one", 
				Code 		= "List.Flatten({ 1, 2, Table.FromRecords({[x=1]}), {3, 4, 5} })", 
				Result 		= "{ 1, 2, Table.FromRecords({[x=1]}), 3, 4, 5}"] },
			
			(list as list) => 
				List.Accumulate(list, {}, (state, current) =>
					let
						currentListContent = if current is list then @List.Flatten(current) else {current}
					in
						List.Combine({state, currentListContent})
			)
		),
	List.Items    		= // # –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —ç–ª–µ–º–µ–Ω—Ç—ã —Å–ø–∏—Å–∫–∞ –ø–æ –Ω–æ–º–µ—Ä—É –≤—Ö–æ–∂–¥–µ–Ω–∏—è
		/*
			–ü—Ä–∏–º–µ—Ä		F[List.Items]({10,20,30,40,50},{1,3,4})
			–†–µ–∑—É–ª—å—Ç–∞—Ç	{10, 30, 40}
			–ù–∞–ø—Ä–∏–º–µ—Ä	F[List.Items](Table.ColumnNames(from),{1,3,4})
		*/
		Document(
			"List.Items", 
			"–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–ø–∏—Å–æ–∫ –∑–Ω–∞—á–µ–Ω–∏–π –ø–æ –ø–æ–∑–∏—Ü–∏–∏ —ç–ª–µ–º–µ–Ω—Ç–æ–≤",
			{ [ Description = "–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —ç–ª–µ–º–µ–Ω—Ç—ã —Å–ø–∏—Å–∫–∞ –ø–æ –Ω–æ–º–µ—Ä—É –≤—Ö–æ–∂–¥–µ–Ω–∏—è", 
				Code 		= "= F[List.Items]({1,2,3,4,5,6,7,8,9,10},{1,3,4})", //  
				Result 		= "{1, 3, 4}" ]},
		
			(MyList as list, Indexes as list) =>
				List.Transform(
					List.Select(Indexes, (x)=> x>=0 and x<=List.Count(MyList) ),
					each MyList{_-1}
				)
		),

	List.From    		= // –ø—Ä–µ–æ–±—Ä–∞–∑—É–µ—Ç —Ç–µ–∫—Å—Ç, —Ä–∞–∑–¥–µ–ª–µ–Ω–Ω—ã–π –∑–∞–ø—è—Ç—ã–º–∏ –≤ —Å–ø–∏—Å–æ–∫
		/*
			F[List.From]("{A, B, C}") = {"A", "B", "C"}
		*/
		Document(
			"List.From", 
			"–ü—Ä–µ–æ–±—Ä–∞–∑—É–µ—Ç —Ç–µ–∫—Å—Ç, —Ä–∞–∑–¥–µ–ª–µ–Ω–Ω—ã–π –∑–∞–ø—è—Ç—ã–º–∏ –≤ —Å–ø–∏—Å–æ–∫",
			{[ 	Description = "–ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ—Ç —Ç–µ–∫—Å—Ç –≤ —Å–ø–∏—Å–æ–∫", 
				Code 		= "List.From(""{A, B, C}"")", 
				Result 		= "{ ""A"", ""B"", ""C"" }"	]},
		
			(simpleTextList as text) => [
				trimWhitespace 	= Text.Trim(simpleTextList),
				listToSplit 	= Text.TrimEnd(Text.TrimStart(trimWhitespace, "{"), "}"),
				Result 			= List.Transform(Text.Split(listToSplit, ","), each Text.Trim(_))
			] [Result]
		),
		
	List.ToText   		= // –∫–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ—Ç —Å–ø–∏—Å–æ–∫ –≤ —Ç–µ–∫—Å—Ç. –û–±—Ä–∞—Ç–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è List.From
		/*
			–û–ø–∏—Å–∞–Ω–∏–µ	–°–æ–∑–¥–∞–µ—Ç —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞ (–±–µ–∑ —Ä–∞–∑–¥–µ–ª–∏—Ç–µ–ª–µ–π)
			–ü—Ä–∏–º–µ—Ä		F[List.ToText] ({1, 2, "abc", 1+2}   = "{12abc3}"
						F[List.ToText] ({"abc","def","hgk"}) = {abcdefhgk}
		*/
		Document(
			"List.ToText",
			"–ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ—Ç —Å–ø–∏—Å–æ–∫ –≤ —Ç–µ–∫—Å—Ç. –û–±—Ä–∞—Ç–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è List.From",
			{[ 	Description = "–ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ—Ç —Ç–µ–∫—Å—Ç –≤ —Å–ø–∏—Å–æ–∫", 
				Code 		= "List.ToText({ 1, 2, ""abc"",1+2})", 
				Result 		= """{12abc3}"""	]},
			(list as list) => 
				List.Accumulate(list, "{", (state, current) => state & Text.From(current)) & "}"
		),	
		// or (list as list) as text => "{""" & Text.Combine(list, """, """) & """}"
		
		/* 	
			–í–∞—Ä–∏–∞–Ω—Ç 2. –¢–∞–∫ –∂–µ –∫–∞–∫ –∏ –≤—ã—à–µ, –Ω–æ –¥–æ–±–∞–≤–ª—è–µ—Ç, –º–µ–∂–¥—É –∑–Ω–∞—á–µ–Ω–∏—è–º–∏
			—Ñ—É–Ω–∫—Ü–∏—è ListAsText - —á–µ—Ä–µ–∑ –∑–∞–ø—è—Ç—É—é
			from: https://github.com/microsoft/DataConnectors/blob/460babf2f8c44ec82d7e08d1b65b156984c6ba75/samples/UnitTesting/UnitTesting.query.pq#L210-L244
			
			–û–¥–Ω–æ–π —Å—Ç—Ä–æ–∫–æ–π:
				ListAsText = (x)=> "{" & List.Accumulate(x, "", (s,item) => if s="" then Text.From(item) else s & ", " & Text.From(item)) & "}"

			–ü—Ä–∏–º–µ—Ä
				let	NameList = { "moNkey", "monKEY", "MONKEY", "mONkeY" },
					Source   = Table.FromList(NameList, null,type table[Name = text],null, null),
					Results  = [
						#"Original List" 					= ListAsText(  Source[Name] ),
						#"IsDistinct? Ordinal" 				= List.IsDistinct( Source[Name], Comparer.Ordinal ),
						#"IsDistinct? OrdinalIgnoreCase" 	= List.IsDistinct( Source[Name], Comparer.OrdinalIgnoreCase ),
						#"Distinct using OrdinalIgnoreCase" = ListAsText(  List.Distinct( Source[Name], Comparer.OrdinalIgnoreCase ) ),
						#"Distinct using Ordinal" 			= ListAsText(  List.Distinct( Source[Name], Comparer.Ordinal ) )
					]
				in	Results	
		),*/
				
	List.ToRecord 		= // –∫–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ—Ç —Å–ø–∏—Å–æ–∫ –≤ –∑–∞–ø–∏—Å—å —Å –ª—è–º–±–¥–∞ —Ñ—É–Ω–∫—Ü–∏–µ–π –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏—è
		/*  
            –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ—Ç —Å–ø–∏—Å–æ–∫ —Å—Ç—Ä–æ–∫ –≤ –∑–∞–ø–∏—Å—å, –∏—Å–ø–æ–ª—å–∑—É—è –ª—è–º–±–¥—É —Ñ—É–Ω–∫—Ü–∏—é (–ø–µ—Ä–µ–¥–∞–Ω–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è x)
            –í—Å—Ç—Ä–æ–µ–Ω–Ω—ã–π Record.FromList –ø—Ä–∏–Ω–∏–º–∞–µ—Ç —Ç–æ–ª—å–∫–æ —Å—Ç–∞—Ç–∏—á–µ—Å–∫–∏–µ —Å–ø–∏—Å–∫–∏
			–í —Å–ø–∏—Å–∫–µ –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —Ç–æ–ª—å–∫–æ —Ç–µ–∫—Å—Ç, —Ç.–∫. —ç—Ç–æ –∏–º–µ–Ω–∞ –ø–æ–ª–µ–π

            Usage:	F[List.ToRecord]( {"a","b"}, (x)=> Text.Upper(x) )
            Result: [a="A", b="B"]

			Usage:	F[List.ToRecord]( {"1","2"}, (x)=> Number.From(x) + 1 )
			Result:	[1=2, 2=3]
		*/
		Document(
			"List.ToRecord", 
			"–ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ—Ç —Å–ø–∏—Å–æ–∫ –≤ –∑–∞–ø–∏—Å—å",
			{[ 	Description = "–ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ—Ç —Å–ø–∏—Å–æ–∫ –≤ –∑–∞–ø–∏—Å—å", 
				Code 		= "List.ToRecord({""a"",""b""}, (k) => Text.Upper(k))", 
				Result 		= "[a=""A"", b=""B""]"	]},
			
			(List as list, Lambda as function) as record =>
				let
					Transformed = List.Transform(List, Lambda)	//each Lambda(_)
				in
					Record.FromList(Transformed, List)
		),
		
	List.ToZip    		= // –∫–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ—Ç –ø–∞—Ä—É —Å–ø–∏—Å–∫–æ–≤ –≤ —Å–ø–∏—Å–æ–∫ –∑–∞–ø–∏—Å–µ–π, –µ—Å–ª–∏ —É–∫–∞–∑–∞–Ω—ã –∏–º–µ–Ω–∞
		/*
			–ê—Ä—Ö–∏–≤–∏—Ä—É–µ—Ç —Å–ø–∏—Å–æ–∫ —Å–ø–∏—Å–∫–æ–≤, —á—Ç–æ–±—ã ¬´—Ç—Ä–∞–Ω—Å–ø–æ–Ω–∏—Ä–æ–≤–∞—Ç—å¬ª –∏—Ö ‚Äî –∫–∞–∫ –∑–∞–ø–∏—Å–∏, –µ—Å–ª–∏ —É–∫–∞–∑–∞–Ω—ã –∏–º–µ–Ω–∞
			–ï—Å–ª–∏ –∏–º–µ–Ω–∞ –Ω–µ —É–∫–∞–∑–∞–Ω—ã, —Ç–æ –±—É–¥–µ—Ç –≤–æ–∑–≤—Ä–∞—Ç–∏—Ç—Å—è —Å–ø–∏—Å–æ–∫ —Å–ø–∏—Å–∫–æ–≤, —á—Ç–æ –∞–Ω–∞–ª–æ–≥–∏—á–Ω–æ List.Zip
		
			–ü—Ä–∏–º–µ—Ä		F[List.ToZip]( { {1,2,3}, {"a","b","c"} }, {"Name","Value"} )
			–†–µ–∑—É–ª—å—Ç–∞—Ç	{ [Name=1, Value="a"], 
						  [Name=2, Value="b"], 
						  [Name=3, Value="c"] }
			
			Usage:  	List.ToZip( { {1,2,3}, {"a","b","c"} } )
			Result: 	{ {1,"a"}, {1,"b"}, {1,"c"}, }
		*/

		(listOfLists as list, optional names as list) as list =>
		let
			max 	= List.Max(List.Transform(listOfLists, each List.Count(_))),
			zipped 	= List.Skip(
				List.Generate(
					()=>[
						i = -1,
						vals = {},
						combined = {}
					],
					each [i] < max,
					each [
						i = [i] + 1,
						vals = List.Transform(listOfLists, each _{i}),
						combined = 	if names = null 
									then vals 
									else Record.FromList(vals, names)
					],
					each [combined]
				))
		in
			zipped,

	List.ReplaceErrors	= // —É–¥–∞–ª—è–µ—Ç –æ—à–∏–±–∫–∏ –≤ —Å–ø–∏—Å–∫–µ –∏–ª–∏ –∑–∞–º–µ–Ω—è–µ—Ç –∏—Ö –Ω–∞ –∑–Ω–∞—á–µ–Ω–∏–µ
		/*
			–û–ø–∏—Å–∞–Ω–∏–µ:	–ó–∞–º–µ–Ω—è–µ—Ç –∑–Ω–∞—á–µ–Ω–∏—è –æ—à–∏–±–æ–∫ –≤ –¥–∞–Ω–Ω–æ–º —Å–ø–∏—Å–∫–µ –ø–µ—Ä–µ–¥–∞–Ω–Ω—ã–º –∑–Ω–∞—á–µ–Ω–∏–µ–º –∑–∞–º–µ–Ω—ã (–∏–ª–∏ –Ω—É–ª–µ–º, –µ—Å–ª–∏ –∑–∞–º–µ–Ω–∞ –æ–ø—É—â–µ–Ω–∞)
			–ü—Ä–∏–º–µ—Ä:		= F[List.RemoveErrors] ({1,2,error "this is an error",4})
			–ü—Ä–∏–º–µ—Ä:		= F[List.RemoveErrors] ({1,2,error "this is an error",4}, "–æ—à–∏–±–∫–∞") // –Ω–µ –ø—Ä–æ–≤–µ—Ä—è–ª –≤—Ç–æ—Ä–æ–π –∞—Ä–≥—É–º–µ–Ω—Ç
			–†–µ–∑—É–ª—å—Ç–∞—Ç:	= {1,2,4}
		*/
		(ListWithError as list, optional Replacement as any) as list =>
			List.Transform(
				List.Positions(ListWithError), 
				each try ListWithError{_} otherwise Replacement
			),
  
	List.RemoveErrors   = // —É–¥–∞–ª—è–µ—Ç –∏–∑ —Å–ø–∏—Å–∫–∞ Error (—Å —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏–µ–π —Å–ø–∏—Å–∫–∞ –≤ —Ç–∞–±–ª–∏—Ü—É, —á–µ—Ä–µ–∑ Table.RemoveRowsWithErrors)
        /*
            –û–ø–∏—Å–∞–Ω–∏–µ:	–ü—Ä–∏–Ω–∏–º–∞–µ—Ç —Å–ø–∏—Å–æ–∫ –≤ –∫–∞—á–µ—Å—Ç–≤–µ –≤—Ö–æ–¥–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Ç–æ—Ç –∂–µ —Å–ø–∏—Å–æ–∫, –Ω–æ –±–µ–∑ –∑–Ω–∞—á–µ–Ω–∏–π –æ—à–∏–±–æ–∫.
            –ü–æ–ª–µ–∑–Ω–æ:	–ö–æ–≥–¥–∞ –æ—à–∏–±–∫–∏ –≤ —Å–ø–∏—Å–æ–∫/—Å—Ç–æ–ª–±–µ—Ü –ø—Ä–∏—à–ª–∏ –∏–∑ –≤–Ω–µ—à–Ω–µ–≥–æ –∏—Å—Ç–æ—á–Ω–∏–∫–∞ –∏ –Ω–µ—Ç –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏ —É—Å—Ç—Ä–∞–Ω–∏—Ç—å –æ—à–∏–±–∫–∏ –ø–µ—Ä–µ–¥ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º —Å–ø–∏—Å–∫–∞.
            –ü—Ä–∏–º–µ—Ä:		= List.RemoveErrors({1,2,error "this is an error",4})
            –†–µ–∑—É–ª—å—Ç–∞—Ç:	= {1,2,4}
        */
		(ListWithErrors as list) as list =>
			let
				CleanList = Table.RemoveRowsWithErrors(Table.FromColumns({ListWithErrors}))[Column1]
			in
				CleanList
		/*  
            –í–∞—Ä–∏–∞–Ω—Ç 2.
			–£–¥–∞–ª—è–µ—Ç –∏–∑ —Å–ø–∏—Å–∫–∞ Error (–±–µ–∑ –∑–∞–º–µ–Ω—ã, –±–µ–∑ —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏–∏ —Å–ø–∏—Å–∫–∞ –≤ —Ç–∞–±–ª–∏—Ü—É, —á–µ—Ä–µ–∑ List.Accumulate) 
			(ListWithError as list) as list =>
					List.Accumulate(
						List.Positions(ListWithError),
						{},
						(CleanListSoFar, CurrentPosition) =>
							CleanListSoFar & 
							(   if (try ListWithError{CurrentPosition})[HasError] 
								then {} 
								else { ListWithError{CurrentPosition} }
							)
					)
				in	Source,		
			*/
		,
			
	List.RemovePositions = // —É–¥–∞–ª—è–µ—Ç –∏–∑ —Å–ø–∏—Å–∫–∞ —ç–ª–µ–º–µ–Ω—Ç—ã –ø–æ –Ω–æ–º–µ—Ä—É –ø–æ–∑–∏—Ü–∏–∏ 
		/*
			–ü—Ä–∏ –≤—ã–∑–æ–≤–µ —ç—Ç–æ–π —Ñ—É–Ω–∫—Ü–∏–∏ –º—ã –º–æ–∂–µ–º —É–¥–∞–ª–∏—Ç—å —ç–ª–µ–º–µ–Ω—Ç—ã –Ω–∞ 2-–π –∏ 4-–π –ø–æ–∑–∏—Ü–∏—è—Ö –∏–Ω–¥–µ–∫—Å–∞ –∏–∑ —Å–ø–∏—Å–∫–∞:
			Used	List.RemovePositions( { "a".."g" } , { 2, 4 } ) 
			Output	{ "a", "b", "d", "f", "g" }
		*/
		( list as list, removeIndexes as list ) as list =>
			let
				Source     = list, 
				RemoveN    = removeIndexes, 
				Indexes    = List.Positions ( Source ), 
				KeepValues = List.Difference ( Indexes, RemoveN ), 
				Result     = List.Transform ( KeepValues, each Source{_} )
			in
				Result,
	
	List.SelectPositions = // –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç N-–π —ç–ª–µ–º–µ–Ω—Ç –∏–∑ —Å–ø–∏—Å–∫–∞,
		/* 
			–í—ã–∑–æ–≤–∏—Ç–µ —ç—Ç—É —Ñ—É–Ω–∫—Ü–∏—é fxListSelectPositions –∫–∞–∂–¥—ã–π —Ä–∞–∑, –∫–æ–≥–¥–∞ –≤–∞–º –Ω—É–∂–Ω–æ –ø–æ–ª—É—á–∏—Ç—å N-–π —ç–ª–µ–º–µ–Ω—Ç –∏–∑ —Å–ø–∏—Å–∫–∞, –≤—ã –º–æ–∂–µ—Ç–µ –ø—Ä–æ—Å—Ç–æ –Ω–∞–ø–∏—Å–∞—Ç—å:
			fxListSelectPositions( {"a".."z"}, {10, 15, 20 } )
		*/
		( inputList as list, positions as list ) as list =>
			let
				myList 	  = inputList,
				BufferList = List.Buffer( myList ),
				Positions  = positions,
				FetchItems = List.Transform( Positions,  each BufferList { _ } )
			in
				FetchItems,
	
	// –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ
	List.CrossJoin      = // –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –ø–µ—Ä–µ–∫—Ä–µ—Å—Ç–Ω–æ–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –¥–≤—É—Ö —Å–ø–∏—Å–∫–æ–≤ –≤ –≤–∏–¥–µ —Ç–∞–±–ª–∏—Ü—ã
        /*
            –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –ø–µ—Ä–µ–∫—Ä–µ—Å—Ç–Ω–æ–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –¥–≤—É—Ö –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤ (–º–æ–≥—É—Ç –±—ã—Ç—å —Å–ø–∏—Å–∫–∞–º–∏ –∏–ª–∏ —Ç–∞–±–ª–∏—Ü–∞–º–∏)

            Usage:	List.CrossJoin({"A","B"},{1..3})
            Result: 
                #table(
                    {"A","B"},
                    {
                        {"A",1},
                        {"A",2},
                        {"A",3},
                        {"B",1},
                        {"B",2},
                        {"B",3}
                    }
                )
        */

        (A as list, B as list) as table =>
        let
            firstList        = List.RemoveNulls(A),
            secondList       = List.RemoveNulls(B),
            firstLength      = List.Count(firstList),
            secondLength     = List.Count(secondList),
            resultFirstList  = 
                List.Generate( 
                    () => 0, 
                    each _ < firstLength * secondLength, 
                    each _ + 1, 
                    each firstList{ Number.IntegerDivide(_, secondLength) }
                ),
            resultSecondList = List.Repeat( secondList, firstLength)
        in
            Table.FromColumns({resultFirstList, resultSecondList}),

    List.FlatMap        = // —Å–æ–ø–æ—Å—Ç–∞–≤–ª—è–µ—Ç —Å–ø–∏—Å–æ–∫ —Å –ø–æ–º–æ—â—å—é –õ–Ø–ú–ë–î–´, –æ–±—ä–µ–¥–∏–Ω—è—è –≤—Å–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã –≤ –æ–¥–∏–Ω —Å–ø–∏—Å–æ–∫ 
        /*
            –û–ø–∏—Å–∞–Ω–∏–µ	–°–æ–ø–æ—Å—Ç–∞–≤–ª—è–µ—Ç —Å–ø–∏—Å–æ–∫ —Å –ø–æ–º–æ—â—å—é –ª—è–º–±–¥–∞ —Ñ—É–Ω–∫—Ü–∏–∏ —Ç–∞–∫–∏–º –æ–±—Ä–∞–∑–æ–º, —á—Ç–æ –≤—Å–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã —Å–Ω–æ–≤–∞ –æ–±—ä–µ–¥–∏–Ω—è—é—Ç—Å—è –≤ –æ–¥–∏–Ω —Å–ø–∏—Å–æ–∫
            –ü—Ä–∏–º–µ—Ä 1	= List.FlatMap({1,2,3}, (x)=> List.Numbers(1, x))	–†–µ–∑—É–ª—å—Ç–∞—Ç 	= {1, 1, 2, 1, 2, 3}
        */

        (lst as list, fx as function) => 
			List.Combine(List.Transform(lst, fx)),

    List.RankDense      = // —Ä–∞–Ω–∂–∏—Ä—É–µ—Ç –≤—Ö–æ–¥–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –≤ —Å–µ—Ä–∏–∏. –£–¥–∞–ª—è–µ—Ç –¥—É–±–ª–∏–∫–∞—Ç—ã, —á—Ç–æ–±—ã —Ä–∞–Ω–∂–∏—Ä–æ–≤–∞—Ç—å —É–Ω–∏–∫–∞–ª—å–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è 
        /*
            –û–ø–∏—Å–∞–Ω–∏–µ		–†–∞–Ω–∂–∏—Ä—É–µ—Ç –≤—Ö–æ–¥–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –≤ —Å–µ—Ä–∏–∏ (–ø–æ –≤–æ–∑—Ä–∞—Å—Ç–∞–Ω–∏—é –∏–ª–∏ —É–±—ã–≤–∞–Ω–∏—é). 
			–û—Å–æ–±–µ–Ω–Ω–æ—Å—Ç—å		–£–¥–∞–ª—è–µ—Ç –¥—É–±–ª–∏–∫–∞—Ç—ã, —á—Ç–æ–±—ã —Ä–∞–Ω–∂–∏—Ä–æ–≤–∞—Ç—å —Ç–æ–ª—å–∫–æ —É–Ω–∏–∫–∞–ª—å–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è.
            –°—Å—ã–ª–∫–∞			http://social.technet.microsoft.com/Forums/en-US/973e9381-ff46-4756-a071-88bb4c2105e4/pushing-more-calcs-to-power-query-replacing-dax-rankx
            –ü—Ä–∏–º–µ—Ä			= F[List.RankDense] ("B",{"A","A","B","C"})
            Result			2
        */

        (inputValue as any, inputSeries as list, optional orderDescending as nullable logical) as number => 
			let
				order 			= if orderDescending or orderDescending = null then Order.Descending else Order.Ascending,
				SortedSeries    = List.Sort(inputSeries, order),
				DistinctSeries  = List.Distinct(SortedSeries),
				RankDense       = List.PositionOf(DistinctSeries,inputValue)+1
			in
				RankDense,

    List.RankEqual      = // —Ä–∞–Ω–∂–∏—Ä—É–µ—Ç –≤—Ö–æ–¥–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –≤ —Å–µ—Ä–∏–∏. –ù–µ —É–¥–∞–ª—è–µ—Ç –¥—É–±–ª–∏–∫–∞—Ç—ã 
        /*
            –û–ø–∏—Å–∞–Ω–∏–µ 	–†–∞–Ω–∂–∏—Ä—É–µ—Ç –≤—Ö–æ–¥–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –≤ —Å–µ—Ä–∏–∏ (–ø–æ –≤–æ–∑—Ä–∞—Å—Ç–∞–Ω–∏—é –∏–ª–∏ —É–±—ã–≤–∞–Ω–∏—é). –ù–µ —Ñ–∏–ª—å—Ç—Ä—É–µ—Ç –¥—É–±–ª–∏–∫–∞—Ç—ã.
			–°—Å—ã–ª–∫–∞		http://social.technet.microsoft.com/Forums/en-US/973e9381-ff46-4756-a071-88bb4c2105e4/pushing-more-calcs-to-power-query-replacing-dax-rankx
            –ü—Ä–∏–º–µ—Ä		= F[List.RankEqual] ("B",{"A","A","B","C"})
            Result     	3	
			–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç 	–Ω–æ–º–µ—Ä –≤—Ö–æ–∂–¥–µ–Ω–∏—è –∏—Å–∫–æ–º–æ–≥–æ —ç–ª–µ–º–µ–Ω—Ç–∞ –ø–æ—Å–ª–µ —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∏

        */
        (inputValue as any, inputSeries as list, optional orderDescending as nullable logical) as number => 
			let
				order 		 = if orderDescending or orderDescending = null then Order.Descending else Order.Ascending,
				SortedSeries = List.Sort(inputSeries, order),
				RankEqual    = List.PositionOf(SortedSeries,inputValue) + 1
			in
				RankEqual,

    // –¥–∞—Ç—ã
	List.DatesBetween   	= // —Å–æ–∑–¥–∞–µ—Ç —Å–ø–∏—Å–æ–∫ –¥–∞—Ç –º–µ–∂–¥—É –∑–∞–¥–∞–Ω–Ω—ã–º–∏ –¥–≤—É–º—è –¥–∞—Ç–∞–º–∏
        /*
            –û–ø–∏—Å–∞–Ω–∏–µ:
				List_DatesBetween —è–≤–ª—è–µ—Ç—Å—è –∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–æ–π —Ñ—É–Ω–∫—Ü–∏–∏ List.Dates. 
            	–û–Ω –ø—Ä–∏–Ω–∏–º–∞–µ—Ç —Ç–æ–ª—å–∫–æ –¥–≤–µ –¥–∞—Ç—ã –≤ –∫–∞—á–µ—Å—Ç–≤–µ –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤ –∏ —Å–æ–∑–¥–∞–µ—Ç —Å–ø–∏—Å–æ–∫ –¥–∞—Ç –º–µ–∂–¥—É –∑–∞–¥–∞–Ω–Ω—ã–º–∏ –¥–≤—É–º—è –¥–∞—Ç–∞–º–∏
            Usage: 
                List_DatesBetween(11/17/2016, 12/19/2016)
        */

        (dateStart as date, dateFinish as date) =>
			let
				countOfDays = Number.From(dateFinish - dateStart),
				output =    if countOfDays > 0 
							then List.Dates(dateStart, countOfDays + 1, #duration(1,0,0,0))
							else "Error! Your inputs are incorrect. Check the inputs." 
			in
				output,

    List.Dates.HolidaysRU 	= 
        /*	Function gets list of non-working days (weekends and official holidays) 
			from official source "Open Data" managed by Analytical Center of Russian Federation
			
			Function has two arguments - From_Year, To_Year
			which allows to restrict period of time that you need for your data model.
			
			Usage:		List.Dates.HolidaysRU( 2015, 2016 )
			Response:	List of non-working days in Russian Federations for years 2015 and 2016
		*/

        (from_year as number, to_year as number) =>
            let
                fGetLatestURL = 
                    let
                        Source = Table.FromColumns({Lines.FromBinary(Web.Contents("http://data.gov.ru/node/19107/code-passport"))}),
                        #"Filtered Rows" = Table.SelectRows(Source, each Text.Contains([Column1], "–ì–∏–ø–µ—Ä—Å—Å—ã–ª–∫–∞ (URL) –Ω–∞ –Ω–∞–±–æ—Ä")),
                        #"Get Text with URL" = #"Filtered Rows"{0}[Column1],
                        #"Position of HTTP" = Text.PositionOf(#"Get Text with URL", "http"),
                        #"Position of CSV" = Text.PositionOf( #"Get Text with URL", ".csv" ),
                        URL = Text.Range( #"Get Text with URL", #"Position of HTTP", #"Position of CSV" - #"Position of HTTP" + 4 )
                    in
                        URL,

                Source = Csv.Document(Web.Contents( fGetLatestURL ),[Delimiter=",", Columns=13, Encoding=65001, QuoteStyle=QuoteStyle.None]),		
                #"Promoted Headers" = Table.PromoteHeaders( Source ),
                #"Changed Type" = Table.TransformColumnTypes(#"Promoted Headers",{{"–ì–æ–¥/–ú–µ—Å—è—Ü", Int64.Type}}),
                #"Filtered Rows1" = Table.SelectRows(#"Changed Type", each [#"–ì–æ–¥/–ú–µ—Å—è—Ü"] >= from_year and [#"–ì–æ–¥/–ú–µ—Å—è—Ü"] <= to_year ),
                #"Renamed Columns1" = Table.RenameColumns(#"Filtered Rows1",{{"–Ø–Ω–≤–∞—Ä—å", "1"}, {"–§–µ–≤—Ä–∞–ª—å", "2"}, {"–ú–∞—Ä—Ç", "3"}, {"–ê–ø—Ä–µ–ª—å", "4"}, {"–ú–∞–π", "5"}, {"–ò—é–Ω—å", "6"}, {"–ò—é–ª—å", "7"}, {"–ê–≤–≥—É—Å—Ç", "8"}, {"–°–µ–Ω—Ç—è–±—Ä—å", "9"}, {"–û–∫—Ç—è–±—Ä—å", "10"}, {"–ù–æ—è–±—Ä—å", "11"}, {"–î–µ–∫–∞–±—Ä—å", "12"}, {"–ì–æ–¥/–ú–µ—Å—è—Ü", "–ì–æ–¥"}}),
                #"Unpivoted Other Columns" = Table.UnpivotOtherColumns(#"Renamed Columns1", {"–ì–æ–¥"}, "Attribute", "Value"),
                #"Split Column by Delimiter" = Table.SplitColumn(#"Unpivoted Other Columns","Value",Splitter.SplitTextByDelimiter(",", QuoteStyle.Csv) ),
                #"Unpivoted Other Columns1" = Table.UnpivotOtherColumns(#"Split Column by Delimiter", {"–ì–æ–¥", "Attribute"}, "Attribute.1", "Value"),
                #"Removed Columns" = Table.RemoveColumns(#"Unpivoted Other Columns1",{"Attribute.1"}),
                #"Renamed Columns" = Table.RenameColumns(#"Removed Columns",{{"Attribute", "–ú–µ—Å—è—Ü"}, {"Value", "–î–µ–Ω—å"}}),
                #"Filtered Rows" = Table.SelectRows(#"Renamed Columns", each not Text.Contains([–î–µ–Ω—å], "*")),
                #"Changed Type1" = Table.TransformColumnTypes(#"Filtered Rows",{{"–ú–µ—Å—è—Ü", Int64.Type}, {"–î–µ–Ω—å", Int64.Type}}),
                #"Added Custom" = Table.AddColumn(#"Changed Type1", "Date", each #date( [–ì–æ–¥], [–ú–µ—Å—è—Ü], [–î–µ–Ω—å] ), type date),
                #"Removed Other Columns1" = Table.SelectColumns(#"Added Custom",{"Date"})

            in
                #"Removed Other Columns1",
    
    List.Dates.LastNDays  	= 
        (N as number) => 
            List.Dates(Date.AddDays(Date.From(DateTime.FixedLocalNow()), -N), N, #duration(1,0,0,0)),

    List.Dates.LastNYears 	= 
        (N as number) =>
            let
                start 	= Date.StartOfYear(Date.AddYears(Date.From(DateTime.FixedLocalNow()), -N)),
                end 	= Date.EndOfYear(Date.AddYears(Date.From(DateTime.FixedLocalNow()), -1)),
                result 	= List.Dates(start, Duration.Days(end - start) + 1, #duration(1,0,0,0))
            in 
                result,

    List.Dates.LastNYearsAndCurYear  = 
        // last N years and Current year
        (N as number) =>
            let
                start 	= Date.StartOfYear(Date.AddYears(Date.From(DateTime.FixedLocalNow()), -N)),
                end 	= Date.EndOfYear(Date.From(DateTime.FixedLocalNow())),
                result 	= List.Dates(start, Duration.Days(end - start) + 1, #duration(1,0,0,0))
            in 
                result,

    List.Dates.NYearsToDate          = 
        // N years to today
        (N as number) =>
            let
                start 	= Date.StartOfYear(Date.AddYears(Date.From(DateTime.FixedLocalNow()), -N)),
                end 	= Date.From(DateTime.FixedLocalNow()),
                result 	= List.Dates(start, Duration.Days(end - start) + 1, #duration(1,0,0,0))
            in 
                result,
    
    List.Dates.R12MExcCurMonth       = 
        () =>
            let
                start  = Date.StartOfMonth(Date.AddMonths(Date.From(DateTime.FixedLocalNow()), -12)),
                end    = Date.AddDays(Date.StartOfMonth(Date.From(DateTime.FixedLocalNow())), -1),
                result = List.Dates(start, Duration.Days(end - start) + 1, #duration(1,0,0,0))
            in 
                result,
    
    List.Dates.R12MIncCurMonthToDate = 
        () =>
            let
                start   = Date.StartOfMonth(Date.AddMonths(Date.From(DateTime.FixedLocalNow()), -11)),
                end     = Date.From(DateTime.FixedLocalNow()),
                result  = List.Dates(start, Duration.Days(end - start) + 1, #duration(1,0,0,0))
            in 
                result,
    
    List.Dates.YTD          = 
        () =>
            let
                start   = Date.StartOfYear(Date.From(DateTime.FixedLocalNow())),
                end     = Date.From(DateTime.FixedLocalNow()),
                result  = List.Dates(start, Duration.Days(end - start) + 1, #duration(1,0,0,0))
            in 
                result,

    List.Dates.YTDLastYear  = 
        () =>
            let
                start 	= Date.StartOfYear(Date.AddYears(Date.From(DateTime.FixedLocalNow()), -1)),
                end 	= Date.AddYears(Date.From(DateTime.FixedLocalNow()), -1),
                result  = List.Dates(start, Duration.Days(end - start) + 1, #duration(1,0,0,0))
            in 
                result,
	// —Ä–∞–∑–æ–±—Ä–∞—Ç—å
	List.TransformSaveType = // —Å–ø–∏—Å–æ–∫ + –ª—è–º–±–¥–∞ —Ñ—É–Ω–∫—Ü–∏—è. –°–æ—Ö—Ä–∞–Ω—è–µ—Ç —Ç–∏–ø—ã –Ω–∞ –≤—ã—Ö–æ–¥–µ //* –ù–∞–¥–æ –Ω–∞ –ø—Ä–∏–º–µ—Ä–µ –ø–æ–ø—Ä–æ–±–æ–≤–∞—Ç—å
		/*	
			–û–ø–∏—Å–∞–Ω–∏–µ
				–≠—Ç–∏ —Ñ—É–Ω–∫—Ü–∏–∏ –≤ –æ—Å–Ω–æ–≤–Ω–æ–º –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è—é—Ç —Å–æ–±–æ–π –≤–µ—Ä—Å–∏–∏ —Ñ—É–Ω–∫—Ü–∏–π, —Å–æ–∑–¥–∞–Ω–Ω—ã—Ö Microsoft. 
				–û–¥–Ω–∞–∫–æ —ç—Ç–∏ —Ñ—É–Ω–∫—Ü–∏–∏ –ø–æ–º–æ–≥–∞—é—Ç —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å –≤–æ–∑–≤—Ä–∞—â–∞–µ–º—ã–µ —Ç–∏–ø—ã —Ñ—É–Ω–∫—Ü–∏–π, –∫–æ—Ç–æ—Ä—ã–µ —Ç–∞–∫ –ª–µ–≥–∫–æ —Ç–µ—Ä—è—é—Ç—Å—è. 
				–û–¥–Ω–∏–º –∏–∑ –ø—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∏—Ö —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è —ç—Ç–∏—Ö —Ñ—É–Ω–∫—Ü–∏–π –≤ –≤–∞—à–∏—Ö –∑–∞–ø—Ä–æ—Å–∞—Ö —è–≤–ª—è–µ—Ç—Å—è —Ç–æ, 
				—á—Ç–æ —Å—Ç–æ–ª–±—Ü—ã –≤–∞—à–µ–π —Ç–∞–±–ª–∏—Ü—ã —Å –º–µ–Ω—å—à–µ–π –≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å—é –∏–∑–º–µ–Ω—è—Ç—Å—è –Ω–∞ –∫–∞–∫–æ–π-–ª–∏–±–æ —Ç–∏–ø 

			–ü—Ä–∏–º–µ—Ä

		*/
		(list as list, transform as function)=>
		let
			listTransform = List.Transform(list, transform),
			listType      = type {Type.FunctionReturn(Value.Type(transform))}
		in
			Value.ReplaceType(listTransform,listType),
   
	
	//======================== 
	// Number
	//======================== 
	Number.Digits 	 = {0,1,2,3,4,5,6,7,8,9},
	Number.ParseText = // –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ –∏–¥—É—â–∏–µ —Ü–∏—Ñ—Ä—ã –≤ —Ç–µ–∫—Å—Ç–æ–≤–æ–π —Å—Ç—Ä–æ–∫–µ —Å–ª–µ–≤–∞ (–º–æ–∂–Ω–æ —Å–ø–∏—Å–æ–∫ —Å–∏–º–≤–æ–ª–æ–≤ –∏—Å–∫–ª—é—á–µ–Ω–∏–π)
		/*
			–û–ø–∏—Å–∞–Ω–∏–µ 	
				–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –ø–µ—Ä–≤–æ–µ —á–∏—Å–ª–æ (1 + –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω—ã–µ —Ü–∏—Ñ—Ä—ã) –≤  —Ç–µ–∫—Å—Ç–µ. 
				–ü—Ä–∏ –∂–µ–ª–∞–Ω–∏–∏ –º–æ–∂–Ω–æ —É–∫–∞–∑–∞—Ç—å —Ä–∞–∑—Ä–µ—à–µ–Ω–Ω—ã–µ —Å–∏–º–≤–æ–ª—ã, —á—Ç–æ–±—ã –∏—Ö –∏–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞—Ç—å.
			–û—Å–æ–±–µ–Ω–Ω–æ—Å—Ç–∏
				–Ω–∞—á–∏–Ω–∞–µ—Ç —Å –ø–µ—Ä–≤–æ–≥–æ –Ω–∞–π–¥–µ–Ω–Ω–æ–π —Ü–∏—Ñ—Ä—ã, –æ—Å—Ç–∞–ª—å–Ω—ã–µ –∏–≥–Ω–æ—Ä–∏—Ä—É—é—Ç—Å—è
			–ê—Ä–≥—É–º–µ–Ω—Ç—ã
				text as text						- —Ç–µ–∫—Å—Ç
				optional startIndex as number		- —Å—Ç–∞—Ä—Ç–æ–≤—ã–π –∏–Ω–¥–µ–∫—Å
				optional allowCharacters as list	- —Å–ø–∏—Å–æ–∫ –∏—Å–∫–ª—é—á–∞–µ–º—ã—Ö —Å–∏–º–≤–æ–ª–æ–≤
			–ü—Ä–∏–º–µ—Ä		
				= F[Number.ParseText]("–ß–∏—Å–ª–æ 9000!", 0, {"",""}) 	= "9000"	// —Ç–æ–ª—å–∫–æ —á–∏—Å–ª–∞	
				= F[Number.ParseText]("–ß–∏—Å–ª–æ 9000!", 8, {"","!"}) 	= "00!"		// —á–∏—Å–ª–∞ + ! –Ω–∞—á–∏–Ω–∞—è —Å 8 —Å–∏–º–≤–æ–ª–∞
				= F[Number.ParseText]("1 –ß–∏—Å–ª–æ 9000!", 0, {"",""}) 	= "1"		// –ø–µ—Ä–≤–æ–µ —á–∏—Å–ª–æ —Å–ª–µ–≤–∞
			–í—ã–≤–æ–¥		
				—Ç–µ–∫—Å—Ç–æ–≤–∞—è —Å—Ç—Ä–æ–∫–∞
		*/

		Document(
			"Number.ParseText",
			"Returns the first number (1+ consecutive digits) in the given text. Optionally, provide allowed characters to ignore them",
			{[ 	Description = "Allow commas", 
				Code		= "F[Number.ParseText](""–ß–∏—Å–ª–æ 9,000!"", 0, {"",""})", 
				Result 		= "9000" ]},

			(text as text, optional startIndex as number, optional allowCharacters as list) => 
				let
					consider = if startIndex is null then text else Text.Range(text,startIndex), 
					_allowCharacters = if allowCharacters is null then {} else allowCharacters,
					numberSeries = 
						List.FirstN(
							List.Skip(
								Text.ToList(consider), 
								each not Text.IsNumber(_)
							), 
							each Text.IsNumber(_) or List.Contains(_allowCharacters, _)
						)
				in 
					if text is null then null else Text.FromList(numberSeries)	
		),

	Number.ToLetters = // –ø–µ—Ä–µ–≤–æ–¥–∏—Ç —á–∏—Å–ª–æ (–Ω–∞—á–∏–Ω–∞—è —Å 1) –≤ –∞–ª—Ñ–∞–≤–∏—Ç–Ω–æ–µ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏–µ (–∫–∞–∫ –∑–∞–≥–æ–ª–æ–≤–∫–∏ —Å—Ç–æ–ª–±—Ü–æ–≤ –≤ Excel, 2->B)
		Document(
			"Number.ToLetters",
			"Converts a number  (starting at 1) to an alphabet representation. Works like column headers in Excel.",
			{[ 	Description = "Column 27", 
				Code 		= "F[Number.ToLetters](27)", 
				Result 		= "AB"	]},
			
			(value as number) =>
				let
					GetLetter = (num as number) => 
						let 
							number = Number.Mod(num, 26),
							val    = if number = 0 then 26 else number,
							valid  = number < 26 and number > 0 
						in 
							if valid 
							then Text.At(Text.Alphabet, val - 1) 
							else error "Can't get letter for " & Text.From(num),
					
					func = (value as number, factor as number) =>
						let
							ThisLetter = GetLetter(Number.RoundDown(value/Number.Power(26, factor))),
							Result = 
								if value <= Number.Power(26, factor) 
								then "" 
								else @func(value, factor+1) & ThisLetter
						in
							Result
				in
					if value <= 26 
					then GetLetter(value) 
					else func(value, 1) & GetLetter(value)	
		),

	Number.Dec2Bin 	 = // 
        /*
            Description:	Function that converts number from decimal to binary notation
            Link:			https://support.office.com/en-us/article/DEC2BIN-function-0f63dd0e-5d1a-42d8-b511-5bf5c6d43838
            Usage:  		Number.Dec2Bin( 1026 )
            Result: 		10000000010
			
			–≤ –¥—Ä—É–≥–æ–º –º–µ—Å—Ç–µ –±—ã–ª–æ —Ç–∞–∫:
				Number.DecToBin = (num as number)=>
					List.Last(
						List.Generate(
							() =>[	reminder  = num,	
									binString = Number.ToText(Number.BitwiseAnd(reminder,1))
								 ],
							each [	reminder ] > 0,
							each [	reminder  = Number.BitwiseShiftRight([reminder],1),
								  	binString = Number.ToText(Number.BitwiseAnd(reminder,1))&[binString]
								 ],
							each [	binString ]
							))
        */

        (num as number, optional string as nullable text) =>
            let
                input_string = if string = null then "" else string,
                reminder     = Number.Mod( num, 2 ),
                result		 = Text.From( reminder ) & input_string,
                input  		 = Number.IntegerDivide( num, 2 ),
                return = if input > 0 
                         then @Number.Dec2Bin( input , result) // ! Number_Dec2Bin
                         else result
            in
                return,

	Number.HexToDec  = // 
		(hexString as text) => 
			Expression.Evaluate("0x"&hexString),

	//======================== 
	// Splitters
	//======================== 
	Splitter.SplitTextByNonAlpha = // –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–ø–∏—Å–æ–∫ –±—É–∫–≤ –∏–∑ –ª—é–±–æ–≥–æ —Ç–µ–∫—Å—Ç–∞ (—Å–ø–∏—Å–æ–∫ —Å–∏–º–≤–æ–ª–æ–≤ –º–æ–∂–Ω–æ –º–µ–Ω—è—Ç—å) //! –ø—Ä–∏–º–µ—Ä
		/*
			–ü—Ä–∏–º–µ—Ä	
				= F[Splitter.SplitTextByNonAlpha] ("A1B,C") = {"A","B","C"}
				Text.Alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
		*/

		Document(
			"Splitter.SplitTextByNonAlpha",
			"Splits text by characters that aren't [A-Za-z]",
			{[ 	Description = "Split text", 
				Code		= "F[Splitter.SplitTextByNonAlpha](""A1B,C"")", 
				Result 		= "{ ""A"", ""B"", ""C"" }" ]},
			
			(line as text) => 
					Splitter.SplitTextByNotIn( F[Text.Alphabet] )
		),
	
	Splitter.SplitTextByNotIn    = // —Ä–∞–∑–±–∏–≤–∞–µ—Ç —Ç–µ–∫—Å—Ç –Ω–∞ –ª—é–±—ã–µ —Å–∏–º–≤–æ–ª—ã, –∫–æ—Ç–æ—Ä—ã–µ –Ω–µ —è–≤–ª—è—é—Ç—Å—è ¬´–±–µ–∑–æ–ø–∞—Å–Ω—ã–º–∏¬ª ? —Å–∏–º–≤–æ–ª–∞–º–∏ //! –ø—Ä–∏–º–µ—Ä—ã
		/*
			–û–ø–∏—Å–∞–Ω–∏–µ 	–†–∞–∑–±–∏–≤–∞–µ—Ç —Ç–µ–∫—Å—Ç –Ω–∞ –ª—é–±—ã–µ —Å–∏–º–≤–æ–ª—ã, –∫–æ—Ç–æ—Ä—ã–µ –Ω–µ —è–≤–ª—è—é—Ç—Å—è ¬´–±–µ–∑–æ–ø–∞—Å–Ω—ã–º–∏¬ª —Å–∏–º–≤–æ–ª–∞–º–∏
			–ü—Ä–∏–º–µ—Ä		= F[Splitter.SplitTextByNotIn] (F[Text.Alphanumeric]) ("Power BI is #1")
			–†–µ–∑—É–ª—å—Ç–∞—Ç	= {"Power BI is ", "1"}
			–ë–µ–∑–æ–ø–∞—Å–Ω—ã–µ —Å–∏–º–≤–æ–ª—ã = // ?
			Text.Alphanumeric  = Text.AlphabetRu & "0123456789"
		*/
		Document(
			"Splitter.SplitTextByNotIn",
			"Splits text on any characters that aren't the provided 'safe' characters",
			{[ 	Description = "Split on non-alphanumeric", 
				Code 		= "F[Splitter.SplitTextByNotIn](PBI[Text.Alphanumeric])(""Power BI is #1"")", 
				Result 		= "{""Power BI is "", ""1""}" ]},

		(safeCharacters as text) => 
			(line as nullable text) =>
				if   line is null 
				then {} 
				else
					List.Accumulate(
						Text.ToList(line), 
						{null} , 
						(state, current) => 
							let
								doSkip 	 	= not Text.Contains(safeCharacters, current),
								lastItem 	= List.Last(state),
								appendLast 	= lastItem <> null
							in
								if doSkip 
								then 	if lastItem is null 
										then state 
										else List.Combine({state, {null}})
								else if appendLast 
									 then List.Combine( { List.RemoveLastN(state, 1), {lastItem & current} } )
									 else List.Combine( { List.RemoveLastN(state, 1), {current} } )
					)
		),

	//===========================
	// Switch
	//===========================
	Switch    		= // # –≤–æ–∑–≤—Ä–∞—â—è–µ—Ç –ø–∞—Ä–Ω—ã–π —ç–ª–µ–º–µ–Ω—Ç –∏–∑ —Å–ø–∏—Å–∫–∞ —Å–ø–∏—Å–∫–æ–≤ –∏–ª–∏ –ø–∞—Ä—ã —Å–ø–∏—Å–∫–æ–≤
		/* 	–í–æ–∑–≤—Ä–∞—â—è–µ—Ç –ø–∞—Ä–Ω—ã–π —ç–ª–µ–º–µ–Ω—Ç –∏–∑ —Å–ø–∏—Å–∫–∞
			–ü—Ä–∏–º–µ—Ä:
				1. 	to = F[fxSwitch](
							3, 	// Date.Month(DateTime.From(date))
							{1,2,3,4,5,6,7,8,9,10,11,12}, 
							{"–Ø–Ω–≤–∞—Ä—å","–§–µ–≤—Ä–∞–ª—å","–ú–∞—Ä—Ç","–ê–ø—Ä–µ–ª—å","–ú–∞–π","–ò—é–Ω—å","–ò—é–ª—å","–ê–≤–≥—É—Å—Ç","–°–µ–Ω—Ç—è–±—Ä—å","–û–∫—Ç—è–±—Ä—å","–ù–æ—è–±—Ä—å","–î–µ–∫–∞–±—Ä—å"}, 
							null
						) // Return: –ú–∞—Ä—Ç
				2. 	to = F[fxSwitch]("B", { {"A",1}, {"B",2}, {"C",3} })			  // Return: 2
				3. 	to = F[fxSwitch]("TE", {"QB","RB","WR","TE","D/ST"}, {1,2,3,4,5}) // Return: 4
				4. 	to = F[fxSwitch](
							Date.DayOfWeek(DateTime.From("03/05/24")), // —á–∏—Å–ª–æ
							{0, 1, 2, 3, 4, 5, 6}, 
							{"–í–æ—Å–∫—Ä–µ—Å–µ–Ω—å–µ", "–ü–æ–Ω–µ–¥–µ–ª—å–Ω–∏–∫", "–í—Ç–æ—Ä–Ω–∏–∫", "–°—Ä–µ–¥–∞", "–ß–µ—Ç–≤–µ—Ä–≥", "–ü—è—Ç–Ω–∏—Ü–∞", "–°—É–±–±–æ—Ç–∞"}, 
							null
						)
				1.	–°–¥–µ–ª–∞—Ç—å –ø—Ä–∏–º–µ—Ä —á–µ—Ä–µ–∑ List.Zip
		*/
		(	value as any, 							// —á—Ç–æ –∏—Å–∫–∞—Ç—å
			casesOrPairs as list, 					// –≥–¥–µ –∏—Å–∫–∞—Ç—å, —Å–ø–∏—Å–æ–∫ —Å–ø–∏—Å–∫–æ–≤ –∏–ª–∏ 2 —Å–ø–∏—Å–∫–∞ —á–µ—Ä–µ–∑ ",". –ú–æ–∂–Ω–æ —á–µ—Ä–µ–∑ List.Zip —Å–ª–æ–≤–∞—Ä—å —Å–¥–µ–ª–∞—Ç—å
			optional resultsOrDefault as any, 		// —á—Ç–æ –≤–æ–∑–≤—Ä–∞—â–∞—Ç—å
			optional default as any					// –µ—Å–ª–∏ –æ—à–∏–±–∫–∞
		) =>
		let
			hasPairs   = List.First(casesOrPairs) is list,
			usingPairs = 
				let
					targetPosition = 
						List.PositionOf(
							casesOrPairs, 
							value, 
							Occurrence.First, 
							(case, theValue) => theValue = case{0}
						)
				in
					if targetPosition = -1 
					then resultsOrDefault 
					else casesOrPairs{targetPosition}{1},
			usingCases = 
				let
					cases = casesOrPairs,
					results = resultsOrDefault
				in
					if List.IsEmpty(cases) or List.IsEmpty(results) 
					then default 
					else 	if value = List.First(cases) 
							then List.First(results) 
							else @Switch(value, List.Skip(cases, 1), List.Skip(results, 1), default)
		in
			if hasPairs then usingPairs else usingCases,
	
	Switch.Record 	= // –≤—Ä—É—á–Ω—É—é –µ—Å–ª–∏ –ø–æ–¥—Å—Ç–∞–≤–ª—è—Ç—å, —á–µ—Ä–µ–∑ Record.FieldOrDefault
        	[ func = (–ö–æ–¥–†–µ–≥–∏–æ–Ω–∞ as text) => 
                Record.FieldOrDefault(
                    [1 = "–ë—Ä–µ—Å—Ç", 2 = "–í–∏—Ç–µ–±—Å–∫", 3 = "–ì–æ–º–µ–ª—å", 
					 4 = "–ì—Ä–æ–¥–Ω–æ", 5 = "–ú–∏–Ω—Å–∫", 6 = "–ú–æ–≥–∏–ª–µ–≤", 0 = "–ë–ö–°"], 
                    –ö–æ–¥–†–µ–≥–∏–æ–Ω–∞, 
                    null
			    )
        	] [func],
	Switch.DAX    	= // –∑–∞–º–µ–Ω–∞ –∑–Ω–∞—á–µ–Ω–∏—è –≤ —è—á–µ–π–∫–µ (–≤—Å—è —è—á–µ–π–∫–∞). –ê–Ω–∞–ª–æ–≥ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏ SWITCH –≤ DAX
		/*	
			–û–ø–∏—Å–∞–Ω–∏–µ:	–∑–∞–º–µ–Ω–∞ –∑–Ω–∞—á–µ–Ω–∏—è –≤ —è—á–µ–π–∫–µ (–≤—Å—è —è—á–µ–π–∫–∞). –ú–æ–≥—É—Ç –±—ã—Ç—å –ª–æ–≥–∏—á–µ—Å–∫–∏–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ
						–ü–µ—Ä–≤—ã–π —ç–ª–µ–º–µ–Ω—Ç —Å–ø–∏—Å–∫–∞ - –ø—Ä–æ–≤–µ—Ä—è–µ–º–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ, –¥–∞–ª–µ–µ –∏–¥—É—Ç –ø–∞—Ä—ã, –ø–æ—Å–ª–µ–¥–Ω–∏–º –≤—Å–µ –æ—Å—Ç–∞–ª—å–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è
			–†–µ–∑—É–ª—å—Ç–∞—Ç:	–ª—é–±–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –∏–∑ —Ç–∞–±–ª–∏—Ü—ã –ø–æ–¥—Å—Ç–∞–Ω–æ–≤–∫–∏
			–°–∞–π—Ç: 		https://xxlbi.com/blog/switch-true-in-power-query/
			–ü—Ä–∏–º–µ—Ä:	1.	= Switch.DAX(
							{	2, 
								1, "A", 
								2, "B"}
							), 							=> Result = "B"
			
					2.	= Switch.DAX(
							{	"b", 
								"a", "first", 
								"b", "second", 
								"c"}
							)						=> Result = "second"
					
					3.	= Switch.DAX(
							{	true, 
								1 > 2, "first", 
								0 = 1, "second", 
								"other"}
							)						=> Result = "other"
					
					4.  = F[Switch.DAX](
							{	true, 
								List.ContainsAny(from[–ê–ö–¢–ò–í–´],{"–∑–∞–ø–∞—Å—ã"}, Text.Contains), "–ï—Å—Ç—å —Ç–∞–∫–æ–µ —Å–ª–æ–≤–æ",
								"–ù–µ—Ç —Ç–∞–∫–æ–≥–æ"
							})
		*/
		[func = 
			(input as list) as any =>
				let
					Source         = List.Buffer(input),
					Expression     = List.First(Source),
					SkipExpression = List.Skip(Source),
					HasElse        = Number.IsEven(List.Count(Source)),
					ElseValue      = if HasElse then List.Last(Source) else null,
					ValuesResults  = List.RemoveLastN(SkipExpression, Number.From(HasElse)),
					Values         = List.Alternate(ValuesResults, 1, 1, 1),
					Results        = List.Alternate(ValuesResults, 1, 1, 0),
					FirstResult    = List.PositionOf(Values, Expression),
					FunctionResult = if FirstResult = -1 then ElseValue else Results{FirstResult}
				in
					FunctionResult,
			
			fnType = type function (input as list) as any
				meta [
					Documentation.Name = "Switch",
					Documentation.LongDescription = "Evaluates an expression against a list of values and returns one of multiple possible result expressions.",
					Documentation.Examples = {
						[Description = "Simple Switch expression", Code = "Switch({2, 1, ""A"", 2, ""B""})", Result = """B"""],
						[Description = "An equivalent of SWITCH(TRUE... in DAX", Code = "Switch({true, 1 > 2, ""A"", 1 < 2, ""B"", ""No result""})", Result = """B"""]
					}
				],
			result = Value.ReplaceType(func, fnType)
		][result],
		
	Switch.Lite   	= // –Ω–∞–¥–æ –¥–æ–¥–µ–ª–∞—Ç—å
		(input) => 
		let values = {	{"E", "Employee"}, 
						{"S", "SCYC"}, 
						{"M", "Medical"},
						{input, "Undefined"} 
					}, 
			Result = List.First(List.Select(values, (x)=> x{0}=input)){1} 
		in  Result,
	
	
	//===========================
	// Table
	//===========================
	// –æ—Å–Ω–æ–≤–Ω—ã–µ
	Table.AddBlankRow 		 = 
		// 
		(table as table) => Table.Combine({table, Table.FromRecords({[]})}),
	
	Table.DrillIntoColumn 	 = 
		/*
			Transforms a column's value into its nested value -- if it eventually finds only one. 
			Consider the following column:
				MyCol
				---------------------------------------------------------
				"a"
				{{{"b"}}}
				Table.FromRecords({[MyCol=Table.FromRecords({[col=2]})})
				{}
				---------------------------------------------------------
			
			Table.DrillColumn(table, "MyCol") will convert it to
				MyCol
				---------------------------------------------------------
				"a"
				"b"
				2
				null	
				---------------------------------------------------------
		*/
		(table as table, columnName as text) =>
		let
			FindValue = (value as any) => 
				if value is list 
				then
					if List.Count(value) = 1 
					then @FindValue(List.First(value)) 
						else if List.Count(value) = 0 
							 then null
							 else error "Couldn't find single value"
						else if value is table 
						then
							if Table.RowCount(value) = 1 
							then @FindValue(List.First(Table.ToColumns(value)))
							else if Table.RowCount(value) = 0 
								then null 
								else error "Couldn't find single value"
								else  value,
			Result = Table.TransformColumns(table, {{columnName, FindValue}})
		in
			Result,
	Table.ConcatenateRows 	 = // –¥–æ–±–∞–≤–ª—è–µ—Ç –≤–ø—Ä–∞–≤–æ –≤—Å–µ —Å—Ç–æ–ª–±—Ü—ã –∏–∑ —Ç–∞–±–ª–∏—Ü—ã B –≤ —Ç–∞–±–ª–∏—Ü—É A (—Å–æ –∑–Ω–∞—á–µ–Ω–∏—è–º–∏) 
		/*
			–û–ø–∏—Å–∞–Ω–∏–µ	–î–æ–±–∞–≤—å—Ç–µ –≤—Å–µ —Å—Ç–æ–ª–±—Ü—ã –∏–∑ —Ç–∞–±–ª–∏—Ü—ã B –≤ —Ç–∞–±–ª–∏—Ü—É A (—Å–æ –∑–Ω–∞—á–µ–Ω–∏—è–º–∏)
			–û—Å–æ–±–µ–Ω–Ω–æ—Å—Ç—å	1 –ò–º–µ–Ω–∞ —Å—Ç–æ–ª–±—Ü–æ–≤ –Ω–µ –¥–æ–ª–∂–Ω—ã —Å–æ–≤–ø–∞–¥–∞—Ç—å
						2 –°—Ç—Ä–æ–∫–∏ –¥–æ–±–∞–≤–ª—è—é—Ç—Å—è –ø–æ –∏–Ω–¥–µ–∫—Å—É
						3 –í–º–µ—Å—Ç–æ –ø—É—Å—Ç—ã—Ö –∑–Ω–∞—á–µ–Ω–∏–π –±—É–¥–µ—Ç 0
			–ü—Ä–∏–º–µ—Ä		= F[Table.ConcatenateRows](table1,table2)
			–†–µ–∑—É–ª—å—Ç–∞—Ç	
		*/
		(tableA as table, tableB as table) =>
			let
				IndexColumn = [
					A = "__IndexA__",
					B = "__IndexB__"
				],
				Indexed = [
					A = Table.AddIndexColumn(tableA, IndexColumn[A], 0, 1),
					B = Table.AddIndexColumn(tableB, IndexColumn[B], 0, 1)
				],
				
				Join = Table.Join(
					Indexed[A],
					IndexColumn[A],
					Indexed[B],
					IndexColumn[B],
					JoinKind.LeftOuter
				),
				Return = Table.RemoveColumns(Join, Record.FieldValues(IndexColumn))
			in
				Return,	
		
	Table.EnterDataFormula 	 = 
		Document(
			"Table.EnterDataFormula",
			"Convert a table into a formula that's compatible with the Enter Data UI. This function returns an expression you can copy and paste to editthe " &
				" table using Enter Data. Paste the formula, then click the gear icon next to the step name. This is an easy way to allow people to customize a table you've queried",
			{[ 
				Description = "Simple table", 
				Code 		= "Web.Page(Web.Contents(""https://en.wikipedia.org/wiki/List_of_Super_Bowl_champions"")){3}[Data]", 
				Result 		= "Table.FromRows(Json.Document(Binary.Decompress(Binary.FromText(""jVVtb9s2EP4rRD4aRqI3S9TH2Gm7ZWkb1MGGom6Aq83IhBkyoOik2a8fT6Ski6Fu+yDdWea9Pffc8du3M342P7uVzrU/jrbZs7UTQgnb+q+lfzL/nFeLxIu0ror55pglWcK8viA6J3o96vVwJksSqvNRT5Ognn2fh1yuQClo2cq8/DCvmMbCPzmmUWaLkEYyn2GkNIhFEFUQvBN1FkQexGI2uP8kXtg73SjQO3YLzkrjMEgRn/NFEmrlpL66JLmnRM+JXhC9IvWR82lxWqvQz8KypTV6a9pYJxZ5nlex1mpMg5dEp98p5OR7TWEmqaYLkgY2eQ2avbegt7LdGlbUof1dApgLz/MASQCcF0EEpH3wDuJiNkfXWUAabT9YITRbwqvHeXsIPovBZ4S5jDWl3kdZjbqHfBbKmXUkGd1iA78ae2AfJGg36ZRH46QzTqKIrtLR1Wc4IA82FzemZZe68cRv2ReQu5Bs3vO/7JOt5kixEt886d45Vp1kg8u/oN1L3Tij2Rexaw9ST3qqAj95FIGmPFC4Jhl+lPAo2ZVRT/vgKeuHoeg9pWT2MqLnhCDkO6ccROSWoJx8NFZsLn7XO48pPBklcQCV6yNmdDJKPrbJj+LIejol9UmUj1Jr0RoH7E/pQWnQc9LPXNJ7ronngEkVyFaVszHh48MDKMOWUqlJN3VCZoDAUxMY6pwkiIASCmwu1u6c3ZijRDY8tpFeHQh5nIUq0r4O3Iotw//WApxTgnm5h5fDhHW3DGdhKDtRBOuMdsNHfhZDy7vCYoEdo8dhzkghePQP0C3uT+le2WovxUOfQfqmieX8Hkeuvh8M/eEtNB5XAXbShoesk3JM93YvFewE0hPYO2g8ejHbjHaExxEkha6kXzdag5M+oG5ATRuS9nF+UukKrGeqBr9ftNuHmT3xgDs6LKZ4BaR0g1wL1xdKAUaK3w+n7+DxCbo1tjxut6CFsFNGuAXehvhslfC9YGuQejIOjslogkv4SgrfgNUebDOWk77hNh1f/OfS+RXmx+o9qK3R0zZ8jHIncA5bIdiddPCL8/VpDCv/Nh5nD/jO460mrPBSD1Hw10qJZ9Fdsf5qexmi4IOuUxzXT5uLy8HgSjhrpGM30vyP09f+PmmNfvYLQLBraI5g/9voN3NscS3fiZ/wbzG+/wM="", BinaryEncoding.Base64), Compression.Deflate)), let _t = ((type text) meta [Serialized.Text = true]) in type table [Appearances = _t, Team = _t, Wins = _t, Losses = _t, Winning percentage = _t, Season(s) = _t])"
			]},
			(table as table) =>
				let
					Encoded    = Table.JsonEncode(table),
					ColumnMeta = "[" & 
								 Text.Range(
									List.Accumulate(
										Table.ColumnNames(table), 
										"", 
										(state, current) => state & ", " & current & " = _t"),
										2) 
								 & "]",
					Text = 	"Table.FromRows(Json.Document(Binary.Decompress(Binary.FromText(""" & Encoded & """, BinaryEncoding.Base64), Compression.Deflate))," & 
							" let _t = ((type text) meta [Serialized.Text = true]) in type table " & ColumnMeta & ")"
				in
					Text
		),
	
	Table.ExpandRecordColumn = //* —Ö–æ—Ä–æ—à–∞—è
		(	table as table, 
			columnName as text, 
			optional fieldNames as list, 
			optional newColumnNames as nullable list
		) => 
		
		// if fieldNames aren't specified, use the field names from the first row of the column.
		
		let
			_fieldNames = 	if fieldNames <> null 
							then fieldNames 
							else List.Buffer(Record.FieldNames(List.First(Table.Column(table, columnName)))),
			
			_newColumnNames = 	if newColumnNames <> null 
								then newColumnNames 
								else _fieldNames,
			
			Result = Table.ExpandRecordColumn(table, columnName, _fieldNames , _newColumnNames)
		in 
			Result,

	Table.FromListCrossJoin  = 
		/* 
			Perform a cross join of lists. Example usage:
			Table.FromListCrossJoin({ {ColorsTable[ColorName], "Color"}, {NumbersTable[Number], "Number"}})
			Will give me a new table with two columns, "Color" and "Number" which contains one row for each possible
			combination of colors and numbers
			Table.FromListCrossJoin({{"Red", "Blue"}, "Color"}, {{1,2,3}, "Number"}}) = 
			Table.FromRecords({[Color="Red", Number=1],[Color="Red", Number = 2],[Color="Red", Number = 3],[Color="Blue", Number=1],[Color="Blue", Number=2],[Color="Blue", Number=3]})
		*/
		(listColumnNamePairs as any) =>
			let 
				remainingPairs 	= List.Skip(listColumnNamePairs, 1),
				current 		= List.First(listColumnNamePairs),
				theList 		= List.First(current),
				columnName 		= List.First(List.Skip(current),1),
				firstTable 		= Table.FromList(theList, null, {columnName}),
				doStuff = (table as table, remainingPairs as list) =>
					if List.Count(remainingPairs) <= 0 
					then table 
					else	let 
								current = List.First(remainingPairs),
								theList = List.First(current),
								columnName = List.First(List.Skip(current), 1),
								nextTable = Table.ExpandListColumn(Table.AddColumn(table, columnName, each theList), columnName)
							in 
								@doStuff(nextTable, List.Skip(remainingPairs, 1)),
				Result = doStuff(firstTable, remainingPairs)
			in
				Result,
	
	Table.JsonEncode 		 = // # –∫–æ–¥–∏—Ä—É–µ—Ç —Ç–∞–±–ª–∏—Ü—É –≤ –¥–≤–æ–∏—á–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç (–±–µ–∑ –∑–∞–≥–æ–ª–æ–≤–∫–æ–≤)
		(table as table) =>
		let
			Rows 		= Table.ToRows(table),
			Json 		= Json.FromValue(Rows),
			Compressed 	= Binary.Compress(Json, Compression.Deflate),
			Encoded 	= Binary.ToText(Compressed, BinaryEncoding.Base64)
		in
			Encoded,
	Table.JsonDecode 		 = // # –¥–µ–∫–æ–¥–∏—Ä—É–µ—Ç —Ç–∞–±–ª–∏—Ü—É –∏–∑ –¥–≤–æ–∏—á–Ω–æ–≥–æ —Ñ–æ—Ä–º–∞—Ç–∞ (2 —Å—Ç–æ–ª–±—Ü–∞)
		// 
		(encoded as text) =>
		let
			Decompressed = Binary.Decompress(Binary.FromText(encoded, BinaryEncoding.Base64), Compression.Deflate),
			Decoded 	 = Table.FromRows(Json.Document(Decompressed), 
								let _t = ( (type text) meta [Serialized.Text = true] ) 
								in 	type table [Name = _t, Number = _t])
		in
			Decoded,

	Table.JsonEncodeWithHead = // # –∫–æ–¥–∏—Ä—É–µ—Ç —Ç–∞–±–ª–∏—Ü—É –≤ –¥–≤–æ–∏—á–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç (—Å –∑–∞–≥–æ–ª–æ–≤–∫–∞–º–∏ –∏ —Ç–∏–ø–∞–º–∏) ‚ö°
		(table as table) =>
		let
			ColumnNames = Table.ColumnNames(table),
			ColumnTypes = Table.Schema(table)[TypeName], // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ç–∏–ø—ã –¥–∞–Ω–Ω—ã—Ö –∫–∞–∫ —Ç–∏–ø—ã (—Ç–µ–∫—Å—Ç!)
			Rows 		= Table.ToRows(table),
			DataWithTypes = List.Transform(Rows, each List.Zip({ColumnNames, _})),
			
			Json 		= Json.FromValue([ColumnNames=ColumnNames, ColumnTypes=ColumnTypes, Data=DataWithTypes]),
			Compressed 	= Binary.Compress(Json, Compression.Deflate),
			Encoded 	= Binary.ToText(Compressed, BinaryEncoding.Base64)
		in
			Encoded,
			
	Table.JsonDecodeWithHead = // # –¥–µ–∫–æ–¥–∏—Ä—É–µ—Ç —Ç–∞–±–ª–∏—Ü—É –∏–∑ –¥–≤–æ–∏—á–Ω–æ–≥–æ —Ñ–æ—Ä–º–∞—Ç–∞ (—Å –∑–∞–≥–æ–ª–æ–≤–∫–∞–º–∏ –∏ —Ç–∏–ø–∞–º–∏) ‚ö°
		(encoded as text) =>
		let
			//	–î–µ–∫–æ–¥–∏—Ä—É–µ–º base64
				DecodedBinary = Binary.FromText(encoded, BinaryEncoding.Base64),
				Decompressed  = Binary.Decompress(DecodedBinary, Compression.Deflate),
				Json 		  = Json.Document(Decompressed),

			// 	–ò–∑–≤–ª–µ–∫–∞–µ–º –Ω–∞–∑–≤–∞–Ω–∏—è —Å—Ç–æ–ª–±—Ü–æ–≤ –∏ –∏—Ö —Ç–∏–ø—ã
				ColumnNames = Json[ColumnNames],
				ColumnTypes = Json[ColumnTypes],
				DataRows 	= Json[Data],

			// 	–ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ —Å—Ç—Ä–æ–∫–æ–≤—ã—Ö –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏–π —Ç–∏–ø–æ–≤ –¥–∞–Ω–Ω—ã—Ö –≤ –æ–±—ä–µ–∫—Ç—ã —Ç–∏–ø–∞ `type`
				// —Å–¥–µ–ª–∞—Ç—å –±–æ–ª—å—à–µ –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤ —Ç–∏–ø–æ–≤ –∏–ª–∏ –ø—Ä–∏–∫—Ä—É—Ç–∏—Ç—å —Ñ—É–Ω–∫—Ü–∏—é —Ç–∏–ø–∞ Value
				TypeTextToType = (typeString as text) =>
					Record.FieldOrDefault(
						[	Number.Type 	= type number,
							Text.Type 		= type text,
							Date.Type 		= type date,
							DateTime.Type 	= type datetime,
							Time.Type 	    = type time,
							Logical.Type 	= type logical,
							Duration.Type   = type duration,
							Int64.Type 		= type number
						], 
							typeString, type any
					),

			//	–°–ø–∏—Å–æ–∫ —Ç–∏–ø–æ–≤ –∫–æ–ª–æ–Ω–æ–∫
				ColumnTypesList = List.Transform(ColumnTypes, each TypeTextToType(_)),

			// 	–ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö –≤ –∑–∞–ø–∏—Å–∏
				ConvertRowToRecord = (row as list) =>
					Record.FromList(List.Transform(row, each _{1}), ColumnNames),

			// 	–ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ –≤—Å–µ—Ö –¥–∞–Ω–Ω—ã—Ö –≤ –∑–∞–ø–∏—Å–∏
				RecordsList = List.Transform(DataRows, each ConvertRowToRecord(_)),
				DataTable 	= Table.FromRecords(RecordsList),

			// 	–ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ —Ç–∏–ø–æ–≤ –¥–∞–Ω–Ω—ã—Ö –∫ —Å—Ç–æ–ª–±—Ü–∞–º
				ApplyTypes = Table.TransformColumnTypes(
								DataTable, 
								List.Zip({ColumnNames, ColumnTypesList})
							 ),
			
			// 	–§—É–Ω–∫—Ü–∏—è –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏—è —Å—Ç–æ–ª–±—Ü–∞ "Date" —Å–æ –∑–Ω–∞—á–µ–Ω–∏–µ–º —Ç–∏–ø–∞ 2020-12-31T00:00:00 
			//	–≤ —Ç–∏–ø `date` –∏ —Ñ–æ—Ä–º–∞—Ç –≤–∏–¥–∞ "–î–î.–ú–ú.–ì–ì–ì–ì"
			
				ConvertDateColumn = (table as table) =>
					let
						ColumnName 	 = "Date",
						ColumnExists = Table.HasColumns(table, {ColumnName}),
						UpdatedTable = if ColumnExists then
							Table.TransformColumns(table, {
								{ColumnName, each 
									try if Text.Contains(_, "T") 
										then Date.From(Date.ToText(Date.FromText(Text.BeforeDelimiter(_, "T")), "dd.MM.yyyy"))
										else _ 
									otherwise _
									, type date}
							})
						else
							table
					in
						UpdatedTable,

			// 	–ü—Ä–∏–º–µ–Ω—è–µ–º –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ –∫ —Ç–∞–±–ª–∏—Ü–µ
				FinalTable = ConvertDateColumn(ApplyTypes)
		in
			FinalTable,

	Table.MoveColumnsToStart = // # –ø–µ—Ä–µ–º–µ—â–∞–µ—Ç –∫–æ–ª–æ–Ω–∫—É –∏–ª–∏ —Å–ø–∏—Å–æ–∫ –∫–æ–ª–æ–Ω–æ–∫ –≤ –Ω–∞—á–∞–ª–æ —Ç–∞–±–ª–∏—Ü—ã 
		// = F[Table.MoveColumnsToStart](from,{"Year"})
		// (x, y) => Table.ReorderColumns(x, y & List.RemoveItems(Table.ColumnNames(x), y)),
		(tbl as table, columnNames as list) =>
			Table.ReorderColumns(
				tbl,
				columnNames & List.RemoveItems(Table.ColumnNames(tbl), columnNames)
			),

	Table.MoveColumnsToEnd 	 = // # –ø–µ—Ä–µ–º–µ—â–∞–µ—Ç –∫–æ–ª–æ–Ω–∫—É –∏–ª–∏ —Å–ø–∏—Å–æ–∫ –∫–æ–ª–æ–Ω–æ–∫ –≤ –∫–æ–Ω–µ—Ü —Ç–∞–±–ª–∏—Ü—ã
		// = F[Table.MoveColumnsToEnd](from,{"Year"})
		(tbl as table, columnNames as list) =>
			Table.ReorderColumns(
				tbl, 
				List.RemoveItems(Table.ColumnNames(tbl), columnNames) & columnNames
			),
	Table.NumberColumns		 = // # –ø—Ä–µ–æ–±—Ä–∞–∑—É–µ—Ç –∫–æ–ª–æ–Ω–∫—É –≤ number —Ç–∏–ø –∏ –∑–∞–º–µ–Ω—è–µ–º 0 –Ω–∞ null
		/*
			–û–ø–∏—Å–∞–Ω–∏–µ 	–ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤—ã–≤–∞–µ—Ç –∫–æ–ª–æ–Ω–∫—É –≤ number —Ç–∏–ø –∏ –∑–∞–º–µ–Ω—è–µ–º –Ω—É–ª–∏ null
			–ü—Ä–µ–æ–±—Ä–∞–∑—É–π—Ç–µ —Ç–∏–ø –≤—ã–±—Ä–∞–Ω–Ω—ã—Ö —Å—Ç–æ–ª–±—Ü–æ–≤ –≤ —á–∏—Å–ª–æ, –∑–∞–º–µ–Ω–∏—Ç–µ –Ω—É–ª–µ–≤—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è –Ω—É–ª—è–º–∏.
		*/
		(table as table, columns as list) as table =>
		let
			NumberTypes   = List.Repeat({type number}, List.Count(columns)),
			DataWithTypes = Table.TransformColumnTypes(table, List.Zip({columns, NumberTypes})),
			NumberNotNull = (number) => if number is null then 0 else number,
			DataNoNulls   = Table.TransformColumns(
				DataWithTypes,
				List.Zip({
					columns,
					List.Repeat({NumberNotNull}, List.Count(columns)),
					NumberTypes
				})
			),
			Return = DataNoNulls
		in
			Return
		,
	Table.ReplaceValueIf	 = // Replaces a value if it matches a predicate
		
		(table as table, replaceIf as function, after as any, columnNameOrList as any) => 
		Table.ReplaceValue( table, 
			null, 
			after, 
			(text, old, new)=> 
				if replaceIf(text) 
				then new 
				else text, 
			if columnNameOrList is list 
				then columnNameOrList 
				else {columnNameOrList}
		),

	
	Table.SplitColumnNames 	 = // Splits camelCased and PascalCased column names. 	
		
		(table as table) => 
			Table.RenameColumns(
				table, 
				List.Transform(
					Table.ColumnNames(table), 
					each {_, Text.SplitCamelCase(_)}
				)
			), 
	
	Table.SplitColumnText 	 = // Splits camelCased and PascalCased text in a column. 
		(table as table, columns as list) => 
			if List.Count(columns) = 0 
			then table 
			else Table.TransformColumns(
					@Table.SplitColumnText(
							table, 
							List.Skip(columns, 1)
						),
					{{List.First(columns), Text.SplitCamelCase}}
				),

	Table.TransformColumn 	 = // * –ø—Ä–∏–º–µ—Ä –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –ø—Ä–∏–¥—É–º–∞—Ç—å
		// 
		(table as table, column as text, transform as function) => 
			Table.TransformColumns(table, {{column, transform}}),

	Table.RenameColumn 		 = // * –ø–µ—Ä–µ–∏–º–µ–Ω–æ–≤–∞–Ω–∏–µ –∫–æ–ª–æ–Ω–æ–∫ ? –ø—Ä–æ–≤–µ—Ä–∏—Ç—å
		// –ü—Ä–∏–º–µ—Ä:	Table.RenameColumn(from,)
		(table as table, column as text, newName as text) => 
			Table.RenameColumns(table, {{column, newName}}),

	Table.RenameAndTransformColumn = 
		(table, currentName as text, newName as text, transform as function) => 
			Table.TransformColumn(
				Table.RenameColumns(table, {currentName, newName}), 
				newName, 
				transform
			),

	// –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ
	Table.AddScrape          = // –¥–æ–±–∞–≤–ª—è–µ—Ç —Å—Ç–æ–ª–±–µ—Ü —Å –ø–æ–ª—É—á–µ–Ω–Ω—ã–º–∏ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞–º–∏, Table.AddColumn() + Web.Contents()
        /*
            Description:
                Add a column based on sequentially scraped results to a table. It's like Table.AddColumn() + Web.Contents(), except combining those directly would rape the server rather than inserting proper politeness delays.
                –î–æ–±–∞–≤—å—Ç–µ –≤ —Ç–∞–±–ª–∏—Ü—É —Å—Ç–æ–ª–±–µ—Ü –Ω–∞ –æ—Å–Ω–æ–≤–µ –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ –ø–æ–ª—É—á–µ–Ω–Ω—ã—Ö —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤. 
                –≠—Ç–æ –ø–æ—Ö–æ–∂–µ –Ω–∞ Table.AddColumn() + Web.Contents(), –∑–∞ –∏—Å–∫–ª—é—á–µ–Ω–∏–µ–º —Ç–æ–≥–æ, —á—Ç–æ –∏—Ö –æ–±—ä–µ–¥–∏–Ω–µ–Ω–∏–µ 
                –Ω–∞–ø—Ä—è–º—É—é –ø—Ä–∏–≤–µ–¥–µ—Ç –∫ –∏–∑–Ω–∞—Å–∏–ª–æ–≤–∞–Ω–∏—é —Å–µ—Ä–≤–µ—Ä–∞, –∞ –Ω–µ –∫ –≤—Å—Ç–∞–≤–∫–µ –Ω–∞–¥–ª–µ–∂–∞—â–∏—Ö –∑–∞–¥–µ—Ä–∂–µ–∫ –∏–∑ –≤–µ–∂–ª–∏–≤–æ—Å—Ç–∏.

            Usage:
                let
                    Web.AddScrape = Load("Web.AddScrape"),
                    BaseUrl = "http://example.com/?p=",
                    Pages = List.Numbers(1, 5),
                    Tbl = Table.FromList(Pages),
                in
                    Web.AddScrape(Tbl, "Value", BaseUrl)
            Result: 
                [a table with the response bodies of the URLs with the given variables added into a new column]
                [—Ç–∞–±–ª–∏—Ü–∞ —Å —Ç–µ–ª–∞–º–∏ –æ—Ç–≤–µ—Ç–æ–≤ URL-–∞–¥—Ä–µ—Å–æ–≤ —Å –∑–∞–¥–∞–Ω–Ω—ã–º–∏ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–º–∏, –¥–æ–±–∞–≤–ª–µ–Ω–Ω—ã–º–∏ –≤ –Ω–æ–≤—ã–π —Å—Ç–æ–ª–±–µ—Ü]
        */

        (
            Tbl as table,                   //the table in question to add scrape results to
            Col as text,                    //the column of variable content to append to the base URL
            BaseUrl as text,                //the base URL
            optional newColName as text,    //the name of the new column to be added, default Content
            optional Delay as number,       //in seconds, default 1
            optional Encoding as number,    //https://msdn.microsoft.com/en-us/library/windows/desktop/dd317756(v=vs.85).aspx
            optional Options                //see options in Web.FetchSequentially
        ) as table =>
        let
            newColName = if (newColName<>null) then newColName else "Content",
            Web.FetchSequentially = Load("Web.FetchSequentially"),

            InputList     = Table.Column(Tbl, Col),
            DedupedList   = List.Distinct(InputList),
            InputUrls     = List.Transform(DedupedList, each BaseUrl & Expression.Constant(_)),
            ScrapedList   = Web.FetchSequentially(InputUrls, Delay, Encoding, Options),
            ScrapedRecord = Record.FromList(ScrapedList, DedupedList),
            Merged        = Table.AddColumn(Tbl, newColName, each Record.Field(ScrapedRecord, Record.Field(_, Col))),
            Buffered      = Table.Buffer(Merged),
            Return        = Buffered
        in
            Return,

    Table.CrossJoin          = // –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –ø–µ—Ä–µ–∫—Ä–µ—Å—Ç–Ω–æ–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –¥–≤—É—Ö –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤ (–º–æ–≥—É—Ç –±—ã—Ç—å —Å–ø–∏—Å–∫–∞–º–∏ –∏–ª–∏ —Ç–∞–±–ª–∏—Ü–∞–º–∏) 
        /*
            Returns the Cartesian product (i.e. crossjoin) of two arguments (can be lists or tables).
            –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –¥–µ–∫–∞—Ä—Ç–æ–≤–æ –ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ (—Ç. –µ. –ø–µ—Ä–µ–∫—Ä–µ—Å—Ç–Ω–æ–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ) –¥–≤—É—Ö –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤ (–º–æ–≥—É—Ç –±—ã—Ç—å —Å–ø–∏—Å–∫–∞–º–∏ –∏–ª–∏ —Ç–∞–±–ª–∏—Ü–∞–º–∏).
            
            Usage:
                Table.CrossJoin = Load("Table.CrossJoin"),
                Table.CrossJoin({"A","B"},{1..3})	//list version
                TableA = #table({"A"},{{"A"},{"B"}}),
                TableB = #table({"B"},{{1},{2},{3}}),
                Table.CrossJoin(TableA, TableB)		//table version
            
            Result: 
                #table({"A","B"},{{"A",1},{"A",2},{"A",3},{"B",1},{"B",2},{"B",3}})
        */

        (A as any, B as any) as any =>
        let
            TableA  = if A is table then A else Table.FromValue(A),
            TableB  = if B is table then B else Table.FromValue(B),
            Renamed = if Table.HasColumns(TableA, "Value")
                      then Table.RenameColumns(TableA, {"Value", "Original"})
                      else TableA,
            Merged  = Table.AddColumn(Renamed, "Table", each TableB),
            ColumnsToExpand = List.Distinct(List.Combine(List.Transform(Table.Column(Merged, "Table"), each if _ is table then Table.ColumnNames(_) else {}))),
            Expand  = Table.ExpandTableColumn(Merged, "Table", ColumnsToExpand)
        in
            Expand,

    Table.CrossJoin2         = 1// —Ä–∞–∑–≤–∏–≤–∞–µ—Ç Table.CrossJoin —Å –ø–æ–º–æ—â—å—é UdfContents –∏ –ø—Ä–æ—á–µ–≥–æ 
        // let
        //     Table.CrossJoin = Load("Table.CrossJoin"),
        //     Tokens    = Table.RenameColumns(Table.FromList(Record.FieldNames(#shared)), {"Column1", "Token"}),
        //     AddAlts   = Table.AddColumn(Tokens, "TokenAlt", each Text.Replace([Token], "_", ".")),
        //     Crossed   = Table.CrossJoin(AddAlts, UdfContents),
        //     Contained = Table.AddColumn(Crossed, "Contains", each Text.Contains([Contents], [Token]) or Text.Contains([Contents], [TokenAlt])),
        //     Filtered  = Table.SelectRows(Contained, each [Contains]),
        //     FiltCols  = Table.SelectColumns(Filtered, {"Token", "TokenAlt", "Name"}),
        //     Return    = FiltCols
        // in
        //     Return
			,
    
    Table.CrossJoinTables    = // –ø–µ—Ä–µ–∫—Ä–µ—Å—Ç–Ω–æ–µ –æ–±—ä–µ–¥–∏–Ω–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞ —Ç–∞–±–ª–∏—Ü –≤ —Ç–∞–±–ª–∏—Ü—É, —Å–æ–¥–µ—Ä–∂–∞—â—É—é –≤—Å–µ –∫–æ–º–±–∏–Ω–∞—Ü–∏–∏ —Å—Ç—Ä–æ–∫ 
        /*
            Cross-join a list of tables into one super table containing every combination of rows of its constituents
            –ü–µ—Ä–µ–∫—Ä–µ—Å—Ç–Ω–æ–µ –æ–±—ä–µ–¥–∏–Ω–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞ —Ç–∞–±–ª–∏—Ü –≤ –æ–¥–Ω—É —Å—É–ø–µ—Ä—Ç–∞–±–ª–∏—Ü—É, —Å–æ–¥–µ—Ä–∂–∞—â—É—é –≤—Å–µ –∫–æ–º–±–∏–Ω–∞—Ü–∏–∏ —Å—Ç—Ä–æ–∫ –µ–µ —Å–æ—Å—Ç–∞–≤–ª—è—é—â–∏—Ö.
            Usage:
                Table.CrossJoinTables = Load("Table.CrossJoinTables"),
                Table.CrossJoinTables({
                    #table({"A","B"},{{"A",1},{"B",2}}),
                    #table({"C","D"},{{"E",3},{"F",4}})
                })
            Result: 
                a cross-joined version of all the tables. beware of performance, the result could get big!
                –ø–µ—Ä–µ–∫—Ä–µ—Å—Ç–Ω–æ-—Å–æ–µ–¥–∏–Ω–µ–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è –≤—Å–µ—Ö —Ç–∞–±–ª–∏—Ü. –ú–µ–¥–ª–µ–Ω–Ω–æ!
        */

        (   tables as list,
            optional TableNames as list,        // names to append as prefixes on clash or if desired, default {1, 2, 3, ...}
            optional AlwaysPrefix as logical    // whether to use append table names if without column name clashes
        ) as table => 
        let
            CrossJoin = List.Accumulate(
                List.Positions(tables),
                #table({},{}), 
                (state, current) => 
                    let
                        CurrentTable = tables{current}, // need check for table type?
                        CurrentNames = Table.ColumnNames(state),
                        OldNames     = Table.ColumnNames(CurrentTable),
                        Prefix = if TableNames <> null 
                                then try TableNames{current} otherwise Text.From(current+1) 
                                else Text.From(current+1),
                        NewNames = 
                            List.Transform(
                                OldNames, 
                                each if AlwaysPrefix or List.Contains(CurrentNames, _) 
                                    then Prefix & "_" & _ 
                                    else _
                            ),
                        Renamed = Table.RenameColumns(CurrentTable, List.Zip({OldNames, NewNames}))
                    in
                        Table.Join(state, {}, Renamed, {}, JoinKind.FullOuter)
                )
        in
            if List.IsEmpty(tables) 
            then #table({},{}) 
            else CrossJoin,
 
    Table.ExpandAll          = // –ø–æ–ª–Ω–æ—Å—Ç—å—é —Ä–∞—Å–∫—Ä—ã–≤–∞–µ—Ç –ª—é–±—ã–µ –≤–ª–æ–∂–µ–Ω–Ω—ã–µ –∑–∞–ø–∏—Å–∏ –∏ —Ç–∞–±–ª–∏—Ü—ã –≤–Ω—É—Ç—Ä–∏ —Ç–∞–±–ª–∏—Ü—ã 
        /*
            –ü–æ–ª–Ω–æ—Å—Ç—å—é —Ä–∞—Å–∫—Ä—ã–≤–∞–µ—Ç –ª—é–±—ã–µ –≤–ª–æ–∂–µ–Ω–Ω—ã–µ –∑–∞–ø–∏—Å–∏ –∏ —Ç–∞–±–ª–∏—Ü—ã –≤–Ω—É—Ç—Ä–∏ —Ç–∞–±–ª–∏—Ü—ã.
            https://cwebbbi.wordpress.com/2014/05/21/expanding-all-columns-in-a-table-in-power-query/
            
            Usage:
                Table.ExpandAll = Load("Table.ExpandAll"),
                xml = Xml.Tables("<books><book><name>Book1</name><pages><page>1</page><page>2</page><page>3</page></pages></book><book><name>Book2</name><pages><page>1</page><page>2</page><page>3</page></pages></book></books>"),
                Table.ExpandAll(xml)	//, null, true
            
            Result: 
                [—Ä–∞—Å—à–∏—Ä–µ–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è –¥–∞–Ω–Ω–æ–π —Ç–∞–±–ª–∏—Ü—ã —Å –≤–ª–æ–∂–µ–Ω–Ω—ã–º–∏ –∑–∞–ø–∏—Å—è–º–∏/—Ç–∞–±–ª–∏—Ü–∞–º–∏]
        */

        (
            TableToExpand as table,					//the table you wish to expand
            optional ColumnNumber as number,		//the column number to expand
            optional AppendParentNames as logical	//whether to use append parent column names e.g. "ul.li", or just keep "li" where possible (reverting to the qualified name in case of a colum name clash)
        ) as table =>
        let
            ColumnNumber = if (ColumnNumber=null) then 0 else ColumnNumber,
            AppendParentNames = if (AppendParentNames=null) then false else AppendParentNames
        in

        List.Last(
            List.Generate(
                ()=>[ col = ColumnNumber,
                    Tbl = TableToExpand ],
                each [col]<=(Table.ColumnCount([Tbl])-1),
                each 
                    let ColumnNames = Table.ColumnNames([Tbl]),
                        ColumnName 	= ColumnNames{[col]},
                        ColumnsToExpand = List.Distinct(List.Combine(List.Transform(Table.Column([Tbl], ColumnName),
                            each if _ is table then Table.ColumnNames(_) else {}))),
                        NewColumnNames = List.Transform(ColumnsToExpand, each if (AppendParentNames or List.Contains(ColumnNames,_)) then ColumnName & "." & _ else _),
                        CanExpandCol   = List.Count(ColumnsToExpand)>0
                    in [Tbl = 	if CanExpandCol
                                then Table.ExpandTableColumn([Tbl], ColumnName, ColumnsToExpand, NewColumnNames)
                                else [Tbl],
                        col = 	if CanExpandCol
                                then [col]
                                else [col]+1 ],
                each [Tbl]
            )
        ),

    Table.ExpandRecords      = // –ø–æ–ª–Ω–æ—Å—Ç—å—é —Ä–∞—Å–∫—Ä—ã–≤–∞–µ—Ç –ª—é–±—ã–µ –≤–ª–æ–∂–µ–Ω–Ω—ã–µ –∑–∞–ø–∏—Å–∏ –≤ —Ç–∞–±–ª–∏—Ü–µ 
        /*
            –ü–æ–ª–Ω–æ—Å—Ç—å—é —Ä–∞—Å–∫—Ä—ã–≤–∞–µ—Ç –ª—é–±—ã–µ –≤–ª–æ–∂–µ–Ω–Ω—ã–µ –∑–∞–ø–∏—Å–∏ –≤ —Ç–∞–±–ª–∏—Ü–µ.
            https://cwebbbi.wordpress.com/2014/05/21/expanding-all-columns-in-a-table-in-power-query/
            
            Usage:
                tbl = Table.FromColumns({ {1}, {[c=0,d=2]} }, {"a", "b"}),
                Table.ExpandRecords(tbl)    //, null, true
            
            Result: 
                [—Ä–∞—Å—à–∏—Ä–µ–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è –¥–∞–Ω–Ω–æ–π —Ç–∞–±–ª–∏—Ü—ã —Å –≤–ª–æ–∂–µ–Ω–Ω—ã–º–∏ –∑–∞–ø–∏—Å—è–º–∏]
        */

        (   TableToExpand as table,                  // the table you wish to expand
            optional ColumnNames as list,            // the columns to expand
            optional AppendParentNames as logical    // whether to use append parent column names e.g. "ul.li", or just keep "li" where possible (reverting to the qualified name in case of a colum name clash)
                                                     // –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ª–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–µ –∏–º–µ–Ω —Ä–æ–¥–∏—Ç–µ–ª—å—Å–∫–∏—Ö —Å—Ç–æ–ª–±—Ü–æ–≤, –Ω–∞–ø—Ä–∏–º–µ—Ä. "ul.li", 
                                                     // –∏–ª–∏ –ø—Ä–æ—Å—Ç–æ –æ—Å—Ç–∞–≤—å—Ç–µ ¬´li¬ª, –≥–¥–µ —ç—Ç–æ –≤–æ–∑–º–æ–∂–Ω–æ (–≤–æ–∑–≤—Ä–∞—â–∞—è—Å—å –∫ –ø–æ–ª–Ω–æ–º—É –∏–º–µ–Ω–∏ –≤ —Å–ª—É—á–∞–µ –∫–æ–Ω—Ñ–ª–∏–∫—Ç–∞ –∏–º–µ–Ω —Å—Ç–æ–ª–±—Ü–æ–≤)   
        ) as table =>                                
        let
            ColumnNames = if (ColumnNames=null) then Table.ColumnNames(TableToExpand) else ColumnNames,
            count       = List.Count(ColumnNames),
            AppendParentNames = if (AppendParentNames=null) then false else AppendParentNames
        in
            List.Accumulate(ColumnNames, TableToExpand, (tbl, col) => 
                let
                    ColumnsToExpand = 
                        List.Distinct(
                            List.Combine(
                                List.Transform(
                                    Table.Column(tbl, col),
                                    each if _ is record then Record.FieldNames(_) else {}
                                )
                            )
                        ),

                    NewColumnNames = 
                        List.Transform(
                            ColumnsToExpand, 
                            each if (AppendParentNames or List.Contains(ColumnNames,_)) then col & "." & _ else _
                        ),

                    CanExpandCol = List.Count(ColumnsToExpand) > 0
                in  
                    if CanExpandCol
                    then Table.ExpandRecordColumn(tbl, col, ColumnsToExpand, NewColumnNames)
                    else tbl
        ),

    Table.ExpandTables       = // –ø–æ–ª–Ω–æ—Å—Ç—å—é —Ä–∞—Å–∫—Ä—ã–≤–∞–µ—Ç –ª—é–±—ã–µ –≤–ª–æ–∂–µ–Ω–Ω—ã–µ —Ç–∞–±–ª–∏—Ü—ã –≤–Ω—É—Ç—Ä–∏ —Ç–∞–±–ª–∏—Ü—ã 
        /*
            –ü–æ–ª–Ω–æ—Å—Ç—å—é —Ä–∞—Å–∫—Ä—ã–≤–∞–µ—Ç –ª—é–±—ã–µ –≤–ª–æ–∂–µ–Ω–Ω—ã–µ —Ç–∞–±–ª–∏—Ü—ã –≤–Ω—É—Ç—Ä–∏ —Ç–∞–±–ª–∏—Ü—ã.
            https://cwebbbi.wordpress.com/2014/05/21/expanding-all-columns-in-a-table-in-power-query/
           
            Usage:
                Table.ExpandTables = Load("Table.ExpandTables"),
                xml = Xml.Tables("<books><book><name>Book1</name><pages><page>1</page><page>2</page><page>3</page></pages></book><book><name>Book2</name><pages><page>1</page><page>2</page><page>3</page></pages></book></books>"),
                Table.ExpandTables(xml)    //, null, true
            
            Result: 
                [—Ä–∞—Å—à–∏—Ä–µ–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è –¥–∞–Ω–Ω–æ–π —Ç–∞–±–ª–∏—Ü—ã —Å –≤–ª–æ–∂–µ–Ω–Ω—ã–º–∏ —Ç–∞–±–ª–∏—Ü–∞–º–∏]
        */

        (
            TableToExpand as table,                 // the table you wish to expand
            optional ColumnNames as list,           // the columns to expand
            optional AppendParentNames as logical   // whether to use append parent column names e.g. "ul.li", or just keep "li" where possible (reverting to the qualified name in case of a colum name clash)
        ) as table =>
        
        let
            ColumnNames = if (ColumnNames=null) then Table.ColumnNames(TableToExpand) else ColumnNames,
            count       = List.Count(ColumnNames),
            AppendParentNames = if (AppendParentNames=null) then false else AppendParentNames
        in
            List.Accumulate(ColumnNames, TableToExpand, (tbl, col) => 
                let
                    ColumnsToExpand = List.Distinct(List.Combine(List.Transform(Table.Column(tbl, col), each if _ is table then Table.ColumnNames(_) else {}))),
                    NewColumnNames  = List.Transform(ColumnsToExpand, each if (AppendParentNames or List.Contains(ColumnNames,_)) then col & "." & _ else _),
                    CanExpandCol    = List.Count(ColumnsToExpand) > 0
                in 
                    if CanExpandCol
                    then Table.ExpandTableColumn(tbl, col, ColumnsToExpand, NewColumnNames)
                    else tbl
            ),

    Table.ExpandTablesRecursive = // –ø–æ–ª–Ω–æ—Å—Ç—å—é —Ä–∞—Å–∫—Ä—ã–≤–∞–µ—Ç –ª—é–±—ã–µ –≤–ª–æ–∂–µ–Ω–Ω—ã–µ —Ç–∞–±–ª–∏—Ü—ã –≤–Ω—É—Ç—Ä–∏ —Ç–∞–±–ª–∏—Ü—ã
        /*
            Fully expands any nested tables within a table
            –ü–æ–ª–Ω–æ—Å—Ç—å—é —Ä–∞—Å–∫—Ä—ã–≤–∞–µ—Ç –ª—é–±—ã–µ –≤–ª–æ–∂–µ–Ω–Ω—ã–µ —Ç–∞–±–ª–∏—Ü—ã –≤–Ω—É—Ç—Ä–∏ —Ç–∞–±–ª–∏—Ü—ã.
            
            Originally written by Chris Webb: 
            https://cwebbbi.wordpress.com/2014/05/21/expanding-all-columns-in-a-table-in-power-query/
            
            Usage:
                Table.ExpandTablesRecursive = Load("Table.ExpandTablesRecursive"),
                xml = Xml.Tables("<books><book><name>Book1</name><pages><page>1</page><page>2</page><page>3</page></pages></book><book><name>Book2</name><pages><page>1</page><page>2</page><page>3</page></pages></book></books>"),
                Table.ExpandTablesRecursive(xml)    //, null, true
            
            Result: 
                [an expanded version of the given table with nested tables]
        */

        (   TableToExpand as table,                 // the table you wish to expand
            optional ColumnNumber as number,        // the column number to expand
            optional AppendParentNames as logical   // whether to use append parent column names e.g. "ul.li", or just keep "li" where possible (reverting to the qualified name in case of a colum name clash)
        ) as table =>
        let
            ColumnNumber        = if (ColumnNumber=null) then 0 else ColumnNumber,
            AppendParentNames   = if (AppendParentNames=null) then false else AppendParentNames
        in
            List.Last(
                List.Generate(
                    ()=>[
                        col = ColumnNumber,
                        Tbl = TableToExpand
                    ],
                    each [col]<=(Table.ColumnCount([Tbl])-1),
                    each 
                        let
                            ColumnNames     = Table.ColumnNames([Tbl]),
                            ColumnName      = ColumnNames{[col]},
                            ColumnsToExpand = List.Distinct(List.Combine(List.Transform(Table.Column([Tbl], ColumnName), each if _ is table then Table.ColumnNames(_) else {}))),
                            NewColumnNames  = List.Transform(ColumnsToExpand, each if (AppendParentNames or List.Contains(ColumnNames,_)) then ColumnName & "." & _ else _),
                            CanExpandCol    = List.Count(ColumnsToExpand)>0
                        in 
                            [   Tbl = if CanExpandCol
                                    then Table.ExpandTableColumn([Tbl], ColumnName, ColumnsToExpand, NewColumnNames)
                                    else [Tbl],
                                col = if CanExpandCol
                                    then [col]
                                    else [col]+1
                            ],
                    each [Tbl]
                )
            ),

    Table.FromString         = // —Å–æ–∑–¥–∞–µ—Ç –ø—É—Å—Ç—É—é —Ç–∞–±–ª–∏—Ü—É —Å –∑–∞–≥–æ–ª–æ–≤–∫–∞–º–∏, –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–Ω—ã–º–∏ –≤ —Å—Ç—Ä–æ–∫–µ —Å —Ä–∞–∑–¥–µ–ª–∏—Ç–µ–ª—è–º–∏
        /* */
        (String as text, Separator as text) => 
            Table.PromoteHeaders( 
                Table.Transpose( 
                    Table.FromList( 
                        Text.Split( String, Separator ) 
                    ) 
                ) 
            ),

    Table.JoinMany           = // –æ–±—ä–µ–¥–∏–Ω–µ–Ω–∏–µ 3+ —Ç–∞–±–ª–∏—Ü –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ
        /*
            Join 3+ tables at once
            –ü—Ä–∏—Å–æ–µ–¥–∏–Ω—è–π—Ç–µ—Å—å –∫ 3+ —Ç–∞–±–ª–∏—Ü–∞–º –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ

            Usage:
                Table.JoinMany = Load("Table.JoinMany"),
                TableA = #table({"country","language"},{{"US", "English"},{"Netherlands", "Dutch"},{"Japan", "Japanese"}}),
                TableB = #table({"country","continent"},{{"US", "Americas"},{"Netherlands", "Europe"},{"Japan", "Asia"}}),
                TableC = #table({"country","population"},{{"US", 316148990},{"Netherlands", 16770000},{"Japan", 127600000}}),
                Table.JoinMany({TableA,TableB,TableC},"country")	//,{"lang","cont","pop"}
            
            Result: 
                #table(
                    {"country","language","continent","population"},
                    {
                        {"US",          "English",  "Americas", 316148990   },
                        {"Netherlands", "Dutch",    "Europe",   16770000    },
                        {"Japan",       "Japanese", "Asia",     127600000   }
                    }
                )
        */

        (   tables as list,							//the tables you wish to join
            key as any,								//the key(s) to join them by, either as single string or as a list with 1 key per table
            //names as list,						//names of the tables used for prefixing identically named columns
            optional joinKind as nullable number	//how to join the tables: JoinKind.Inner (default), JoinKind.LeftOuter, JoinKind.RightOuter, JoinKind.FullOuter, JoinKind.LeftAnti, JoinKind.RightAnti
        ) as table =>
        let
            joinKind = if (joinKind=null) then JoinKind.Inner else joinKind,
            count    = List.Count(tables),
            Combined = List.Last(
                List.Generate(
                    ()=>[
                        i = 1,
                        Tbl = tables{0}
                    ],
                    each [i]<=count,
                    each let
                        i1 = [i]-1,		//index
                        i2 = [i],
                        n1 = "JoinCol1",	//names{i1},	//table name for prefixing
                        n2 = "JoinCol2",	//names{i2},
                        k1 = if key is list then key{i1} else key,	//column key
                        k2 = if key is list then key{i2} else key,
                        key1 = n1 & "." & k1,	//qualified key (because PQ Join doesn't allow joining tables with identical column names)
                        key2 = n2 & "." & k2,
                        t1 = [Tbl],
                        t2 = tables{i2},
                        tab1 = Table.RenameColumns(t1,{k1,key1}),
                        tab2 = Table.RenameColumns(t2,{k2,key2}),
                        Merged = Table.Join(tab1, key1, tab2, key2, joinKind),
                        AddCol = Table.AddColumn(Merged, k2, each let
                                r1 = Record.Field(_,key1),
                                r2 = Record.Field(_,key2)
                            in if r1 = null then r2 else r1),
                        Removed = Table.RemoveColumns(AddCol, {key1, key2})
                    in [
                        Tbl = Removed,
                        i = [i]+1
                    ],
                    each [Tbl]
                )
            ),
            KeyColName 		= if key is list then key{count} else key,
            MergedColNames 	= Table.ColumnNames(Combined),
            KeyToFront 		= List.Combine({{KeyColName},List.RemoveItems(MergedColNames,{KeyColName})}),
            Reordered 		= Table.ReorderColumns(Combined, KeyToFront)

        in
            Reordered,

    Table.MergeColumns       = // –æ–±—ä–µ–¥–∏–Ω—è–µ—Ç –¥–≤–∞ —Å—Ç–æ–ª–±—Ü–∞, –±–µ—Ä—è —Å—Ç–æ–ª–±–µ—Ü A, –Ω–æ –≤–æ–∑–≤—Ä–∞—â–∞—è—Å—å –∫ B, –≥–¥–µ A = null 
        /*
            Merges two columns in a table that refer to the thing, taking column A but falling back to B where A is null
            –û–±—ä–µ–¥–∏–Ω—è–µ—Ç –¥–≤–∞ —Å—Ç–æ–ª–±—Ü–∞, –∫–æ—Ç–æ—Ä—ã–µ —Å—Å—ã–ª–∞—é—Ç—Å—è –Ω–∞ –æ–±—ä–µ–∫—Ç, –±–µ—Ä—è —Å—Ç–æ–ª–±–µ—Ü A, –Ω–æ –≤–æ–∑–≤—Ä–∞—â–∞—è—Å—å –∫ B, –≥–¥–µ A  = null
            
            Usage:
                Table.MergeColumns = Load("Table.MergeColumns"),
                Tbl = #table({"Tel.", "Phone #"},{{"234", null},{null, "123"}}),
                Table.MergeColumns(Tbl, "Tel.", "Phone #")
           
            Result: 
                #table({"Tel."},{{"234"},{"123"}})
        */

        (Source as table, aCol as text, bCol as text) as table => 
        let
            colName = "SomeCustomColName",
            InsertedCustom = Table.AddColumn(Source, colName, each if Record.Field(_,aCol)=null then Record.Field(_,bCol) else Record.Field(_,aCol) ),
            RemovedColumns = Table.RemoveColumns(InsertedCustom,{aCol, bCol}),
            RenamedColumns = Table.RenameColumns(RemovedColumns,{{colName, aCol}})
        in 
            RenamedColumns,

    Table.RemoveBlankColumns = // –ø–æ–∑–≤–æ–ª—è–µ—Ç —É–¥–∞–ª—è—Ç—å –ø—É—Å—Ç—ã–µ —Å—Ç–æ–ª–±—Ü—ã/—Å—Ç—Ä–æ–∫–∏ –∏–∑ —Ç–∞–±–ª–∏—Ü—ã 
        /*
            Allows to remove blank (empty) columns from a table like "Remove Empty Rows" UI option. 
            Optional parameter for empty strings ("") removing (also as nulls)

            –ü–æ–∑–≤–æ–ª—è–µ—Ç —É–¥–∞–ª—è—Ç—å –ø—É—Å—Ç—ã–µ —Å—Ç–æ–ª–±—Ü—ã –∏–∑ —Ç–∞–±–ª–∏—Ü—ã, –Ω–∞–ø—Ä–∏–º–µ—Ä –æ–ø—Ü–∏—é –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–æ–≥–æ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞ ¬´–£–¥–∞–ª–∏—Ç—å –ø—É—Å—Ç—ã–µ —Å—Ç—Ä–æ–∫–∏¬ª. 
            –ù–µ–æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–π –ø–∞—Ä–∞–º–µ—Ç—Ä –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è –ø—É—Å—Ç—ã—Ö —Å—Ç—Ä–æ–∫ ("") (—Ç–∞–∫–∂–µ –≤ –≤–∏–¥–µ –Ω—É–ª–µ–π)

            Usage:
                Table.RemoveBlankColumns = Load("Table.RemoveBlankColumns"),
                
                remove column with nulls AND empty strings:
                Table.RemoveBlankColumns(
                    Table.FromRecords({[A = null, B = 1],[A = null, B = 2],[A = "", B = 3]}), 
                    true
                )
            
            Result: 
                Table.FromRecords({[B = 1],[B = 2],[B = 3]})

                remove column with nulls only:
                Table.RemoveBlankColumns(
                    Table.FromRecords({[A = null, B = 1],[A = null, B = 2],[A = "", B = 3]})
                )
            
            Result: 
                Table.FromRecords({[A = null, B = 1],[A = null, B = 2],[A = "", B = 3]})
        */

        (   tab as table,                        // table to clean
            optional EmptStr as nullable logical // flag to remove columns which contains nulls OR empty strings - only
        ) as table =>

            let
                ToRemove      = {null} & (if EmptStr = true then {""} else {}), // list of "blank" values 
                tabDemoted    = Table.DemoteHeaders(tab),
                tabTransposed = Table.Transpose(tabDemoted),
                RowsRemoved   = Table.SelectRows(
                    tabTransposed, 
                    each not List.IsEmpty(
                        List.RemoveMatchingItems(
                            Record.FieldValues(
                                Record.RemoveFields(_, "Column1")   // after demote+transpose first column is allways with columns headers
                            ), 
                            ToRemove)
                        )
                    ),
                tabTransposedAgain = Table.Transpose(RowsRemoved)
            in
                Table.PromoteHeaders(tabTransposedAgain),

        /* 
            Alternative version (performance didn't checked between versions):

            let
                ToRemove = {null} & (if EmptStr = true then {""} else {}) // list of "blank" values 
            in
                List.Accumulate(
                    Table.ColumnNames(tab), 
                    tab, 
                    (state, current)=> 
                        if List.IsEmpty(
                            List.RemoveMatchingItems(
                                Table.Column(state, current), 
                                ToRemove)
                            ) 
                        then Table.RemoveColumns(state, current) 
                        else state
                    )
        */

    Table.RowsCombination  	 = // —Å–æ–∑–¥–∞–µ—Ç –≤—Å–µ –≤–æ–∑–º–æ–∂–Ω—ã–µ –∫–æ–º–±–∏–Ω–∞—Ü–∏–∏ —Å—Ç—Ä–æ–∫ –∏–∑ –¢–∞–±–ª–∏—Ü—ã1 –∏ –¢–∞–±–ª–∏—Ü—ã2 
        /*
            Returns the Cartesian product of rows of list of tables having same structure
            –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –¥–µ–∫–∞—Ä—Ç–æ–≤–æ –ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ —Å—Ç—Ä–æ–∫ —Å–ø–∏—Å–∫–∞ —Ç–∞–±–ª–∏—Ü, –∏–º–µ—é—â–∏—Ö –æ–¥–∏–Ω–∞–∫–æ–≤—É—é —Å—Ç—Ä—É–∫—Ç—É—Ä—É.
            
            How it was created:
            https://bondarenkoivan.wordpress.com/2016/09/20/combination-of-rows-of-tables-list-in-power-query/

            Usage:
                Table.RowsCombination( {Table1, Table2} )
                
            Result: 
                all possible combination of rows from Table1 and Table2
        */

        (tables as list)=>
        let
            tableslist      = List.Buffer( tables ),
            list_as_numbers = List.Buffer( List.Transform( tableslist, each { 1 .. Table.RowCount(_) } ) ),

        // Tycho's function
        // https://github.com/tycho01/pquery/blob/master/List.CrossJoin.m
            
            list_crossjoin = (A as list, B as list) as table =>
                let
                    firstList 	 	= List.RemoveNulls(A),
                    secondList 	 	= List.RemoveNulls(B),
                    firstLength  	= List.Count(firstList),
                    secondLength    = List.Count(secondList),
                    resultFirstList = 
                        List.Generate( () => 0, 
                            each _ < firstLength * secondLength, 
                            each _ + 1, 
                            each firstList{ Number.IntegerDivide(_, secondLength) }
                        ),

                    resultSecondList = List.Repeat( secondList, firstLength ),
                    list_to_table 	 = Table.FromColumns( {resultFirstList, resultSecondList} ),
                    // my adjustment - merge and leave only merged column
                    add_merged 		 = Table.AddColumn(list_to_table, "Merged", each Text.Combine({Text.From([Column1]), Text.From([Column2])}, ""), type text),	
                    remove_other 	 = Table.SelectColumns( add_merged,{"Merged"})
                in
                    remove_other,

        //  loop through list of numbers (each element is qty of table rows)
            generator = List.Accumulate(list_as_numbers, null, (acc, x) => if acc = null then x else Table.Column(list_crossjoin(acc, x), "Merged")),

        //  function that collects corresponding records (rows) from initial tables - loop through combination of indices
            get_tables_rows = (combination as text) => List.Last( 
                List.Generate(
                    ()=> [i=0, L={}],
                    each [i] <= List.Count( tableslist ),
                    each [i = [i]+1,
                        L = List.Combine( { [L], { tableslist{ [i] }{ Number.From( Text.Range( combination, [i], 1) )-1 } } } ) ],
                    each [L] 
                ) 
            ),

            resulting_list = List.Transform( generator, each Table.FromRecords( get_tables_rows(_) ) ),
            list_to_table  = Table.FromList(resulting_list, Splitter.SplitByNothing(), null, null, ExtraValues.Error),	
            result    	   = Table.ExpandTableColumn( list_to_table, "Column1", Table.ColumnNames( tableslist{0} ), Table.ColumnNames( tableslist{0} ) )	
        in
            result,

    Table.RowsCombination2   = // —Å–æ–∑–¥–∞–µ—Ç –≤—Å–µ –≤–æ–∑–º–æ–∂–Ω—ã–µ –∫–æ–º–±–∏–Ω–∞—Ü–∏–∏ —Å—Ç—Ä–æ–∫ –∏–∑ –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö –¢–∞–±–ª–∏—Ü
        /*  tables = { Table1, Table2, Table3, Table4, Table5 } */
        (tables as list) =>
        let
            add_tables = List.Last(
                List.Generate( ()=>
                    [i = 0, T = tables{0}],
                    each [i] <= List.Count( tables ) - 1,
                    each [i = [i] + 1, T = Table.AddColumn( [T], "Custom." & Text.From( i ), each tables{ i } ) ],
                    each [T] 
                ) ),
            
            expand_tables = 
                List.Last(
                    List.Generate( ()=>
                        [i=0, T=add_tables],
                        each [i] <=List.Count( tables ) - 1,
                        each [  i = [i]+1,
                                T = Table.ExpandTableColumn( 
                                        [T], 
                                        "Custom." & Text.From( i ), 
                                        Table.ColumnNames( tables{0} ), 
                                        List.Transform( 
                                            Table.ColumnNames( tables{0} ), 
                                            each Text.From(_) & "." & Text.From( i ) 
                                        )
                                    ) 
                            ],
                        each [T] 
                    ) 
                ),

            AddedIndex     = Table.AddIndexColumn(expand_tables, "Index", 1, 1),
            UnpivotedOtherColumns  = Table.UnpivotOtherColumns(AddedIndex, {"Index"}, "Attribute", "NewValue"),
            SplitColumnbyDelimiter = Table.SplitColumn(UnpivotedOtherColumns,"Attribute",Splitter.SplitTextByEachDelimiter({"."}, QuoteStyle.Csv, false),{"Attribute.1", "Attribute.2"}),
            PivotedColumn  = Table.Pivot(SplitColumnbyDelimiter, List.Distinct(SplitColumnbyDelimiter[Attribute.1]), "Attribute.1", "NewValue"),
            RemovedColumns = Table.RemoveColumns(PivotedColumn,{"Attribute.2"})
        in
            RemovedColumns,

    Table.TranslateColumn    = // –°–æ–∑–¥–∞–µ—Ç ¬´–ø–µ—Ä–µ–≤–µ–¥–µ–Ω–Ω—ã–π¬ª —Å—Ç–æ–ª–±–µ—Ü –ø–æ —Å–ª–æ–≤–∞—Ä—é –∑–∞–º–µ–Ω
        /*
            Makes a 'translated' column simultaneously executing multiple replaces on the original (using a list of lists as a 'translation sheet')
            –°–æ–∑–¥–∞–µ—Ç ¬´–ø–µ—Ä–µ–≤–µ–¥–µ–Ω–Ω—ã–π¬ª —Å—Ç–æ–ª–±–µ—Ü, –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ –≤—ã–ø–æ–ª–Ω—è—è –Ω–µ—Å–∫–æ–ª—å–∫–æ –∑–∞–º–µ–Ω –æ—Ä–∏–≥–∏–Ω–∞–ª–∞ (–∏—Å–ø–æ–ª—å–∑—É—è —Å–ø–∏—Å–æ–∫ —Å–ø–∏—Å–∫–æ–≤ –≤ –∫–∞—á–µ—Å—Ç–≤–µ ¬´–ª–∏—Å—Ç–∞ –ø–µ—Ä–µ–≤–æ–¥–∞¬ª).

            Usage:
                Table.TranslateColumn = Load("Table.TranslateColumn"),
                Tbl = #table({"ÂèØËÉΩ"},{{"‰∏çÂèØ"},{"ÂèØ"}}),
                Table.TranslateColumn(Tbl, "ÂèØËÉΩ", "Possible", {{"‰∏çÂèØ", "Nope"},{"ÂèØ","Yes"}})
            
            Result: 
                #table({"Possible"},{{"Nope"},{"Yes"}})
        */

        (Tbl as table, OldCol as text, NewColName as text, TranslationList as list) as table =>

        let
            ColAdded   = Table.AddColumn(Tbl, NewColName, 
                            each List.ReplaceMatchingItems(
                                    {Record.Field(_, OldCol)}, 
                                    TranslationList
                                 )
                            ),
            Columnized = Table.ExpandListColumn(ColAdded, NewColName)
        in 
            Columnized,

    Table.UnpivotByNumbers   = // Unpivot, –Ω–æ —Å—Ç—Ä–æ–∫–∏ –∑–∞–≥–æ–ª–æ–≤–∫–∞, –¥–æ–ª–∂–Ω—ã –Ω–∞—Ö–æ–¥–∏—Ç—å—Å—è –≤ –ø–µ—Ä–≤—ã—Ö —Å—Ç—Ä–æ–∫–∞—Ö —Ç–∞–±–ª–∏—Ü—ã, –ù–ï –≤ –∑–∞–≥–æ–ª–æ–≤–∫–∞—Ö
        let func =  
        /* 
            The header rows to be unpivoted must sit in the first rows of your table and NOT in the header itself. 
            The header will be ignored, so if it shall be unpivoted as well, demote it first

            –°—Ç—Ä–æ–∫–∏ –∑–∞–≥–æ–ª–æ–≤–∫–∞, –∫–æ—Ç–æ—Ä—ã–µ –Ω—É–∂–Ω–æ –æ—Ç–º–µ–Ω–∏—Ç—å, –¥–æ–ª–∂–Ω—ã –Ω–∞—Ö–æ–¥–∏—Ç—å—Å—è –≤ –ø–µ—Ä–≤—ã—Ö —Å—Ç—Ä–æ–∫–∞—Ö —Ç–∞–±–ª–∏—Ü—ã, –∞ –ù–ï –≤ —Å–∞–º–æ–º –∑–∞–≥–æ–ª–æ–≤–∫–µ. 
            –ó–∞–≥–æ–ª–æ–≤–æ–∫ –±—É–¥–µ—Ç –∏–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞—Ç—å—Å—è, –ø–æ—ç—Ç–æ–º—É, –µ—Å–ª–∏ –æ–Ω —Ç–∞–∫–∂–µ –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ—Ç–∫–ª—é—á–µ–Ω, —Å–Ω–∞—á–∞–ª–∞ –ø–æ–Ω–∏–∑—å—Ç–µ –µ–≥–æ —É—Ä–æ–≤–µ–Ω—å.
        */

        (Table 					as table, 
        FirstNColumnsToKeep 	as number, 
        FirstNRowsToKeep 		as number) =>

        let
            Source = Table,

        //  Determine column names to keep
            FirstColumnsToKeep = List.FirstN(Table.ColumnNames(Source), FirstNColumnsToKeep),

        //  Those columns who are not to keep shall be unpivoted
            UnpivotColumns = List.Difference(Table.ColumnNames(Source), FirstColumnsToKeep),

        //  Create list of lists with one row per header row
            Headers = if FirstNRowsToKeep=0 then {UnpivotColumns} else List.Buffer(Table.ToRows(Table.FirstN(Table.SelectColumns(Source, UnpivotColumns),FirstNRowsToKeep))),

        //  This step effectively unpivots the values of every row of the table and creates one table per row with an index column indicating the values relative positions.
            ValuesRecord = Table.AddColumn(Source, "Custom", each Table.AddIndexColumn(Table.FromColumns(List.Union({Headers, {Record.FieldValues(Record.SelectFields(_, UnpivotColumns))}})), "IndexUnpivot",1,1)),
            Cleanup = Table.RemoveColumns(ValuesRecord, UnpivotColumns),

        //  Remove the first rows who hold the "to-be-unpivoted" headers.
            RemoveTopNRows = Table.Skip(Cleanup,FirstNRowsToKeep),

        //  Retrieve the column names of the unpivoted columns-table 
            ColsToExpand = List.Union(List.Transform(RemoveTopNRows[Custom], each Table.ColumnNames(_))),

        //  Expand the columns and add ".1" to now columns to avoid duplicate column names
            fnUnpivotByNumbers = Table.ExpandTableColumn(RemoveTopNRows, "Custom", ColsToExpand, List.Transform(ColsToExpand, each _&".1") )
        in
            fnUnpivotByNumbers,

        // Documentation	
            documentation = [
                Documentation.Name            = " fnTable.UnpivotByNumbers", 
                Documentation.Description     = " Unpivots a table according to the number of columns and header rows passed on in the parameters", 
                Documentation.LongDescription = " Unpivots a table according to the number of columns and header rows passed on in the parameters", 
                Documentation.Category  = " Table functions", 
                Documentation.Source    = " local", 
                Documentation.Author    = " Imke Feldmann: www.TheBIccountant.com", 
                Documentation.Examples  = {[  
                    Description =  " ", 
                    Code        = " Check this blogpost explaining how it works: http://wp.me/p6lgsG-zW", 
                    Result      = " "
                ]}
            ] 
        in 
            Value.ReplaceType(func, Value.ReplaceMetadata(Value.Type(func), documentation)),
	// —Ä–∞–∑–Ω—ã–µ –æ—Ç masterPQ
	link1 = "" /* https://github.com/camwally/Power-Query 
					https://www.dingbatdata.com/2018/04/28/retaining-column-types-in-power-query/
		*/,
	ReplaceUsingTable 		= // * –Ω—É–∂–µ–Ω –ø—Ä–∏–º–µ—Ä, –ø–æ–∫–∞ –æ—à–∏–±–∫–∞
		/*
			https://github.com/camwally/Power-Query 
			https://www.dingbatdata.com/2018/04/28/retaining-column-types-in-power-query/
		*/
		(Table as table)=>
		let 
			Rec = Record.FromTable(Table.FromColumns(List.FirstN(Table.ToColumns(Table),2),{"Name","Value"}))
		in 
			(Text as text)=> if Text = null then null else Record.FieldOrDefault(Rec,Text,Text),
	
	
	Table.FromRecordOfLists = // * –Ω—É–∂–µ–Ω –ø—Ä–∏–º–µ—Ä, –ø–æ–∫–∞ –æ—à–∏–±–∫–∞
		(rec as record)=>
		let
			tab2col 	  = Record.ToTable(rec),
			valuess_names = List.Reverse(Table.ToColumns(tab2col)),
			tab 		  = Function.Invoke(Table.FromColumns, valuess_names)
		in
			tab,
	
	Table.ToRecordOfLists 	= // –∫–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ—Ç —Ç–∞–±–ª–∏—Ü—É –≤ –∑–∞–ø–∏—Å—å: Name - –∏–º–µ–Ω–∞ —Å—Ç–æ–ª–±—Ü–æ–≤, Value —Å–ø–∏—Å–∫–∏ –∑–Ω–∞—á–µ–Ω–∏–π
		(table as table, optional buffer as nullable logical)=>
		let
			tab 	= if buffer = true then Table.Buffer(table) else table,
			Name 	= Table.ColumnNames(tab),
			Value 	= Table.ToColumns(tab),
			Record 	= Record.FromTable(Table.FromColumns({Name, Value},{"Name","Value"}))
		in
			Record,

	Table.ToMCode2 			= //? –∏–∑ —Ç–∞–±–ª–∏—Ü—ã –Ω–∞ –≤—Ö–æ–¥–µ –¥–µ–ª–∞–µ—Ç —ç—Ç—É –∂–µ —Ç–∞–±–ª–∏—Ü—É –≤ –∫–æ–¥–µ M
		(inputTable as table, optional #"table type is vertical?" as nullable logical) as text =>
		let
			vert = #"table type is vertical?" ?? false,
			source = Table.Schema(inputTable),
			sortRows = Table.Sort(source,{{"Position", Order.Ascending}}),
			simplifyTypeNameRec = 
				[#"Any.Type" = "any",
				#"Binary.Type" = "binary",
				#"Date.Type" = "date",
				#"DateTime.Type" = "datetime",
				#"DateTimeZone.Type" = "datetimezone",
				#"Duration.Type" = "duration",
				#"Function.Type" = "function",
				#"List.Type" = "list",
				#"Logical.Type" = "logical",
				#"None.Type" = "none",
				#"Null.Type" = "null",
				#"Number.Type" = "number",
				#"Record.Type" = "record",
				#"Table.Type" = "table",
				#"Text.Type" = "text",
				#"Time.Type" = "time",
				#"Type.Type" = "type"],
			simplifyTypeNames	= Table.TransformColumns(sortRows,{{"TypeName", each Record.FieldOrDefault(simplifyTypeNameRec,_,_)}}),
			selectColumns 		= Table.SelectColumns(simplifyTypeNames,{"Name", "TypeName","IsNullable"}),
			addColOfTypeNames	= 
				Table.AddColumn( selectColumns, "TypeNames", 
					each 	Expression.Identifier([Name]) 
							& " = " 
							& (if [IsNullable] then "nullable " else "") 
							& [TypeName]
				),
			tableTypeRec = "[" & Text.Combine(addColOfTypeNames[TypeNames], if vert then "#(lf)," else ", ") & "]",

			//Code above is based on a function by Chris Webb

			tableOfExpressions = Table.TransformColumns(inputTable,{},Expression.Constant),
			listOfCols = Table.ToColumns(tableOfExpressions),
			listOfColsOfPaddedText = 
				List.Transform(
						listOfCols,
					(col as list)=>
					let 
							buf = List.Buffer(col),
							maxTextLength = List.Max(List.Transform(buf,Text.Length)),
							paddedText = List.Transform(buf,each Text.PadEnd(_,maxTextLength))
						in
							paddedText
				),
				listOfRowsOfPaddedText = List.Zip(listOfColsOfPaddedText),
				bodyAsList = List.Transform(listOfRowsOfPaddedText, (row as list)=> "{"&Text.Combine(row,",")&"}"),
				bodyAsText = "{"&Text.Combine(bodyAsList,"#(lf),")&"#(lf)}",
				together =  
						"#table(type table"
					& (if vert then "#(lf)" else "")
					& tableTypeRec
					& ",#(lf)"
					& bodyAsText
					& ")"
		in
			together,
	
	Table.RunningTotal 		= // –Ω–∞–∫–æ–ø–∏—Ç–µ–ª—å–Ω—ã–π –∏—Ç–æ–≥ –≤ –Ω–æ–≤–æ–º —Å—Ç–æ–ª–±—Ü–µ
		(table as table, colToSum as text, colAsNew as text)=>
		let
			tableB 			= Table.Buffer(table),
			listToSum 		= List.Buffer(Table.Column(tableB,colToSum)),
			listToSumCount 	= List.Count(listToSum),
			runningTotalB 	= 
				List.Buffer(
					List.Skip(
						List.Generate(
							()=> [item = 0, counter = 0],
							each [counter] <= listToSumCount,
							each [item = [item]+listToSum{[counter]}, counter = [counter]+1],
							each [item]
						),
					1)
				),
			addIndex 		= Table.AddIndexColumn(tableB,"IndexUniqueName",0,1),
			addRunningTotal = Table.AddColumn(addIndex,colAsNew,each runningTotalB{[IndexUniqueName]}, type number),
			removeIndex 	= Table.RemoveColumns(addRunningTotal,{"IndexUniqueName"})
		in
			removeIndex,
	
	Table.TransformOtherColumns = // # –∏–∑–º–µ–Ω–µ–Ω–∏–µ –¥—Ä—É–≥–∏—Ö –∫–æ–ª–æ–Ω–æ–∫ —Å–≤–æ–µ–π —Ñ—É–Ω–∫—Ü–∏–µ–π –∫—Ä–æ–º–µ —Å–ø–∏—Å–∫–∞ –∏—Å–∫–ª—é—á–∞–µ–º—ã—Ö
		/*
			–°—Ç–∞—Ç—É—Å—Ç:	–ø–µ—Ä—Å–ø–µ–∫—Ç–∏–≤–Ω–∞—è
			–ü—Ä–∏–º–µ—Ä: 	F[Table.TransformOtherColumns](from, {"–°—Ç–∞—Ç—å—è"}, (x)=>if x is text then x & "+" else x, type text)
			–†–µ–∑—É–ª—å—Ç–∞—Ç: 	–ó–Ω–∞—á–µ–Ω–∏—è –≤—Å–µ—Ö —Ç–µ–∫—Å—Ç–æ–≤—ã—Ö –∫–æ–ª–æ–Ω–æ–∫, –∫—Ä–æ–º–µ –∫–æ–ª–æ–Ω–∫–∏ "–°—Ç–∞—Ç—å—è" —Ç—Ä–∞–Ω—Ñ–æ—Ä–º–∏—Ä—É—é—Ç—Å—è –≤ x & "+"

		*/
		(	Table as table, 
			ColumnsToIgnore as list, 
			Function as function, 
			optional TypeForColumns as nullable type
		) as table =>
		let
			FunctionType 	= Value.Type(Function),
			TypeForFunction = 
				Type.ForFunction([ReturnType = TypeForColumns, Parameters = Type.FunctionParameters(FunctionType)],
				Type.FunctionRequiredParameters(FunctionType)),
		
			FunctionWithNewReturnType = 
				if TypeForColumns is null 
				then Function 
				else Value.ReplaceType(Function,TypeForFunction),  
		
			TransformOtherCols = 
				Table.TransformColumns(
					Table,
					List.Transform(
						ColumnsToIgnore,
						(ColName)=> {ColName, each _}),
				FunctionWithNewReturnType)
		in
			TransformOtherCols,

	Table.AddRandomColumn 	= // # —Å–æ–∑–¥–∞–µ—Ç –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–π —Å—Ç–æ–ª–±–µ—Ü —Å–æ —Å–ª—É—á–∞–π–Ω—ã–º–∏ —á–∏—Å–ª–∞–º–∏
		/*	
			–°—Ç–∞—Ç—É—Å:	1

			1. 	Add column of random numbers between 0 and 1:
				F[Table.AddRandomColumn](Source,"Random Number",0,1)
			
			2. 	Add column of random percentages between 0% and 100%:
				F[Table.AddRandomColumn](Source,"Random Percentage",0,1,Percentage.Type)
			
			3. 	Retrieve random item from list:
				F[Table.AddRandomColumn](
					Source,
					"Random Item",
					0,
					List.Count(ListOfItems),{each ListOfItems{Number.RoundDown(_)}, type text}
				)
					ListOfItems = List.Buffer(SomeList))
		*/
		(Table as table, 
			RandColName as text, 
			Min as number, 
			Max as number, 
			optional TransformAndTypeCriteria as any) =>
		let
			List = List.Buffer( 
					if not (TransformAndTypeCriteria is list) 
					then {TransformAndTypeCriteria} 
					else	if List.Count(TransformAndTypeCriteria)<=2 
							then TransformAndTypeCriteria 
							else error "Invalid Criteria (Too many items)"
					),
		
			TransformFunc = if List{0} is null or List{0} is type 
							then null 
							else	if List{0} is function 
									then List{0} 
									else error "Invalid Criteria (Tranform)", 

			ListLast = List.Last(List),
		
			Type = 	if	ListLast is null or ListLast is function 
					then type number 
					else  	if ListLast is type 
							then ListLast 
							else error "Invalid Criteria (Type)", 
		
			FirstName = Table.ColumnNames(Table){0},
		
			AddColumn = Table.AddColumn(Table,
										RandColName,
										each Number.RandomBetween(if Record.Field(_,FirstName)=null then Min else Min,Max),
										Type),
		
			Transform = if TransformFunc = null 
						then AddColumn 
						else Table.TransformColumns(AddColumn,{RandColName, TransformFunc})
		in
			Transform,

	Table.AddClusteredIndex = // # –¥–æ–±–∞–≤–ª—è–µ—Ç —Å—Ç–æ–ª–±–µ—Ü —Å –∏–Ω–¥–µ–∫—Å–æ–º –ø–æ –≤—ã–±—Ä–∞–Ω–Ω–æ–º—É —Å—Ç–æ–ª–±—Ü—É –≥—Ä—É–ø–ø–∏—Ä–æ–≤–∫–∏ (–∫–ª–∞—Å—Ç–µ—Ä—É) //! –ø—Ä–∏–º–µ—Ä—ã –¥–æ–±–∞–≤–∏—Ç—å
		/* 
			–û–ø–∏—Å–∞–Ω–∏–µ

			–ü—Ä–∏–º–µ—Ä
				1	–µ—Å–ª–∏ –≥–æ–¥—ã + –º–µ—Å—è—Ü—ã, —Ç–æ –Ω—É–º–µ—Ä—É–µ—Ç –º–µ—Å—è—Ü—ã –ø–æ –ø–æ—Ä—è–¥–∫—É
					= F[Table.AddClusteredIndex](tbl, {"Year"}) 

		*/
		(Table as table, GroupOnCols as list) => 
		let
			Group   = Table.Group(Table, 
						GroupOnCols, 
						{"ColumnOfTables", each Table.AddIndexColumn(_, "ClustIndex", 0, 1)} 
					),
			Combine = Table.Combine(Group[ColumnOfTables])
		in
			Combine,
	
	Table.CombineJoins 		= // –æ–±—ä–µ–¥–∏–Ω—è–µ—Ç —Å—Ç–æ–ª–±—Ü—ã //! –ø—Ä–∏–º–µ—Ä—ã –¥–æ–±–∞–≤–∏—Ç—å
		(	LeftTable as table,  LeftKey as list, 
			RightTable as table, RightKey as list, 
			ListOfJoins as list) =>
		let
			Func 		 = each Table.NestedJoin(LeftTable, LeftKey, RightTable, RightKey,"Right",_), 
			ListOfTables = List.Transform(ListOfJoins, Func),
			Combine 	 = Table.Combine(ListOfTables)
		in
			Combine,

	Table.CombineJoinsExpandCoalesce = 
		/* 
		Similar to combine joins, but also: 
			1) Preserves the order
			2) Expands right hand side table
			3) Right key is transferred to left key when left key is null, right key is then deleted 
		*/

		(	LeftTable as table, LeftKeys as list, 
			RightTable as table ,RightKeys as list,
			ListOfJoins as list
		) =>
		let
			Func = each Table.NestedJoin(LeftTable, LeftKeys, RightTable, RightKeys,"Right",_), 
			ListOfTables 	 = List.Transform(ListOfJoins, Func),
			Combine 		 = Table.Combine(ListOfTables),
			OldRightColNames = List.Buffer(Table.ColumnNames(RightTable)),
			NewRightKeys 	 = List.Buffer(List.Transform(RightKeys, each "Right." & _)),
			NewRightColNames = List.ReplaceMatchingItems(OldRightColNames,List.Zip({RightKeys,NewRightKeys})),
			//Below: Using Table.Buffer, so that order is preserved on expand
			ExpandRight 	 = Table.ExpandTableColumn(Table.Buffer(Combine), "Right", OldRightColNames, NewRightColNames),
			Coalesce = 
				List.Accumulate(
					List.Zip({LeftKeys,NewRightKeys}),
					ExpandRight, 
					(Table, Keys) =>Table.ReplaceValue(Table, null, each Record.Field(_,Keys{1}), Replacer.ReplaceValue, {Keys{0}})
				),
			
			RemoveRightKeys 	 = Table.RemoveColumns(Coalesce,NewRightKeys),
			OriginalLeftKeyTypes = List.Transform(LeftKeys, each Type.TableColumn(Value.Type(LeftTable),_)),
			ChangeTypes 		 = Table.TransformColumnTypes(RemoveRightKeys,List.Zip({LeftKeys, OriginalLeftKeyTypes}))
		in
			ChangeTypes,

	Table.NonAggPivotMultRows 	= // # –ü—Ä–æ–∫–∞—á–∞–Ω–Ω—ã–π –≤–∞—Ä–∏–∞–Ω—Ç –°–≤–µ–¥–µ–Ω–æ. –ü–µ—Ä–µ–≤–æ—Ä–∞—á–∏–≤–∞–µ—Ç —Å—Ç—Ä–æ–∫–∏ –≤ —Å—Ç–æ–ª–±—Ü—ã //!
		/*	
			https://www.dingbatdata.com/non-aggregate-pivot-with-multiple-rows-in-powerquery/
			–µ—Å—Ç—å xlsx –ø—Ä–∏–º–µ—Ä –∏ –æ–ø–∏—Å–∞–Ω–∏–µ —Ä–∞–±–æ—Ç—ã —Å –∫–∞–∂–¥—ã–º —à–∞–≥–æ–º —Ñ—É–Ω–∫—Ü–∏–∏
			to = PivotMultRows(FlatTable, "Vehicle", "Person")
		*/
		(	Source 			as table,
			ColToPivot 		as text,
			ColForValues 	as text
		) => 

		let
			PivotColNames = List.Buffer(List.Distinct(Table.Column(Source,ColToPivot))), 
			Pivot		  = Table.Pivot(Source, PivotColNames, ColToPivot, ColForValues, each _),

			TableFromRecordOfLists = 
				(rec as record, fieldnames as list) =>
					let	PartialRecord = Record.SelectFields(rec,fieldnames),
						RecordToList  = Record.ToList(PartialRecord),
						Table 		  = Table.FromColumns(RecordToList,fieldnames)
					in	Table,

			AddColumn 	  = Table.AddColumn(Pivot, "Values", each TableFromRecordOfLists(_,PivotColNames)),
			RemoveColumns = Table.RemoveColumns(AddColumn,PivotColNames),
			ExpandTable   = Table.ExpandTableColumn(RemoveColumns, "Values", PivotColNames)
		in
			ExpandTable,

	Table.NonAggPivotMultRows2 	= // –ø—Ä–æ–∫–∞—á–∞–Ω–Ω—ã–π –≤–∞—Ä–∏–∞–Ω—Ç –°–≤–µ–¥–µ–Ω–æ –Ω–µ –ø—Ä–æ–≤–µ—Ä—è–ª
		/*

		*/
		(	Source as table,
			PivotCol as text,
			ValueCol as text
		)=> 
		let
			Source = Table.Buffer(Source), //As source table is referenced 3 times
			GroupClustIndex = 
				Table.Group(Source,
					List.RemoveItems(Table.ColumnNames(Source),{ValueCol}),
					{"ColOfTables", each Table.AddIndexColumn(_,"idx")}
				),

			CombineTables = Table.Combine(GroupClustIndex[ColOfTables]),
			Pivot 		  = Table.Pivot(CombineTables, List.Distinct(Table.Column(Source,PivotCol)), PivotCol, ValueCol),
			RemoveIndex   = Table.RemoveColumns(Pivot,{"idx"})
		in
			RemoveIndex,

	Table.OrderFirstOccurrence 	= // –≥—Ä—É–ø–ø–∏—Ä–æ–≤–∫–∞ –º–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω—ã—Ö –≤—Ö–æ–∂–¥–µ–Ω–∏–π —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –º–∞—Å—Å–∏–≤–∞, —É–ø–æ—Ä—è–¥–æ—á–µ–Ω–Ω—ã—Ö –ø–æ –ø–µ—Ä–≤–æ–º—É –≤—Ö–æ–∂–¥–µ–Ω–∏—é
		/*	
			–£—á–∏—Ç—ã–≤–∞—è –Ω–µ—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –º–∞—Å—Å–∏–≤ —Å –ø–æ–≤—Ç–æ—Ä–µ–Ω–∏—è–º–∏, –∑–∞–¥–∞—á–∞ —Å–æ—Å—Ç–æ–∏—Ç –≤ —Ç–æ–º, —á—Ç–æ–±—ã —Å–≥—Ä—É–ø–ø–∏—Ä–æ–≤–∞—Ç—å 
			–º–Ω–æ–≥–æ–∫—Ä–∞—Ç–Ω–æ–µ –≤—Ö–æ–∂–¥–µ–Ω–∏–µ –æ—Ç–¥–µ–ª—å–Ω—ã—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤. –ì—Ä—É–ø–ø–∏—Ä–æ–≤–∫–∞ –¥–æ–ª–∂–Ω–∞ –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç—å —Ç–∞–∫–∏–º –æ–±—Ä–∞–∑–æ–º, 
			—á—Ç–æ–±—ã —Å–æ—Ö—Ä–∞–Ω—è—Ç—å—Å—è –ø–æ—Ä—è–¥–æ–∫ –ø–µ—Ä–≤–æ–≥–æ –ø–æ—è–≤–ª–µ–Ω–∏—è –≤—Å–µ—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤.
			https://www.geeksforgeeks.org/group-multiple-occurrence-of-array-elements-ordered-by-first-occurrence 
		*/ 
		(Source as table, GroupBy as list) =>
		let
			#"Grouped Rows" 	= Table.Group(Source, GroupBy, {{"Tables", each _, type table}}),
			#"Removed Columns" 	= Table.RemoveColumns(#"Grouped Rows", GroupBy),
			#"Expanded Tables" 	= Table.ExpandTableColumn(#"Removed Columns", "Tables", Table.ColumnNames(Source)),
			RevertTypes 		= Value.ReplaceType(#"Expanded Tables", Value.Type(Source))
		in
			RevertTypes,
	
	Table.StableSortAndOrderFirstOccurrence = // 
		/*
			It's a bit like Table.Sort, but:
			1) Sorts are stable
			2) If you neglect to put a Order.Ascending or a Order.Descending then ordered by first occurrence 
		*/
		(Table as table, List as list) =>
		let
			fMakeEfficientList = (List as list) =>
				let 
					ColName 	= List.Transform(List, each _{0}),
					Order 		= List.Transform(List, each _{1}?),
					TableForm 	= Table.FromColumns({ColName,Order},{"ColName","Order"}),
					Comparer 	= (a as record, b as record) => Number.From(a[Order] is null or b[Order] is null) ,
					PartionedTable = Table.Group(TableForm, {"Order"}, {{"NestedLists", each Table.ToRows(_), type list}},GroupKind.Local, Comparer),
					PartionedList  = PartionedTable[NestedLists]
				in
					PartionedList,

			fReorder = (Table as table, List as list) =>
				let
					ListItem = List.Buffer(List{0}),
					ListItemColNames = List.Buffer(List.Zip(ListItem){0}),
					GroupedTable = Table.Group(Table, ListItemColNames, {{"NestedTables", each Table.RemoveColumns(_,ListItemColNames), type table}}),
					SortedTable  = if ListItem{0}{1} = null then GroupedTable else Table.Sort(GroupedTable,ListItem),
					fRecursion 	 = each if List.Count(List) > 1 then @fReorder(_, List.Skip(List)) else _,
					RecurseOnNestedTables = Table.Buffer(Table.TransformColumns(SortedTable, {"NestedTables", fRecursion})),
					Expand = Table.ExpandTableColumn(RecurseOnNestedTables, "NestedTables", Table.ColumnNames(RecurseOnNestedTables[NestedTables]{0}))
				in
					Expand,
			
			EfficientList 	= List.Buffer(fMakeEfficientList(List)),
			ReorderRows 	= fReorder(Table,EfficientList),
			ReclaimColOrder = Table.ReorderColumns(ReorderRows,Table.ColumnNames(Table)),
			ReclaimColTypes = Value.ReplaceType(ReclaimColOrder,Value.Type(Table))
		in
			ReclaimColTypes,
	
	Table.SyncTableTypeOfCol 	= // –ø—Ä–∏–ø–∏—Å—ã–≤–∞–µ—Ç —Ç–∏–ø —Ç–∞–±–ª–∏—Ü—ã —Å—Ç–æ–ª–±—Ü—É –Ω–∞ –æ—Å–Ω–æ–≤–µ –ø–µ—Ä–≤–æ–π —Ç–∞–±–ª–∏—Ü—ã –≤ —Å—Ç–æ–ª–±—Ü–µ
		/*
			–ü—Ä–∏–ø–∏—Å—ã–≤–∞–µ—Ç —Ç–∏–ø —Ç–∞–±–ª–∏—Ü—ã —Å—Ç–æ–ª–±—Ü—É –Ω–∞ –æ—Å–Ω–æ–≤–µ –ø–µ—Ä–≤–æ–π —Ç–∞–±–ª–∏—Ü—ã –≤ —Å—Ç–æ–ª–±—Ü–µ –∫–∞–∫
			Table.TransformColumnTypes –Ω–µ —Ä–∞–±–æ—Ç–∞–µ—Ç —Å–æ —Å–ª–æ–∂–Ω—ã–º–∏ —Ç–∏–ø–∞–º–∏
		*/
		(PreviousStep as table,ColName as text) =>
			Table.TransformColumns(
				PreviousStep, 
				{ColName, each {_}{0}, Value.Type(Table.Column(PreviousStep,ColName){0})}
			),
	
	Table.SelectRowsWeb 		= // –Ω–µ –ø—Ä–æ–±–æ–≤–∞–ª –ø—Ä–∏–º–µ–Ω–∏—Ç—å
		/*

		*/
		
		(	Table as table,
			fnFilter as function,
			optional Range as nullable list,
			optional Horizontal as nullable logical)=>

		let
			Range      	= if Range      = null then {0}   else Range,
			Horizontal 	= if Horizontal = null then false else Horizontal,
			AddIndex 	= Table.AddIndexColumn(Table, "Index", 0, 1),
			Filter 		= Table.SelectRows(AddIndex, fnFilter),
			Positions 	= List.Buffer(Filter[Index]),
			Values 		= List.Buffer(Table[Column1]),
			
			ListOfTables = 
				List.Transform(Positions, (Pos)=>  
					let  
						Len = List.Count(Range),
						Gen = List.Generate(()=>[i= 0      , Rng = Range{i}, Position = Pos+Rng,  Value = Values{Position}],
											each _[i] < Len,
											each [i= _[i]+1, Rng = Range{i}, Position = Pos+Rng,  Value = Values{Position}],
											each _[[Value],[Rng],[Position]]),
						
						Table = Table.FromRecords(Gen),
						RenameAndChangeTypes = Value.ReplaceType(Table, type table[Value = text, Range = Int64.Type, Position = Int64.Type])
					in
						RenameAndChangeTypes),
			
			Combine 	 = Table.Combine(ListOfTables),
			ValuesToRows = Table.FromRows(List.Transform(ListOfTables, each _[Value]))
		in
			if Horizontal then ValuesToRows else Combine,
	
	Table.TakeTypesAndTryApply 	= // # –ø—Ä–∏–ø–∏—Å—ã–≤–∞–µ—Ç —Ç–∏–ø—ã –∏–∑ –æ–¥–Ω–æ–π —Ç–∞–±–ª–∏—Ü—ã –∏ –ø—Ä–∏–º–µ–Ω—è–µ—Ç –∏—Ö –∫ –æ–¥–Ω–æ–∏–º–µ–Ω–Ω—ã–º —Å—Ç–æ–ª–±—Ü–∞–º –≤ –¥—Ä—É–≥–æ–π —Ç–∞–±–ª–∏—Ü–µ
		/*
			–ï—Å–ª–∏ –≤ —Ç–∞–±–ª–∏—Ü–µ –ø–æ—è–≤–∏–ª–∏—Å—å –∏–ª–∏ –ø–æ—Ç–µ—Ä—è–Ω—ã —Å—Ç–æ–ª–±—Ü—ã, –≤–º–µ—Å—Ç–æ —ç—Ç–æ–≥–æ –≤—ã –º–æ–∂–µ—Ç–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —ç—Ç—É —Ñ—É–Ω–∫—Ü–∏—é. 
			–û–Ω –≤–æ–∑—å–º–µ—Ç —Ç–∏–ø—ã –∏–∑ –ø—Ä–µ–¥—ã–¥—É—â–µ–≥–æ —à–∞–≥–∞ –∏ –ø—Ä–∏–º–µ–Ω–∏—Ç –∏—Ö —Ç–∞–º, –≥–¥–µ –∏–º–µ–Ω–∞ —Å—Ç–æ–ª–±—Ü–æ–≤ –æ–¥–∏–Ω–∞–∫–æ–≤—ã.
			https://www.dingbatdata.com/2018/04/28/retaining-column-types-in-power-query/
			https://blog.crossjoin.co.uk/2017/09/25/setting-data-types-on-nested-tables-in-m/
	
		*/
		(tblToAlter as table, tblGet as table) =>
			let
				typetblGet  = Value.Type(tblGet),
				NameCols 	= List.Intersect({Table.ColumnNames(tblGet), Table.ColumnNames(tblToAlter)}),
				NameFuncTypes = 
					List.Transform(
						NameCols, 
						(x) => {x, 
								each {_}{0}, 
								Type.TableColumn(typetblGet, x)}
					),
				Transform = Table.TransformColumns(tblToAlter, NameFuncTypes)
			in
				Transform,
	
	Table.SplitColsDateTime 	= // –Ω–∞–≤–µ—Ä–Ω–æ–µ –ø—Ä–∞–≤–∏–ª—å–Ω–æ —Å–æ–µ–¥–∏–Ω—è–µ—Ç —Å—Ç–æ–ª–±—Ü—ã —Å –¥–∞—Ç–æ–π –∏ –≤—Ä–µ–º–µ–Ω–µ–º
		/*
		
		*/
		(	table as table,
			ColName as any, // Can be as list of column names or a single column name 
			optional ColNameDate as nullable text,
			optional ColNameTime as nullable text,
			optional Delimiter   as nullable text
		) as table=> 
		let
			ColNameDateD  = if ColNameDate is null then "Date" else ColNameDate, // Default values can be changed to fit  
			ColNameTimeD  = if ColNameTime is null then "Time" else ColNameTime, // your own language or table naming standards
			DelimiterD    = if Delimiter   is null then "."    else Delimiter,   // (only applicable when ColName is list)
			ColNameIsText = if ColName is text then true else
							if ColName is list then false else
							error "ColName needs to be a text value or a list of text values", 
			fnSplitColumn = 
				(State as table, CurrentColName as text) as table=>
					let
						CurrentColNamesNew = 
							if ColNameIsText 
							then {ColNameDateD, ColNameTimeD}
							else {CurrentColName & DelimiterD & ColNameDateD, CurrentColName & DelimiterD & ColNameTimeD},

						SplitColumn =  Table.SplitColumn(State, CurrentColName, each {_,_}, CurrentColNamesNew),
						
						ColumnTransType = {
							{DateTime.Date, type nullable date},
							{DateTime.Time, type nullable time}
						}, 
						
						TransformColumns = 
							Table.TransformColumns(
								SplitColumn,
								List.Zip({CurrentColNamesNew} & List.Zip(ColumnTransType))
							)
					in
						TransformColumns
		in
			List.Accumulate(
				if ColNameIsText then {ColName} else ColName,
				table,
				fnSplitColumn
			),

	Table.Others  			 = "",
	//===========================
	// Text
	//===========================
	// –æ—Å–Ω–æ–≤–Ω—ã–µ
	Text.Alphabet       = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz", // –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å: Text.ToList() –∏–ª–∏ {}
	Text.AlphabetRu     = "–ê–ë–í–ì–î–ï–ñ–ó–ò–ô–ö–õ–ú–ù–û–ü–†–°–¢–£–§–•–¶–ß–®–©–™–´–¨–≠–Æ–Ø–∞–±–≤–≥–¥–µ–∂–∑–∏–π–∫–ª–º–Ω–æ–ø—Ä—Å—Ç—É—Ñ—Ö—Ü—á—à—â—ä—ã—å—ç—é—è",
	Text.AlphaNumeric   = Text.AlphabetRu & "0123456789",
	Text.ExtractDate    = // # –∏–∑–≤–ª–µ–∫–∞–µ—Ç –¥–∞—Ç—É –∏–∑ —Ç–µ–∫—Å—Ç–æ–≤–æ–π —Å—Ç—Ä–æ–∫–∏
		/* 
			–ü—Ä–∏–º–µ—Ä:		F[Text.ExtractDate]("–°–µ–≥–æ–¥–Ω—è30.06.2022 —á–∏—Å–ª–æ.xlsx")
			–ù–∞ –≤—ã—Ö–æ–¥–µ:	"30.06.2022"
		*/
		( text as text ) =>
			let
				selectChars = Text.Select ( text, { " ", "_", ".", "0" .. "9" } ),
				split       = Text.SplitAny ( selectChars, " _" ),
				filterList  = List.Select ( split, ( x ) => 
								Text.Length ( x ) = 10 and 
								Text.PositionOf ( x, ".", Occurrence.All ) = { 2, 5 }  
							  ) {0}?,
				toDate      = Date.FromText ( filterList, "RU-ru" )
			in
				toDate,
	Text.FromList       = // –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Ç–µ–∫—Å—Ç –∏–∑ —Å–ø–∏—Å–∫–∞ 
		// 
		(list as list) => List.Accumulate(list, "", (state, current) => state & Text.From(current)),
	Text.IsUpperCase    = // –ø—Ä–æ–≤–µ—Ä–∏—Ç—å, —á—Ç–æ –¥–µ–ª–∞–µ—Ç
		/* 
			Is text all uppercase? returns false if any non-alpha characters are present
			
			Switch(1, {1, 2, 3}, {""A"", ""B"", ""C""})" = –ê
		*/
		Document(
			"Text.IsUpperCase", 
			"–ø–µ—Ä–µ–∫–ª—é—á–∞–µ—Ç —Ç–µ–∫—Å—Ç",
			{ 
				[ Description = "sdfvsd",   Code = "Switch(1, {1, 2, 3}, {""A"", ""B"", ""C""})",       Result = "A"],
				[ Description = "sdvsdbv",  Code = "Switch(1, {{1, ""A""}, {2, ""B""}, {3, ""C""}})",   Result = "A"]
			},
		(text as text) => 
			List.AllTrue(
				List.Transform(
					Text.ToList(text), 
					(letter)=>Text.Contains(Text.Alphabet, letter) and letter = Text.Upper(letter)
				)
			) 
		),

	Text.IsAlpha        = // —è–≤–ª—è–µ—Ç—Å—è –ª–∏ –≤–µ—Å—å —Ç–µ–∫—Å—Ç –∞–Ω–≥–ª–∏–π—Å–∫–∏–º/—Ä—É—Å—Å–∫–∏–º (–ø—Ä–æ–≤–µ—Ä—è–µ—Ç –∫–∞–∂–¥—ã–π —Å–∏–º–≤–æ–ª)
		(text as text) => 
			List.MatchesAll(Text.ToList(text), each Text.Contains(Text.Alphabet, _)),
	Text.IsNumber       = //  # –ø—Ä–æ–≤–µ—Ä–∫–∞ —Ç–µ–∫—Å—Ç–∞ –Ω–∞ –Ω–æ–º–µ—Ä (true/false)
		// 
		(text as text) => try Number.FromText(text) is number otherwise false,

	Text.RemoveDubleWhitespace = // # –∑–∞–º–µ–Ω—è–µ—Ç –¥–≤–æ–π–Ω—ã–µ –∏ –±–æ–ª–µ–µ –ø—Ä–æ–±–µ–ª—ã –Ω–∞ –æ–¥–∏–Ω–∞—Ä–Ω—ã–π –ø–æ –±–æ–∫–∞–º –∏ –≤–Ω—É—Ç—Ä–∏ —Ç–µ–∫—Å—Ç–∞
		(text as text) => 
			Text.Combine(Splitter.SplitTextByWhitespace()(text)," "), 

	Text.SplitCamelCase  = // # —Ä–∞–∑–¥–µ–ª—è–µ–º —Ç–µ–∫—Å—Ç –ø—Ä–æ–±–µ–ª–æ–º –ø–µ—Ä–µ–¥ –ë–æ–ª—å—à–∏–º–∏ –±—É–∫–≤–∞–º–∏
		/*
			Splits camelCased and PascalCased text and separates by a space. Ex: "thisIsAColumn" -> "this Is A Column"
		*/
		(text as nullable text) => 
			if text is null then null else List.Accumulate(Text.ToList(text),"", (state, current) => 
		let
			PreviousLetter = Text.End(state, 1),
			Ignore = (text as text) => text = " " or text = "."
		in 
			state & 
			(if 
				not Text.IsUpperCase(PreviousLetter) and 
				not Ignore(PreviousLetter) and 
				not Ignore(current) and 
				Text.IsUpperCase(current) 
			then 
				" " else "" ) & 
			current),

	Text.SplitOnNotIn    = // —Ñ—É–Ω–∫—Ü–∏—è —Ä–∞–∑–¥–µ–ª—è–µ—Ç —Å—Ç—Ä–æ–∫—É –Ω–∞ —á–∞—Å—Ç–∏, –∏—Å–ø–æ–ª—å–∑—É—è —Å–∏–º–≤–æ–ª—ã, –∫–æ—Ç–æ—Ä—ã–µ –Ω–µ –≤—Ö–æ–¥—è—Ç –≤ validCharacters, –∫–∞–∫ —Ä–∞–∑–¥–µ–ª–∏—Ç–µ–ª–∏ //! –Ω—É–∂–Ω–æ –º–Ω–æ–≥–æ –ø—Ä–∏–º–µ—Ä–æ–≤
		/*
			–û–ø–∏—Å–∞–Ω–∏–µ	
				—Ñ—É–Ω–∫—Ü–∏—è —Ä–∞–∑–¥–µ–ª—è–µ—Ç line –Ω–∞ —á–∞—Å—Ç–∏, –∏—Å–ø–æ–ª—å–∑—É—è —Å–∏–º–≤–æ–ª—ã, –∫–æ—Ç–æ—Ä—ã–µ –Ω–µ –≤—Ö–æ–¥—è—Ç –≤ validCharacters, –∫–∞–∫ —Ä–∞–∑–¥–µ–ª–∏—Ç–µ–ª–∏.
				todo –æ—Å—Ç–∞–≤–ª—è–µ–º —Ç–æ–ª—å–∫–µ–æ —Å–∏–º–≤–æ–ª—ã –∫–æ—Ç–æ—Ä—ã–µ –≤ —Å–ø–∏—Å–∫–µ –∏—Å–∫–ª—é—á–∞–µ–º—ã—Ö!

			–ù–∞ –≤—ã—Ö–æ–¥–µ
				—Å–ø–∏—Å–æ–∫ —Å–ª–æ–≤, –∫–æ—Ç–æ—Ä—ã—Ö –Ω–µ—Ç –≤ 	
				–µ—Å–ª–∏ line —Ä–∞–≤–µ–Ω null, —Ñ—É–Ω–∫—Ü–∏—è –≤–µ—Ä–Ω–µ—Ç null
			
			–ù–∞–ø—Ä–∏–º–µ—Ä
				–µ—Å–ª–∏ validCharacters —Å–æ–¥–µ—Ä–∂–∏—Ç –±—É–∫–≤—ã –ª–∞—Ç–∏–Ω—Å–∫–æ–≥–æ –∞–ª—Ñ–∞–≤–∏—Ç–∞ (A-Z, a-z), 
				—Ç–æ –≤—Å–µ —Å–∏–º–≤–æ–ª—ã, –Ω–µ –≤—Ö–æ–¥—è—â–∏–µ –≤ —ç—Ç–æ—Ç –Ω–∞–±–æ—Ä (–Ω–∞–ø—Ä–∏–º–µ—Ä, –ø—Ä–æ–±–µ–ª—ã, —Ü–∏—Ñ—Ä—ã, –∑–Ω–∞–∫–∏ –ø—Ä–µ–ø–∏–Ω–∞–Ω–∏—è), 
				–±—É–¥—É—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è –¥–ª—è —Ä–∞–∑–¥–µ–ª–µ–Ω–∏—è —Å—Ç—Ä–æ–∫–∏
			
			–ü—Ä–∏–º–µ—Ä
				line = "Hello, World! 123"
				validCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
				Result 		= Splitter.SplitTextByNotIn(validCharacters)(line)
				–†–µ–∑—É–ª—å—Ç–∞—Ç:	= {"Hello", "World", "", "123"}
			
			–ü—Ä–∏–º–µ—Ä—ã	
				1	= F[Text.SplitOnNotIn]("–ü—Ä–∏–≤–µ—Ç, –º–∏—Ä! 123", "–º")
					= {"–º", null}

				2	= F[Text.SplitOnNotIn]("–ü—Ä–∏–≤–µ—Ç, –º–∏—Ä! 123", "–∞–±–≤–≥–¥–µ–∂–∑–∏–π–∫–ª–º–Ω–æ–ø—Ä—Å—Ç—É—Ñ—Ö—Ü—á—à—â—ä—ã—å—ç—é—è–ê–ë–í–ì–î–ï–ñ–ó–ò–ô–ö–õ–ú–ù–û–ü–†–°–¢–£–§–•–¶–ß–®–©–™–´–¨–≠–Æ–Ø")
					= {"–ü—Ä–∏–≤–µ—Ç", "–º–∏—Ä", null}
				
				3	= F[Text.SplitOnNotIn]("–ü—Ä–∏–≤–µ—Ç, –º–∏—Ä! 123", " –∞–±–≤–≥–¥–µ–∂–∑–∏–π–∫–ª–º–Ω–æ–ø—Ä—Å—Ç—É—Ñ—Ö—Ü—á—à—â—ä—ã—å—ç—é—è–ê–ë–í–ì–î–ï–ñ–ó–ò–ô–ö–õ–ú–ù–û–ü–†–°–¢–£–§–•–¶–ß–®–©–™–´–¨–≠–Æ–Ø")
					= {"–ü—Ä–∏–≤–µ—Ç", "–º–∏—Ä", "", null}
				
				4	= F[Text.SplitOnNotIn]("–º–∞–º–∞ –º—ã–ª–∞ —Ä–∞–º—É","–º–∞")
					= {"–º–∞–º–∞", "–º", "–∞"," –∞–º", null}
		*/

		(line as nullable text, validCharacters as text) => 
			Splitter.SplitTextByNotIn(validCharacters)(line),

	Text.SplitOnNonAlpha = // –ø–æ—Ç–µ—Å—Ç–∏—Ä–æ–≤–∞—Ç—å 
		// 
		(line as nullable text) =>
			if line is null 
			then null 
			else List.Accumulate(
					Text.ToList(line), 
					{null} , 
					(state, current) => 
						let
							doSkip 	   = not Text.Contains(Text.Alphabet, current),
							lastItem   = List.Last(state),
							appendLast = lastItem<>null
						in
							if doSkip then 
								if lastItem is null 
								then state 
								else List.Combine({state, {null}})
							else
								if appendLast 
								then List.Combine({List.RemoveLastN(state, 1), {lastItem & current}})
								else List.Combine({List.RemoveLastN(state, 1), {current}})
				),

	Text.Substring       = // # —Ñ—É–Ω–∫—Ü–∏—è –ø–æ–∑–≤–æ–ª—è–µ—Ç –∏–∑–≤–ª–µ–∫–∞—Ç—å —á–∞—Å—Ç—å —Å—Ç—Ä–æ–∫–∏, –Ω–∞—á–∏–Ω–∞—è —Å —É–∫–∞–∑–∞–Ω–Ω–æ–≥–æ –∏–Ω–¥–µ–∫—Å–∞ –∏ –¥–æ –∑–∞–¥–∞–Ω–Ω–æ–≥–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ —Å–∏–º–≤–æ–ª–æ–≤
		/*
			–ü–∞—Ä–∞–º–µ—Ç—Ä—ã:
				text	—Å—Ç—Ä–æ–∫–∞, –∏–∑ –∫–æ—Ç–æ—Ä–æ–π –±—É–¥–µ—Ç –∏–∑–≤–ª–µ–∫–∞—Ç—å—Å—è –ø–æ–¥—Å—Ç—Ä–æ–∫–∞
				start	–Ω–∞—á–∞–ª—å–Ω—ã–π –∏–Ω–¥–µ–∫—Å –¥–ª—è –∏–∑–≤–ª–µ—á–µ–Ω–∏—è (–¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –Ω–µ–æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω—ã–º)
				count	–Ω–µ–æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–π –ø–∞—Ä–∞–º–µ—Ç—Ä, –æ–ø—Ä–µ–¥–µ–ª—è—é—â–∏–π –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–∏–º–≤–æ–ª–æ–≤ –¥–ª—è –∏–∑–≤–ª–µ—á–µ–Ω–∏—è
			
			–ü—Ä–æ–≤–µ—Ä–∫–∏:
				–ü—Ä–æ–≤–µ—Ä—è–µ—Ç—Å—è, —á—Ç–æ start –Ω–µ –æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω—ã–π. –ï—Å–ª–∏ –æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω—ã–π, –≤–æ–∑–Ω–∏–∫–∞–µ—Ç –æ—à–∏–±–∫–∞
				–ï—Å–ª–∏ count –Ω–µ —É–∫–∞–∑–∞–Ω, –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –¥–ª–∏–Ω–∞ —Å—Ç—Ä–æ–∫–∏. –ï—Å–ª–∏ —É–∫–∞–∑–∞–Ω, –ø—Ä–æ–≤–µ—Ä—è–µ—Ç—Å—è, —á—Ç–æ –æ–Ω –Ω–µ –ø—Ä–µ–≤—ã—à–∞–µ—Ç –¥–ª–∏–Ω—É —Ç–µ–∫—Å—Ç–∞
			
			–ò–∑–≤–ª–µ—á–µ–Ω–∏–µ –ø–æ–¥—Å—Ç—Ä–æ–∫–∏:
				–ü—Ä–µ–æ–±—Ä–∞–∑—É–µ—Ç —Ç–µ–∫—Å—Ç –≤ —Å–ø–∏—Å–æ–∫ —Å–∏–º–≤–æ–ª–æ–≤.
				–ü—Ä–æ–ø—É—Å–∫–∞–µ—Ç –ø–µ—Ä–≤—ã–µ start —Å–∏–º–≤–æ–ª–æ–≤ –∏ –∏–∑–≤–ª–µ–∫–∞–µ—Ç end - start —Å–∏–º–≤–æ–ª–æ–≤, —Å–æ–∑–¥–∞–≤–∞—è –Ω–æ–≤—É—é —Å—Ç—Ä–æ–∫—É –∏–∑ —Å–ø–∏—Å–∫–∞
			
			–í–æ–∑–≤—Ä–∞—â–∞–µ–º–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ:
				–§—É–Ω–∫—Ü–∏—è –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∏–∑–≤–ª–µ—á–µ–Ω–Ω—É—é –ø–æ–¥—Å—Ç—Ä–æ–∫—É
			
			–ü—Ä–∏–º–µ—Ä:
				1	–ò–∑–≤–ª–µ—á–µ–Ω–∏–µ –ø–æ–¥—Å—Ç—Ä–æ–∫–∏ —Å –Ω–∞—á–∞–ª–∞:
					= F[Text.Substring] ("Hello, World!", 0, 5)		= "Hello"

				2	–ò–∑–≤–ª–µ—á–µ–Ω–∏–µ –ø–æ–¥—Å—Ç—Ä–æ–∫–∏, –Ω–∞—á–∏–Ω–∞—è —Å –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω–æ–≥–æ –∏–Ω–¥–µ–∫—Å–∞:
					= F[Text.Substring] ("Hello, World!", 7, 5)		= "World"

				3	–ò–∑–≤–ª–µ—á–µ–Ω–∏–µ –ø–æ–¥—Å—Ç—Ä–æ–∫–∏ —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º —Ç–æ–ª—å–∫–æ –Ω–∞—á–∞–ª—å–Ω–æ–≥–æ –∏–Ω–¥–µ–∫—Å–∞:
					= F[Text.Substring] ("Hello, World!", 7)		= "World!" (–∏–∑–≤–ª–µ–∫–∞–µ—Ç –¥–æ –∫–æ–Ω—Ü–∞ —Å—Ç—Ä–æ–∫–∏)

				4	–ü–æ–ø—ã—Ç–∫–∞ –∏–∑–≤–ª–µ—á–µ–Ω–∏—è —Å –æ—à–∏–±–∫–æ–π:
					= F[Text.Substring] ("Hello, World!", -1, 5)	= –û—à–∏–±–∫–∞: "start index should be >= 0"

				5	–ü–æ–ø—ã—Ç–∫–∞ –∏–∑–≤–ª–µ—á–µ–Ω–∏—è —Å –ø—Ä–µ–≤—ã—à–∞—é—â–∏–º –∑–Ω–∞—á–µ–Ω–∏–µ–º count:
					= F[Text.Substring] ("Hello, World!", 0, 20)	=  –û—à–∏–±–∫–∞: "count should be <= text length"

		*/
		(text as text, start as number, optional count as number) => 
			let 
				start 	 = 	if start >= 0 then start else error "start index should be >= 0",
				end 	 = 	if 	count = null 
							then Text.Length(text) 
							else 	if count <= Text.Length(text) 
									then count 
									else error "count should be <= text length",
				textList = Text.ToList(text),
				substr 	 = Text.FromList(List.FirstN(List.Skip(textList, start), end - start))
			in 
				substr,

	Text.ToList_		 = // —Ä–∞–∑–¥–µ–ª–µ–Ω–∏–µ —Ç–µ–∫—Å—Ç–∞ –ø–æ –∫–∞–∂–¥–æ–º—É —Å–∏–º–≤–æ–ª—É (–≤—Å—Ç—Ä–æ–µ–Ω–Ω–∞ —Ñ—É–Ω–∫—Ü–∏—è)
		(txt as text)=> Text.ToList(Text.AlphabetRu),
	Text.PositionAfter   = // # —Ñ—É–Ω–∫—Ü–∏—è –ø–æ–∏—Å–∫–∞ –ø–æ–∑–∏—Ü–∏–∏ –ø–æ—Å–ª–µ –ø–µ—Ä–≤–æ–≥–æ –≤—Ö–æ–∂–¥–µ–Ω–∏—è –ø–æ–¥—Å—Ç—Ä–æ–∫–∏ –≤ —Å—Ç—Ä–æ–∫–µ
		/*
			–ü–æ–∏—Å–∫ —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–π –ø–æ–¥—Å—Ç—Ä–æ–∫–∏:
				text 		= "Hello, World!"
				substring 	= "Hello"
				–†–µ–∑—É–ª—å—Ç–∞—Ç: 	5 (–∏–Ω–¥–µ–∫—Å —Å—Ä–∞–∑—É –ø–æ—Å–ª–µ "Hello")

			–ü–æ–∏—Å–∫ –Ω–µ—Å—É—â–µ—Å—Ç–≤—É—é—â–µ–π –ø–æ–¥—Å—Ç—Ä–æ–∫–∏:
				text 		= "Hello, World!"
				substring 	= "Goodbye"
				–†–µ–∑—É–ª—å—Ç–∞—Ç: 	-1 (–ø–æ–¥—Å—Ç—Ä–æ–∫–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞)
			
			–†–∞–±–æ—Ç–∞ —Å null:
				text 		= null
				substring 	= "Hello"
				–†–µ–∑—É–ª—å—Ç–∞—Ç: 	-1 (—Ç–µ–∫—Å—Ç —Ä–∞–≤–µ–Ω null)
		*/

		(text as nullable text, substring as text) => 
			let 
				firstIndex = Text.PositionOf(text, substring),
				indexAfter = if firstIndex >=0 then firstIndex + Text.Length(substring) else -1
			in
				if text is null then -1 else if indexAfter >= 0 and indexAfter < Text.Length(text) then indexAfter else -1,
	
	Text.Until         	 = // # —Ñ—É–Ω–∫—Ü–∏—è –∏–∑–≤–ª–µ–∫–∞–µ—Ç –ø–æ–¥—Å—Ç—Ä–æ–∫—É –∏–∑ —Ç–µ–∫—Å—Ç–∞, –Ω–∞—á–∏–Ω–∞—è —Å –∑–∞–¥–∞–Ω–Ω—ã–º –∏–Ω–¥–µ–∫—Å–æ–º –∏ –∑–∞–∫–∞–Ω—á–∏–≤–∞—è –ø–µ—Ä–µ–¥ —É–∫–∞–∑–∞–Ω–Ω—ã–º —Ä–∞–∑–¥–µ–ª–∏—Ç–µ–ª–µ–º
		/*
			–û–ø–∏—Å–∞–Ω–∏–µ
				—Ñ—É–Ω–∫—Ü–∏—é, –∫–æ—Ç–æ—Ä–∞—è –∏–∑–≤–ª–µ–∫–∞–µ—Ç –ø–æ–¥—Å—Ç—Ä–æ–∫—É –∏–∑ –∑–∞–¥–∞–Ω–Ω–æ–≥–æ —Ç–µ–∫—Å—Ç–∞, –Ω–∞—á–∏–Ω–∞—è —Å –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω–æ–≥–æ –∏–Ω–¥–µ–∫—Å–∞ –∏ –∑–∞–∫–∞–Ω—á–∏–≤–∞—è –ø–µ—Ä–µ–¥ —É–∫–∞–∑–∞–Ω–Ω—ã–º —Ä–∞–∑–¥–µ–ª–∏—Ç–µ–ª–µ–º
			
			–ü–∞—Ä–∞–º–µ—Ç—Ä—ã:
				text			—Å—Ç—Ä–æ–∫–∞, –∏–∑ –∫–æ—Ç–æ—Ä–æ–π –∏–∑–≤–ª–µ–∫–∞–µ—Ç—Å—è –ø–æ–¥—Å—Ç—Ä–æ–∫–∞
				endDelimiter	—Ä–∞–∑–¥–µ–ª–∏—Ç–µ–ª—å, —É–∫–∞–∑—ã–≤–∞—é—â–∏–π, –≥–¥–µ –∑–∞–∫–æ–Ω—á–∏—Ç—å –∏–∑–≤–ª–µ—á–µ–Ω–∏–µ
				startIndex		–Ω–µ–æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–π –ø–∞—Ä–∞–º–µ—Ç—Ä, —É–∫–∞–∑—ã–≤–∞—é—â–∏–π, —Å –∫–∞–∫–æ–≥–æ –∏–Ω–¥–µ–∫—Å–∞ –Ω–∞—á–∏–Ω–∞—Ç—å –∏–∑–≤–ª–µ—á–µ–Ω–∏–µ (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é 0)
			
			–û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –Ω–∞—á–∞–ª—å–Ω–æ–≥–æ –∏–Ω–¥–µ–∫—Å–∞:
				–ï—Å–ª–∏ startIndex —Ä–∞–≤–µ–Ω null, —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç—Å—è –∑–Ω–∞—á–µ–Ω–∏–µ start —Ä–∞–≤–Ω—ã–º 0
				–í –ø—Ä–æ—Ç–∏–≤–Ω–æ–º —Å–ª—É—á–∞–µ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –∑–Ω–∞—á–µ–Ω–∏–µ startIndex
			
			–ò–∑–≤–ª–µ—á–µ–Ω–∏–µ —Ç–µ–∫—Å—Ç–∞:
				textFromStart –∏–∑–≤–ª–µ–∫–∞–µ—Ç –ø–æ–¥—Å—Ç—Ä–æ–∫—É –∏–∑ text, –Ω–∞—á–∏–Ω–∞—è —Å start —Å –ø–æ–º–æ—â—å—é —Ñ—É–Ω–∫—Ü–∏–∏ Text.Substring
			
			–ü–æ–∏—Å–∫ –ø–æ–∑–∏—Ü–∏–∏ —Ä–∞–∑–¥–µ–ª–∏—Ç–µ–ª—è:
				delimPosition –∏—â–µ—Ç –ø–æ–∑–∏—Ü–∏—é endDelimiter –≤ textFromStart
				–ï—Å–ª–∏ —Ä–∞–∑–¥–µ–ª–∏—Ç–µ–ª—å –Ω–∞–π–¥–µ–Ω, —Å–æ—Ö—Ä–∞–Ω—è–µ—Ç—Å—è –µ–≥–æ –ø–æ–∑–∏—Ü–∏—è; –µ—Å–ª–∏ –Ω–µ—Ç, –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –¥–ª–∏–Ω–∞ textFromStart
			
			–í–æ–∑–≤—Ä–∞—â–∞–µ–º–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ:
				–ï—Å–ª–∏ text —Ä–∞–≤–Ω–æ null, —Ñ—É–Ω–∫—Ü–∏—è –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç null
				–í –ø—Ä–æ—Ç–∏–≤–Ω–æ–º —Å–ª—É—á–∞–µ, —Ñ—É–Ω–∫—Ü–∏—è –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –ø–æ–¥—Å—Ç—Ä–æ–∫—É –∏–∑ textFromStart, –Ω–∞—á–∏–Ω–∞—è —Å 0 –∏ –¥–æ delimPosition
			
			–ü—Ä–∏–º–µ—Ä
				–ò–∑–≤–ª–µ—á–µ–Ω–∏–µ –ø–æ–¥—Å—Ç—Ä–æ–∫–∏:
					Result = Text.Range("Hello, World! This is a test.", " ", 7)
					–†–µ–∑—É–ª—å—Ç–∞—Ç: "World!" (–∏–∑–≤–ª–µ—á–µ–Ω–∏–µ —Ç–µ–∫—Å—Ç–∞ –æ—Ç –∏–Ω–¥–µ–∫—Å–∞ 7 –¥–æ –ø–µ—Ä–≤–æ–≥–æ –ø—Ä–æ–±–µ–ª–∞ –ø–æ—Å–ª–µ "World!")
				
				–ï—Å–ª–∏ —Ä–∞–∑–¥–µ–ª–∏—Ç–µ–ª—å –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç:
					text = "Hello, World!"
					endDelimiter = "."
					–†–µ–∑—É–ª—å—Ç–∞—Ç: "Hello, World!" (—Ç–∞–∫ –∫–∞–∫ —Ä–∞–∑–¥–µ–ª–∏—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω, –ø–æ–¥—Å—Ç—Ä–æ–∫–∞ –∏–∑–≤–ª–µ–∫–∞–µ—Ç—Å—è –¥–æ –∫–æ–Ω—Ü–∞)
		*/

		(text as text, endDelimiter as text, optional startIndex as number) => 
		let
			start = if startIndex = null then 0 else startIndex,
			textFromStart = Text.Substring(text, start),
			delimPosition = if Text.PositionOf(textFromStart, endDelimiter) >= 0 then Text.PositionOf(textFromStart, endDelimiter) else Text.Length(textFromStart)
		in
			if text is null then null else Text.Range(textFromStart, 0, delimPosition),
	// –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ
	Text.AsciiOnly     	= // –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –Ω–µ ascii —Å–∏–º–≤–æ–ª—ã (<= 255) –≤ —Å—Ç—Ä–æ–∫–µ
        //Filters out all non-ascii characters from a string
        (s as text) as text =>
        let
            Listified   = Text.ToList(s),
            Numbered    = List.Transform(Listified, each Character.ToNumber(_)),
            Filtered    = List.Select(Numbered, each _ <= 255),
            Stringified = List.Transform(Filtered, each Character.FromNumber(_)),
            Joined      = Text.Combine(Stringified, ""),
            Return      = Joined
        in
            Return,

    Text.Between       	= // –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Ç–µ–∫—Å—Ç –º–µ–∂–¥—É —Ä–∞–∑–¥–µ–ª–∏—Ç–µ–ª—è–º–∏
        /*
            –û–ø–∏—Å–∞–Ω–∏–µ 	–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Ç–µ–∫—Å—Ç –º–µ–∂–¥—É —Ä–∞–∑–¥–µ–ª–∏—Ç–µ–ª—è–º–∏
            Usage		F[Text.Between]("abcdef", "bc", "f")
            Result	 	"de"
        */

        (   Text       as text, 
            After      as text, 
            Before     as text
        ) as text =>
            let
                CutAfter  = Text.Split(Text, After),
                CutBefore = Text.Split(CutAfter{1}, Before),
                Needle    = 
                    if List.Count(CutAfter) > 1
                    then (if List.Count(CutBefore) > 1 
                        then CutBefore{0} 
                        else Error.Record("–ù–∞–π—Ç–∏ —Ç–µ–∫—Å—Ç –Ω–µ —É–¥–∞–ª–æ—Å—å","–¢–µ–∫—Å—Ç –Ω–µ —Å–æ–¥–µ—Ä–∂–∏—Ç –∫–ª—é—á–µ–≤—ã—Ö —Å–ª–æ–≤" & Before, Text))
                    else error Error.Record("FindTextFailed","The text did not contain the keyword " & After, Text)
            in 
                Needle,

    Text.ContainsAny   	= // —Å–æ–¥–µ—Ä–∂–∏—Ç –ª–∏ —Å—Ç—Ä–æ–∫–∞ –∫–∞–∫–æ–µ-–ª–∏–±–æ —Å–ª–æ–≤–æ –∏–∑ —Å–ø–∏—Å–∫–∞
        /*
            –û–ø–∏—Å–∞–Ω–∏–µ	–ø—Ä–æ–≤–µ—Ä–∫–∞ —Å—Ç—Ä–æ–∫–∏ –Ω–∞ –Ω–∞–ª–∏—á–∏–µ –ª—é–±–æ–≥–æ —Å–ª–æ–≤–∞ –∏–∑ –∑–∞–¥–∞–Ω–Ω–æ–≥–æ —Å–ø–∏—Å–∫–∞
            –ü—Ä–∏–º–µ—Ä		= F[Text.ContainsAny] ("the cat sat on the mat", {"cat", "apple"})
            –†–µ–∑—É–ª—å—Ç–∞—Ç	true
            –ü—Ä–∏–º–µ—á–∞–Ω–∏–µ	–¢–æ –∂–µ, —á—Ç–æ –∏ List.ContainsAny({"–º–∞–º–∞ –º—ã–ª–∞ –ø–∞–ø—É —Ä—è–¥–æ–º"}, {"–º–∞–ø–∞","–ø–∞–ø—É"}, Text.Contains)
        */

        (str, needles) as logical =>
        let
            count = List.Count(needles)
        in
            List.AnyTrue(
                List.Generate(
                    ()=>[i=0],
                    each [i] < count,
                    each [i=[i]+1],
                    each Text.Contains(str,needles{[i]})
                )
            ),

    Text.Count         	= // —á–∏—Å–ª–æ –≤—Ö–æ–∂–¥–µ–Ω–∏–π —Å–∏–º–≤–æ–ª–∞ –≤ —Å—Ç—Ä–æ–∫–µ
        /*
            Returns the number of occurrences of a substring (needle) within another string (haystack).
            Usage:
                let
                    Text.Count = Load("Text.Count")
                in
                    Text.Count("Abba", "b")
            Result: 
                2
        */

        (Haystack as text, Needle as text) as number =>
            List.Count(Text.Split(Haystack, Needle)) - 1,

    Text.EachBetween   	= // –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Ç–µ–∫—Å—Ç –º–µ–∂–¥—É –Ω–µ—Å–∫–æ–ª—å–∫–∏–º–∏ –ø–∞—Ä–Ω—ã–º–∏ —Ä–∞–∑–¥–µ–ª–∏—Ç–µ–ª—è–º–∏
        /*
            Grabs the substring between the specified 'after' and 'before' strings
            Usage:
                Text.EachBetween = Load("Text.EachBetween"),
                Text.EachBetween("a[bc][d]ef", "[", "]")
            Result: 
                {"bc", "d"}
        */

        (Haystack as text, After as text, Before as text) as list =>
        let
            CutAfter  = Text.Split(Haystack, After),
            SkipFirst = List.Skip(CutAfter),
            CutEach   = List.Transform(SkipFirst, each Text.Split(_, Before){0})
        in 
            CutEach,

    Text.EachFromTo    	= // –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Ç–µ–∫—Å—Ç –º–µ–∂–¥—É –Ω–µ—Å–∫–æ–ª—å–∫–∏–º–∏ –ø–∞—Ä–Ω—ã–º–∏ —Ä–∞–∑–¥–µ–ª–∏—Ç–µ–ª—è–º–∏ + —Ä–∞–∑–¥–µ–ª–∏—Ç–µ–ª–∏
        /*
            Grabs the substring between the specified 'after' and 'before' strings
            
            Usage:		F[Text.EachFromTo]("a[bc][d]ef", "[", "]")
            Result: 	{"[bc]", "[d]"}
        */

        (
            Haystack 	as text, 
            After 		as text, 
            Before 		as text
        ) =>
        
        let
            CutAfter 	= Text.Split(Haystack, After),
            SkipFirst 	= List.Skip(CutAfter),
            CutEach 	= List.Transform(SkipFirst, each After & Text.Split(_, Before){0} & Before)
        in 
            CutEach,

    Text.FromTo        	= // –∑–∞—Ö–≤–∞—Ç—ã–≤–∞–µ—Ç –ø–µ—Ä–≤—É—é –ø–æ–¥—Å—Ç—Ä–æ–∫—É –æ—Ç —É–∫–∞–∑–∞–Ω–Ω–æ–π —Å—Ç—Ä–æ–∫–∏ ¬´–û—Ç¬ª –¥–æ —Å—Ç—Ä–æ–∫–∏ ¬´–í–≤–µ—Ä—Ö –¥–æ¬ª
        /*
            Description:
                Grabs the first substring from the specified 'From' up to the 'UpTo' string
                –ó–∞—Ö–≤–∞—Ç—ã–≤–∞–µ—Ç –ø–µ—Ä–≤—É—é –ø–æ–¥—Å—Ç—Ä–æ–∫—É –æ—Ç —É–∫–∞–∑–∞–Ω–Ω–æ–π —Å—Ç—Ä–æ–∫–∏ ¬´–û—Ç¬ª –¥–æ —Å—Ç—Ä–æ–∫–∏ ¬´–í–≤–µ—Ä—Ö –¥–æ¬ª.
            
            Usage:
                Text.FromTo = Load("Text.FromTo"),
                Text.FromTo("abcdef", "bc", "f")
            
            Result: 
                "bcdef"
        */

        (Haystack as text, From as text, UpTo as text) as text =>
        let
            CutAfter  = Text.Split(Haystack, From),
            CutBefore = Text.Split(CutAfter{1}, UpTo),
            Needle = 
                if List.Count(CutAfter) > 1
                then (
                    if List.Count(CutBefore) > 1 
                    then From & CutBefore{0} & UpTo 
                    else Error.Record("FindTextFailed","The text did not contain the keyword " & UpTo, Haystack)
                    )
            else error Error.Record("FindTextFailed","The text did not contain the keyword " & From, Haystack)
        in 
            Needle,

    Text.Like          	= // –ø–æ–∑–≤–æ–ª—è–µ—Ç –≤—ã–ø–æ–ª–Ω—è—Ç—å –Ω–µ—á–µ—Ç–∫–∏–µ —Å—Ä–∞–≤–Ω–µ–Ω–∏—è —Å—Ç—Ä–æ–∫, –∞–Ω–∞–ª–æ–≥–∏—á–Ω—ã–µ SQL LIKE
        /*
            Description:            
                Allows doing fuzzy string comparisons akin to SQL's LIKE
                –ü–æ–∑–≤–æ–ª—è–µ—Ç –≤—ã–ø–æ–ª–Ω—è—Ç—å –Ω–µ—á–µ—Ç–∫–∏–µ —Å—Ä–∞–≤–Ω–µ–Ω–∏—è —Å—Ç—Ä–æ–∫, –∞–Ω–∞–ª–æ–≥–∏—á–Ω—ã–µ SQL LIKE.

            Usage:
                Text.Like = Load("Text.Like"),
                Text.Like("the cat sat on the mat", "%cat%sat%mat%")
            
            Result: 
                true
        */

        //Originally written by Chris Webb: https://cwebbbi.wordpress.com/2014/05/27/implementing-a-basic-likewildcard-search-function-in-power-query/
        (Phrase as text, Pattern as text) as logical =>
        let
            PatternList  = Text.Split(Pattern, "%"),	 // Split pattern up into a list using % as a delimiter
            StartsWithWc = (List.First(PatternList)=""), // if the first character in the pattern is % then the first item in the list is an empty string
            EndsWithWc   = (List.Last(PatternList)=""),	 // if the last character in the pattern is % then the last item in the list is an empty string
            
            //if the first character is not % then we have to match the first string in the pattern with the opening characters of the phrase
            StartsTest = 
                if (StartsWithWc=false) 
                then Text.StartsWith(Phrase, List.First(PatternList)) 
                else true,
            
            //if the last item is not % then we have to match the final string in the pattern with the final characters of the phrase
            EndsText = 
                if (EndsWithWc=false) 
                then Text.EndsWith(Phrase, List.Last(PatternList)) 
                else true,
            
            //now we also need to check that each string in the pattern appears in the correct order in the phrase and to do this we need to declare a function PhraseFind
            PhraseFind = 
                (Phrase as text, SearchString as list) =>
                let
                    //does the first string in the pattern appear in the phrase?
                    StringPos = Text.PositionOf(Phrase, SearchString{0}, Occurrence.First),
                    PhraseFindOutput = 
                        if
                        
                        //if string not find then return false 
                        (StringPos=-1) 
                        then false 
                        else if
                        
                        //we have found the string in the pattern, and if this is the last string in the pattern, return true
                        List.Count(SearchString)=1
                        then true
                        else
                        
                        //if it isn't the last string in the pattern test the next string in the pattern by removing the first string from the pattern list and all text up to and including the string we have found in the phrase
                        (true and
                        @PhraseFind(
                        Text.RemoveRange(Phrase, 0, StringPos + Text.Length(SearchString{0})),
                        List.RemoveRange(SearchString, 0, 1)))
                    in
                        PhraseFindOutput,
            
            //return true if we have passed all tests    
            Output = StartsTest and EndsText and PhraseFind(Phrase, PatternList) 
        in
            Output,

    Text.MixedSort     	= // —Å–æ—Ä—Ç–∏—Ä—É–µ—Ç —Å–º–µ—à–∞–Ω–Ω—É—é —Å—Ç—Ä–æ–∫—É –∏–∑ —Ç–µ–∫—Å—Ç–∞ (–≤ –±—É–∫–≤–µ–Ω–Ω–æ-—Ü–∏—Ñ—Ä–æ–≤–æ–º –ø–æ—Ä—è–¥–∫–µ) –∏ —á–∏—Å–µ–ª (–≤ —á–∏—Å–ª–æ–≤–æ–º –ø–æ—Ä—è–¥–∫–µ)
        /*
            Description:
                Sorts mixed list of text and numbers in a numerical order for numbers and alphanumeric for text 
                Arguments// "txt"= Text value to sort 

                –°–æ—Ä—Ç–∏—Ä—É–µ—Ç —Å–º–µ—à–∞–Ω–Ω—ã–π —Å–ø–∏—Å–æ–∫ —Ç–µ–∫—Å—Ç–∞ –∏ —á–∏—Å–µ–ª –≤ —á–∏—Å–ª–æ–≤–æ–º –ø–æ—Ä—è–¥–∫–µ –¥–ª—è —á–∏—Å–µ–ª –∏ –≤ –±—É–∫–≤–µ–Ω–Ω–æ-—Ü–∏—Ñ—Ä–æ–≤–æ–º –ø–æ—Ä—è–¥–∫–µ –¥–ª—è —Ç–µ–∫—Å—Ç–∞. 
                –ê—Ä–≥—É–º–µ–Ω—Ç—ã// "txt"= –¢–µ–∫—Å—Ç–æ–≤–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –¥–ª—è —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∏
            
            Author: 
                Bill Szysz in https://social.technet.microsoft.com/Forums/en-US/aed476c6-0daa-4aa2-b763-993195d4d0eb/how-to-sort-in-cell-values-with-comma-seperated-using-power-query?forum=powerquery 

            Suggested improvement: 
                Integrate option to choose order direction (ascending, descending) by function parameters 
                –ò–Ω—Ç–µ–≥—Ä–∏—Ä–æ–≤–∞—Ç—å –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å –≤—ã–±–æ—Ä–∞ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è –æ—Ä–¥–µ—Ä–∞ (–ø–æ –≤–æ–∑—Ä–∞—Å—Ç–∞–Ω–∏—é, —É–±—ã–≤–∞–Ω–∏—é) –ø–æ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º —Ñ—É–Ω–∫—Ü–∏–∏
        */
       
        (txt as text) as text =>
        let 
            SplitTrim   = List.Transform(Text.Split(txt, ","), each Text.Trim(_)), 
            Transform   = List.Transform(SplitTrim, each try Number.From(_) otherwise _), 
            LstSort     = List.Sort(Transform, 0), 
            Transform2  = List.Transform(LstSort, each Text.From(_)), 
            CombineText = Text.Combine(Transform2, ", ")  	 
        in 
            CombineText,

    Text.PowerTrim     	= // —É–¥–∞–ª—è–µ–º –¥–≤–æ–π–Ω—ã–µ –ø—Ä–æ–±–µ–ª—ã (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ –¥—Ä—É–≥–æ–π —Å–∏–º–≤–æ–ª), –∞ —Ç–∞–∫–∂–µ –ø—Ä–æ–±–µ–ª—ã –≤ –Ω–∞—á–∞–ª–µ/–∫–æ–Ω—Ü–µ —Å—Ç—Ä–æ–∫–∏
        /*
			Description:
				–§—É–Ω–∫—Ü–∏—è —É–¥–∞–ª—è–µ—Ç –¥–≤–æ–π–Ω—ã–µ —Å–∏–º–≤–æ–ª—ã —É–∫–∞–∑–∞–Ω–Ω—ã—Ö —Å–∏–º–≤–æ–ª–æ–≤
				–ü–æ —É–º–æ–ª—á–∞–Ω–∏—é —É–¥–∞–ª—è—é—Ç—Å—è –¥–≤–æ–π–Ω—ã–µ –ø—Ä–æ–±–µ–ª—ã –∏ –Ω–∞—á–∞–ª—å–Ω—ã–µ –∏ –∫–æ–Ω–µ—á–Ω—ã–µ –ø—Ä–æ–±–µ–ª—ã.
				–ö–∞–∫ —Ñ—É–Ω–∫—Ü–∏—è TRIM –≤ Excel
            Link:
                http://www.excelguru.ca/blog/2015/10/08/clean-whitespace-in-powerquery/
        */

        (text as text, optional char_to_trim as text) =>
            let
                char  = if char_to_trim = null 
                        then " " 
                        else char_to_trim,
                split        = Text.Split(text, char),
                removeblanks = List.Select(split, each _ <> ""),
                result       = Text.Combine(removeblanks, char)
            in
                result,

    Text.Queries       	= 1, // –∑–∞–ø—Ä–æ—Å—ã –∏–∑ —Ñ–∞–π–ª–æ–≤ –≤ –ø–∞–ø–∫–µ –≤ –≤–∏–¥–µ —Ç–µ–∫—Å—Ç–∞, –Ω–µ –ø—Ä–æ–≤–µ—Ä—è–ª
        // /*
        //     Description:
        //         text user-defined queries
        //     to = Text.Combine(List.Select(Text.Split(text, char), each _ <> ""), char)
        // */
        // let
        //     LoadPath = "", // 
		// 	Files       = Folder.Files(LoadPath), // Folder.Contents
        //     AddDecode   = Table.AddColumn(Files, "Text", each Text.FromBinary([Content])),
        //     FilterCols  = Table.SelectColumns(AddDecode, {"Name", "Text"}),
        //     TextCol     = Table.Column(FilterCols, "Text"),
        //     TextMerged  = Text.Combine(TextCol),
        //     TextCleaned = TextMerged, // sorry, no regex to clean out comments!
        //     Return      = TextCleaned
        // in
        //     Return,

    Text.RemoveSymbols 	= // —á–∏—Å—Ç–∏–º —Ç–µ–∫—Å—Ç –æ—Ç –≤—Å–µ—Ö –Ω–µ–ø–µ—á–∞—Ç–Ω—ã—Ö —Å–∏–º–≤–æ–ª–æ–≤ (129 —Å–∏–º–≤–æ–ª–æ–≤)
        /*
			Description		–ß–∏—Å—Ç–∏–º —Ç–µ–∫—Å—Ç –æ—Ç –≤—Å–µ—Ö –Ω–µ–ø–µ—á–∞—Ç–Ω—ã—Ö —Å–∏–º–≤–æ–ª–æ–≤
            Link			https://cwebbbi.wordpress.com/2014/08/18/removing-punctuation-from-text-in-power-query/
            Usage			= F[Text.RemoveSymbols]("a,b,c") 
            Result			= "abc" -> —É–¥–∞–ª–∏–ª –∑–∞–ø—è—Ç—ã–µ
        */

        (inputtext as text) as text =>
        let
            //  get a list of lists containing the numbers of Unicode punctuation characters
                numberlists = {{0..31},{33..47},{58..64},{91..96},{123..191}},
            
            //  turn this into a single list
                combinedlist = List.Combine(numberlists),
            
            //  get a list of all the punctuation characters that these numbers represent
                punctuationlist = List.Transform(combinedlist, each Character.FromNumber(_)),
            
            //  some text to test this on
            //  inputtext = "Hello! My name is Chris, and I'm hoping that this *cool* post will help you!",
            //  the text with punctuation removed
                outputtext = Text.Remove(inputtext, punctuationlist)
        in
            outputtext,

    Text.ReplaceAll    	= // –Ω–µ—Å–∫–æ–ª—å–∫–æ –∑–∞–º–µ–Ω —Ç–µ–∫—Å—Ç–∞, –ø–µ—Ä–µ–¥–∞–≤–∞—è –∑–∞–º–µ–Ω—ã –≤ –≤–∏–¥–µ —Å–ø–∏—Å–∫–∞ —Å–ø–∏—Å–∫–æ–≤ (List.Accumulate)
        /*
            –û–ø–∏—Å–∞–Ω–∏–µ:
                –í—ã–ø–æ–ª–Ω—è–π—Ç–µ –Ω–µ—Å–∫–æ–ª—å–∫–æ –∑–∞–º–µ–Ω —Ç–µ–∫—Å—Ç–∞ –∑–∞ –æ–¥–∏–Ω –≤—ã–∑–æ–≤ —Ñ—É–Ω–∫—Ü–∏–∏, –ø–µ—Ä–µ–¥–∞–≤–∞—è –∑–∞–º–µ–Ω—ã –≤ –≤–∏–¥–µ —Å–ø–∏—Å–∫–∞ —Å–ø–∏—Å–∫–æ–≤.
            
            –ü—Ä–∏–º–µ—Ä:	= F[Text.ReplaceAll] (
						"(test)", 
						{
							{"(", "["},
							{")", "]"}
						}
					)

            –†–µ–∑—É–ª—å—Ç–∞—Ç: 
                "[test]"
			
			–û–¥–Ω–æ–π —Å—Ç—Ä–æ–∫–æ–π:
				f = (str as text, Replacements as list) as text => List.Accumulate(Replacements, str, (s, c) => Text.Replace(s, c{0}, c{1}))
        */

        (str as text, Replacements as list) as text => 
            List.Accumulate(
				Replacements, 
				str, 
				(s, c) => Text.Replace(s, c{0}, c{1})
			),
	// —Ä–∞–∑–æ–±—Ä–∞—Ç—å 
	Text.q1 = "",
	//===========================
	// Time
	//===========================
	Time.EpochToTime 	= // —É–¥–∞–ª—è–µ—Ç –≤ —Ç–µ–∫—Å—Ç–æ–≤–æ–º –≤—Ä–µ–º–µ–Ω–∏ —Å–∏–º–≤–æ–ª—ã "PT","S" –∏ –º–µ–Ω—è–µ—Ç "H","M" –Ω–∞ ":"
        (epoch as nullable text ) =>
        let
            res = if epoch = null then null else
				let
					remove_word    = Text.Replace(epoch, "PT", ""),
					remove_letterH = Text.Replace(remove_word, "H", ":"),
					remove_letterM = Text.Replace(remove_letterH, "M", ":"),
					remove_letterS = Text.Replace(remove_letterM, "S", "")
				in 
					remove_letterS
        in
            res,
	Misc.Wait   	 	= // –∑–∞–¥–µ—Ä–∂–∞—Ç—å –¥–µ–π—Å—Ç–≤–∏–µ –Ω–∞ —É–∫–∞–∑–∞–Ω–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–µ–∫—É–Ω–¥ (–∞–Ω–∞–ª–æ–≥ Function.InvokeAfter)
        /*
            –ó–∞–¥–µ—Ä–∂–∞—Ç—å –¥–∞–Ω–Ω–æ–µ –¥–µ–π—Å—Ç–≤–∏–µ –Ω–∞ —É–∫–∞–∑–∞–Ω–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–µ–∫—É–Ω–¥.
			–≠—Ç–∞ —Ñ—É–Ω–∫—Ü–∏—è —É—Å—Ç–∞—Ä–µ–ª–∞ –∏–∑-–∑–∞ –¥–æ–±–∞–≤–ª–µ–Ω–∏—è Function.InvokeAfter(), —Å–º.:
        	link:	https://cwebbbi.wordpress.com/2015/04/30/using-function-invokeafter-in-power-query/

			Usage:	Misc.Wait(0.5, ()=> Web.Contents("www.bing.com"))
            Result: [whatever result of the given action, except 0.5 seconds slower]
        */

        (seconds as number, action as function) =>
        if (
            List.Count(
                List.Generate(
                    () => DateTimeZone.LocalNow() + #duration(0,0,0,seconds),
                    (x) => DateTimeZone.LocalNow() < x,
                    (x) => x
                )
            ) = 0
        )
        then null
        // this if ... then null never triggers, but its purpose is to make the function depend on the waiting loop finishing
        else action(),
    
    
    
	//===========================
	// Record
	//===========================
	Record.Rename        = // –ø–µ—Ä–µ–∏–º–µ–Ω–æ–≤—ã–≤–∞–µ—Ç –ò–º—è –∑–∞–ø–∏—Å–∏, –∏—Å–ø–æ–ª—å–∑—É—è –ª—è–º–±–¥—É (–ø–µ—Ä–µ–¥–∞–≤–∞–µ–º—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è x,y)
        /*
            Description:	–ü–µ—Ä–µ–∏–º–µ–Ω—É–π—Ç–µ –∑–∞–ø–∏—Å—å, –∏—Å–ø–æ–ª—å–∑—É—è –∑–∞–¥–∞–Ω–Ω—É—é –ª—è–º–±–¥—É (–ø–µ—Ä–µ–¥–∞–≤–∞–µ–º—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è x,y)
            Usage:			= F[Record.Rename]([A=1, B=2], (x,y)=> x & Text.From(y))
            Result: 		[A1 = 1, B2 = 2]
        */

        (Rec as record, Lambda as function) as record =>
        let
            Keys     = Record.FieldNames(Rec),
            Values   = Record.FieldValues(Rec),
            Renamed  = List.Transform(Keys, each Lambda(_, Record.Field(Rec, _))),
            Recorded = Record.FromList(Values, Renamed),
            Return   = Recorded
        in
            Return,

    Record.Transform     = // –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤—ã–≤–∞–µ—Ç –ó–Ω–∞—á–µ–Ω–∏–µ –∑–∞–ø–∏—Å–∏, –∏—Å–ø–æ–ª—å–∑—É—è –ª—è–º–±–¥—É (–ø–µ—Ä–µ–¥–∞–≤–∞–µ–º—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è x,y)
        /*
            Description:	–ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤—ã–≤–∞–µ—Ç VALUE –∑–∞–ø–∏—Å–∏, –∏—Å–ø–æ–ª—å–∑—É—è –∑–∞–¥–∞–Ω–Ω—É—é –ª—è–º–±–¥—É (–ø–µ—Ä–µ–¥–∞–Ω–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è x,y)
            Usage:          F[Record.Transform]([A=1, B=2], (x,y) => x & Text.From(y))
            Result: 		[A="A1", B="B2"]
        */

        (Rec as record, Lambda as function) as record =>
        let
            Keys        = Record.FieldNames(Rec),
            Transformed = List.Transform(Keys, each Lambda(_, Record.Field(Rec, _))),
            Recorded    = Record.FromList(Transformed, Keys),
            Return      = Recorded
        in
            Return,

    Record.TransformJoin = // –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å—Ç—Ä–æ–∫—É –∏–∑ –ò–º–µ–Ω–∏ –∏ –ó–Ω–∞—á–µ–Ω–∏—è –∑–∞–ø–∏—Å–∏ (—Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º –ª—è–º–±–¥—ã –∏ —Ä–∞–∑–¥–µ–ª–∏—Ç–µ–ª—è)
        /*
            Description:	–°–æ–∫—Ä–∞—â–µ–Ω–∏–µ –¥–ª—è –≤–æ–∑–≤—Ä–∞—Ç–∞ —Å—Ç—Ä–æ–∫–æ–≤–æ–≥–æ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏—è (—Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º –∑–∞–¥–∞–Ω–Ω–æ–π –ª—è–º–±–¥—ã) –∑–∞–ø–∏—Å–∏
            Usage:			Record.TransformJoin([A=1, B=2], each _ & "=" & Text.From(Record.Field(Rec, _)))
            Result: 		"A=1, B=2"
        */

        (Rec as record, Lambda as function, optional Delimiter as text) as text =>
        let
            Delimiter   = if (Delimiter<>null) then Delimiter else ", ",
            Keys        = Record.FieldNames(Rec),
            Transformed = List.Transform(Keys, each Lambda(_, Record.Field(Rec,_))),
            Combined    = Text.Combine(Transformed, Delimiter),
            Return      = Combined
        in
            Return,

		
	//===========================
	// Value
	//===========================
	Value.TypeText 	 = 
		//
		(value as any) => 
			if value is binary then "binary" else
			if value is date then "date" else
			if value is datetime then "datetime" else
			if value is datetimezone then "datetimezone" else
			if value is duration then "duration" else
			if value is function then "function" else
			if value is list then "list" else
			if value is logical then "logical" else
			if value is none then "none" else
			if value is null then "null" else
			if value is number then "number" else
			if value is record then "record" else
			if value is table then "table" else
			if value is text then "text" else
			if value is time then "time" else
			if value is type then "type" else
			if value is any then "any"
			else error "unknown -- not a primitive type!",
	Value.ToText 	 = 
        /*
            Returns a string representation of a value, which works even on containers, unlike the built-in Text.From()
            Usage:
                Value.ToText = Load("Value.ToText"),
                Value.ToText({1,2,3})
            Result: 
                "{1, 2, 3}"
        */

        let 
            Value.ToText = (Val as any, optional RecursTypes as logical) as text =>
            let
                Record.TransformJoin = Load("Record.TransformJoin"),
                Type.ToText          = Load("Type.ToText"),
                RecursTypes          = if (RecursTypes<>null) then RecursTypes else false,
                Tried                = (try Val),
                Value                =  if Tried[HasError] 
                                        then Tried[Error] 
                                        else Tried[Value],
            /*
                DurationVals = {Duration.Days, Duration.Hours, Duration.Minutes, Duration.Seconds},
                DateVals = {Date.Year, Date.Month, Date.Day},
                TimeVals = {Time.Hour, Time.Minute, Time.Second},
                ZoneVals = {DateTimeZone.ZoneHours, DateTimeZone.ZoneMinutes},
                GetNumbers = (vals as list, obj as any) as text => Text.Combine(List.Transform(vals, each Number.ToText(Function.Invoke(_, {obj}))), ","),
            */
                CaseValues = {
                //{ (x)=> (try x)[HasError], "error " & @Value.ToText((try Value)[Error], RecursTypes) },
                { (x)=> Value.Is(x, type type), Type.ToText(Value, RecursTypes) },
                { (x)=> Value.Is(x, type function),
                    let
                        Type = Value.Type(Value),
                        Params = Type.FunctionParameters(Type),
                        Reqd = Type.FunctionRequiredParameters(Type),
                        Ret = Type.FunctionReturn(Type)
                    in
                        "function (" &
                        Record.TransformJoin(Params, (k,v) =>
                            (if List.PositionOf(Record.FieldNames(Params), k) >= Reqd then "optional " else "") &
                            k & " as " & @Value.ToText(v, RecursTypes)
                        )
                        & ") as " & @Value.ToText(Ret, RecursTypes)
                },
                { (x)=> Value.Is(x, type table), "#table(" & @Value.ToText(Table.ColumnNames(Value), RecursTypes) & ", " & @Value.ToText(Table.ToRows(Value), RecursTypes) & ")"},
                { (x)=> Value.Is(x, type record), "[" &
                    Record.TransformJoin(Value, (k,v) => k & "=" & @Value.ToText(v, RecursTypes))
                & "]" },
                { (x)=> Value.Is(x, type list), "{" & Text.Combine(List.Transform(Value, each @Value.ToText(_, RecursTypes)), ", ") & "}" },
                { (x)=> x = null, "null" },
            /*
                { (x)=> Value.Is(x, type text), """" & Value & """" },
                { (x)=> Value.Is(x, type binary), "#binary(""" & Binary.ToText(Value) & """)" },
                { (x)=> Value.Is(x, type date), "#date(" & GetNumbers(DateVals, Value) & ")" },    //alt: Date.ToText(Value)
                { (x)=> Value.Is(x, type time), "#time(" & GetNumbers(TimeVals, Value) & ")" },    //alt: Time.ToText(Value)
                { (x)=> Value.Is(x, type datetime),
                    let
                        Date = DateTime.Date(Value),
                        Time = DateTime.Time(Value)
                    in
                        "#datetime(" & GetNumbers(DateVals, Date) & ", " & GetNumbers(TimeVals, Time) & ")"
                },    //alt: DateTime.ToText(Value)
                { (x)=> Value.Is(x, type datetimezone),
                    let
                        DateTime = DateTimeZone.RemoveZone(Value),
                        Date = DateTime.Date(DateTime),
                        Time = DateTime.Time(DateTime)
                    in
                        "#datetimezone(" & GetNumbers(DateVals, Date) & ", " & GetNumbers(TimeVals, Time) & ", " & GetNumbers(ZoneVals, Value) & ")"
                },    //alt: DateTimeZone.ToText(Value)
                { (x)=> Value.Is(x, type duration), "#duration(" & GetNumbers(DurationVals, Value) & ")" },    //alt: Duration.ToText(Value)
            //    { (x)=> Value.Is(x, type logical), Logical.ToText(Value) },
            //    { (x)=> Value.Is(x, type number), Number.ToText(Value) },
                { (x)=> true, Text.From(Value) }
            */
                { (x)=> true, Expression.Constant(Value) }
                },
                Return = List.First(List.Select(CaseValues, each _{0}(Value))){1}
            in Return
        in Value.ToText,

    Value.TypeToText = 
        /*
            Returns a simple string representation of a value's type, which allows easy filtering, unlike the built-in Value.Type()
            Usage:
                let
                    Value.TypeToText = Load("Value.TypeToText")
                in
                    Value.TypeToText({1,2,3})
            Result: \
                "list"
        */

        (Value as any, optional Recurs as logical) as text =>
        let
            Recurs = if (Recurs<>null) 
                     then Recurs 
                     else false,
            
            // Type.ToText = Load("Type.ToText"),
			Type.ToText = F[Type.ToText],

            Type = Value.Type(Value),
            ToText = 
                if Value.Is(Value, type type) and Recurs 
                then "type " & 	Type.ToText(Value, Recurs)
                else 			Type.ToText(Type, Recurs),
        /*
            CaseValues = {
            { (x)=> (try x)[HasError], "error" },
            { (x)=> x = null, "null" },
            { (x)=> Value.Is(x, type type), "type"},
            { (x)=> Value.Is(x, type function), "function"},
            { (x)=> Value.Is(x, type table), "table"},
            { (x)=> Value.Is(x, type record), "record"},
            { (x)=> Value.Is(x, type list), "list"},
            { (x)=> Value.Is(x, type binary), "binary"},
            { (x)=> Value.Is(x, type logical), "logical"},
            { (x)=> Value.Is(x, type number), "number"},
            { (x)=> Value.Is(x, type text), "text"},
            { (x)=> Value.Is(x, type date), "date"},
            { (x)=> Value.Is(x, type time), "time"},
            { (x)=> Value.Is(x, type datetime), "datetime"},
            { (x)=> Value.Is(x, type datetimezone), "datetimezone"},
            { (x)=> Value.Is(x, type duration), "duration"},
            { (x)=> true, "?"}
            },
            Return = List.First(List.Select(CaseValues, each _{0}(Value))){1}
        */
            Return = ToText
        in 
            Return,

    Value.WaitFor    = 
        //author: Curt Hagenlocher
        //https://gist.github.com/CurtHagenlocher/68ac18caa0a17667c805

        (producer as function, interval as function, optional count as number) as any =>
        let
            list = List.Generate(
                //  start: first try, no result
                    () => {0, null},
                
                //  condition: stop if we have the result (try count null'd) or we've exceeded the max tries
                    (state) => state{0} <> null and (count = null or state{0} < count),
               
                //  next: stop try tally if we have our result, otherwise check again and tally a try
                    (state) =>  if state{1} <> null
                                then {null, state{1}}
                                else {  1 + state{0}, 
                                        Function.InvokeAfter(
                                            () => producer(state{0}), 
                                            interval(state{0})
                                        )},
                
                //  transformer: only return the result, not try tally
                    (state) => state{1})
        in
            List.Last(list),

	//===========================
	// Web
	//===========================
    Web.ContentsCustomRetry = 
        /*
            This is an example of how one can use custom handling of a web response based on the request's response status.
            author: Curt Hagenlocher
            https://gist.github.com/CurtHagenlocher/68ac18caa0a17667c805
        */

        (url as text, optional options as record) => 
        let
            Value.WaitFor = Load("Value.WaitFor")
        in
            Value.WaitFor(
                (i) =>
                    let
                        options2 = if options = null then [] else options,
                        options3 = options2 & (if i=0 then [] else [IsRetry=true]),
                        result   = Web.Contents(url, options3 & [ManualStatusHandling={429}]),
                        buffered = Binary.Buffer(result), // avoid risk of double request
                        status   = if buffered = null then 0 else Value.Metadata(result)[Response.Status],
                        actualResult = if status = 429 then null else buffered
                    in
                        actualResult,
                (i) => #duration(0, 0, 0, i*0.1)
            ),

    Web.Curl = 
        /*
            Get a curl command string for a given url and options (as used in Web.Contents()) for debugging purposes.
            Usage:
                Web.Curl = Load("Web.Curl"),
                Web.Curl("http://item.taobao.com/item.htm", [Query=[id="16390081398"]])
            Result: 
                'curl "http://item.taobao.com/item.htm?id=16390081398" -v'
        */

        (url as text, optional options as record) as text =>
        let
            //url = "http://item.taobao.com/item.htm?id=16390081398",
            //options = [Query=null],

            query   = options[Query],
            headers = options[Headers],
            qList   = List.Transform(Record.FieldNames(query), each _ & "=" & Record.Field(query, _)),
            hList   = List.Transform(Record.FieldNames(headers), each " -H """ & _ & ": " & Record.Field(headers, _) & """"),
            qJoined = try "?" & Text.Combine(qList, "&") otherwise "",
            hJoined = try Text.Combine(hList, "") otherwise "",
            Return  = "curl """ & url & qJoined & """" & hJoined & " -v"
        in
            Return,

    Web.FetchSequentially = 
        /*
            Sequentially scrape a given list of URLs with a given minimum delay between fetches
            Usage:
                let
                    Web.FetchSequentially = Load("Web.FetchSequentially"),
                    BaseUrl = "http://example.com/?p=",
                    Pages = List.Numbers(1, 5),
                    Urls = List.Transform(Pages, each BaseUrl & Number.ToText(_))
                in
                    Web.FetchSequentially(Urls)

            Result: 
                [a list of decoded contents for each of the input URLs]
        */

        (
            Urls as list, //type {text}
            optional Delay as number,       //in seconds, default 1
            optional Encoding as number,    //https://msdn.microsoft.com/en-us/library/windows/desktop/dd317756(v=vs.85).aspx
            optional Options                //see options below
        ) as list =>

        let
            Web.Scrape = Load("Web.Scrape"),
            Delay    = if (Delay    <> null) then Delay else 1,
            Encoding = if (Encoding <> null) then Encoding else TextEncoding.Utf8,
            Options  = if (Options  <> null) then Options else [
                //ApiKeyName = "",
                //Content = "",
                Query = [],
                Headers = []
            ],
            Count = List.Count(Urls)
        in

        List.Buffer(
            List.Skip(
                List.Generate(
                    () => [
                        i = 0,
                        Page = null
                    ],
                    each [i] <= Count,
                    each let
                        Url = Urls{[i]},
                        GetPage = (uri as text) => Text.FromBinary(
                            //Binary.Buffer(Web.Contents(uri, Options))
                            Web.Scrape(uri, Options)
                        , Encoding)
                    in [
                        i = [i] + 1,
                        Page = Function.InvokeAfter(()=>GetPage(Url), #duration(0,0,0,Delay))
                    ],
                    each [Page]
                )
            )
        ),

    Web.Scrape =
        /*
        Scrape a web page, raising an error with a curl command for debugging purposes in case the response is empty.
        Usage:
            Web.Scrape = Load("Web.Scrape"),
            Web.Scrape("http://google.com", [#"Referer"="http://google.com"])
        Result: 
            a binary representation of the Google front-page

        –ó–∞–≥—Ä—É–∂–∞–µ—Ç —Å—Ç—Ä–∞–Ω–∏—Ü—É —á–µ—Ä–µ–∑ –±–∏–Ω–∞—Ä–Ω—ã–π —Ñ–∞–π–ª –∏ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ –µ–≥–æ –≤ Csv 
        –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é –∫–æ–¥–∏—Ä–æ–≤–∫–∞ 1251 - —ç—Ç–æ –æ–ø—Ü–∏–∏ Web.Contents. –í–æ—Ç —ç—Ç–∏ Csv.Document(to,[Delimiter=",", Columns=5, Encoding=1251, QuoteStyle=QuoteStyle.None])
        */

        (url as text, optional options as record) as binary =>

        let
            Web.Curl = Load("Web.Curl"),
            Response = Web.Contents(url, options),
            Buffered = Binary.Buffer(Response),
            Meta     = try Value.Metadata(Response) otherwise null,
            Status   = if Buffered = null then 0 else Meta[Response.Status],
            Return   = if Status = 0 or Status >= 400  // Binary.Length(Buffered) = 0
                       then error Error.Record("ScrapeFailed", Web.Curl(url, options), Meta)
                       else Buffered
        in
            Return,

    Web.TimeAndDateCom.GetCountries = 
        /*
            Function returns a table with ID and Country Name used on service http://timeanddate.com
        */

        let
            Source       = Table.FromColumns({Lines.FromBinary(Web.Contents("http://www.timeanddate.com/calendar/"))}),
            FilteredRows = Table.SelectRows(Source, each Text.Contains([Column1], "select id")),
            FullText     = FilteredRows{0}[Column1],
            SelectText   = Text.Range( FullText, Text.PositionOf( FullText, "<select"), Text.PositionOf( FullText, "</select" ) - Text.PositionOf( FullText, "<select" ) ),
            TextToList   = Text.Split( SelectText, "option value="),
            RemFirstRow  = List.Skip(TextToList,1),
            ReplacedClosingTag = List.ReplaceValue(RemFirstRow,"</option><","",Replacer.ReplaceText),
            ConvertedtoTable   = Table.FromList(ReplacedClosingTag, Splitter.SplitByNothing(), null, null, ExtraValues.Error),
            SplitIDandName     = Table.SplitColumn(ConvertedtoTable,"Column1",Splitter.SplitTextByEachDelimiter({">"}, QuoteStyle.Csv, false),{"ID", "Country"}),
            ReplacedSelected   = Table.ReplaceValue(SplitIDandName," selected","",Replacer.ReplaceText,{"ID"}),
            ReplacedLastClosingTag = Table.ReplaceValue(ReplacedSelected,"</option>","",Replacer.ReplaceText,{"Country"}),
            RemovedDuplicates  = Table.Distinct(ReplacedLastClosingTag),
            SortedRows         = Table.Sort(RemovedDuplicates,{{"Country", Order.Ascending}})
        in
            SortedRows,
	//  Other
	Function.Profile = // –ø—Ä–æ—Ñ–∏–ª–∏—Ä—É–µ—Ç –≤—Ä–µ–º—è, –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ–µ –¥–ª—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è —Ñ—É–Ω–∫—Ü–∏–∏ –¥–ª—è –∑–∞–¥–∞–Ω–Ω—ã—Ö –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤.
        /*
            Description:
                Profiles the time taken to execute a function for the given parameters
                –ü—Ä–æ—Ñ–∏–ª–∏—Ä—É–µ—Ç –≤—Ä–µ–º—è, –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ–µ –¥–ª—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è —Ñ—É–Ω–∫—Ü–∏–∏ –¥–ª—è –∑–∞–¥–∞–Ω–Ω—ã—Ö –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤
            
            Usage:
                Text.Between = Load("Text.Between"),
                Function.Profile = Load("Function.Profile"),
                Function.Profile(Text.Between, {"abcdef", "bc", "f"})
           
           Result: 
            	"de" meta 00:00:00
        */
    
        (fn as function, params as list) as datetime =>
        let
            TimeBefore = DateTime.LocalNow(),
            evaluated = Function.Invoke(fn, params),
            TimeAfter = (try evaluated as none otherwise DateTime.LocalNow()),
        // ^ always evaluates to otherwise, just using the expression as a dummy to force getting the time only after evaluation has finished
            TimeTaken = TimeAfter - TimeBefore
        in
            evaluated meta [taken=TimeTaken],
	
	Type.ToText 	 = 
        /*
            Returns a simple string representation of a type, which allows easy filtering
            Usage:
                Type.ToText = Load("Type.ToText"),
                Type.ToText(type list)
            Result: 
                "list"
        */

        let 
            Type.ToText =
                (Type as any, optional Recurs as logical) as text =>
        let
            Record.TransformJoin = Load("Record.TransformJoin"),
            Recurs = if (Recurs<>null) then Recurs else false,

            CaseValues = {
            { (x)=> (try x)[HasError], "error" },
            { (x)=> Type.Is(x, type type), "type"},    //if Recurs then  else 
            { (x)=> Type.Is(x, type function), "function"},
            { (x)=> Type.Is(x, type table), if Recurs then "table " & @Type.ToText(Type.TableRow(NonNull), Recurs) else "table"},
            { (x)=> Type.Is(x, type record), if Recurs then
                let
                    Record = Type.RecordFields(NonNull)
                in "[" & Record.TransformJoin(Record, (k,v) =>
                    (if v[Optional] then "optional " else "") & Expression.Identifier(k) & " = " & @Type.ToText(v[Type], Recurs)
                ) & "]"
            else "record"},
            { (x)=> Type.Is(x, type list), if Recurs then "{" & @Type.ToText(Type.ListItem(NonNull), Recurs) & "}" else "list"},
            { (x)=> Type.Is(x, type binary), "binary"},
            { (x)=> Type.Is(x, type logical), "logical"},
            { (x)=> Type.Is(x, type number), "number"},
            { (x)=> Type.Is(x, type text), "text"},
            { (x)=> Type.Is(x, type date), "date"},
            { (x)=> Type.Is(x, type time), "time"},
            { (x)=> Type.Is(x, type datetime), "datetime"},
            { (x)=> Type.Is(x, type datetimezone), "datetimezone"},
            { (x)=> Type.Is(x, type duration), "duration"},
            { (x)=> Type.Is(type anynonnull, x), "anynonnull"},
            { (x)=> Type.Is(type null, x), "null"},
            { (x)=> Type.Is(None.Type, x), "none"},
        //    { (x)=> Type.Is(type any, x), "any"},
            { (x)=> true, "?"}
            },
            NonNull = Type.NonNullable(Type),
            Return = if Type.Is(type any, Type) then "any"
            else (if Type.IsNullable(Type) then "nullable " else "")
            & List.First(List.Select(CaseValues, each _{0}(NonNull))){1}
        in Return
        in Type.ToText,

    Vlookup 		 = 
        // originally created by Ken Puls
        // http://www.excelguru.ca/blog/2015/01/28/creating-a-vlookup-function-in-power-query/

        (   lookup_value as any, 
            table_array as table, 
            col_index_number as number, 
            optional approximate_match as logical 
        ) as any =>

        let
            /* Provide optional match if user didn't */
            matchtype = if approximate_match = null 
                        then true 
                        else approximate_match,

            /* Get name of return column */
            Cols            = Table.ColumnNames(table_array),
            ColTable        = Table.FromList(Cols, Splitter.SplitByNothing(), null, null, ExtraValues.Error),
            ColName_match   = Record.Field(ColTable{0},"Column1"),
            ColName_return  = Record.Field(ColTable{col_index_number - 1},"Column1"),

            /* Find closest match */
            SortData        = Table.Sort(table_array,{{ColName_match, Order.Descending}}),
            RenameLookupCol = Table.RenameColumns(SortData,{{ColName_match, "Lookup"}}),
            RemoveExcess    = Table.SelectRows(RenameLookupCol, each [Lookup] <= lookup_value),
            ClosestMatch    =
                if Table.IsEmpty(RemoveExcess)=true
                then "#N/A"
                else Record.Field(RemoveExcess{0},"Lookup"),

            /* What should be returned in case of approximate match? */
            ClosestReturn   =
                if Table.IsEmpty(RemoveExcess)=true
                then "#N/A"
                else Record.Field(RemoveExcess{0},ColName_return),

            /* Modify result if we need an exact match */
            Return =
                if matchtype = true
                then ClosestReturn
                else if lookup_value = ClosestMatch
                     then ClosestReturn
                     else "#N/A"

        in
            Return
    	
	],  // –∫–æ–Ω–µ—Ü –±–∏–±–ª–∏–æ—Ç–µ–∫–∏ extensionLibrary

LibPQ      = [ // –º–Ω–æ–≥–æ —Ñ—É–Ω–∫—Ü–∏–π –ø–æ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—é —Ñ—É–Ω–∫—Ü–∏–π. –•–æ—Ä–æ—à–æ, –Ω–æ —Å–ª–æ–∂–Ω–æ–≤–∞—Ç–æ
	Link = "// https://github.com/sio/LibPQ/blob/master/Modules/Folder.Latest.pq", 
	Tests.ConcatenateRows = 
		[
			Table.ConcatenateRows = F[Table.ConcatenateRows],
			data       = {1,0,2,0,3,0,0,4,5},
			headers    = {"foo", "bar", "baz", "sid"},
			TableOneA  = Table.FromColumns({data}, {headers{0}}),
			TableOneB  = Table.FromColumns({data}, {headers{1}}),
			TableOneC  = Table.FromColumns({data}, {headers{2}}),
			TableTwo   = Table.FromColumns({data, data}, List.FirstN(headers, 2)),
			TableThree = Table.FromColumns({data, data, data}, {headers{2}, headers{0}, headers{1}}),

			testTwoOneColumnTables =
				Assert[Equal](
					Table.ConcatenateRows(TableOneA, TableOneB),
					TableTwo
				),

			testOneColumnAndTwoColumnCombined =
				Assert[Equal](
					Table.ConcatenateRows(TableOneC, TableTwo),
					TableThree
				),

			/** Import assertion functions **/
			Assert = F[UnitTest.Assert]
		] meta [LibPQ.TestSuite = 1]
		,
	
	UnitTest.Constants 	  = // Constants for LibPQ UnitTest framework
		[
			Error.Reason = "LibPQ.AssertionError",	/* Default error reason for failed tests */
			Test.Prefix = "test",					/* All tests have to be stored in fields which names start with the prefix */
			Suite.MetaField = "LibPQ.TestSuite",	/* Metadata field that indicates the record is LibPQ test suite */
			Suite.Runners = [
				// [test suite version : test runner module name]
				// 	Test runner is a function that takes one argument (test suite),
				// 	runs it and returns test results as a table structured the same as
				// 	the output of UnitTest.Run (reference test runner)
				1 = "UnitTest.Run",
				Facts = "UnitTest.Facts.Summarize"
			]
		]
		,
	UnitTest.Assert  	  = // A collection of assertion functions for LibPQ UnitTest framework
		/*
			Calling an assertion function results in one of three outcomes:
			- If assertion is not true, the function has to raise an error with reason "LibPQ.AssertionError" (test FAILED)
			- If an error occurs while calculating the assertion value, the function passes that error up unchanged (test ERROR)
			- If assertion is true, the function returns any value without raising an error. The returned value is not relevant (test PASSED)
		*/
		[
			/** Default error reason **/
				Error.Reason = F[UnitTest.Constants][Error.Reason],

			/** Basic assertion function. Check if expression is true **/
				True = (expression, optional message as nullable text, optional detail) =>
					() =>
					let
						Message = if message = null then "value is not true" else message,
						Detail = if detail = null then expression else detail,
						Return =
							if expression = true
							then expression
							else error Error.Record(Error.Reason, Message, Detail)
					in
						Return,

			/** Check if expression is false **/
				False = (expression, optional message as nullable text, optional detail) =>
					let
						Message = if message = null then "value is not false" else message,
						Detail = if detail = null then expression else detail,
						Return = True(expression = false, Message, Detail)
					in
						Return,

			/** Check if a and b are equal **/
				Equal = (a, b, optional message as nullable text, optional detail) =>
					let
						Message = if message = null then "values are not equal" else message,
						Detail = if detail = null then {a,b} else detail,
						Return = True(a = b, Message, Detail)
					in
						Return,

			/** Check if a and b are not equal **/
				NotEqual = (a, b, optional message as nullable text, optional detail) =>
					let
						Message = if message = null then "values are equal" else message,
						Detail = if detail = null then {a,b} else detail,
						Return = False(a = b, Message, Detail)
					in
						Return,

			/** Check if zero-argument function raises error **/
				Raises = (func, reason as text, optional message as nullable text, optional detail) =>
					let
						Message = if message = null then "does not raise " & reason else message,
						Detail = if detail = null then func else detail,
						Reason = try (try func())[Error][Reason] otherwise null,
						Return = True(Reason = reason, Message, Detail)
					in
						Return,

			/** Same as Raises but with argument list **/
				InvokeRaises = (func, args as nullable list, reason as text, optional message as nullable text, optional detail) =>
					Raises(() => Function.Invoke(func, args), reason, message, detail)
		]
	],

buch       = [ // –±–∏–±–ª–∏–æ—Ç–µ–∫–∞ –ú–∏—Ö–∞–∏–ª–∞ https://www.youtube.com/playlist?list=PL0iH5kvb4jwTFO_XCLsZ2Frw-czEwKdac
    readme = "// –ù–µ–±–æ–ª—å—à–∞—è –±–∏–±–ª–∏–æ—Ç–µ–∫–∞ –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö –∏–∑ —Ñ–∞–π–ª–æ–≤ –ø–∞–∫–µ—Ç–∞ MS Office (@buchlotnik)",
	read_word 						= // –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–ø–∏—Å–æ–∫ —Ç–∞–±–ª–∏—Ü –∏–∑ —Ñ–∞–π–ª–∞ Word —Ñ–æ—Ä–º–∞—Ç–∞ *.docx
		/*
			–û–ø–∏—Å–∞–Ω–∏–µ:		—Å–º Word.TablesList 
			–ü—Ä–∏–º–µ—Ä:			= F[Word.TablesList](File.Contents("F:\–ù–∞–∑–≤–∞–Ω–∏–µ –§–∞–π–ª–∞.docx"))
		*/
		(file) =>
			[	getTable = (xml)=> // —Ñ—É–Ω–∫—Ü–∏—è –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Ç–∞–±–ª–∏—Ü—ã –∏–∑ xml —Ä–∞–∑–º–µ—Ç–∫–∏
				[	f=(x)=>[a = Table.SelectRows(x,(r)=>r[Name]="tr")[Value],
							b = List.Max(List.Transform(a,Table.RowCount)),
							c = Table.FromList(a,g,b)
						]  [c],
						
					g=(x)=>List.Transform(x[Value],h),
						
					h=(x)=>Text.Combine(List.Transform(Table.SelectRows(x,(r)=>r[Name]="p")[Value],i),"#(lf)"),
						
					i=(x)=>[a = Table.SelectRows(x,(r)=>r[Name]="r")[Value],
							b = (x)=> Table.SelectRows(x,(r)=>r[Name]="t")[Value],
							c = List.Combine(List.Transform(a,b)),
							d = List.Select(c,(x)=>Value.Is(x,Text.Type)),
							f = Text.Combine(d)
						]  [f],
					to = f(xml)
				]  [to],
				
				from  = fxUnzip2016(file),
				xml   = Xml.Document(from{[FileName="word/document.xml"]}[Content]){[Name="document"]}[Value]{[Name="body"]}[Value],
				filtr = Table.SelectRows(xml, each ([Name] = "tbl"))[Value],
				to    = List.Transform(filtr, getTable)
			]  [to],
		
	Word.CountListAndTable			= // –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ª–∏—Å—Ç–æ–≤ –≤ –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ö –ø–∞–ø–∫–∏ .docx (—Å —É—á–µ—Ç–æ–º –ø–æ–¥–ø–∞–ø–æ–∫)
		/*  
			–ü—Ä–∏–º–µ—Ä		F[Word.CountListAndTable]("F:\1 –†–ê–ë–û–¢–ê - –ù–ò–†")
			–†–µ–∑—É–ª—å—Ç–∞—Ç 	—Ç–∞–±–ª–∏—Ü–∞ —Å –∏–º–µ–Ω–µ–º —Ñ–∞–π–ª–æ–≤ –∏ –∫–æ–ª–æ–Ω–∫–æ–π —Å –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ–º –ª–∏—Å—Ç–æ–≤ –∏ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ–º —Ç–∞–±–ª–∏—Ü –≤ —Ñ–∞–π–ª–µ
		*/
		(pathFolder as text) =>
		let
			f=(x)=>[ a = unzip(x){[Name="docProps/app.xml"]}[Value],
					b = Number.From(Xml.Tables(a){0}[Pages])
				][b],
			
			unzip = Expression.Evaluate(Text.FromBinary(Web.Contents("https://raw.githubusercontent.com/buchlotnik/buchlotnik_functions/main/buchOfficePack")),#shared)[fxUnzip],
			from  = Folder.Files(pathFolder), // –ø—É—Ç—å –∫ –ø–∞–ø–∫–µ
			filtr = Table.SelectRows(from,(r)=>r[Extension]=".docx" and not Text.Contains(r[Name],"~")),
			tbl   = Table.SelectColumns(filtr,{"Name","Content","Folder Path"}),
			tr    = Table.TransformColumns(tbl,{"Content",f}),
						    
			removeErr  = Table.ReplaceErrorValues(tr, {{"Content", null}}),
			rename     = Table.RenameColumns(removeErr,{{"Content", "–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –ª–∏—Å—Ç–æ–≤"}}),
    		addTblList = Table.AddColumn(rename,"tablelist",each F[Word.TablesList](File.Contents([Folder Path] & [Name]))),
    		countTable = Table.AddColumn(addTblList, "–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ç–∞–±–ª–∏—Ü", each List.Count([tablelist])),
    		delcol     = Table.ReorderColumns(
							Table.RemoveColumns(countTable,{"Folder Path"}),
							{"Name", "–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –ª–∏—Å—Ç–æ–≤", "–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ç–∞–±–ª–∏—Ü", "tablelist"}
						 )
		in
			delcol,
	
	Word.TablesList 			  	= // –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–ø–∏—Å–æ–∫ —Ç–∞–±–ª–∏—Ü –∏–∑ —Ñ–∞–π–ª–∞ Word —Ñ–æ—Ä–º–∞—Ç–∞ *.docx
		/*
			–û–ø–∏—Å–∞–Ω–∏–µ:		–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–ø–∏—Å–æ–∫ —Ç–∞–±–ª–∏—Ü –≤ —Ñ–∞–π–ª–µ Word —Ñ–æ—Ä–º–∞—Ç–∞ *.docx
			–ü—Ä–∏–º–µ—Ä:			F[Word.TablesList](File.Contents("F:\1 –†–ê–ë–û–¢–ê - –ù–ò–†\_–ù–ò–† –¢–æ–ª–∫–∞—á–µ–≤–∞ (2023)\–ì–ª–∞–≤–∞ - –ö–æ—Ä–ø–æ—Ä–∞—Ç–∏–≤–Ω–∞—è –æ—Ç—á–µ—Ç–Ω–æ—Å—Ç—å (–ú–µ–¥–≤–µ–¥–µ–≤).docx"))
			–ó–∞–≤–∏—Å–∏–º–æ—Å—Ç—å:	—Ñ—É–Ω–∫—Ü–∏—è Unzip
		
			–ê–ª–≥–æ—Ä–∏—Ç–º:		—Ñ—É–Ω–∫—Ü–∏—è –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ ¬´–º–∞—Ç—Ä—ë—à–∫–æ–π —Ñ—É–Ω–∫—Ü–∏–π¬ª —Ä–∞–∑–±–∏—Ä–∞–µ—Ç ¬´–º–∞—Ç—Ä–µ—à–∫—É xml¬ª
				from  ‚Äì –ø–æ–ª—É—á–∏–ª–∏ —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ —Ñ–∞–π–ª–∞ —á–µ—Ä–µ–∑ UnZip
				xml   ‚Äì –∏–∑ —Å–æ–¥–µ—Ä–∂–∏–º–æ–≥–æ –ø–æ–ª—É—á–∞–µ–º –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ document.xml, –≤ –Ω–µ–º document, –≤ –Ω–µ–º body
				filtr ‚Äì –≤—ã–±—Ä–∞–ª–∏ —Ç–æ–ª—å–∫–æ —Ç–∞–±–ª–∏—Ü—ã - tbl (–µ—Å–ª–∏ –≤–∞–º –Ω—É–∂–Ω—ã –Ω–µ —Ç–∞–±–ª–∏—Ü—ã, –∞ —Ç–µ–∫—Å—Ç ‚Äì –≤—ã–±–∏—Ä–∞–π—Ç–µ p)
				to    ‚Äì –≤—ã—Ç–∞—â–∏–ª–∏ –∏–∑ xml —Å–∞–º–∏ —Ç–∞–±–ª–∏—Ü—ã —Ñ—É–Ω–∫—Ü–∏–µ–π getTable
		
			–ü–æ–¥—Ä–æ–±–Ω–µ–µ –ø—Ä–æ getTable:
				to ‚Äì –∏—Ç–æ–≥–æ–º —Ä–∞–±–æ—Ç—ã —Ñ—É–Ω–∫—Ü–∏–∏ —è–≤–ª—è–µ—Ç—Å—è –ø—Ä–∏–º–µ–Ω–µ–Ω–∏–µ —Ñ—É–Ω–∫—Ü–∏–∏ f –∫ xml-—Å–æ–¥–µ—Ä–∂–∏–º–æ–º—É
				f  ‚Äì –Ω–∞ —à–∞–≥–µ:
					—à–∞–≥ a ‚Äì –≤—ã–Ω–∏–º–∞–µ–º —Ç–æ–ª—å–∫–æ —Ç–µ–≥–∏ tr ‚Äì —ç—Ç–æ —Å—Ç—Ä–æ–∫–∏ —Ç–∞–±–ª–∏—Ü—ã, 
					—à–∞–≥ b ‚Äì –Ω–∞—Ö–æ–¥–∏–º –º–∞–∫—Å–∏–º–∞–ª—å–Ω—É—é –¥–ª–∏–Ω—É —Å—Ç—Ä–æ–∫–∏ (—à–∞–≥ –Ω—É–∂–µ–Ω, –ø–æ—Å–∫–æ–ª—å–∫—É —Ç–∞–±–ª–∏—Ü—ã –º–æ–≥—É—Ç –±—ã—Ç—å —Å –æ–±—ä–µ–¥–∏–Ω—ë–Ω–Ω—ã–º–∏ —è—á–µ–π–∫–∞–º–∏),
					—à–∞–≥ —Å ‚Äì —Å–æ–±–∏—Ä–∞–µ–º —Ç–∞–±–ª–∏—Ü—É —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º –≤—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω–æ–π g
				g ‚Äì –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–ø–∏—Å–æ–∫, –Ω–æ –∫ –∫–∞–∂–¥–æ–º—É —ç–ª–µ–º–µ–Ω—Ç—É –ø—Ä–∏–º–µ–Ω—è–µ—Ç h
				h ‚Äì —Å–æ–±–∏—Ä–∞–µ—Ç —Ç–µ–∫—Å—Ç —á–µ—Ä–µ–∑ —Ä–∞–∑—Ä—ã–≤ —Å—Ç—Ä–æ–∫–∏ (–≤ —Ç–∞–±–ª–∏—Ü–∞—Ö —Ç–æ–∂–µ –±—ã–≤–∞—é—Ç –∞–±–∑–∞—Ü—ã), –ø—Ä–∏–º–µ–Ω–∏–≤ –∫ –∫–∞–∂–¥–æ–º—É –∞–±–∑–∞—Ü—É —Ñ—É–Ω–∫—Ü–∏—é i
				i ‚Äì –¥–æ–∫–∞–ø—ã–≤–∞–µ—Ç—Å—è –¥–æ —Ç–µ–∫—Å—Ç–∞:
					a ‚Äì –±–µ—Ä–µ—Ç —Ç–µ–≥–∏ "r"
					b ‚Äì —Ñ—É–Ω–∫—Ü–∏—è –≤—ã–Ω–∏–º–∞–Ω–∏—è —Ç–µ–≥–∞ "t"
					c ‚Äì –ø–æ–ª—É—á–∞–µ—Ç –∏–∑ –∫–∞–∂–¥–æ–≥–æ —ç–ª–µ–º–µ–Ω—Ç–∞ "t"
					d ‚Äì –æ—Å—Ç–∞–≤–ª—è–µ—Ç —Ç–æ–ª—å–∫–æ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ
					f ‚Äì —Å–æ–±–∏—Ä–∞–µ—Ç –∫—É—Å–∫–∏ –≤ –µ–¥–∏–Ω—ã–π —Ç–µ–∫—Å—Ç
			*/
		(file) =>
			[	getTable = (xml)=> // —Ñ—É–Ω–∫—Ü–∏—è –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Ç–∞–±–ª–∏—Ü—ã –∏–∑ xml —Ä–∞–∑–º–µ—Ç–∫–∏
				[	f=(x)=>[a = Table.SelectRows(x,(r)=>r[Name]="tr")[Value],
							b = List.Max(List.Transform(a,Table.RowCount)),
							c = Table.FromList(a,g,b)
						]  [c],
					g=(x)=>List.Transform(x[Value],h),
					h=(x)=>Text.Combine(List.Transform(Table.SelectRows(x,(r)=>r[Name]="p")[Value],i),"#(lf)"),
					i=(x)=>[a = Table.SelectRows(x,(r)=>r[Name]="r")[Value],
							b = (x)=> Table.SelectRows(x,(r)=>r[Name]="t")[Value],
							c = List.Combine(List.Transform(a,b)),
							d = List.Select(c,(x)=>Value.Is(x,Text.Type)),
							f = Text.Combine(d)
						]  [f],
					to = f(xml)
				]  [to],
				
				from  = fxUnzip2016(file),
				xml   = Xml.Document(from{[FileName="word/document.xml"]}[Content]){[Name="document"]}[Value]{[Name="body"]}[Value],
				filtr = Table.SelectRows(xml, each ([Name] = "tbl"))[Value],
				to    = List.Transform(filtr, getTable)
			]  [to],
	
	fxUnzip2016     			  	= // —Ñ—É–Ω–∫—Ü–∏—è —Å—á–∏—Ç—ã–≤–∞–µ—Ç —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ zip-–∞—Ä—Ö–∏–≤–∞ –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Ç–∞–±–ª–∏—Ü—É —Å –ø–æ–ª—è–º–∏ FileName –∏ Content 
		/* 	
			–§—É–Ω–∫—Ü–∏—è —Å—á–∏—Ç—ã–≤–∞–µ—Ç —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ zip-–∞—Ä—Ö–∏–≤–∞ –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Ç–∞–±–ª–∏—Ü—É —Å –ø–æ–ª—è–º–∏ FileName - –∏–º—è —Ñ–∞–π–ª–∞ 
			(—Å –ø—É—Ç—ë–º, –µ—Å–ª–∏ –æ–Ω –≤ –ø–æ–¥–ø–∞–ø–∫–µ) –∏ Content - –±–∏–Ω–∞—Ä–Ω–æ–µ —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ —Ñ–∞–π–ª–∞. 
			–ö–æ–¥–∏—Ä–æ–≤–∫–∞ —Ç—Ä–µ–±—É–µ—Ç—Å—è –¥–ª—è –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–≥–æ —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏—è –Ω–µ –ª–∞—Ç–∏–Ω—Å–∫–∏—Ö –∏–º—ë–Ω —Ñ–∞–π–ª–æ–≤ 
			(–¥–ª—è –æ—Ñ–∏—Å–Ω—ã—Ö –¥–æ–∫—É–º–µ–Ω—Ç–æ–≤ —É–∫–∞–∑—ã–≤–∞—Ç—å –Ω–µ–æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ), –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é 866 - –∫–æ–¥–∏—Ä–æ–≤–∫–∞ DOS —Å –ø–æ–¥–¥–µ—Ä–∂–∫–æ–π –∫–∏—Ä–∏–ª–ª–∏—Ü—ã 
		*/
		[   func = (ZIP, optional cp)=>
				[   ui16 = BinaryFormat.ByteOrder(BinaryFormat.UnsignedInteger16, ByteOrder.LittleEndian),
					ui32 = BinaryFormat.ByteOrder(BinaryFormat.UnsignedInteger32, ByteOrder.LittleEndian),
					b = (x) => BinaryFormat.Binary(x),
					c = if cp is null then 866 else cp,
					f = (x) => try Binary.Decompress(x, Compression.Deflate) otherwise null,
					g = (x) => BinaryFormat.Transform(b(x),f),
					h = (x) => [head = BinaryFormat.Record(
											[	a 	  = b(14), 
												size  = ui32, 
												c	  = b(4), 
												name  = ui16, 
												extra = ui16])(x),
								body = BinaryFormat.Record( 
											[ 	FileName = BinaryFormat.Text(head[name],c),
												Extras   = b(head[extra]),
												Content  = g(head[size]),
												flag  	 = true])][body],
					iftrue 	 = BinaryFormat.Choice(b(26),h),
					iffalse  = BinaryFormat.Record([flag = false]),
					getfile  = BinaryFormat.Choice(ui32, (x)=> if x = 67324752 then iftrue else iffalse, type binary),
					filelist = BinaryFormat.List(getfile, each [flag] = true)(ZIP),
					remove 	 = List.RemoveLastN(filelist,1),
					to 		 = Table.FromRecords(remove, type table [FileName = text, Content = binary])
				]  [to],
			typ = type function (
						ZIP as 			(type binary meta [Documentation.FieldCaption = "–±–∏–Ω–∞—Ä–Ω–æ–µ —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ (zip,xlsx,docx,pptx –∏ —Ç.–ø.)"]),
						optional cp as 	(type number meta [Documentation.FieldCaption = "–∫–æ–¥–∏—Ä–æ–≤–∫–∞", Documentation.SampleValues = {866}])
								)           
						as table meta [ 
							Documentation.Name = "UnZip (@buchlotnik)",
							Documentation.LongDescription = "–§—É–Ω–∫—Ü–∏—è —Å—á–∏—Ç—ã–≤–∞–µ—Ç —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ zip-–∞—Ä—Ö–∏–≤–∞ –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Ç–∞–±–ª–∏—Ü—É —Å –ø–æ–ª—è–º–∏ FileName - –∏–º—è —Ñ–∞–π–ª–∞ (—Å –ø—É—Ç—ë–º, –µ—Å–ª–∏ –æ–Ω –≤ –ø–æ–¥–ø–∞–ø–∫–µ) –∏ Content - –±–∏–Ω–∞—Ä–Ω–æ–µ —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ —Ñ–∞–π–ª–∞. –ö–æ–¥–∏—Ä–æ–≤–∫–∞ —Ç—Ä–µ–±—É–µ—Ç—Å—è –¥–ª—è –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–≥–æ —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏—è <b>–Ω–µ –ª–∞—Ç–∏–Ω—Å–∫–∏—Ö</b> –∏–º—ë–Ω —Ñ–∞–π–ª–æ–≤ (–¥–ª—è –æ—Ñ–∏—Å–Ω—ã—Ö –¥–æ–∫—É–º–µ–Ω—Ç–æ–≤ —É–∫–∞–∑—ã–≤–∞—Ç—å –Ω–µ–æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ), –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é 866 - –∫–æ–¥–∏—Ä–æ–≤–∫–∞ DOS <b>—Å –ø–æ–¥–¥–µ—Ä–∂–∫–æ–π –∫–∏—Ä–∏–ª–ª–∏—Ü—ã</b>"
							],
			result = Value.ReplaceType(func,typ)
		][result],

	fxUnzip 					  	= // —Ñ—É–Ω–∫—Ü–∏—è —Å—á–∏—Ç—ã–≤–∞–µ—Ç —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ zip-–∞—Ä—Ö–∏–≤–∞ (–≤–µ—Ä—Å–∏—è –¥–ª—è Word –¥–æ –≤–µ—Ä—Å–∏–∏ 2013 –≤–∫–ª—é—á–∏—Ç–µ–ª—å–Ω–æ) 
		[func=
			(ZIP, optional options)=>
			let encod = [ a = options[Encoding]?, b = if a = null then 866 else a][b],
				compr = (x)=> if x = 0 then Compression.None else Compression.Deflate,

				u16 = BinaryFormat.ByteOrder(BinaryFormat.UnsignedInteger16,ByteOrder.LittleEndian),
				u32 = BinaryFormat.ByteOrder(BinaryFormat.UnsignedInteger32,ByteOrder.LittleEndian),

				get = (x) => BinaryFormat.Record(
					if Binary.Range(x,0,4) = #binary({0x50,0x4b,0x03,0x04})
					then [  Name  = BinaryFormat.Text(u16(Binary.Range(x,26,2)),encod),
							Extr  = BinaryFormat.Binary(u16(Binary.Range(x,28,2))),
							Value = BinaryFormat.Transform(BinaryFormat.Binary(u32(Binary.Range(x,18,4))),(y)=>Binary.Decompress(y,compr(u16(Binary.Range(x,8,2)))))]
					else []
				),

				lst = BinaryFormat.List(BinaryFormat.Choice(BinaryFormat.Binary(30),get),(x)=>x<>[])(ZIP),
				to  = Table.FromRecords(List.RemoveLastN(lst,1),type table [Name=text,Value=binary])
			in 	to,

		typ = type function (
				ZIP as (type binary meta [ Documentation.FieldCaption="ZIP - –±–∏–Ω–∞—Ä–Ω–æ–µ —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ (zip, xlsx, docx, pptx –∏ —Ç.–¥.)"]), 
				optional options as record) as table meta [
						Documentation.Name = "fxUnzip (@buchlotnik)",
						Documentation.LongDescription ="—Ñ—É–Ω–∫—Ü–∏—è —Å—á–∏—Ç—ã–≤–∞–µ—Ç —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ –∞—Ä—Ö–∏–≤–∞ –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Ç–∞–±–ª–∏—Ü—É —Å –ø–æ–ª—è–º–∏:<p> <b>Name</b> - –∏–º—è —Ñ–∞–π–ª–∞ (—Å –ø—É—Ç—ë–º –∫ —Ñ–∞–π–ª—É) <p><b>Value</b> - –±–∏–Ω–∞—Ä–Ω–æ–µ —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ —Ñ–∞–π–ª–∞. <p>–ù–µ–æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–π –∞—Ä–≥—É–º–µ–Ω—Ç <b>options</b> –Ω–∞ —Ç–µ–∫—É—â–∏–π –º–æ–º–µ–Ω—Ç –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç —Å–ª–µ–¥—É—é—â–∏–µ –ø–æ–ª—è: <p>1) <b>Encoding</b> - —Ç—Ä–µ–±—É–µ—Ç—Å—è –¥–ª—è –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–≥–æ —á—Ç–µ–Ω–∏—è –Ω–µ –ª–∞—Ç–∏–Ω—Å–∫–∏—Ö –∏–º—ë–Ω —Ñ–∞–π–ª–æ–≤ (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é <b>866 - –∫–∏—Ä–∏–ª–ª–∏—Ü–∞</b>)"],
		result = Value.ReplaceType(func,typ)
		]  [result],
    fxParseHead   					= // —Å–≤–æ—Ä–∞—á–∏–≤–∞–Ω–∏–µ –º–Ω–æ–≥–æ—É—Ä–æ–≤–Ω–µ–≤—ã—Ö –∑–∞–≥–æ–ª–æ–≤–∫–æ–≤
		/*	–°—Å—ã–ª–∫–∞ 	–¢–∞–Ω–∫ "1–°.–†–∞–∑–±–∏—Ä–∞–µ–º –º–Ω–æ–≥–æ—É—Ä–æ–≤–Ω–µ–≤—É—é —à–∞–ø–∫—É /  #1C - —à–∞–ø–∫–∞"
    		–ü—Ä–∏–º–µ—Ä 	1. 	—à–∞–ø–∫–∞ –∏–∑ —Ç—Ä–µ—Ö —Å—Ç—Ä–æ–∫ + —Ä–∞–∑–¥–µ–ª–∏—Ç–µ–ª—å —É—Ä–æ–≤–Ω–µ–π
						=F[ParseHead](from, 3, ".")	
			*/

		[ 
			func = 	(table, num, optional delim, optional fill) =>
				[
					lst = List.Buffer(Table.ToColumns(Table.TransformColumns(Table.Range(table,0,num),{},Text.From))), 
					delim = if delim=null then " " else delim,
					f=(x,y)=>List.Accumulate(   List.Zip({x,y}),
												[i=false,j={}],
												(s,c)=>[i=s[i]=true or c{0}<>null,j=if i then s[j]&{c{0}} else s[j]&{if c{0}=null then c{1} else c{0}}]
											)[j],
					g=(x)=>if fill=null then Text.Combine(x,delim) else Text.Combine(List.ReplaceValue(x,null,fill,Replacer.ReplaceValue),delim), 
					gen = List.Generate(    ()=>[i=0,l=lst{i},o=l],
											(x)=>x[i]<List.Count(lst),
											(x)=>[i=x[i]+1,l=lst{i},o=f(l,x[o])],
											(x)=>g(x[o])
										),
					out = Table.RenameColumns(Table.Range(table,num),List.Zip({Table.ColumnNames(table),gen}))
				][out],
			typ  = 	type function 
					(
						table as (type table meta [Documentation.FieldCaption = "–∏—Å—Ö–æ–¥–Ω–∞—è —Ç–∞–±–ª–∏—Ü–∞"]),
						num as (type number meta [Documentation.FieldCaption = "—á–∏—Å–ª–æ —Å—Ç—Ä–æ–∫ –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞ —à–∞–ø–∫–∏"]),
						optional delim as (type text meta [Documentation.FieldCaption = "(–Ω–µ–æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ) —Ä–∞–∑–¥–µ–ª–∏—Ç–µ–ª—å –¥–ª—è –Ω–∞–∑–≤–∞–Ω–∏–π —Å—Ç–æ–ª–±—Ü–æ–≤ —Ä–∞–∑–Ω—ã—Ö —É—Ä–æ–≤–Ω–µ–π"]),
						optional fill as (type text meta [Documentation.FieldCaption = "(–Ω–µ–æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ) —Å—Ç—Ä–æ–∫–æ–≤–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ, –ø–æ–¥—Å—Ç–∞–≤–ª—è–µ–º–æ–µ –≤–º–µ—Å—Ç–æ –æ—Ç—Å—É—Ç—Å—Ç–≤—É—é—â–µ–≥–æ –∑–∞–≥–æ–ª–æ–≤–∫–∞"])
					)           
						as table meta 
						[
							Documentation.Name = "ParsHead (@buchlotnik)", 
							Documentation.Description = "—Ñ—É–Ω–∫—Ü–∏—è –∞–Ω–∞–ª–∏–∑–∏—Ä—É–µ—Ç –ø–µ—Ä–≤—ã–µ –Ω–µ—Å–∫–æ–ª—å–∫–æ —Å—Ç—Ä–æ–∫ —Ç–∞–±–ª–∏—Ü—ã <i><b>table</b></i>, —É–∫–∞–∑–∞–Ω–Ω—ã—Ö –≤ –ø–∞—Ä–∞–º–µ—Ç—Ä–µ  <i><b>num</b></i>, –æ—Å—É—â–µ—Å—Ç–≤–ª—è–µ—Ç –∑–∞–ø–æ–ª–Ω–µ–Ω–∏–µ —è—á–µ–µ–∫ (–ø–æ –ø—Ä–∏–Ω—Ü–∏–ø—É ""fillrigth"") –ø—Ä–∏ —É—Å–ª–æ–≤–∏–∏, —á—Ç–æ —è—á–µ–π–∫–∏ –≤ —Ç–µ–∫—É—â–µ–º —Å—Ç–æ–ª–±—Ü–µ –≤—ã—à–µ –ø—É—Å—Ç—ã, –¥–∞–ª–µ–µ –ø–æ —Å—Ç–æ–ª–±—Ü–∞–º –∏–¥—ë—Ç –æ–±—ä–µ–¥–∏–Ω–µ–Ω–∏–µ —Ç–µ–∫—Å—Ç–∞ —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º –≤ –∫–∞—á–µ—Å—Ç–≤–µ —Ä–∞–∑–¥–µ–ª–∏—Ç–µ–ª—è –ø–∞—Ä–∞–º–µ—Ç—Ä–∞  <i><b>delim</b></i>. –û–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ —á–µ—Ç–≤–µ—Ä—Ç—ã–π –ø–∞—Ä–∞–º–µ—Ç—Ä <i><b>fill</b></i> –ø–æ–∑–≤–æ–ª—è–µ—Ç –∑–∞–¥–∞—Ç—å —Å—Ç—Ä–æ–∫–æ–≤–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ, –∫–æ—Ç–æ—Ä–æ–µ –±—É–¥–µ—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–æ –¥–ª—è –∑–∞–≥–æ–ª–æ–≤–∫–æ–≤ –Ω–∏–∂–Ω–∏—Ö —É—Ä–æ–≤–Ω–µ–π –≤ —Å–ª—É—á–∞–µ –∏—Ö –æ—Ç—Å—É—Ç—Å—Ç–≤–∏—è –≤ –¥–∞–Ω–Ω–æ–º —Å—Ç–æ–ª–±—Ü–µ "
						],
			res  = Value.ReplaceType(func,typ)
		]  [res],
	
	fxExcelGetCellAttributes		= //
		[
			func = (filebin, optional options) =>[
				bin   = Binary.Buffer(filebin),
				unbin = fxUnzip(bin),
				xml   = List.Buffer(Table.SelectRows(unbin,(r)=>Text.StartsWith(r[Name],"xl/worksheets/sheet"))[Value]),
				style = List.Buffer(List.Transform(Xml.Document(unbin{[Name="xl/styles.xml"]}[Value]){0}[Value]{[Name="cellXfs"]}[Value][Attributes],Record.FromTable)),
				alignment= List.Buffer(List.Transform(Xml.Document(unbin{[Name="xl/styles.xml"]}[Value]){0}[Value]{[Name="cellXfs"]}[Value][Value],(x)=>x{[Name="alignment"]}?[Attributes]?{[Name="indent"]}?[Value]?)),
				
					wb  = Table.Group(Excel.Workbook(bin,false),"Kind",{"tmp",(x)=>x}),
					xl  = wb{[Kind="Sheet"]}[tmp],
					add = Table.AddIndexColumn(xl,"xml"),
					tr  = Table.TransformColumns(add,{"xml",(x)=>xml{x}}),
					cmb = Table.CombineColumns(tr,{"xml","Data"},(x)=>fxExcelSheetAddXmlInformation(x,[Cells=true]),"Data"),
				
				styledetails    =(x)=> Table.TransformColumns(x,{"Attributes",(y)=>[a=y[s]?,b=if a=null then [] else style{Number.From(a)}][b]}),
				alignmentdetails=(x)=> Table.TransformColumns(x,{"Attributes",(y)=>[a=y[s]?,b=if a=null then [] else alignment {Number.From(a)}][b]}),
				
					rep = 	if options[StyleDetails]?=true 
							then Table.TransformColumns(cmb,{"Data",styledetails}) 
								else if options[Indent]?=true then Table.TransformColumns(cmb,{"Data", alignmentdetails }) 
							else cmb,
					def = [a=wb{[Kind="DefinedName"]}?[tmp]?,b=if a = null then #table({},{}) else a][b],
					to  = if options[SheetsOnly]?=true then rep else rep & def
				]  [to],

			typ = type function(filebin as binary, optional options as record) as table meta [
					Documentation.Name = "fxExcelGetCellAttributes (@buchlotnik)",
					Documentation.LongDescription = "—Ñ—É–Ω–∫—Ü–∏—è –ø–æ–≤—Ç–æ—Ä—è—Ç –¥–µ–π—Å—Ç–≤–∏—è —Ñ—É–Ω–∫—Ü–∏–∏ Excel.Workbook, –Ω–æ –∫ —Ç–∞–±–ª–∏—Ü–µ –∫–∞–∂–¥–æ–≥–æ –ª–∏—Å—Ç–∞ –¥–æ–±–∞–≤–ª—è–µ—Ç –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ–± –∞—Ç—Ä–∏–±—É—Ç–∞—Ö —è—á–µ–π–∫–∏ –ø–µ—Ä–≤–æ–≥–æ —Å—Ç–æ–ª–±—Ü–∞ –∫–∞–∂–¥–æ–π –∏–∑ —Å—Ç—Ä–æ–∫"],
			result = Value.ReplaceType(func,typ)
		]  [result],

	fxExcelGetRowsAttributes	  	= // –∞–Ω–∞–ª–æ–≥ Excel.Workbook, –Ω–æ –∫ —Ç–∞–±–ª–∏—Ü–µ –∫–∞–∂–¥–æ–≥–æ –ª–∏—Å—Ç–∞ –¥–æ–±–∞–≤–ª—è–µ—Ç –∞—Ç—Ä–∏–±—É—Ç—ã —Å—Ç—Ä–æ–∫ 
		/*
			–û–ø–∏—Å–∞–Ω–∏–µ	—Ñ—É–Ω–∫—Ü–∏—è –ø–æ–≤—Ç–æ—Ä—è—Ç –¥–µ–π—Å—Ç–≤–∏—è —Ñ—É–Ω–∫—Ü–∏–∏ Excel.Workbook, –Ω–æ –∫ —Ç–∞–±–ª–∏—Ü–µ –∫–∞–∂–¥–æ–≥–æ –ª–∏—Å—Ç–∞ 
						–¥–æ–±–∞–≤–ª—è–µ—Ç –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ–± –∞—Ç—Ä–∏–±—É—Ç–∞—Ö —Å—Ç—Ä–æ–∫
			–ó–∞–≤–∏—Å–∏—Ç		fxUnzip2016, fxUnzip, fxExcelSheetAddXmlInformation
			–°—Å—ã–ª–∫–∞ 		https://www.youtube.com/watch?v=wfESfhIg09E
			
			–ü—Ä–∏–º–µ—Ä		G:\=EXCEL - 1C\–û—Ç—á–µ—Ç –æ –ø—Ä–æ–¥–∞–∂–∞—Ö (–ú–∏—Ö–∞–∏–ª). –¢—É—Ç –∏—Å—Ç–æ—á–Ω–∏–∫ –∏ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫, –≤—ã–≥—Ä—É–∑–∫–∞ –æ—Ç—á–µ—Ç–∞ –∏–∑ 1–°
			–ü—Ä–∏–º–µ—Ä		
						let	path    = "G:\=EXCEL BI - –º–æ–∏ –ø—Ä–æ–µ–∫—Ç—ã\2024.01 - –ê–Ω–∞–ª–∏–∑ –û—Ç—á–µ—Ç–Ω–æ—Å—Ç–∏\1. –û—Ç—á–µ—Ç–Ω–æ—Å—Ç—å\–ë–ö–°\—Ñ–æ—Ä–º–∞ 1-–ø (–Ω–∞—Ç—É—Ä–∞, –≥–æ–¥–æ–≤–∞—è) –û–ü–û\PG1221 2021.xlsx",
							from    = File.Contents(path),
							getAtr1 = F[fxExcelGetRowsAttributes](from)						// –≤—Å–µ —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ –∫–Ω–∏–≥–∏
							getAtr2 = F[fxExcelGetRowsAttributes](from,[SheetsOnly = true]) // —Ç–æ–ª—å–∫–æ –ª–∏—Å—Ç—ã
							getAtr3 = F[fxExcelGetRowsAttributes](from,[Excel2016 = true])  // —Ñ–∞–π–ª—ã Excel 2016+
						in	getAtr1
			
			–†–µ–∑—É–ª—å—Ç–∞—Ç	—Ç–∞–±–ª–∏—Ü–∞ —Å —Å–æ–¥–µ—Ä–∂–∏–º—ã–º —Ñ–∞–π–ª–∞
			
			–°–ø—Ä–∞–≤–æ—á–Ω–æ	–æ–ø–∏—Å–∞–Ω–∏–µ –∞—Ç—Ä–∏–±—É—Ç–æ–≤
				r 				–∏–Ω–¥–µ–∫—Å —Å—Ç—Ä–æ–∫–∏, –Ω–∞—á–∏–Ω–∞—è —Å 1. –≠—Ç–æ —É–Ω–∏–∫–∞–ª—å–Ω—ã–π –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä —Å—Ç—Ä–æ–∫–∏ –≤ —Ç–∞–±–ª–∏—Ü–µ
				spans			–¥–∏–∞–ø–∞–∑–æ–Ω –∑–∞–ø–æ–ª–Ω–µ–Ω–Ω—ã—Ö —Å—Ç–æ–ª–±—Ü–æ–≤ –≤ —Å—Ç—Ä–æ–∫–µ. –ù–∞–ø—Ä–∏–º–µ—Ä spans="1:5" —É–∫–∞–∑—ã–≤–∞–µ—Ç, —á—Ç–æ –≤ —Å—Ç—Ä–æ–∫–µ –∑–∞–ø–æ–ª–Ω–µ–Ω—ã –¥–∞–Ω–Ω—ã–º–∏ —è—á–µ–π–∫–∏ –≤ —Å—Ç–æ–ª–±—Ü–∞—Ö —Å 1 –ø–æ 5
				dyDescent		—Å–º–µ—â–µ–Ω–∏–µ –¥–ª—è –≤—ã—Ä–∞–≤–Ω–∏–≤–∞–Ω–∏—è —Ç–µ–∫—Å—Ç–∞ –Ω–∏–∂–µ –±–∞–∑–æ–≤–æ–π –ª–∏–Ω–∏–∏ —à—Ä–∏—Ñ—Ç–∞ (–¥–µ—Å–µ–Ω—Ç). –ù–∞–ø—Ä–∏–º–µ—Ä, dyDescent="0.25", —á—Ç–æ —É–∫–∞–∑—ã–≤–∞–µ—Ç –Ω–∞ 25% –¥–µ—Å–µ–Ω—Ç–∞ —Ç–µ–∫—Å—Ç–∞ –æ—Ç –≤—ã—Å–æ—Ç—ã —à—Ä–∏—Ñ—Ç–∞.
				ht 				–≤—ã—Å–æ—Ç–∞ —Å—Ç—Ä–æ–∫–∏ –≤ –ø—É–Ω–∫—Ç–∞—Ö. –ï—Å–ª–∏ –∞—Ç—Ä–∏–±—É—Ç –Ω–µ —É–∫–∞–∑–∞–Ω, —Ç–æ –≤—ã—Å–æ—Ç—É —Å—Ç—Ä–æ–∫–∏ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–∞—è. –ù–∞–ø—Ä–∏–º–µ—Ä, ht="15" –æ–∑–Ω–∞—á–∞–µ—Ç, —á—Ç–æ –≤—ã—Å–æ—Ç–∞ —Å—Ç—Ä–æ–∫–∏ = 15 –ø—É–Ω–∫—Ç–æ–≤.
				customHeight	–ª–æ–≥–∏—á–µ—Å–∫–∏–π –∞—Ç—Ä–∏–±—É—Ç, –∫–æ—Ç–æ—Ä—ã–π —É–∫–∞–∑—ã–≤–∞–µ—Ç, –±—ã–ª–∞ –ª–∏ –≤—ã—Å–æ—Ç–∞ —Å—Ç—Ä–æ–∫–∏ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞ –≤—Ä—É—á–Ω—É—é. –ï—Å–ª–∏ customHeight="1", —ç—Ç–æ –∑–Ω–∞—á–∏—Ç, —á—Ç–æ –≤—ã—Å–æ—Ç–∞ —Å—Ç—Ä–æ–∫–∏ –±—ã–ª–∞ –∏–∑–º–µ–Ω–µ–Ω–∞ –≤—Ä—É—á–Ω—É—é –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º –∏–ª–∏ –ø—Ä–æ–≥—Ä–∞–º–º–Ω–æ. –ï—Å–ª–∏ –∞—Ç—Ä–∏–±—É—Ç –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç –∏–ª–∏ –∏–º–µ–µ—Ç –∑–Ω–∞—á–µ–Ω–∏–µ false (–∏–ª–∏ 0), —Å—Ç—Ä–æ–∫–∞ –∏–º–µ–µ—Ç —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—É—é –≤—ã—Å–æ—Ç—É
				outlineLevel	—É—Ä–æ–≤–µ–Ω—å –≤–ª–æ–∂–µ–Ω–Ω–æ—Å—Ç–∏ —Å—Ç—Ä–æ–∫–∏ –≤ —Å—Ç—Ä—É–∫—Ç—É—Ä–µ (—á–∏—Å–ª–æ –æ—Ç 0 –¥–æ 7). –ß–µ–º –±–æ–ª—å—à–µ –∑–Ω–∞—á–µ–Ω–∏–µ, —Ç–µ–º –≥–ª—É–±–∂–µ —Å—Ç—Ä–æ–∫–∞ –≤–ª–æ–∂–µ–Ω–∞ –≤ —Å—Ç—Ä—É–∫—Ç—É—Ä—É
			
			–ï—â–µ 10 –≤–æ–∑–º–æ–∂–Ω—ã—Ö –∞—Ç—Ä–∏–±—É—Ç–æ–≤
				r (Reference)		–û–ø—Ä–µ–¥–µ–ª—è–µ—Ç —Å—Å—ã–ª–∫—É –Ω–∞ —è—á–µ–π–∫—É –∏–ª–∏ —Å—Ç—Ä–æ–∫—É, –∫–∞–∫ —É–ø–æ–º—è–Ω—É—Ç–æ —Ä–∞–Ω–µ–µ. –≠—Ç–æ—Ç –∞—Ç—Ä–∏–±—É—Ç –ø—Ä–∏—Å—É—Ç—Å—Ç–≤—É–µ—Ç –∫–∞–∫ —É —Å—Ç—Ä–æ–∫, —Ç–∞–∫ –∏ —É —è—á–µ–µ–∫, –æ–±–æ–∑–Ω–∞—á–∞—è –∏—Ö –ø–æ–ª–æ–∂–µ–Ω–∏–µ –Ω–∞ –ª–∏—Å—Ç–µ (–Ω–∞–ø—Ä–∏–º–µ—Ä, A1 –¥–ª—è —è—á–µ–π–∫–∏ –∏–ª–∏ r="1" –¥–ª—è —Å—Ç—Ä–æ–∫–∏).
				s (Style Index)		–£–∫–∞–∑—ã–≤–∞–µ—Ç –∏–Ω–¥–µ–∫—Å —Å—Ç–∏–ª—è –¥–ª—è —è—á–µ–π–∫–∏. –≠—Ç–æ—Ç –∞—Ç—Ä–∏–±—É—Ç —Å—Å—ã–ª–∞–µ—Ç—Å—è –Ω–∞ —Å—Ç–∏–ª—å –∏–∑ –∫–æ–ª–ª–µ–∫—Ü–∏–∏ —Å—Ç–∏–ª–µ–π (style.xml). –û–Ω –ø–æ–∑–≤–æ–ª—è–µ—Ç –ø—Ä–∏–º–µ–Ω–∏—Ç—å —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –∫ —è—á–µ–π–∫–µ, –≤–∫–ª—é—á–∞—è —à—Ä–∏—Ñ—Ç, —Ü–≤–µ—Ç, –≥—Ä–∞–Ω–∏—Ü—ã –∏ –≤—ã—Ä–∞–≤–Ω–∏–≤–∞–Ω–∏–µ.
				t (Type)			–û–ø—Ä–µ–¥–µ–ª—è–µ—Ç —Ç–∏–ø —Å–æ–¥–µ—Ä–∂–∏–º–æ–≥–æ —è—á–µ–π–∫–∏. –í–æ–∑–º–æ–∂–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è:
						t="s" ‚Äî —Å—Ç—Ä–æ–∫–∞ (string)
						t="b" ‚Äî –±—É–ª–µ–≤—ã–π —Ç–∏–ø (boolean)
						t="e" ‚Äî –æ—à–∏–±–∫–∞ (error)
						t="n" ‚Äî —á–∏—Å–ª–æ (number)
						t="inlineStr" ‚Äî –≤—Å—Ç—Ä–æ–µ–Ω–Ω–∞—è —Å—Ç—Ä–æ–∫–∞ (inline string)
				cm 			–£–∫–∞–∑—ã–≤–∞–µ—Ç —É—Ä–æ–≤–µ–Ω—å —Å–∂–∞—Ç–∏—è –∏–ª–∏ —Å–≤–æ—Ä–∞—á–∏–≤–∞–Ω–∏—è —Å—Ç—Ä–æ–∫–∏
				hidden		–£–∫–∞–∑—ã–≤–∞–µ—Ç, —Å–∫—Ä—ã—Ç–∞ –ª–∏ —Å—Ç—Ä–æ–∫–∞ –∏–ª–∏ —è—á–µ–π–∫–∞. –ï—Å–ª–∏ hidden="1", —ç—Ç–æ –æ–∑–Ω–∞—á–∞–µ—Ç, —á—Ç–æ —Å—Ç—Ä–æ–∫–∞ –∏–ª–∏ —è—á–µ–π–∫–∞ —Å–∫—Ä—ã—Ç–∞
				collapsed 	–û–ø—Ä–µ–¥–µ–ª—è–µ—Ç, —Å–≤–µ—Ä–Ω—É—Ç–∞ –ª–∏ —Å—Ç—Ä–æ–∫–∞ –≤ –≥—Ä—É–ø–ø–µ. –ï—Å–ª–∏ collapsed="1", —Å—Ç—Ä–æ–∫–∞ –±—É–¥–µ—Ç –æ—Ç–æ–±—Ä–∞–∂–∞—Ç—å—Å—è —Å–≤–µ—Ä–Ω—É—Ç–æ–π –≤ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–µ Excel. –≠—Ç–æ—Ç –∞—Ç—Ä–∏–±—É—Ç —á–∞—Å—Ç–æ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –≤–º–µ—Å—Ç–µ —Å –∞—Ç—Ä–∏–±—É—Ç–æ–º outlineLevel.
				mergeAcross –∏ mergeDown: mergeAcross="2" –æ–±—ä–µ–¥–∏–Ω—è–µ—Ç —Ç–µ–∫—É—â—É—é —è—á–µ–π–∫—É —Å –¥–≤—É–º—è —Å–æ—Å–µ–¥–Ω–∏–º–∏ —Å–ø—Ä–∞–≤–∞, –∞ mergeDown="3" –æ–±—ä–µ–¥–∏–Ω—è–µ—Ç —è—á–µ–π–∫—É —Å —Ç—Ä–µ–º—è —Å—Ç—Ä–æ–∫–∞–º–∏ –Ω–∏–∂–µ
				h (Hidden)	–û–ø—Ä–µ–¥–µ–ª—è–µ—Ç, —Å–∫—Ä—ã—Ç–∞ –ª–∏ —è—á–µ–π–∫–∞ –∏–ª–∏ —Å—Ç—Ä–æ–∫–∞. –ó–Ω–∞—á–µ–Ω–∏–µ h="1" –æ–∑–Ω–∞—á–∞–µ—Ç, —á—Ç–æ —ç–ª–µ–º–µ–Ω—Ç —Å–∫—Ä—ã—Ç
				dataValidation	–£–∫–∞–∑—ã–≤–∞–µ—Ç –Ω–∞ –Ω–∞–ª–∏—á–∏–µ –ø—Ä–∞–≤–∏–ª–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è —è—á–µ–π–∫–∏
			*/

		[func=(filebin,optional options)=>
			let sheetsonly = if options[SheetsOnly]? = true then true else false,
				fxUnzip    = if options[Excel2016]?  = true then fxUnzip2016 else fxUnzip,
				bin = Binary.Buffer(filebin),
				xml = List.Buffer(Table.SelectRows(fxUnzip(bin),(r)=>Text.StartsWith(r[Name],"xl/worksheets/sheet"))[Value]),
				wb  = Table.Group(Excel.Workbook(bin,false),"Kind",{"tmp",(x)=>x}),
				xl  = wb{[Kind="Sheet"]}[tmp],
				add = Table.AddIndexColumn(xl,"xml"),
				tr  = Table.TransformColumns(add,{"xml",(x)=>xml{x}}),
				cmb = Table.CombineColumns(tr,{"xml","Data"},fxExcelSheetAddXmlInformation,"Data"),
				to  = if sheetsonly then cmb else cmb & wb{[Kind="DefinedName"]}[tmp]
			in	to,
				
		typ = 	type function(filebin as binary, optional options as record) as table 
				meta [Documentation.Name="fxExcelGetRowsAttributes (@buchlotnik)",
					  Documentation.LongDescription="—Ñ—É–Ω–∫—Ü–∏—è –ø–æ–≤—Ç–æ—Ä—è—Ç –¥–µ–π—Å—Ç–≤–∏—è —Ñ—É–Ω–∫—Ü–∏–∏ Excel.Workbook, –Ω–æ –∫ —Ç–∞–±–ª–∏—Ü–µ –∫–∞–∂–¥–æ–≥–æ –ª–∏—Å—Ç–∞ –¥–æ–±–∞–≤–ª—è–µ—Ç –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ–± –∞—Ç—Ä–∏–±—É—Ç–∞—Ö —Å—Ç—Ä–æ–∫"],
		result = Value.ReplaceType(func,typ)
		]  [result],
	
	fxExcelSheetAddXmlInformation 	= //? –∫ —Ñ—É–Ω–∫—Ü–∏–∏ fxExcelGetRowsAttributes - –¥–æ–±–∞–≤–ª—è–µ—Ç –∫ —Ç–∞–±–ª–∏—Ü–µ –ª–∏—Å—Ç–∞ –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –∏–∑ xml-—Ä–∞–∑–º–µ—Ç–∫–∏ 
		// –≤—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è, –¥–æ–±–∞–≤–ª—è—é—â–∞—è –∫ —Ç–∞–±–ª–∏—Ü–µ –ª–∏—Å—Ç–∞ –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –∏–∑ xml-—Ä–∞–∑–º–µ—Ç–∫–∏
		[ func=(x,optional options)=>
			let xml  = Xml.Document(x{0}){0}[Value]{[Name="sheetData"]}[Value][Attributes],
				xml1 = Xml.Document(x{0}){0}[Value]{[Name="sheetData"]}[Value][Value],
				tr   = 	if options[Cells]?=true 
						then  List.Transform(xml1,
								(x) => [a = x{0}?[Attributes]?,
										b = if a = null then [] else Record.FromTable(a)
							  	 	] [b]
							  ) 
						else List.Transform(xml,Record.FromTable),
				nms  = List.Transform(xml,(x)=>x{[Name="r"]}?[Value]?),
				dict = Record.FromList(tr,nms),
				add  = Table.AddIndexColumn(x{1},"Attributes",Number.From(nms{0})),
				tr1  = Table.TransformColumns(add,{"Attributes",(x)=>Record.FieldOrDefault(dict,Text.From(x))}),
				to   = Table.ReorderColumns(tr1,{"Attributes"}&Table.ColumnNames(x{1}))
			in  to,
		
		  typ  = type function(x as list, optional options as record) as table 
				 meta [ Documentation.Name="fxExcelSheetAddXmlInformation (@buchlotnik)",
						Documentation.LongDescription="–≤—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è, –¥–æ–±–∞–≤–ª—è—é—â–∞—è –∫ —Ç–∞–±–ª–∏—Ü–µ –ª–∏—Å—Ç–∞ –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –∏–∑ xml-—Ä–∞–∑–º–µ—Ç–∫–∏"],
		  result = Value.ReplaceType(func,typ)
		] [result],

	fxGetMCode 					  	= // –ø–æ–ª—É—á–∞–µ—Ç –∫–æ–¥ –ú –∏–∑ —Ñ–∞–π–ª–æ–≤ .xlsx 
		(file)=>
			[ 	u32  = BinaryFormat.ByteOrder(BinaryFormat.UnsignedInteger32,ByteOrder.LittleEndian),
				f=(x)=>[a=Text.Split(x," = "),b={Text.Trim(Text.Replace(a{0},"shared","")),Text.Combine(List.Skip(a)," = ")}][b],
				from = fxUnzip(file){[Name="customXml/item1.xml"]}?[Value]?,
				bin  = Binary.FromText(Xml.Document(from){0}[Value],BinaryEncoding.Base64),
				data = BinaryFormat.Choice(BinaryFormat.Binary(8),(x)=>BinaryFormat.Binary(u32(Binary.Range(x,4,4))))(bin),
				unz  = fxUnzip(data){[Name="Formulas/Section1.m"]}[Value],
				txt  = Text.FromBinary(unz)&"#(cr,lf)",
				splt = Text.Split(txt,";#(cr,lf)"),
				lst  = List.Range(splt,1,List.Count(splt)-2),
				tbl  = Table.FromList(lst,f,{"Name","Value"}),
				to   = if from=null then #table({"Name","Value"},{{null,null}}) else tbl
			][to],
	
	Table.RemoveEmptyColumns	  	= // —É–¥–∞–ª—è–µ—Ç –ø—É—Å—Ç—ã–µ —Å—Ç–æ–ª–±—Ü—ã –∏–∑ —Ç–∞–±–ª–∏—Ü—ã
		[ func = (table, optional options) =>
			let	tbl = Table.Buffer(Table.Profile(table)),
				lst = Table.SelectRows(tbl,(x)=>x[Count]=x[NullCount])[Column],
				to  = Table.RemoveColumns(table,lst)
			in  to,
		  
		  typ = type function (table as table, optional options as record) as table 
			    meta [ Documentation.Name            = "fxTableRemoveEmptyColumns (@buchlotnik)",
				  	   Documentation.LongDescription = "—Ñ—É–Ω–∫—Ü–∏—è, —É–¥–∞–ª—è—é—â–∞—è –ø—É—Å—Ç—ã–µ —Å—Ç–æ–ª–±—Ü—ã –∏–∑ —Ç–∞–±–ª–∏—Ü—ã"],
		  result = Value.ReplaceType(func,typ)
		][result],	

	Table.RenameColumnsByPositions 	= // –ø–µ—Ä–µ–∏–º–µ–Ω–æ–≤—ã–≤–∞–µ—Ç —Å—Ç–æ–ª–±—Ü—ã —Ç–∞–±–ª–∏—Ü—ã –ø–æ –∏—Ö –Ω–æ–º–µ—Ä—É
		/* 
			–û–ø–∏—Å–∞–Ω–∏–µ
				1 	–§—É–Ω–∫—Ü–∏—è –ø–µ—Ä–µ–∏–º–µ–Ω–æ–≤—ã–≤–∞–µ—Ç —Å—Ç–æ–ª–±—Ü—ã —Ç–∞–±–ª–∏—Ü—ã –ø–æ –∏—Ö –Ω–æ–º–µ—Ä—É
				2 	–ü–∞—Ä–∞–º–µ—Ç—Ä—ã –ø–µ—Ä–µ–∏–º–µ–Ω–æ–≤–∞–Ω–∏—è –∑–∞–¥–∞—é—Ç—Å—è –≤ –≤–∏–¥–µ: 
						- —Å–ø–∏—Å–∫–∞ 				{–Ω–æ–º–µ—Ä, –Ω–æ–≤–æ–µ –Ω–∞–∑–≤–∞–Ω–∏–µ} 
						- –ª–∏–±–æ —Å–ø–∏—Å–∫–∞ —Å–ø–∏—Å–∫–æ–≤ 	{ {–Ω–æ–º–µ—Ä1, –Ω–æ–≤–æ–µ –Ω–∞–∑–≤–∞–Ω–∏–µ1}, {–Ω–æ–º–µ—Ä2, –Ω–æ–≤–æ–µ –Ω–∞–∑–≤–∞–Ω–∏–µ2} }
				3	–ü–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –Ω–æ–º–µ—Ä–∞ –∑–∞–¥–∞–µ—Ç –Ω—É–º–µ—Ä–∞—Ü–∏—é —Å –Ω–∞—á–∞–ª–∞ —Ç–∞–±–ª–∏—Ü—ã, –æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω–æ–µ - —Å –∫–æ–Ω—Ü–∞
			–ü—Ä–∏–º–µ—Ä
				1	–ø–µ—Ä–µ–∏–º–µ–Ω–æ–≤–∞—Ç—å –ø–µ—Ä–≤—ã–π —Å—Ç–æ–ª–±–µ—Ü
					rename  = TableRenameColumnsByPositions(#table({"a","b","c"},{}),{1,"–ø–µ—Ä–≤—ã–π"})
					Result	= #table({"–ø–µ—Ä–≤—ã–π","b","c"},{})
				2	–ø–µ—Ä–∏–º–µ–Ω–æ–≤–∞—Ç—å –ø–µ—Ä–≤—ã–π —Å –∫–æ–Ω—Ü–∞ —Å—Ç–æ–ª–±–µ—Ü"
							= TableRenameColumnsByPositions(#table({"a","b","c"},{}),{-1,"–ø–µ—Ä–≤—ã–π —Å –∫–æ–Ω—Ü–∞"})
					Result	= #table({"a","b","–ø–µ—Ä–≤—ã–π —Å –∫–æ–Ω—Ü–∞"},{})
				3	–ø–µ—Ä–µ–∏–º–µ–Ω–æ–≤–∞—Ç—å –ø–µ—Ä–≤—ã–π –∏ –ø–æ—Å–ª–µ–¥–Ω–∏–π —Å—Ç–æ–ª–±—Ü—ã
							= TableRenameColumnsByPositions(#table({"a","b","c"},{}),{{1,"–ø–µ—Ä–≤—ã–π"},{-1,"–ø–æ—Å–ª–µ–¥–Ω–∏–π"}})
					Result	= #table({"–ø–µ—Ä–≤—ã–π","b","–ø–æ—Å–ª–µ–¥–Ω–∏–π"},{})
			*/
		[func =(table,list) =>
			[   a = List.Buffer(Table.ColumnNames(table)),
				b = List.Count(a),
				c = (x) =>{a{if x{0}>0 then x{0}-1 else b+x{0}},x{1}},
				d = if list{0} is list then List.Transform(list,c) else c(list),
				e = Table.RenameColumns(table,d)
			]  [e],
		 
		 typ = type function (
							table as (type table meta [Documentation.FieldCaption = "–∏—Å—Ö–æ–¥–Ω–∞—è —Ç–∞–±–ª–∏—Ü–∞"]),
							list as (type list meta [Documentation.FieldCaption = "–ø–∞—Ä–∞–º–µ—Ç—Ä—ã –ø–µ—Ä–µ–∏–º–µ–Ω–æ–≤–∞–Ω–∏—è"])
						)           
						as table 
							meta [ 	Documentation.Name = "TableRenameColumnsByPositions> (@buchlotnik)",
									Documentation.LongDescription = "–§—É–Ω–∫—Ü–∏—è –ø–µ—Ä–µ–∏–º–µ–Ω–æ–≤—ã–≤–∞–µ—Ç —Å—Ç–æ–ª–±—Ü—ã —Ç–∞–±–ª–∏—Ü—ã  –ø–æ –∏—Ö –Ω–æ–º–µ—Ä—É. –ü–∞—Ä–∞–º–µ—Ç—Ä—ã –ø–µ—Ä–µ–∏–º–µ–Ω–æ–≤–∞–Ω–∏—è –∑–∞–¥–∞—é—Ç—Å—è –≤ –≤–∏–¥–µ —Å–ø–∏—Å–∫–∞ {–Ω–æ–º–µ—Ä, –Ω–æ–≤–æ–µ –Ω–∞–∑–≤–∞–Ω–∏–µ} –ª–∏–±–æ —Å–ø–∏—Å–∫–∞ —Å–ø–∏—Å–∫–æ–≤ {{–Ω–æ–º–µ—Ä1, –Ω–æ–≤–æ–µ –Ω–∞–∑–≤–∞–Ω–∏–µ1},{–Ω–æ–º–µ—Ä2, –Ω–æ–≤–æ–µ –Ω–∞–∑–≤–∞–Ω–∏–µ2}}. –ü–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –Ω–æ–º–µ—Ä–∞ –∑–∞–¥–∞–µ—Ç –Ω—É–º–µ—Ä–∞—Ü–∏—é —Å –Ω–∞—á–∞–ª–∞ —Ç–∞–±–ª–∏—Ü—ã, –æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω–æ–µ - —Å –∫–æ–Ω—Ü–∞",
									Documentation.Examples = 
									{
										[	Description = "–ø–µ—Ä–µ–∏–º–µ–Ω–æ–≤–∞—Ç—å –ø–µ—Ä–≤—ã–π —Å—Ç–æ–ª–±–µ—Ü", 				
											Code 		= "=TableRenameColumnsByPositions(#table({""a"",""b"",""c""},{}),{1,""–ø–µ—Ä–≤—ã–π""})",
											Result		= "#table({""–ø–µ—Ä–≤—ã–π"",""b"",""c""},{})"
										],
										[	Description = "–ø–µ—Ä–∏–º–µ–Ω–æ–≤–∞—Ç—å –ø–µ—Ä–≤—ã–π —Å –∫–æ–Ω—Ü–∞ —Å—Ç–æ–ª–±–µ—Ü", 		
											Code 		= "=TableRenameColumnsByPositions(#table({""a"",""b"",""c""},{}),{-1,""–ø–µ—Ä–≤—ã–π —Å –∫–æ–Ω—Ü–∞""})",
											Result		= "#table({""a"",""b"",""–ø–µ—Ä–≤—ã–π —Å –∫–æ–Ω—Ü–∞""},{})"
										], 
										[	Description = "–ø–µ—Ä–µ–∏–º–µ–Ω–æ–≤–∞—Ç—å –ø–µ—Ä–≤—ã–π –∏ –ø–æ—Å–ª–µ–¥–Ω–∏–π —Å—Ç–æ–ª–±—Ü—ã", 	
											Code 		= "=TableRenameColumnsByPositions(#table({""a"",""b"",""c""},{}),{{1,""–ø–µ—Ä–≤—ã–π""},{-1,""–ø–æ—Å–ª–µ–¥–Ω–∏–π""}})",
											Result		= "#table({""–ø–µ—Ä–≤—ã–π"",""b"",""–ø–æ—Å–ª–µ–¥–Ω–∏–π""},{})"
										]
									}       
								],
		 result = Value.ReplaceType(func,typ)
		][result],
	
	fxTableSetColumnTypes 			= // —Ç–∏–ø–∏–∑–∞—Ü–∏—è —Å—Ç–æ–ª–±—Ü–æ–≤ –ø–æ —Å–æ–¥–µ—Ä–∂–∏–º–æ–º—É. –ò—é–Ω—å 2025
		/*

		*/
		
		let 
			func = (tbl as table, optional options as record) as table => [
				// –æ–ø—Ü–∏–∏
				n     = if options[rows]? 	 	= null then 100  else options[rows],
				cul   = if options[culture]? 	= null then "ru" else options[culture],
				tr 	  = if options[transform]? 	= null then true else options[transform],
				f_val = if options[deep]? 		= true then g 	 else Value.Type,
				
				// —Ñ—É–Ω–∫—Ü–∏–∏ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏—è
				f_lst = (x)=>Type.Union(List.Transform(x,f_tr)),
    			f_tr  = if tr then (x)=>f_val(Value.FromText(x,cul)) else f_val,
				
				g = (x) => 
					if x is number then if Number.Mod(x,1)=0 then Int64.Type else Number.Type
					else if x is datetime then if Date.Year(x)=1899 then Time.Type meta [f=true]
						else if Time.From(x)=#time(0,0,0) then Date.Type meta [f=true]
						else DateTime.Type
					else Value.Type(x),
				
				// –ø—Ä–µ–≤—Ä–∞—â–µ–Ω–∏–µ —Å—Ç—Ä–æ–∫ –≤ –Ω–∞–±–æ—Ä —Ç–∏–ø–æ–≤
				set = List.Buffer(List.Transform(List.Zip(List.FirstN(Table.ToList(tbl,(x)=>x),n)),f_lst)),
				nms = List.Buffer(Table.ColumnNames(tbl)),
				zip = List.Zip({nms,set}),
				
				// –ø—Ä–æ–≤–µ—Ä–∫–∞, –≤—Å–µ –ª–∏ –Ω–∞–¥–æ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤—ã–≤–∞—Ç—å
				trlst = if tr then zip else List.Select(zip,(x)=>Value.Metadata(x{1})[f]?=true),
				
				// —Ç–∏–ø—ã –¥–ª—è –∏—Ç–æ–≥–æ–≤–æ–π —Ç–∞–±–ª–∏—Ü—ã
				typ   = type table 
							Type.ForRecord(
								Record.FromList(
									List.Transform(
										set, 
										(x)=> [Type = x, Optional = false]),
								nms),
							false),

				// –∏—Ç–æ–≥–æ–≤–∞—è —Ç–∞–±–ª–∏—Ü–∞
				to  = Value.ReplaceType(Table.TransformColumnTypes(tbl,trlst,cul),typ)
				][to],

			metadata = [
				Documentation.Name="fxTableSetColumnTypes (@buchlotnik)",
				Documentation.LongDescription="—Ñ—É–Ω–∫—Ü–∏—è, —Ç–∏–ø–∏–∑–∏—Ä—É—é—â–∞—è —Å—Ç–æ–ª–±—Ü—ã —Ç–∞–±–ª–∏—Ü—ã –Ω–∞ –æ—Å–Ω–æ–≤–∞–Ω–∏–∏ –∏—Ö –∑–Ω–∞—á–µ–Ω–∏–π. <p> –û–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–π –∞—Ä–≥—É–º–µ–Ω—Ç - <b>—Ç–∞–±–ª–∏—Ü–∞</b> <p> –ù–µ–æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–π –∞—Ä–≥—É–º–µ–Ω—Ç - <b>–∑–∞–ø–∏—Å—å</b> —Å –¥–æ–ø—É—Å—Ç–∏–º—ã–º–∏ –ø–æ–ª—è–º–∏:<p> <b>culture</b> - –ª–æ–∫–∞–ª—å, –∫–æ—Ç–æ—Ä—É—é —Å–ª–µ–¥—É–µ—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ø—Ä–∏ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–∏ —Ç–∏–ø–æ–≤ —Å—Ç–æ–ª–±—Ü–æ–≤ <p> <b>rows</b> - –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å—Ç—Ä–æ–∫, –ø–æ –∫–æ—Ç–æ—Ä—ã–º –æ–ø—Ä–µ–¥–µ–ª—è–µ—Ç—Å—è —Ç–∏–ø (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é 100), <p> <b>transform</b> - –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç, –Ω—É–∂–Ω–æ –ª–∏ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤—ã–≤–∞—Ç—å –∑–Ω–∞—á–µ–Ω–∏—è –≤ —Å—Ç–æ–ª–±—Ü–∞—Ö –∏–ª–∏ –∫–æ–Ω—Å—Ç–∞—Ç–∏—Ä–æ–≤–∞—Ç—å —Ç–µ–∫—É—â–∏–µ, –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é <i> true </i>  <p> <b> deep</b> - –≥–ª—É–±–æ–∫–∞—è –æ—Ü–µ–Ω–∫–∞,  –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é <i>false</i> (–µ—Å–ª–∏ <i>true</i> - –∞–Ω–∞–ª–∏–∑–∏—Ä—É–µ—Ç —á–∏—Å–ª–∞ –Ω–∞ –Ω–∞–ª–∏—á–∏–µ —Ü–µ–ª—ã—Ö, –∞–Ω–∞–ª–∏–∑–∏—Ä—É–µ—Ç –¥–∞—Ç—ã–≤—Ä–µ–º–µ–Ω–∞ –Ω–∞ –Ω–∞–ª–∏—á–∏–µ –ø—Ä–æ—Å—Ç–æ –¥–∞—Ç—ã –∏–ª–∏ –ø—Ä–æ—Å—Ç–æ –≤—Ä–µ–º–µ–Ω–∏)"],
			
			to = Value.ReplaceType(func, Value.Type(func) meta metadata)
		in  to,
	
	// 
	RowsOutlineMiha = //* –∏–µ—Ä–∞—Ä—Ö–∏—è –ø—Ä–∏ –≤—ã–≥—Ä—É–∑–∫–µ –∏–∑ 1–°! —Å–º–æ—Ç—Ä–∏ –∫–æ–º–µ—Ä—Ç–∞—Ä–∏–∏ –∫ fxExcelGetRowsAttributes 
		/*
			–û–ø–∏—Å–∞–Ω–∏–µ	—Ñ—É–Ω–∫—Ü–∏—è —Ç–∞–±–ª–∏—Ü–µ –∫–∞–∂–¥–æ–≥–æ –ª–∏—Å—Ç–∞ –¥–æ–±–∞–≤–ª—è–µ—Ç –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ–± –∞—Ç—Ä–∏–±—É—Ç–∞—Ö —Å—Ç—Ä–æ–∫, –≤ —Ç–æ–º —á–∏—Å–ª–µ —É —É—Ä–æ–≤–µ–Ω—å –∏–µ—Ä–∞—Ä—Ö–∏–∏
			–ó–∞–≤–∏—Å–∏—Ç		fxUnzip
			–°—Å—ã–ª–∫–∞ 		https://www.youtube.com/watch?v=wfESfhIg09E
		*/

			let
				//	–ó–∞–≥—Ä—É–∂–∞–µ–º —Ñ—É–Ω–∫—Ü–∏—é UnZip, –∫–æ—Ç–æ—Ä–∞—è –±—É–¥–µ—Ç —Ä–∞—Å–ø–∞–∫–æ–≤—ã–≤–∞—Ç—å Excel —Ñ–∞–π–ª
					unzip = Expression.Evaluate(Text.FromBinary(Web.Contents("https://raw.githubusercontent.com/buchlotnik/buchlotnik_functions/main/UnZip.pq")),#shared),
				
				//	–ß–∏—Ç–∞–µ–º —Ñ–∞–π–ª Excel —Å –∑–∞–¥–∞–Ω–Ω–æ–≥–æ –ø—É—Ç–∏ –∏ —Å–æ—Ö—Ä–∞–Ω—è–µ—Ç –µ–≥–æ –≤ –±—É—Ñ–µ—Ä
					bin   = Binary.Buffer(File.Contents("G:\=EXCEL - 1C\–ò–µ—Ä–∞—Ä—Ö–∏—è (—Å–ª–æ–∂–Ω–∞—è)\–í—ã–≥—Ä—É–∑–∫–∏ –∏–∑ 1–°.xlsx")),
				
				//	–û–±—Ä–∞–±–æ—Ç–∫–∞ XML –∏–∑ Excel	
					//  –ß–∏—Ç–∞–µ–º XML-—Ñ–∞–π–ª –ª–∏—Å—Ç–∞ Excel (sheet1.xml), —Å–æ–¥–µ—Ä–∂–∞—â–∏–π –¥–∞–Ω–Ω—ã–µ –æ —Å—Ç—Ä–æ–∫–∞—Ö
					//	–ò–∑–≤–ª–µ–∫–∞–µ—Ç—Å—è —Å–ø–∏—Å–æ–∫ 1 - val: –£—Ä–æ–≤–Ω–∏ –∏–µ—Ä–∞—Ä—Ö–∏–∏ (outlineLevel)
					//	–ò–∑–≤–ª–µ–∫–∞–µ—Ç—Å—è —Å–ø–∏—Å–æ–∫ 2 - nms: –ò–Ω–¥–µ–∫—Å—ã —Å—Ç—Ä–æ–∫ (r)
					xml   = Xml.Document(unzip(bin){[FileName="xl/worksheets/sheet1.xml"]}[Content]){0}[Value]{[Name="sheetData"]}[Value][Attributes],
					val   = List.Transform(xml,(x)=>x{[Name="outlineLevel"]}?[Value]?),
					nms   = List.Transform(xml,(x)=>x{[Name="r"]}?[Value]?),

				//  –í—ã–¥–µ–ª–µ–Ω–∏–µ –∏–µ—Ä–∞—Ä—Ö–∏–∏ –≤ —Ç–∞–±–ª–∏—Ü–µ
					// 	dict:	–°–æ–∑–¥–∞—ë—Ç—Å—è –∑–∞–ø–∏—Å—å (Record), –≥–¥–µ –∫–ª—é—á–∏ ‚Äî —ç—Ç–æ –∏–Ω–¥–µ–∫—Å—ã —Å—Ç—Ä–æ–∫, –∞ –∑–Ω–∞—á–µ–Ω–∏—è ‚Äî —É—Ä–æ–≤–Ω–∏ –∏–µ—Ä–∞—Ä—Ö–∏–∏. 
					//	sh:  	–ò–∑–≤–ª–µ–∫–∞—é—Ç—Å—è –¥–∞–Ω–Ω—ã–µ –ø–µ—Ä–≤–æ–≥–æ –ª–∏—Å—Ç–∞ –∏–∑ Excel.
					// 	add: 	–î–æ–±–∞–≤–ª—è–µ—Ç—Å—è –∏–Ω–¥–µ–∫—Å–Ω—ã–π —Å—Ç–æ–ª–±–µ—Ü "–£—Ä–æ–≤–µ–Ω—å".
					// 	to:  	–ó–∞–ø–æ–ª–Ω—è–µ—Ç—Å—è —É—Ä–æ–≤–µ–Ω—å –∏–µ—Ä–∞—Ä—Ö–∏–∏ –¥–ª—è –∫–∞–∂–¥–æ–π —Å—Ç—Ä–æ–∫–∏ –∏–∑ –∑–∞–ø–∏—Å–∏ dict.	
					dict = Record.FromList(val,nms),
					sh 	 = Excel.Workbook(bin,false){0}[Data],
					add  = Table.AddIndexColumn(sh, "–£—Ä–æ–≤–µ–Ω—å", Number.From(nms{0}),1),
					to	 = Table.TransformColumns(add,{"–£—Ä–æ–≤–µ–Ω—å",(x)=>Record.FieldOrDefault(dict,Text.From(x))}),
				
				// –º–æ–∂–Ω–æ —É–¥–∞–ª–∏—Ç—å –Ω–µ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ –Ω–µ –ø—Ä–æ–≤–µ—Ä—è–ª –¥–ª—è —ç—Ç–æ–≥–æ –ø—Ä–∏–º–µ—Ä–∞
					add2= Table.AddColumn(to, "–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–π", each null),
					reo = Table.ReorderColumns(add2,{"–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–π", "Column1", "Column2", "Column3", "Column4", "Column5", "Column6", "Column7", "Column8", "Column9", "Column10", "–£—Ä–æ–≤–µ–Ω—å"}),
					sel = Table.SelectRows(reo, each ([Column1] <> null)),
				
				// 	—É–±–∏—Ä–∞–µ–º –ø–µ—Ä–≤—ã–µ —Å—Ç—Ä–æ–∫–∏ –¥–æ —Å—Ç—Ä–æ–∫–∏ "–ò—Ç–æ–≥" –≤ –ø—è—Ç–æ–π –∫–æ–ª–æ–Ω–∫–µ –≤–∫–ª—é—á–∞—è —Å–∞–º—É —Å—Ç—Ä–æ–∫—É
					from = 	
						let 
							last = Table.LastN( sel, (r)=>r[Column5]<>"–ò—Ç–æ–≥"),
							head = Table.PromoteHeaders(last),
							skip = Table.Skip(head,2),
							rem  = Table.RemoveLastN(skip,1)
						in 
							rem,
					/*		
					from = 	Table.RemoveLastN(
								Table.Skip(
									Table.PromoteHeaders(
										Table.LastN( sel, (r)=>r[Column5]<>"–ò—Ç–æ–≥")
									),
								2),
							1),
				   */
				// —Ä–∞–∑–æ–±—Ä–∞—Ç—å—Å—è —á—Ç–æ –º–µ–Ω—è—Ç—å –∏ –∫–∞–∫ —Ä–∞–±–æ—Ç–∞–µ—Ç!!!
				/*f=(x)=> 
					List.ReplaceRange(
						{null,null,null,null,null},		//
						Number.From( List.Last(x)??0 ),	//
						1, //
						{ x{1} }	//
					) 
						& List.RemoveLastN(List.Skip(x,2),1), */

				// 	–ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –∫–∞–∂–¥—É—é —Å—Ç—Ä–æ–∫—É —Ç–∞–±–ª–∏—Ü—ã –≤ —Å–ø–∏—Å–æ–∫, –∑–∞–º–µ–Ω—è—è –ø–µ—Ä–≤—ã–µ 5 —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –∏ —É–¥–∞–ª—è—è –ø–æ—Å–ª–µ–¥–Ω–∏–µ —ç–ª–µ–º–µ–Ω—Ç—ã –≤ —Å—Ç—Ä–æ–∫–∞—Ö. 
					/*
						List.ReplaceRange(
							list as list, 			: –ò—Å—Ö–æ–¥–Ω—ã–π —Å–ø–∏—Å–æ–∫, –≤ –∫–æ—Ç–æ—Ä–æ–º –Ω—É–∂–Ω–æ –ø—Ä–æ–∏–∑–≤–µ—Å—Ç–∏ –∑–∞–º–µ–Ω—É
							offset as number, 		: –ò–Ω–¥–µ–∫—Å –ø–µ—Ä–≤–æ–≥–æ —ç–ª–µ–º–µ–Ω—Ç–∞ –¥–ª—è –∑–∞–º–µ–Ω—ã (–Ω—É–º–µ—Ä–∞—Ü–∏—è –Ω–∞—á–∏–Ω–∞–µ—Ç—Å—è —Å –Ω—É–ª—è)
							count as number, 		: –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —ç–ª–µ–º–µ–Ω—Ç–æ–≤, –∫–æ—Ç–æ—Ä—ã–µ –Ω—É–∂–Ω–æ –∑–∞–º–µ–Ω–∏—Ç—å, –Ω–∞—á–∏–Ω–∞—è —Å –ø–æ–∑–∏—Ü–∏–∏ offset
							replacement as list		: –ù–æ–≤—ã–π —Å–ø–∏—Å–æ–∫, –∫–æ—Ç–æ—Ä—ã–π –∑–∞–º–µ–Ω—è–µ—Ç —É–∫–∞–∑–∞–Ω–Ω—ã–π –¥–∏–∞–ø–∞–∑–æ–Ω
						) as list
					*/
					f=(x) as list => 
						let 
							// –†–µ–∑—É–ª—å—Ç–∞—Ç–æ–º —è–≤–ª—è–µ—Ç—Å—è –Ω–æ–≤—ã–π —Å–ø–∏—Å–æ–∫, –≥–¥–µ –æ–¥–∏–Ω –∏–∑ null –∑–∞–º–µ–Ω—ë–Ω –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–º –∑–Ω–∞—á–µ–Ω–∏–µ–º
							lst1 = [
								list  = {null,null,null,null,null},     // –°–ø–∏—Å–æ–∫, –≤ –∫–æ—Ç–æ—Ä–æ–º –∑–∞–º–µ–Ω—è–µ–º —ç–ª–µ–º–µ–Ω—Ç—ã = —Å–∫–æ–ª—å–∫–æ —É—Ä–æ–≤–Ω–µ–π –≤ —à–∞–ø–∫–µ –æ—Ç—á–µ—Ç–∞
								index = Number.From( List.Last(x)??0 ), // –ò–Ω–¥–µ–∫—Å, –Ω–∞—á–∏–Ω–∞—è —Å –∫–æ—Ç–æ—Ä–æ–≥–æ –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç –∑–∞–º–µ–Ω–∞. –ü–æ—Å–ª–µ–¥–Ω–∏–π —ç–ª–µ–º–µ–Ω—Ç —Å–ø–∏—Å–∫–∞ = x, –ª–∏–±–æ 0, –µ—Å–ª–∏ –ø–æ—Å–ª–µ–¥–Ω–∏–π —ç–ª–µ–º–µ–Ω—Ç –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç
								count = 1,								// –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –¥–ª—è –∑–∞–º–µ–Ω—ã	
								repl  = {x{1}},							// –ó–∞–º–µ–Ω—è–µ—Ç—Å—è –æ–¥–∏–Ω —ç–ª–µ–º–µ–Ω—Ç –Ω–∞ –∑–Ω–∞—á–µ–Ω–∏–µ –∏–∑ –≤—Ç–æ—Ä–æ–≥–æ —ç–ª–µ–º–µ–Ω—Ç–∞ —Å–ø–∏—Å–∫–∞ x
								to    = List.ReplaceRange(list, index, count, repl)
							][to], 
							
							// 
							lst2 = List.RemoveLastN( List.Skip(x,2), 1 ), //&
							to 	 = lst1 & lst2
						in 
							to,
					
				// —Å–ø–∏—Å–æ–∫ —Å–ø–∏—Å–∫–æ–≤. –í –∫–∞–∂–¥–æ–º —Å–ø–∏—Å–∫–µ –∑–Ω–∞—á–µ–Ω–∏—è –∫–æ–ª–æ–Ω–æ–∫
					lst = 
						let f=(x)=> List.ReplaceRange( {null,null,null,null,null}, Number.From(List.Last(x)??0), 1, {x{1}} ) 
									& 
									List.RemoveLastN( List.Skip(x,2), 1 ),
							to = Table.ToList( from, f )
						in  to,
				
				// —Å–æ–±–∏—Ä–∞–µ–º —Ç–∞–±–ª–∏—Ü—É –∏–∑ —Å–ø–∏—Å–∫–∞, –∑–∞–ø–æ–ª–Ω—è–µ–º –≤–Ω–∏–∑ –∫–æ–ª–æ–Ω–∫–∏ —Å —É—Ä–æ–≤–Ω–µ–º, —Ñ—ã–∏–ª—å—Ç—Ä—É–µ–º –∫–æ–ª–æ–Ω–∫—É —Å –ø–æ—Å–ª–µ–¥–Ω–∏–º —É—Ä–æ–≤–Ω–µ–º
					tbl		= Table.FromList(lst,(x)=>x), 
					fill	= Table.FillDown(tbl, {"Column1","Column2","Column3","Column4"}),
					result	= Table.SelectRows(fill, each [Column5] <> null ),

				// –º–æ–π –ø—Ä–∏–º–µ—Ä
					typ = Table.TransformColumnTypes(result,{{"Column6", type number}, {"Column7", type number}, {"Column8", type number}, {"Column9", type number}, {"Column10", type number}, {"Column11", type number}, {"Column12", type number}, {"Column13", type number}, {"Column14", type number}}),
					del = Table.RemoveColumns(typ,{"Column7", "Column8", "Column10", "Column11", "Column13", "Column14"}),
					ren = Table.RenameColumns(del,{{"Column6", "–Ø–Ω–≤–∞—Ä—å"}, {"Column9", "–§–µ–≤—Ä–∞–ª—å"}, {"Column12", "–ú–∞—Ä—Ç"}}),
					unp = Table.UnpivotOtherColumns(ren, {"Column1", "Column2", "Column3", "Column4", "Column5"}, "–ê—Ç—Ä–∏–±—É—Ç", "–ó–Ω–∞—á–µ–Ω–∏–µ")
			in
				unp

	],

Zelensky   = [ // https://github.com/hohlick/power-query-library/blob/master/library/common/Value.ToText.m
	// –∏–∫–æ–Ω–∫b pdg –∏ svg  https://github.com/hohlick/PowerBI-Icons/blob/main/SVG/Power-BI.svg
	fnBuildPath = // –∏–µ—Ä–∞—Ä—Ö–∏—è –≤ —Å–ø—Ä–∞–≤–æ—á–Ω–∏–∫–∞—Ö, parent (–µ—Å—Ç—å —Ñ–∞–π–ª —Å –ø—Ä–∏–º–µ—Ä–æ–º, –µ—Å—Ç—å –≤ —Ç–µ–ª–µ–≥–µ power Bi Group) –°—Ç–∞—Ç—å—è —Å DAX https://www.daxpatterns.com/parent-child-hierarchies/
		let 
			func = (
				Children as list, 
				Parents as list, 
				Node as nullable any, 
				optional ReverseMode as nullable logical
				) as list => 
				
				let
					// Search for the parent for the current Node
					GetParent = (Child as any)=>
						let
							ChildPosition = List.PositionOf(Children, Child),
							Parent = if ChildPosition>=0 then Parents{ChildPosition} else null
						in
							if Parent = Child or Parent = null then null else Parent,
	
					// Parents Search recursion:
					PathList = 
						List.Generate(
							()=>GetParent(Node),
							each _<>null,
							each GetParent(_)
						)
				in
					if Node = null 
					then null 
					else if ReverseMode <> true 
						 then {Node} & PathList 
						 else List.Reverse({Node} & PathList),
				
				documentation = 
					[
						Documentation.Name =  " List.BuildPath ",
						Documentation.Description = " Transforms all columns of a <code>table</code>  with one <code>function</code> and one <code>type</code>. ",
						Documentation.LongDescription = "
						Takes parent/child hierachies as the <code>Children</code> and <code>Parents</code> lists of the same size (typically columns) and transforms them to the list of <code>Parents</code> for the current <code>Node</code>.
						<br>Arguments:
							<ul><li><code>Children</code> = list of ChildID
							<li><code>Parents</code> = list of ParentID
							<li><code>Node</code> = single (current) element from Children
							<li><code>ReverseMode</code> = build list from child to parents or from parent to child
							</ul>",
						Documentation.Category = " List ",
						Documentation.Version = " 1.0 ",
						Documentation.Author = " Maxim Zelensky ",
						Documentation.Examples = 
							{
								[
									Description =  "  ",
									Code = " Table.AddColumn(Typed, ""fnBuildPath"", let children = List.Buffer(Source[Child]), parents = List.Buffer(Source[Parent]) in each fnBuildPath(children, parents, [Child], true), type list)"
									//Result = "  "
								]
							}
					]
			in
				Value.ReplaceType(func, Value.ReplaceMetadata(Value.Type(func), documentation)),

	RowsOutline = // –∏–µ—Ä–∞—Ä—Ö–∏—é —Ä–∞–∑–≤–æ—Ä–∞—á–∏–≤–∞–µ—Ç –≤ –æ—Ç—á–µ—Ç–∞—Ö 1–° //! –Ω–µ –ø—Ä–æ–≤–µ—Ä—è–ª
		/*
			—Ñ–∞–π–ª 		G:\=EXCEL - 1C (–§—É–Ω–∫—Ü–∏—è –ú–∞–∫—Å–ó–µ–ª–µ–Ω—Å–∫–∏–π –ò–µ—Ä–∞—Ä—Ö–∏—è(–Ω—É–∂–µ–Ω 1C –Ω–æ–≤—ã–π —Ñ–µ–≤—Ä–∞–ª—å) + 1C –Ω–æ–≤—ã–π —Ñ–µ–≤—Ä–∞–ª—å)
			Author: 	Maxim Zelensky, info@excel-inside.pro, http://excel-inside.pro
			Updated: 	2017-08-14
			Purpose: 	Get outline levels of rows from Excel worksheets in Power Query.
			Note: 		Included copy of Mark White's UnZip function.
			Parameters:
				FullPath
					Type: text, 
					Description: full path to workbook. Mandatory
					Example: "C:\PQ\Outline\test2.xlsx"
				
				SheetNames
					Type: any
					Description: text or list of worksheet names. Optional
						If argument: 
							not provided, 
							or null,
							or empty list {}, 
							or argument type is different from text/list, 
						then all worksheets from workbook will be analyzed.
					
					Example: {"Sheet1", "Sheet3"}
					Example: "Sheet1"
					
				AddOutlinesToData
					Type: nullable logical
					Description: defines whether add outlineLevel column to the sheet [Data] table. Optional
						If null or not provided then = true
					Example: true, false, null
			*/

		// fnGetRowsOutline

		(FullPath as text, optional SheetNames as any, optional AddOutlinesToData as nullable logical) as table =>
		let
		/* Functions	*/
		// 	UnZip function copy
			fnUnZip = (ZIPFile) => 
			let
				Header = BinaryFormat.Record([
					MiscHeader = BinaryFormat.Binary(14),
					BinarySize = BinaryFormat.ByteOrder(BinaryFormat.UnsignedInteger32, ByteOrder.LittleEndian),
					FileSize   = BinaryFormat.ByteOrder(BinaryFormat.UnsignedInteger32, ByteOrder.LittleEndian),
					FileNameLen= BinaryFormat.ByteOrder(BinaryFormat.UnsignedInteger16, ByteOrder.LittleEndian),
					ExtrasLen  = BinaryFormat.ByteOrder(BinaryFormat.UnsignedInteger16, ByteOrder.LittleEndian)    
				]),

				HeaderChoice = BinaryFormat.Choice(
					BinaryFormat.ByteOrder(BinaryFormat.UnsignedInteger32, ByteOrder.LittleEndian),
					each if _ <> 67324752             // not the IsValid number? then return a dummy formatter
						then BinaryFormat.Record([IsValid = false, Filename=null, Content=null])
						else BinaryFormat.Choice(
								BinaryFormat.Binary(26),      // Header payload - 14+4+4+2+2
								each BinaryFormat.Record([
									IsValid  = true,
									Filename = BinaryFormat.Text(Header(_)[FileNameLen]), 
									Extras   = BinaryFormat.Text(Header(_)[ExtrasLen]), 
									Content  = BinaryFormat.Transform(
										BinaryFormat.Binary(Header(_)[BinarySize]),
										(x) => try Binary.Buffer(Binary.Decompress(x, Compression.Deflate)) otherwise null
									)
									]),
									type binary                   // enable streaming
							)
				),

				ZipFormat = BinaryFormat.List(HeaderChoice, each _[IsValid] = true),

				Entries = List.Transform(
					List.RemoveLastN( ZipFormat(ZIPFile), 1),
					(e) => [FileName = e[Filename], Content = e[Content] ]
				)
			in
				Table.FromRecords(Entries),

		// 	RowsOutline
			fnRowsOutline = (WSrel as text) => 
				let
					Source = UnZipped,
					Sheet1 = Source{[FileName="xl/" & WSrel]}[Content],
					XMLContent = Xml.Tables(Sheet1,null,65001),
					sheetDataTable = XMLContent{[Name="sheetData"]}[Table],
					Filtered = Table.SelectRows(sheetDataTable, each [Name] = "row"),
					rowTable = Filtered{0}[Table],
					RemovedOtherColumns = Table.SelectColumns(rowTable,{"Attribute:r", "Attribute:outlineLevel"}, MissingField.UseNull),
					RenamedColumns = Table.RenameColumns(RemovedOtherColumns,{{"Attribute:r", "RowN"}, {"Attribute:outlineLevel", "outlineLevel"}}),
					Typed = Table.TransformColumnTypes(RenamedColumns,{{"RowN", Int64.Type}, {"outlineLevel", Int64.Type}}),
					RowIndices = List.Zip( { {List.Min(Typed[RowN])..(List.Max(Typed[RowN]))} }),
					RowIndTable = Table.AddIndexColumn(#table(type table [RowNumber=Int64.Type], RowIndices), "Index"),
					ExpandMissedRows = Table.Join(RowIndTable, {"RowNumber"}, Typed, {"RowN"},JoinKind.LeftOuter),
					RemovedOtherColumns1 = Table.SelectColumns(ExpandMissedRows,{"Index", "outlineLevel"}),
					Result = if Table.IsEmpty(sheetDataTable) then #table(type table [Index = number, outlineLevel = Int64.Type],{}) else RemovedOtherColumns1
				in
					Result,
		
		//	–ü–æ–¥–∫–ª—é—á–∞–µ–º—Å—è
			Source = Excel.Workbook(File.Contents(FullPath), false, true),

		// 	leave sheets only
			FilteredSheets = Table.SelectRows(Source, each ([Kind] = "Sheet")),

		// 	sheets in PQ initially in appearance order, i.e. sheets index (despite visibility)
			AddSheetsIndex = Table.AddIndexColumn(FilteredSheets, "Index", 1, 1),

		// 	check SheetNames parameter
			SheetNames = if SheetNames is text then {SheetNames} else if SheetNames is list then SheetNames else null,

		// 	filter sheets by name if provided
			FilteredByNames = if SheetNames = null or List.IsEmpty(SheetNames) then AddSheetsIndex else Table.SelectRows(AddSheetsIndex, each List.Contains(SheetNames, [Name])),

		// 	UnZip file
			UnZipped = Table.Buffer(fnUnZip(File.Contents(FullPath))),
			/*
				let
					Source = Folder.Files(Folder),
					file = Source{[Name = FileName, Folder Path = Folder & "\"]}[Content],
					UnZippedFile = Table.Buffer(fnUnZip(file))
				in
					Table.Buffer(UnZippedFile),
			*/

		// 	relations id table for sheets
			workbook =
				let
					Source = UnZipped,
					Content = Source{[FileName ="xl/workbook.xml"]}[Content],
					ImportedXML = Xml.Tables(Content,null,TextEncoding.Utf8),
					sheetsTable = ImportedXML{[Name = "sheets"]}[Table],
					sheetTable = sheetsTable{[Name = "sheet"]}[Table],
					ExpandedRel = Table.ExpandTableColumn(sheetTable, "http://schemas.openxmlformats.org/officeDocument/2006/relationships", {"Attribute:id"}, {"Attribute:id"}),
					typed = Table.TransformColumnTypes(ExpandedRel,{{"Attribute:name", type text}, {"Attribute:sheetId", Int64.Type}, {"Attribute:id", type text}})
				in
					typed,

		// 	sheets relations id to XML target files
			workbook_rels = 
				let
					Source = UnZipped,
					Filtered = Table.SelectRows(Source, each [FileName]="xl/_rels/workbook.xml.rels"),
					GetXML = Table.TransformColumns(Filtered, {"Content", each Xml.Tables(_,null,65001)}),
					XMLContent = GetXML{0}[Content]{[Name="Relationship"]}[Table],
					FilteredSheetsRel = Table.SelectRows(XMLContent, each [#"Attribute:Type"] = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet"),
					Removed = Table.RemoveColumns(FilteredSheetsRel,{"Attribute:Type"})
				in
					Removed,

		// 	merge relations id (via sheets index)
			MergedRelationsID = Table.Join(FilteredByNames, {"Index"}, workbook, {"Attribute:sheetId"}), 

		// 	join workbook relations
			MergedRelationsTarget = Table.Join(MergedRelationsID,{"Attribute:id"},workbook_rels,{"Attribute:Id"}),

		// 	invoke RowsOutline function to get separate index+outlineLevel table
			AddOutlineTable = Table.AddColumn(MergedRelationsTarget, "RowsOutline", each fnRowsOutline([#"Attribute:Target"]), type table),
		
		// 	Clean table
			RemovedColumns = Table.RemoveColumns(AddOutlineTable,{"Index", "Attribute:Id", "Attribute:Target", "Attribute:name", "Attribute:sheetId", "Attribute:id"}),

		// join [AddOutlineTable] and [Data] by rows index
			AddedRowsOutline = Table.AddColumn(RemovedColumns, "DataWithOutline", each Table.RemoveColumns(Table.Join([RowsOutline], {"Index"}, Table.AddIndexColumn([Data],"Index"), {"Index"}),{"Index"}), type table),

		// add outlines to Data or not
			Result = if AddOutlinesToData or AddOutlinesToData = null then AddedRowsOutline else RemovedColumns
		in
			Result,

	Value.ToJson = 
		/*	-----------------------------------------------------------------------------
			GPLv3 | https://github.com/power-query/power-query-library
			-----------------------------------------------------------------------------
			Authors	: 	Max Buyers
			Function: 	Value.ToJson
			Returns	:  	Minimized JSON-object
			Example	:  	below
			Depends	:  	Value.TypeToText, Value.ToText
			Comments:
			-----------------------------------------------------------------------------
		
			Example
				__("Value.ToJson")([
					array 	 = {1, 2, 3},
					boolean  = true,
					datetime 	 = #datetime(2013,1,3,12,4,5),
					datetimezone = #datetimezone(2012, 7, 24, 14, 50, 52.9842245, -7, 0),
					null 	= null,
					number 	= 123,
					object 	= [ a = "b", c = "d", e = "f" ],
					string 	= "Hello World"])
			
			Return
				{"array":[1,2,3],"boolean":true,"datetime":"2013-01-03T12:04:05.0000000","datetimezone":"2012-07-24T14:50:52.984-07:00","number":123,"object":{"a":"b","c":"d","e":"f"},"string":"Hello World"}
		*/
		let Value.ToJson =
			( Val as any) as text =>
			let
				Value.TypeToText 	= F[Value.TypeToText],
				Value.ToText 		= F[Value.ToText],
				Type 				= Value.TypeToText(Val),
				Sq 					= "#(2032,02DD,2034,02DD,2032)",
				Dq 					= "#(0022)",
				Quote     = (i as text) => Sq & i & Sq,
				Combine   = (i as list) => Text.Combine(i,","),
				Array     = (i as text) => "[" & i & "]",
				Object    = (i as text) => "{" & i & "}",
				Rules = [
					table   = Array(Combine(
						Table.TransformRows(Val, each @Value.ToJson(_)) )),

					record  = 
						let
							Fields    = Record.FieldNames(Val),
							Values    = Record.FieldValues(Val),
							Transform = List.Transform(Fields,
							each Quote(_) & ":" &
							@Value.ToJson(Record.Field(Val, _)))
						in 
							Object(Combine(Transform)),
					
					list = 	Array(Combine(List.Transform(Val, each @Value.ToJson(_)))),
					text    = Quote(Val),
					number  = Value.ToText(Val),
					null    = "null",
					logical = Value.ToText(Val),
					date 	= Quote(Value.ToText(Val, "YYYY-MM-DD")),
					time 	= Quote(Value.ToText(Val, "hh:mm:ss.nnnnnnn")),
					datetime = Quote(Value.ToText(Val, "YYYY-MM-DDThh:mm:ss.nnnnnnn")),
					datetimezone = Quote(Value.ToText(Val, "YYYY-MM-DDThh:mm:ss.nnnZ")),
					duration = Quote(Value.ToText(Val, "PdDhHmM[:s]S")),
					type 	= Quote(Value.TypeToText(Val)),
					binary 	= Quote(Binary.ToText(Val, BinaryEncoding.Hex))
			]
			in Text.Replace(Record.Field(Rules, Type), Sq, Dq)
		in  Value.ToJson,

	Value.ToText = // —á—Ç–æ —Ç–æ –≤—Ä–æ–¥–µ –ø—Ä–æ–≤–µ—Ä–∫–∏ —Ç–∏–ø–æ–≤ 
		/*
			-----------------------------------------------------------------------------
			GPLv3 | https://github.com/power-query/power-query-library
			-----------------------------------------------------------------------------
			Authors: Max Buyers
			Function: Value.ToText
			Returns:  Value with normalized to string primitive values
			Example:  below
			Depends:  Value.TypeToText
			Comments:

			------------------------------------------------------------------------
			Arguments:

			+ Value
				required: yes
				type: any
				desc: primitive or structured value

			+ format:
				required: no
				type: record or text
				desc: optional common or specified format for number/date/time values
				examples:
				[f = "YYYY-MM-DDThh:mm:ssZ"]
				[f = [
					datetime = "YYYY-MM-DDThh:mm:ss.nnnnnnn"
				, datetimezone = "YYYY-MM-DDThh:mm:ssZ"
				]

			+ culture:
				required: no
				type: text
				desc: optional culture for number/date/time values
				examples: [c = "ru-RU"]
				comments:
				+ Use National Language Support (NLS) API Reference for culture codes:
					https://msdn.microsoft.com/en-us/goglobal/bb896001.aspx
			------------------------------------------------------------------------
		*/

		let
			Value.ToText =
				(Value as any, optional format as any, optional culture as text) as any => 
				let
					format    = try format  as text otherwise try format as record otherwise null,
					culture   = try culture as text otherwise "en-US",
					Recursion = (Value) => @Value.ToText(Value, format, culture),
					
					Value.TypeToText = F[Value.TypeToText],
				//
					Type  = Value.TypeToText(Value),
					Rules = [
						null          = "",
						logical       = Logical.ToText(Value),
						number        = Number.ToText(Value,       try format[number]       as text otherwise try format as text otherwise null, culture),
						time          = Time.ToText(Value,         try format[time]         as text otherwise try format as text otherwise null, culture),
						date          = Date.ToText(Value,         try format[date]         as text otherwise try format as text otherwise null, culture),
						datetime      = DateTime.ToText(Value,     try format[datetime]     as text otherwise try format as text otherwise null, culture),
						datetimezone  = DateTimeZone.ToText(Value, try format[datetimezone] as text otherwise try format as text otherwise null, culture),
						duration      = Duration.ToText(Value,     try format[duration]     as text otherwise try format as text otherwise null),
						type          = "type",
						text          = Value,
						list          = List.Transform(Value, each Recursion(_)),
						record        = 
							let
								FieldNames  = Record.FieldNames(Value),
								FieldValues = Record.FieldValues(Value),
								Transformed = List.Transform(FieldValues, each Recursion(_))
							in 
								Record.FromList(Transformed, FieldNames),

						table	= 	Table.TransformColumns(
										Value, 
										List.Transform(
											Table.ColumnNames(Value), 
											each {_, each Recursion(_)}
										)
									),
						binary  = Binary.ToText(Value)
				]
				in Record.Field(Rules, Type)
		in 
			Value.ToText

		/*
		------------------------------------------------------------------------
		Example
		------------------------------------------------------------------------
		–±—ã–ª–æ __("Value.ToText")(

		F[Value.ToText] (
			#table(
				type table [
				Null = null
				, Logical = logical
				, Number  = number
				, Time    = time
				, Date    = date
				, Datetime = datetime
				, Datetimezone = datetimezone
				, Duration = duration
				, Type = type
				, Text = text
				, List = list
				, Record = record
				, Table = table
				, Binary = binary
				]
			, {
				{
					null
				, true
				, 1
				, #time(20,43,12)
				, #date(2015, 1, 1)
				, #datetime(2015, 1, 1, 21, 49, 18)
				, #datetimezone(2015, 1, 1, 21, 49, 18, 3, 0)
				, #duration(0, 0, 5, -30)
				, type {type}
				, "Hello World!"
				, {null, false, 2, #time(20,43,12), "Goodbye World!"}
				, [A = 1, B = "2"]
				, #table({"x", "x^2"}, {{1,1}, {2,4}, {3,9}})
				, #binary({0x00, 0x01, 0x02, 0x03})
				}
				, {
					null
				, false
				, 2
				, #time(12,55,1)
				, #date(2035, 1, 1)
				, #datetime(2035, 5, 5, 15, 55, 55)
				, #datetimezone(2015, 1, 1, 21, 49, 18, 3, 0)
				, #duration(0, 0, 5, -30)
				, type {type}
				, "Hello World!"
				, {null, false, 2, #time(20,43,12), "Goodbye World!"}
				, [A = 1, B = "2"]
				, #table({"x", "x^2"}, {{1,1}, {2,4}, {3,9}})
				, #binary({0x00, 0x01, 0x02, 0x03})
				}
				}
			))
		------------------------------------------------------------------------
		*/
	],

Connectors = [ 
	link1 = // –º–Ω–æ–≥–æ –∫–æ–Ω–Ω–µ–∫—Ç–æ—Ä–æ–≤, –Ω–∞–≤–µ—Ä–Ω–æ–µ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã—Ö –Ω–∞ –≥–∏—Ç—Ö–∞–±–µ microsoft
		"https://github.com/microsoft/DataConnectors/blob/master/samples/ODBC/HiveSample/HiveSample.pq",
	
	OneDriveFolderFiles 	= // –∫–æ–Ω–Ω–µ–∫—Ç–æ—Ä –∫ OneDrive Personal 
		(url)=>
        let
            //  –§—É–Ω–∫—Ü–∏—è –ø–µ—Ä–µ–∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏—è —Å—Å—ã–ª–∫–∏ –≤ –ø–æ–Ω—è—Ç–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –¥–ª—è API
                fx = (t)=> Binary.ToText( Text.ToBinary( t, TextEncoding.Utf8 ), BinaryEncoding.Base64 ),
                API_URL = "https://api.onedrive.com/v1.0/shares/",
            
            //	—Ç–∞—â–∏–º –ø—É—Ç—å –∏–∑ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ —Å –∞–¥—Ä–µ—Å–æ–º –∫ –æ–±—â–µ–π –ø–∞–ø–∫–µ –∏–∑ –æ–±–ª–∞–∫–∞ Onedrive
                FolderUrl = url,
            
            //	–ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤—ã–≤–∞–µ–º —Å—Å—ã–ª–∫—É –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —Ç–æ–∫–µ–Ω–∞ –¥–ª—è API
                UrlToBase64 = fx( FolderUrl ),
            
            //	–∑–∞–º–µ–Ω—è–µ–º –≤—Å—è–∫–æ–µ —Å–æ–≥–ª–∞—Å–Ω–æ –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏ –ø–æ —Å—Å—ã–ª–∫–µ:
            //	https://docs.microsoft.com/ru-ru/onedrive/developer/rest-api/api/shares_get?view=odsp-graph-online#encoding-sharing-urls
                Replaced = Text.Replace( Text.Replace( Text.TrimEnd( UrlToBase64, "=" ), "/", "_" ), "+", "-" ),
            
            //	—Ñ–æ—Ä–º–∏—Ä—É–µ–º –∏—Ç–æ–≥–æ–≤—ã–π —Ç–µ–∫—Å—Ç–æ–≤—ã–π –ø–∞—Ä–∞–º–µ—Ç—Ä –¥–ª—è –ø–µ—Ä–µ–¥–∞—á–∏ –≤ RelativePath
                EncodedPath = "u!" & Replaced & "/root/children",
            
            //	—Ç–∞—â–∏–º —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ –ø–∞–ø–∫–∏ –∏–∑ API
                Source = Json.Document(Web.Contents( API_URL, [RelativePath = EncodedPath] ) ),
            
            //  –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤—ã–≤–∞–µ–º –ø–æ–ª—É—á–µ–Ω–Ω—ã–π JSON –≤ —Ç–∞–±–ª–∏—á–∫—É —Å —Å–æ–¥–µ—Ä–∂–∏–º—ã–º –ø–∞–ø–∫–∏
                TableFromRecords = Table.FromRecords( Source[value] )[[name],[webUrl]],
            
            //  –¥–æ–±–∞–≤–ª—è–µ–º —Å—Ç–æ–ª–±–µ—Ü —Å —Ç–µ–∫—Å—Ç–æ–≤—ã–º–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏ –¥–ª—è –ø–µ—Ä–µ–¥–∞—á–∏ –≤ RelativePath
                AddColEncodedPaths = 
					Table.AddColumn(
						TableFromRecords,
						"GetRelativePath",
						each "u!" & fx([webUrl]) & "/root/content"
           			),
            //	–¥–æ—Å—Ç–∞–µ–º –±–∏–Ω–∞—Ä–Ω–∏–∫–∏ –ø–æ —Å—Ñ–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–Ω—ã–º —Å—Å—ã–ª–∫–∞–º, –¥–∞–ª—å—à–µ –ø–æ –∞–Ω–∞–ª–æ–≥–∏–∏ –∫–∞–∫ —Å –æ–±—ã—á–Ω—ã–º–∏ —Ñ–∞–π–ª–∞–º–∏ —Å –¥–∏—Å–∫–∞
                GetBinaries = 
					Table.AddColumn(
						AddColEncodedPaths,
						"Content",
						each Web.Contents(API_URL, [RelativePath = [GetRelativePath]] ),
						Binary.Type
					)
            in
                GetBinaries,
			
	insert_clickhouse 		= // –∑–∞–≥—Ä—É–∑–∫–∞ –¥–∞–Ω–Ω—ã—Ö –≤ Clickhouse 
		/*	
			Link: http://directprobi.ru/blogs/power-bi-etl-zagruzka-v-bazu-dannyh-postgresql-power-query-excel-clickhouse/
			–ü—Ä–∏–º–µ—Ä:
				= 	insert_clickhouse(
						#"–ü–æ—Å–ª–µ–¥–Ω–∏–π —à–∞–≥ —Ç–∞–±–ª–∏—Ü—ã –ú–µ—Ç—Ä–∏–∫–∏", 
						"–ü–û–õ–¨–ó–û–í–ê–¢–ï–õ–¨ –ë–ê–ó–´ –î–ê–ù–ù–´–•", 
						"–ü–ê–†–û–õ–¨ –ü–û–õ–¨–ó–û–í–ê–¢–ï–õ–Ø", 
						"–°–•–ï–ú–ê.–¢–ê–ë–õ–ò–¶–ê"
					)
			–ê–ª–≥–æ—Ä–∏—Ç–º:
			–ß—Ç–æ–±—ã –≤—Å—ë —Ä–∞–±–æ—Ç–∞–ª–æ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ, –ø–æ–π–¥—ë–º –ø–æ –ø—Ä–æ—Å—Ç–æ–º—É –ø—É—Ç–∏: 
				1. 	–ø–æ–¥–≥–æ—Ç–æ–≤–∏–º –≤ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö —Ç–∞–±–ª–∏—Ü—É –∏–∑ –Ω—É–∂–Ω—ã—Ö —Å—Ç–æ–ª–±—Ü–æ–≤. (–¥–≤–∏–∂–æ–∫ MergeTree) - –Ω–∞–≤–µ—Ä–Ω–æ–µ –∫–∞–∫ –≤–∞—Ä–∏–∞–Ω—Ç 
				2.	–∑–∞—Ç–µ–º –ø–æ–ª—É—á–∏–º –∞–Ω–∞–ª–æ–≥–∏—á–Ω—É—é —Ç–∞–±–ª–∏—Ü—É –∏–∑ API –æ–±—ã—á–Ω—ã–º –∫–æ–Ω–Ω–µ–∫—Ç–æ—Ä–æ–º –Ω–∞ Power Query. 
				3.	–í –∫–æ–Ω—Ü–µ –ø—Ä–∏–º–µ–Ω–∏–º —Ñ—É–Ω–∫—Ü–∏—é –∑–∞–≥—Ä—É–∑–∫–∏ –≤ –±–∞–∑—É –∫ –ø–æ–ª—É—á–µ–Ω–Ω–æ–π —Ç–∞–±–ª–∏—Ü–µ, —á—Ç–æ–±—ã –ø—Ä–æ–≥—Ä—É–∑–∏—Ç—å –¥–∞–Ω–Ω—ã–µ –≤ –ë–î. 
			–í–∞–∂–Ω–æ!
				1. 	–ü–æ—Ä—è–¥–æ–∫ –∏ —Ç–∏–ø—ã —Å—Ç–æ–ª–±—Ü–æ–≤ –≤ Power Query –ø–æ–ª–Ω–æ—Å—Ç—å—é –∞–Ω–∞–ª–æ–≥–∏—á–Ω—ã –∫–ª–∏–∫—Ö–∞—É—Å—É, –∏–Ω–∞—á–µ –≤—Å—Ç–∞–≤–∫–∞ –Ω–µ —Ä–∞–±–æ—Ç–∞–µ—Ç. 
					–ù–∞–∑–≤–∞–Ω–∏—è —Å—Ç–æ–ª–±—Ü–æ–≤ –∫–ª–∏–∫—Ö–∞—É—Å–∞ –∏ power query –º–æ–≥—É—Ç —Ä–∞–∑–ª–∏—á–∞—Ç—å—Å—è - —ç—Ç–æ –Ω–∏ –Ω–∞ —á—Ç–æ –Ω–µ –≤–ª–∏—è–µ—Ç.
				2. 	–ù–µ –∑–∞–±—É–¥—å—Ç–µ –∑–∞–º–µ–Ω–∏—Ç—å –í–ê–® –•–û–°–¢ –ò–õ–ò –î–û–ú–ï–ù CLICKHOUSE:–ü–û–†–¢ –Ω–∞ –∑–Ω–∞—á–µ–Ω–∏—è —Ä–µ–∞–ª—å–Ω–æ–≥–æ —Ö–æ—Å—Ç–∞/–¥–æ–º–µ–Ω–∞ –∏ –ø–æ—Ä—Ç–∞.
		*/

		(pq_table,  ch_user as text, ch_pass as text, ch_table as text)=>
		let
			dateFunc = (dat)=>
				if dat = "yesterday" then Date.ToText(Date.AddDays(Date.From(DateTime.LocalNow()) , -1),"yyyy-MM-dd") 
				else if dat = "today" then Date.ToText(Date.From(DateTime.LocalNow()),"yyyy-MM-dd")
				else if (try Number.From(Text.BeforeDelimiter(dat,"daysAgo")) otherwise 0) >0 then Date.ToText(Date.AddDays(Date.From(DateTime.LocalNow()),-1*Number.From(Text.BeforeDelimiter(dat,"daysAgo"))),"yyyy-MM-dd") 
				else dat,

			added = 
				Table.AddColumn( pq_table,  "all", each  
					"(" & Text.Combine( List.Transform( Record.ToList(_), each 
						if Value.Is(_, type text) 
						then "'"&_&"'" 
						else if Value.Is(_, type date) 
							then "'"&Date.ToText(_,"yyyy-MM-dd")&"'"
							else Text.From(_) 
					),",") & ")"
				),
			
			textview = Text.Combine(added[all],","),
			
			insert 	= 
				// Csv.Document(Web.Contents("–í–ê–® –•–û–°–¢ –ò–õ–ò –î–û–ú–ï–ù CLICKHOUSE:–ü–û–†–¢" , 
				Csv.Document(Web.Contents("localhost", 
					[	Query 	= 
							[	user 	 = ch_user, 
								password = ch_pass, 
								query 	 = "INSERT INTO " & ch_table  &" VALUES " & textview 
							],
						Content = Binary.FromText(""),
						ManualStatusHandling = {429,400,500}
					]), 
					1,
					"",
					ExtraValues.Ignore,
					65001
				)
		in 
			insert,

	insert_postgresql_Old 	= // –∑–∞–≥—Ä—É–∑–∫–∞ –¥–∞–Ω–Ω—ã—Ö –≤ PostgreSQL 
		/*
			–ü—Ä–∏–º–µ—Ä
				= F[insert_postgresql](fromTable, "–°–•–ï–ú–ê.–¢–ê–ë–õ–ò–¶–ê")
				= F[insert_postgresql](to,"newtable") // –∏–º—è—Ç —Ç–∞–±–ª–∏—Ü—ã –≤ –±–∞–∑–µ Test1 —Å—Ö–µ–º—ã public —Ç–∞–±–ª–∏—Ü—ã newtable
		*/
		(pq_table,  postgresql_table as text)=>
		[
			HOST 	 = "localhost",
			DBNAME   = "Test",	
			dateFunc = (dat)=>
				if dat = "yesterday" then Date.ToText(Date.AddDays(Date.From(DateTime.LocalNow()) , -1),"yyyy-MM-dd") 
				else if dat = "today" then Date.ToText(Date.From(DateTime.LocalNow()),"yyyy-MM-dd")
				else if (try Number.From(Text.BeforeDelimiter(dat,"daysAgo")) otherwise 0) >0 then Date.ToText(Date.AddDays(Date.From(DateTime.LocalNow()),-1*Number.From(Text.BeforeDelimiter(dat,"daysAgo"))),"yyyy-MM-dd") 
				else dat,
		
			added    = 
				Table.AddColumn( pq_table, "all", each  
					"(" & 
						Text.Combine( 
							List.Transform( 
								Record.ToList(_), 
								each 
									if Value.Is(_, type text) 
									then "'"&_&"'" 
									else if Value.Is(_, type date) 
										 then "'" & Date.ToText(_,"yyyy-MM-dd")&"'"
										 else Text.From(_) 
							),
						",") & 
					")" 
				),
			
			textview = Text.Combine(added[all],","),
			delete   = 	
				Value.NativeQuery(
					PostgreSQL.Database(HOST, DBNAME),
					"TRUNCATE TABLE " & postgresql_table & ";"
				),

			insert   = 
				Value.NativeQuery( 
					PostgreSQL.Database(HOST, DBNAME),
					"INSERT INTO " & postgresql_table & " VALUES " & textview 
				),
			chdelay = Function.InvokeAfter( ()=>delete & Table.FromRecords({}), #duration(0,0,0,5) ),
			final   = chdelay & insert,
			expand  = List.Accumulate(
						final[insert], 
						Table.FromRows({}), 
						(st,cr)=> 	Function.InvokeAfter(
										()=> st & (if cr=null then Table.FromRows({}) else cr), 
										#duration(0,0,0,3)
									)
					)
		][expand],
		
	insert_postgresql 		=  
		/*
			-- 	public.newtable –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ
			
			-- 	Drop table
				DROP TABLE public.newtable2;
			
			-- 	DROP TABLE public.newtable;
				CREATE TABLE public.newtable (
					"Company" varchar NULL,
					"Date" date NULL
				)

			–ü—Ä–∏–º–µ—Ä
			  = F[insert_postgresql](
					_f_bal[[Company],[Date]], "public.newtable",
					"Date","Date",
					"10000daysAgo","yesterday",
					1000, 2
				)
			*/
		(	pq_table, 
			postgresql_table as text, 
			
			postgresql_column 	as text, 
			pq_column 			as text, 
									
			date1 as text, 
			date2 as text, 

			rowlimit 	as number , 
			delay 		as number )=>

		[
			HOST 	= "localhost",	// –í–ê–® –•–û–°–¢
			DBNAME  = "Test",		// –í–ê–®–ï –ù–ê–ó–í–ê–ù–ò–ï –ë–î
			dateFunc = 
				(dat)=>
					 if dat = "yesterday" then Date.ToText(Date.AddDays(Date.From(DateTime.LocalNow()) , -1),"yyyy-MM-dd")
				else if dat = "today" then Date.ToText(Date.From(DateTime.LocalNow()),"yyyy-MM-dd")
				else if (try Number.From(Text.BeforeDelimiter(dat,"daysAgo")) otherwise 0) >0 
					 then 	Date.ToText(
								Date.AddDays( 
									Date.From( DateTime.LocalNow() ),
									-1 * Number.From( Text.BeforeDelimiter(dat,"daysAgo") )
								),
								"yyyy-MM-dd"
							)
					 else dat,

			added   = 
				Table.AddColumn( 
					Table.SelectRows(pq_table, 
						each Date.From(Record.Field(_,pq_column)) >= Date.From(dateFunc(date1)) and 
							 Date.From(Record.Field(_,pq_column)) <= Date.From(dateFunc(date2))
					), 
					"all", 
					each	
						"(" & 
						Text.Combine( 
							List.Transform( 
								Record.ToList(_), 
								each	 if Value.Is(_, type text)   then "'" & _ & "'"
									else if Value.Is(_, type date)   then "'" & Date.ToText(_,"yyyy-MM-dd") & "'"
									else if Value.Is(_, type number) then Text.Replace(Text.From(_),",",".")
									else Text.From(_)
							),
						",") 
						& ")"
				),

			index   = Table.AddIndexColumn(added, "–ò–Ω–¥–µ–∫—Å", 0, 1, Int64.Type),
			divide  = Table.AddColumn(index, "division", each Number.IntegerDivide([–ò–Ω–¥–µ–∫—Å], rowlimit), Int64.Type),
			groups  = Table.Group(divide, {"division"}, {{"texts", each Text.Combine([all],","), type text}}),
			
			insert  = 
				Table.AddColumn(groups, "insert", each
					Function.InvokeAfter( ()=>
						Value.NativeQuery( 
							PostgreSQL.Database(HOST, DBNAME), 
							"INSERT INTO " & postgresql_table & " VALUES " & [texts]
						), 
						#duration(0,0,0,Number.From(delay))
					)
				),
			
			// delete  = Value.NativeQuery( 
				// 				PostgreSQL.Database(HOST, DBNAME),
				// 				"DELETE FROM " 	& postgresql_table & 
				// 				" WHERE " 		& postgresql_column & 
				// 				" >= '" 		& dateFunc(date1) & 
				// 				"' AND " 		& postgresql_column & 
				// 				" <= '" 		& dateFunc(date2) & 
				// 				"' " 
				// 			),
			Query	=  	"DELETE FROM " 	& postgresql_table & 
							" WHERE " 		& postgresql_column & 
							" >= """ 		& dateFunc(date1) & 
							""" AND " 		& postgresql_column & 
							" <= """ 		& dateFunc(date2) & """;",

			delete2 =  	Value.NativeQuery(
							PostgreSQL.Database(HOST, DBNAME),
							"DELETE FROM " 	& postgresql_table & 
							" WHERE " 		& postgresql_column & 
							" >= """ 		& dateFunc(date1) & 
							""" AND " 		& postgresql_column & 
							" <= """ 		& dateFunc(date2) & """;"
						)
						,
			delete  = 	Value.NativeQuery(
							PostgreSQL.Database(HOST, DBNAME),
								"TRUNCATE TABLE " & postgresql_table & ";"
						),

			chdelay = Function.InvokeAfter( ()=>delete & Table.FromRecords({}), #duration(0,0,0,2) ),
			final   = chdelay & insert,
			expand  = List.Accumulate(
						final[insert], 
						Table.FromRows({}), 
						(st,cr)=> 	Function.InvokeAfter(
										()=> st & (if cr=null then Table.FromRows({}) else cr), 
										#duration(0,0,0,Number.From(delay))
									)
					)
		] ,

	Connect_Yandex_Disk_API = // –ü–æ–ª—É—á–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö –∏–∑ Yandex Disk API
		/*
			–ï—Å–ª–∏ –≤–∞—à –≥—É–≥–ª-–¥–∏—Å–∫ –ø–æ–ø–∞–ª (–∏–ª–∏ –º–æ–∂–µ—Ç –ø–æ–ø–∞—Å—Ç—å) –ø–æ–¥ —Å–∞–Ω–∫—Ü–∏–∏, –∞ —à–ª—é–∑—ã –≤—ã –Ω–µ –ª—é–±–∏—Ç–µ, –≤–∞–º –æ—á–µ–Ω—å –ø—Ä–∏–≥–æ–¥–∏—Ç—Å—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –Ø–Ω–¥–µ–∫—Å –î–∏—Å–∫ API:)
			–ö–∞–∫ –æ–±–Ω–æ–≤–ª—è—Ç—å –¥–∞–Ω–Ω—ã–µ –∏–∑ –ª–æ–∫–∞–ª—å–Ω–æ–≥–æ —Ñ–∞–π–ª–∞ –≤ Power BI Service –±–µ–∑ —à–ª—é–∑–∞? ü•π 
			1) –ì—Ä—É–∑–∏–º —Ñ–∞–π–ª –Ω–∞ –Ø–Ω–¥–µ–∫—Å.–î–∏—Å–∫.
			2) –û–±—Ä–∞—â–∞–µ–º—Å—è –∫ API –Ø–Ω–¥–µ–∫—Å.–î–∏—Å–∫–∞ —Å –ø–æ–º–æ—â—å—é —Ñ—É–Ω–∫—Ü–∏–∏ –∏ –ø–æ–ª—É—á–∞–µ–º —Ñ–∞–π–ª –≤ Power BI Desktop.
			3) –í—ã–≥—Ä—É–∂–∞–µ–º –æ—Ç—á—ë—Ç —Å —Ñ–∞–π–ª–æ–º –≤ –∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—É—é —Ä–∞–±–æ—á—É—é –æ–±–ª–∞—Å—Ç—å Power BI Service ("–ú–æ—è —Ä–∞–±–æ—á–∞—è –æ–±–ª–∞—Å—Ç—å" –Ω–µ –ø–æ–¥–æ–π–¥—ë—Ç). 
			–í "–ú–æ–µ–π —Ä–∞–±–æ—á–µ–π –æ–±–ª–∞—Å—Ç–∏" Power BI —Ç—Ä–µ–±—É–µ—Ç —à–ª—é–∑, —Ç–∞–∫ —á—Ç–æ —Ç–∞–º –ø–æ–ª—å–∑—ã –æ—Ç —Ñ—É–Ω–∫—Ü–∏–∏ –º–∞–ª–æ.
			–ì–¥–µ —ç—Ç–æ –µ—â–µ —Ä–∞–±–æ—Ç–∞–µ—Ç?
			–§—É–Ω–∫—Ü–∏—è —Ä–∞–±–æ—Ç–∞–µ—Ç –≤ Excel, –∞ —Ç–∞–∫–∂–µ –≤ –ø–æ—Ç–æ–∫–∞—Ö –¥–∞–Ω–Ω—ã—Ö Power BI. –ú–æ–∂–Ω–æ –∑–∞–ø—É—Å—Ç–∏—Ç—å –ø–æ—Ç–æ–∫ –¥–∞–Ω–Ω—ã—Ö —Å –æ–±—Ä–∞—â–µ–Ω–∏–µ–º –∫ —Ä–∞–∑–Ω—ã–º —Ñ–∞–π–ª–∞–º –∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –≤–µ–∑–¥–µ –µ–≥–æ - —ç—Ç–æ –¥–æ–≤–æ–ª—å–Ω–æ —É–¥–æ–±–Ω–æ. 
			–°–ª–æ–∂–Ω–æ –ø–æ–≤–µ—Ä–∏—Ç—å, –Ω–æ –≥–æ–≤–æ—Ä—è—Ç, —á—Ç–æ –¥–∞–∂–µ –≤ Report Server —Ñ—É–Ω–∫—Ü–∏—è —Ä–∞–±–æ—Ç–∞–µ—Ç.
			–ê –≤–æ—Ç –∏ —Å–∞–º–∞ —Ñ—É–Ω–∫—Ü–∏—è:
		*/
		let 
			function =
				(fileLink as text, token as text )=>
				let
					headers = [
						#"Content-Type"  = "application/json", 
						#"Authorization" = "OAuth "&token, 
						#"Accept" 		 = "application/json"
					],

					querydata = [
						#"path" = Text.Replace(fileLink, "\","/")
					],

					web 	= Web.Contents(
								"https://cloud-api.yandex.net/", 
								[
									RelativePath		 = "v1/disk/resources/download", 
									Headers 			 = headers, 
									ManualStatusHandling = {404, 400}, 
									Query 				 = querydata
								]),

					result 	= Json.Document(web),
					link 	= result[href], 
					relativ = Text.Replace(result[href], "https://downloader.disk.yandex.ru/",""),
					href 	= Web.Contents(
								"https://downloader.disk.yandex.ru/", 
								[
									RelativePath = relativ, 
									Headers = headers, 
									ManualStatusHandling = {404, 400}
								])
				in 
					href,

			result = Value.ReplaceType(function, FuncType),

			FuncType = type function (

				fileLink as (type text meta [
						Documentation.FieldCaption = "–ü—É—Ç—å –∫ —Ñ–∞–π–ª—É –ø–æ—Å–ª–µ C:\YandexDisk\:",
						Documentation.SampleValues = {"–ú–æ–∏ —Ñ–∞–π–ª—ã\—Ñ–∞–π–ª–∏–∫.xxx"}
					]),   

				token as (type text meta [
						Documentation.FieldCaption = "–í–∞—à —Ç–æ–∫–µ–Ω (—Å—Å—ã–ª–∫–∞ –Ω–∞ –ø–æ–ª—É—á–µ–Ω–∏–µ –Ω–∏–∂–µ):",
						Documentation.SampleValues = {"y0_AgAAAMfGA...rBX0d-ZpA5O"}
					])
						)
					as table meta [
						Documentation.Name = "–ü–æ–ª—É—á–∞–µ–º —Ñ–∞–π–ª —Å –Ø–Ω–¥–µ–∫—Å.–î–∏—Å–∫–∞",
						Documentation.LongDescription =    "",
					
					Documentation.Examples = {
								[
							Description = "–°—Å—ã–ª–∫–∞ –Ω–∞ –ø–æ–ª—É—á–µ–Ω–∏–µ —Ç–æ–∫–µ–Ω–∞:",
							Code = "https://oauth.yandex.ru/authorize?response_type=token&client_id=a363cf6712db45978a012820777fc06a",
							Result = "–ü–æ —Å—Å—ã–ª–∫–µ –≤—ã –ø–æ–ª—É—á–∏—Ç–µ —Ç–æ–∫–µ–Ω"
									]
						}
			]

		in result


	],

Calendar   = [ 
	readme = "–ë–∏–±–ª–∏–æ—Ç–µ–∫–∞ –∫–∞–ª–µ–Ω–¥–∞—Ä–µ–π v 1.1",
	Calendar = 1,
	Calendar_–ì—Ä–∏—à–∏–Ω–∞ = 
		let
		// 	–§—É–Ω–∫—Ü–∏—è List.Dates –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–ø–∏—Å–æ–∫ –¥–∞—Ç
			Source = List.Dates,
		// 	–ê–∫—Ç–∏–≤–∏—Ä—É–π—Ç–µ List.Dates function. –ó–¥–µ—Å—å –≤—ã —Å–º–æ–∂–µ—Ç–µ –Ω–∞—Å—Ç—Ä–æ–∏—Ç—å –ª—é–±—ã–µ –∏–∑–≤—Ä–∞—â–µ–Ω–∏—è –∫–∞–ª–µ–Ω–¥–∞—Ä—è. –ù–æ –ª—É—á—à–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –±–∞–∑–∏—Å—ã.
		// 	–î–∞—Ç–∞ –Ω–∞—á–∞–ª–∞:    # Date (YYYY,MM,DD)
		// 	–î–∞—Ç–∞ –æ–∫–æ–Ω—á–∞–Ω–∏—è: Duration.Days(DateTime.Date(DateTime.FixedLocalNow()) - #date(YYYY, MM, DD))+1  
		//	(It counts the number of days between today and the first date of the table and adds one day more to include today).
		// 	–î–ª—è –∞–¥–∞–ø—Ç–∞—Ü–∏–∏ –∫ –¥—Ä—É–≥–∏–º —Ç–∞–±–ª–∏—Ü–∞–º –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ —ç—Ç–æ—Ç —Ç–∏–ø —Å—Ç–æ–ª–±—Ü–∞ (YYYY; MM; DD)
		// 	#duration (1,0,0,0) –î–æ–±–∞–≤–ª—è–µ—Ç –≤ List.Date –ø–æ –æ–¥–Ω–æ–º—É –¥–Ω—é –∑–∞ —à–∞–≥.
			#"Invoke dates" = Source(
				#date(1910, 1, 1), 
				Duration.Days(DateTime.Date(DateTime.FixedLocalNow()) - #date(2023,01,01)) + 1,
				#duration(1, 0, 0, 0)
			),
		
		// 	–≠—Ç–æ—Ç —à–∞–≥ —Ä–∞–∑–≤–æ—Ä–∞—á–∏–≤–∞–µ—Ç —Ç–∞–±–ª–∏—Ü—É, –∂–µ–ª–∞—Ç–µ–ª—å–Ω–æ —Å—Ç–∞–≤–∏—Ç—å –¥–∞—Ç—ã –æ–¥–∏–Ω–∞–∫–æ–≤—ã–µ.
			#"List to table" = Table.FromList(#"Invoke dates", Splitter.SplitByNothing(), null, null, ExtraValues.Error),
		
		// 	–ü–µ—Ä–µ–∏–º–µ–Ω–æ–≤–∞—Ç—å —Å—Ç–æ–ª–±–µ—Ü
			Date = Table.RenameColumns(#"List to table",{{"Column1", "Date"}}),
		
		// 	–ò–∑–≤–ª–µ–∫–∞–µ–º –¥–µ–Ω—å, –≥–¥–µ –Ω—É–ª–µ–≤—ã–µ –∫–∞–∫ ‚Äú00‚Äù
			#"Day Added" = Table.AddColumn(Date, "Day", each Text.PadStart(Number.ToText(Date.Day([Date])),2,"0")),
		
		// 	–ò–∑–≤–ª–µ–∫–∞–µ–º –¥–µ–Ω—å –Ω–µ–¥–µ–ª–∏, –Ω–∞—á–∞–ª–æ –≤ –ø–æ–Ω–µ–¥–µ–ª—å–Ω–∏–∫.
			#"Day Name Added" = Table.AddColumn(#"Day Added", "Day Name", each Date.ToText([Date],"ddd","ru-RU")),
		// 	–ò–∑–≤–ª–µ–∫–∞–µ–º –º–µ—Å—è—Ü –ù–æ–º–µ—Ä    
			#"Month No Added" = Table.AddColumn(#"Day Name Added", "Month No", each Date.Month([Date])),
		
		// 	–ò–∑–≤–ª–µ–∫–∞–µ–º –Ω–∞–∑–≤–∞–Ω–∏–µ –º–µ—Å—è—Ü–∞
			#"Month Name Added" = Table.AddColumn(#"Month No Added", "Month Name", each Date.ToText([Date],"MMM","ru-RU")),
		
		// 	–ò–∑–≤–ª–µ–∫–∞–µ–º –Ω–æ–º–µ—Ä –∫–≤–∞—Ä—Ç–∞–ª–∞
			#"Quarter No Added" = Table.AddColumn(#"Month Name Added", "Quarter No", each Date.QuarterOfYear([Date])),
		
		// 	–ò–∑–≤–ª–µ–∫–∞–µ–º –Ω–µ–¥–µ–ª–∏. –í–ù–ò–ú–ê–¢–ï–õ–¨–ù–û –°–ú–û–¢–†–ò–¢–ï –ù–ê –¢–û, –°–ö–û–õ–¨–ö–û –ù–ï–î–ï–õ–¨ –í –ì–û–î–£ –í–ê–ú –ù–ê–î–û - –ó–ê–í–ò–°–ò–¢ –û–¢ –ü–û–ñ–ï–õ–ê–ù–ò–ô –ö–õ–ò–ï–ù–¢–ê
			#"Week No added" = Table.AddColumn(#"Quarter No Added", "WeekNo", each Text.PadStart(Number.ToText(Date.WeekOfYear([Date])-1),2,"0")),
		
		// 	–ò–∑–≤–ª–µ–∫–∞–µ–º –≥–æ–¥
			#"Year Added" = Table.AddColumn(#"Week No added", "Year", each Date.Year([Date])),
		
		// 	–û–±—ä–µ–¥–∏–Ω—è–µ–º –≤ –ì–æ–¥–ú–µ—Å—è—Ü
			#"Year Month Added" = Table.AddColumn(#"Year Added", "Year-Month", each Number.ToText([Year])&"-"&[Month Name]),
		
		// 	–û–±—ä–µ–¥–∏–Ω—è–µ–º –ì–æ–¥–ö–≤–∞—Ä—Ç–∞–ª
			#"Year Quarter Added" = Table.AddColumn(#"Year Month Added", "Year-Quarter", each Number.ToText([Year]) & "Q"& Number.ToText([Quarter No],"00")),
		
		// 	–ò–∑–º–µ–Ω—è–µ–º —Ç–∏–ø –Ω–∞ —Ç–µ–∫—Å—Ç
			#"Change type to text" = Table.TransformColumnTypes(#"Year Quarter Added",{{"Year", type text}, {"Date", type date}, {"Month No", type text}, {"Day", type text}, {"Day Name", type text}, {"Month Name", type text}, {"Quarter No", type text}, {"Year-Quarter", type text}, {"Year-Month", type text}, {"WeekNo", type text}}),
		
		// 	–î–µ–ª–∞–µ–º —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫—É –¥–Ω–µ–π
			#"Sort Day" = Table.AddColumn(#"Change type to text", "SortDay", each Date.Day([Date])),
		
		// 	–û–±—ä–µ–¥–∏–Ω—è–µ–º –ì–æ–¥–î–µ–Ω—å–ù–µ–¥–µ–ª–∏
			#"Sort DayName" = Table.AddColumn(#"Sort Day", "SortDayName", each Date.DayOfWeek([Date],1)),
		
		// 	–ò–∑–≤–ª–µ–∫–∞–µ–º –ù–æ–º–µ—Ä –Ω–µ–¥–µ–ª–∏ –ø–æ –ï–≤—Ä–æ–ø–µ–π—Å–∫–æ–º—É —Ñ–æ—Ä–º–∞—Ç—É
			#"Sort Week No" = Table.AddColumn(#"Sort DayName", "SortWeekNo", each Date.WeekOfYear([Date])+1),
		
		// 	–î–µ–ª–∞–µ–º —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫—É –ù–µ–¥–µ–ª—å
			#"Sort YearMonth" = Table.AddColumn(#"Sort Week No", "SortYearMonth", each [Year]&Text.PadStart([Month No],2,"0")),
		
		// 	–î–µ–ª–∞–µ–º —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫—É –ì–æ–¥–ö–≤–∞—Ä—Ç–∞–ª
			#"Sort YearQuarter" = Table.AddColumn(#"Sort YearMonth", "SortYearQuarter", each [Year]&Text.PadStart([Quarter No],2,"0")),
		
		// 	–ò–∑–º–µ–Ω—è–µ–º —Ç–∏–ø –¥–∞–Ω–Ω—ã—Ö —Å–æ—Ä—Ç–∏—Ä–æ–≤–æ–∫ –Ω–∞ —Ü–µ–ª–æ–µ —á–∏—Å–ª–æ
			#"Changed Type to NO" = Table.TransformColumnTypes(#"Sort YearQuarter",{{"SortYearMonth", Int64.Type}, {"SortYearQuarter", Int64.Type}, {"SortDayName", Int64.Type}, {"SortDay", Int64.Type}, {"SortWeekNo", Int64.Type}}),
			#"–í—Å—Ç–∞–≤–ª–µ–Ω–Ω—ã–µ –ø–µ—Ä–≤—ã–µ —Å–∏–º–≤–æ–ª—ã" = Table.AddColumn(#"Changed Type to NO", "–ú–µ—Å—è—Ü –ë—É–∫–≤–∞", each Text.Start(Text.Upper([Month Name]), 1), type text),
			to = Table.TransformColumnTypes(#"–í—Å—Ç–∞–≤–ª–µ–Ω–Ω—ã–µ –ø–µ—Ä–≤—ã–µ —Å–∏–º–≤–æ–ª—ã",{{"Month No", Int64.Type}})
		in
			to,

	fxMyCalendar = // –ú–æ–π –∫–∞–ª–µ–Ω–¥–∞—Ä—å, —Å –∫–æ—Ç–æ—Ä—ã–º —Ä–∞–±–æ—Ç–∞—é
		/*
			= F[fxMyCalendar]()
		*/
		(StartDate as date, EndDate as date, optional Culture as nullable text) as table =>
		let
			DayCount        = Duration.Days(Duration.From(EndDate - StartDate)),
			Source          = List.Dates(StartDate,DayCount,#duration(1,0,0,0)),
			TableFromList   = Table.FromList(Source, Splitter.SplitByNothing()),    
			ChangedType     = Table.TransformColumnTypes(TableFromList,{{"Column1", type date}}),
			RenamedColumns  = Table.RenameColumns(ChangedType,{{"Column1", "Date"}}),
			
			InsertYear          = Table.AddColumn(RenamedColumns, 		"Year", 			each Date.Year([Date])),
			InsertQuarter       = Table.AddColumn(InsertYear, 			"QuarterOfYear", 	each Date.QuarterOfYear([Date])),
			InsertMonth         = Table.AddColumn(InsertQuarter, 		"MonthOfYear", 		each Date.Month([Date])),
			InsertDay           = Table.AddColumn(InsertMonth, 			"DayOfMonth", 		each Date.Day([Date])),
			InsertDayInt        = Table.AddColumn(InsertDay, 			"DateInt", 			each [Year] * 10000 + [MonthOfYear] * 100 + [DayOfMonth]),
			InsertMonthName     = Table.AddColumn(InsertDayInt, 		"MonthName", 		each Date.ToText([Date], "MMMM", Culture), type text),
			InsertCalendarMonth = Table.AddColumn(InsertMonthName, 		"MonthInCalendar", 	each (try(Text.Range([MonthName],0,3)) otherwise [MonthName]) & " " & Number.ToText([Year])),
			InsertCalendarQtr   = Table.AddColumn(InsertCalendarMonth, 	"QuarterInCalendar", each "Q" & Number.ToText([QuarterOfYear]) & " " & Number.ToText([Year])),
			InsertDayWeek       = Table.AddColumn(InsertCalendarQtr, 	"DayInWeek", 		each Date.DayOfWeek([Date])),
			InsertDayName       = Table.AddColumn(InsertDayWeek, 		"DayOfWeekName", 	each Date.ToText([Date], "dddd", Culture), type text),
			InsertWeekEnding    = Table.AddColumn(InsertDayName, 		"WeekEnding", 		each Date.EndOfWeek([Date]), type date)
		in  InsertWeekEnding,

	fxCalendar1  = // –ö–∞–ª–µ–Ω–¥–∞—Ä—å –£–≤–∞—Ä–æ–≤–∞
		(StartDate as date, EndDate as date, optional Culture as nullable text) as table =>
		let
			DayCount        = Duration.Days(Duration.From(EndDate - StartDate)),
			Source          = List.Dates(StartDate,DayCount,#duration(1,0,0,0)),
			TableFromList   = Table.FromList(Source, Splitter.SplitByNothing()),    
			ChangedType     = Table.TransformColumnTypes(TableFromList,{{"Column1", type date}}),
			RenamedColumns  = Table.RenameColumns(ChangedType,{{"Column1", "Date"}}),
			
			InsertYear          = Table.AddColumn(RenamedColumns, 	"Year", 			each Date.Year([Date])),
			InsertQuarter       = Table.AddColumn(InsertYear, 		"QuarterOfYear", 	each Date.QuarterOfYear([Date])),
			InsertMonth         = Table.AddColumn(InsertQuarter, 	"MonthOfYear", 		each Date.Month([Date])),
			InsertDay           = Table.AddColumn(InsertMonth, 		"DayOfMonth", 		each Date.Day([Date])),
			InsertDayInt        = Table.AddColumn(InsertDay, 		"DateInt", 			each [Year] * 10000 + [MonthOfYear] * 100 + [DayOfMonth]),
			InsertMonthName     = Table.AddColumn(InsertDayInt, 	"MonthName", 		each Date.ToText([Date], "MMMM", Culture), type text),
			InsertCalendarMonth = Table.AddColumn(InsertMonthName, 	"MonthInCalendar", 	each (try(Text.Range([MonthName],0,3)) otherwise [MonthName]) & " " & Number.ToText([Year])),
			InsertCalendarQtr   = Table.AddColumn(InsertCalendarMonth, "QuarterInCalendar", each "Q" & Number.ToText([QuarterOfYear]) & " " & Number.ToText([Year])),
			InsertDayWeek       = Table.AddColumn(InsertCalendarQtr, "DayInWeek", 		each Date.DayOfWeek([Date])),
			InsertDayName       = Table.AddColumn(InsertDayWeek, 	"DayOfWeekName", 	each Date.ToText([Date], "dddd", Culture), type text),
			InsertWeekEnding    = Table.AddColumn(InsertDayName, 	"WeekEnding", 		each Date.EndOfWeek([Date]), type date)    
		in  InsertWeekEnding,
	
	
	fxCalendar2  = // –ü—Ä–∞–∑–¥–Ω–∫–∏ P–§
		(–ì–æ–¥) =>
		let
			TextYearParam = Text.From(–ì–æ–¥) & (if –ì–æ–¥=2020 then "b" else ""),
			Source = Lines.FromBinary(Web.Contents("http://www.consultant.ru/law/ref/calendar/proizvodstvennye",[RelativePath = Text.From(TextYearParam) & "/?"])),
			#"Converted to Table" 	= Table.FromList(Source, Splitter.SplitByNothing(), null, null, ExtraValues.Error),
			#"Filtered Rows" 		= Table.SelectRows(#"Converted to Table", each Text.StartsWith([Column1], "#(tab)#(tab)#(tab)<td class=")),
			#"Replaced Value" 		= Table.ReplaceValue(#"Filtered Rows","</tr><tr>","",Replacer.ReplaceText,{"Column1"}),
			#"Added Index" 			= Table.AddIndexColumn(#"Replaced Value", "#Month", 1, 1),
			#"Added Prefix" 		= Table.TransformColumns(#"Added Index", {{"Column1", each Text.Split(_,"</td><td class="), type text}}),
			#"Expanded Custom" 		= Table.ExpandListColumn(#"Added Prefix", "Column1"),
			#"Filtered Rows1" 		= Table.SelectRows(#"Expanded Custom", each not Text.Contains([Column1], "inactively")),
			#"Replaced Value1" 		= Table.ReplaceValue(#"Filtered Rows1","#(tab)#(tab)#(tab)<td class=","",Replacer.ReplaceText,{"Column1"}),
			#"Split Column by Delimiter" = Table.SplitColumn(#"Replaced Value1", "Column1", Splitter.SplitTextByEachDelimiter({">"}, QuoteStyle.Csv, false), {"Day type", "Day"}),
			#"Extracted Text Before Delimiter" = Table.TransformColumns(#"Split Column by Delimiter", {{"Day", each Text.BeforeDelimiter(_, "<"), type text}}),
			#"Changed Type" 		= Table.TransformColumnTypes(#"Extracted Text Before Delimiter",{{"Day", Int64.Type}}),
			#"Added Custom" 		= Table.AddColumn(#"Changed Type", "Year", each –ì–æ–¥, Int64.Type),
			#"Added Custom1" 		= Table.AddColumn(#"Added Custom", "Date", each #date([Year],[#"#Month"],[Day]), type date),
			#"Inserted Month Name" 	= Table.AddColumn(#"Added Custom1", "Month", each Date.MonthName([Date]), type text),
			#"Inserted Day Name" 	= Table.AddColumn(#"Inserted Month Name", "Day name", each Date.DayOfWeekName([Date]), type text)
		in
			#"Inserted Day Name",
		
	fxCalendar3  = // –ö–∞–ª–µ–Ω–¥–∞—Ä—å 3
		(StartDate as date,EndDate as date) =>
		let
			Source = List.Dates,
			#"Invoked FunctionSource" = Source(StartDate, Duration.Days(DateTime.Date(DateTime.FixedLocalNow()) - EndDate) + 1, #duration(1, 0, 0, 0)),
			#"Table from List" = Table.FromList(#"Invoked FunctionSource", Splitter.SplitByNothing(), null, null, ExtraValues.Error),
			#"Changed Type1" = Table.TransformColumnTypes(#"Table from List",{{"Column1", type date}}),
			#"Renamed Columns" = Table.RenameColumns(#"Changed Type1",{{"Column1", "–î–∞—Ç–∞"}}),

			// –î–æ–±–∞–≤–ª–µ–Ω–∏–µ —Å—Ç–æ–ª–±—Ü–æ–≤
			–ì–æ–¥                 = Table.AddColumn(#"Renamed Columns", 	"–ì–æ–¥", 			each Date.Year([–î–∞—Ç–∞]), Int64.Type),
			#"–ù–æ–º–µ—Ä –º–µ—Å—è—Ü–∞"     = Table.AddColumn(–ì–æ–¥, 					"–ú–µ—Å—è—Ü", 		each Date.ToText([–î–∞—Ç–∞],"MM"), type text),
			#"–ù–æ–º–µ—Ä –¥–Ω—è"        = Table.AddColumn(#"–ù–æ–º–µ—Ä –º–µ—Å—è—Ü–∞", 		"–ù–æ–º–µ—Ä –¥–Ω—è", 	each Date.ToText([–î–∞—Ç–∞],"dd"), type text),
			#"–ù–∞–∑–≤–∞–Ω–∏–µ –¥–Ω—è"     = Table.AddColumn(#"–ù–æ–º–µ—Ä –¥–Ω—è", 		"–î–µ–Ω—å", 		each Date.ToText([–î–∞—Ç–∞],"ddd"), type text),
			#"–ù–∞–∑–≤–∞–Ω–∏–µ –º–µ—Å—è—Ü–∞"  = Table.AddColumn(#"–ù–∞–∑–≤–∞–Ω–∏–µ –¥–Ω—è", 		"–ú–µ—Å", 			each Date.ToText([–î–∞—Ç–∞],"MMM"), type text),
			#"–ù–æ–º–µ—Ä –∫–≤–∞—Ä—Ç–∞–ª–∞"   = Table.AddColumn(#"–ù–∞–∑–≤–∞–Ω–∏–µ –º–µ—Å—è—Ü–∞", 	"–ö–≤–∞—Ä—Ç–∞–ª", 		each Date.QuarterOfYear([–î–∞—Ç–∞]), type text),
			#"–ù–æ–º–µ—Ä –Ω–µ–¥–µ–ª–∏"     = Table.AddColumn(#"–ù–æ–º–µ—Ä –∫–≤–∞—Ä—Ç–∞–ª–∞", 	"–ù–æ–º–µ—Ä –Ω–µ–¥–µ–ª–∏", each Date.WeekOfYear([–î–∞—Ç–∞]), Int64.Type),
			#"–ß–∏—Ç–∞–±–µ–ª—å–Ω–∞—è –ù–µ–¥–µ–ª—è" = Table.AddColumn(#"–ù–æ–º–µ—Ä –Ω–µ–¥–µ–ª–∏", 	"–ù–µ–¥–µ–ª—è", 		each Date.ToText(Date.StartOfWeek([–î–∞—Ç–∞]),"MM-dd")&"|"&Date.ToText(Date.EndOfWeek([–î–∞—Ç–∞]),"MM-dd"), type text),

			#"–≠—Ç–∞-–ø—Ä–æ—à–ª–∞—è" = Table.AddColumn(#"–ß–∏—Ç–∞–±–µ–ª—å–Ω–∞—è –ù–µ–¥–µ–ª—è", "–≠—Ç–∞/–ø—Ä–æ—à–ª–∞—è –Ω–µ–¥–µ–ª—è", 
					each if Date.IsInCurrentWeek([–î–∞—Ç–∞]) = true  and Date.From([–î–∞—Ç–∞]) <> Date.From(DateTime.LocalNow()) then "–≠—Ç–∞" 
					else if Date.IsInPreviousWeek([–î–∞—Ç–∞]) = true and Date.AddDays([–î–∞—Ç–∞],7) < Date.From(DateTime.LocalNow()) then "–ü—Ä–æ—à–ª–∞—è" 
					else "", type text),

			#"–ù–æ–º–µ—Ä –¥–Ω—è –Ω–µ–¥–µ–ª–∏" = Table.AddColumn(#"–≠—Ç–∞-–ø—Ä–æ—à–ª–∞—è", "‚Ññ –¥–Ω—è –Ω–µ–¥–µ–ª–∏", 
					each Date.DayOfWeek([–î–∞—Ç–∞]) + 1, Int64.Type),

			#"–≠—Ç–æ—Ç/–ø—Ä–æ—à–ª—ã–π –º–µ—Å—è—Ü" = Table.AddColumn(#"–ù–æ–º–µ—Ä –¥–Ω—è –Ω–µ–¥–µ–ª–∏", "–≠—Ç–æ—Ç/–ø—Ä–æ—à–ª—ã–π –º–µ—Å—è—Ü", 
					each if Date.IsInCurrentMonth([–î–∞—Ç–∞]) = true and Date.From([–î–∞—Ç–∞]) <> Date.From(DateTime.LocalNow()) then "–≠—Ç–æ—Ç –º–µ—Å—è—Ü" 
					else if Date.IsInPreviousMonth([–î–∞—Ç–∞]) = true then "–ü—Ä–æ—à–ª—ã–π –º–µ—Å—è—Ü" 
					else "", type text),

			#"–≠—Ç–∞/–ø—Ä–æ—à–ª–∞—è/–ø–æ–∑–∞–ø—Ä–æ—à–ª–∞—è" = Table.AddColumn(#"–≠—Ç–æ—Ç/–ø—Ä–æ—à–ª—ã–π –º–µ—Å—è—Ü", "–ü—Ä–æ—à–ª–∞—è/–ü–æ–∑–∞–ø—Ä–æ—à–ª–∞—è", 
					each if Date.IsInPreviousWeek([–î–∞—Ç–∞]) = true  then "–ü—Ä–æ—à–ª–∞—è" 
					else if Date.IsInPreviousWeek(Date.AddDays([–î–∞—Ç–∞],7)) = true then "–ü–æ–∑–∞–ø—Ä–æ—à–ª–∞—è" 
					else "", type text)
			in
				#"–≠—Ç–∞/–ø—Ä–æ—à–ª–∞—è/–ø–æ–∑–∞–ø—Ä–æ—à–ª–∞—è",

	fxCalendarKill = // killerDateTableRu
		// —Ñ—É–Ω–∫—Ü–∏—è killerDateTableRu —Å–æ–∑–¥–∞–µ—Ç —Ç–∞–±–ª–∏—Ü—É —Å –¥–∞—Ç–∞–º–∏. –î–æ–ø–æ–ª–Ω—è–µ—Ç –µ–µ —Ä–∞–∑–ª–∏—á–Ω—ã–º–∏ –ø–æ–ª–µ–∑–Ω—ã–º–∏ –¥–ª—è Time Intelligence —Å—Ç–æ–ª–±—Ü–∞–º–∏. 
		// –í —Å–ª—É—á–∞–µ, –µ—Å–ª–∏ —á–µ—Ç–≤–µ—Ä—Ç—ã–π –∞—Ä–≥—É–º–µ–Ω—Ç –ø—Ä–∏–Ω–∏–º–∞–µ—Ç –î–Ω–∏ 1, —Ç–æ —Ñ—É–Ω–∫—Ü–∏—è –¥–æ–±–∞–≤–ª—è–µ—Ç —Å—Ç–æ–ª–±–µ—Ü —Å –≤—ã—Ö–æ–¥–Ω—ã–º–∏.
		// –û—Ä–∏–≥–∏–Ω–∞–ª—å–Ω–∞—è –∏–¥–µ—è philbritton https://gist.github.com/philbritton/9677152
		// –ø—Ä–∏–º–µ—Ä: killerDateTableRu(#date(2017, 2, 1), #date(2017, 2, 4), "RU-ru", 1)
		// –æ—à–∏–±–∫–∞ –≤ —á–µ—Ç–≤–µ—Ä—Ç–æ–º –ø–∞—Ä–∞–º–µ—Ç—Ä–µ. –ù–∞–¥–æ –Ω–µ 1 –∞ TRUE —Å—Ç–∞–≤–∏—Ç—å –∏–ª–∏ —Ç–∏–ø –¥–∞–Ω–Ω—ã—Ö –º–µ–Ω—è—Ç—å
		// –ø—Ä–∏–º–µ—Ä: killerDateTableRu(#date(2017, 2, 1), #date(2017, 2, 4), "RU-ru", true)
		
		// –û–ø–∏—Å–∞–Ω–∏–µ –ø–æ–ª–µ–π —Ä–µ–∑—É–ª—å—Ç–∏—Ä—É—é—â–µ–π —Ç–∞–±–ª–∏—Ü—ã:
		// ===================================================
		// Date - –¥–∞—Ç–∞
		// Year - –≥–æ–¥
		// QuarterOfYear - –Ω–æ–º–µ—Ä –∫–≤–∞—Ä—Ç–∞–ª–∞
		// MonthOfYear - –Ω–æ–º–µ—Ä –º–µ—Å—è—Ü–∞ –≤ –≥–æ–¥—É
		// MonthDayNumber - –Ω–æ–º–µ—Ä –¥–Ω—è –≤ –º–µ—Å—è—Ü–µ
		// DateInt - –¥–∞—Ç–∞ –≤ —Ñ–æ—Ä–º–µ —Ü–µ–ª–æ–≥–æ —á–∏—Å–ª–∞
		// YearMonthNumber - –ú–µ—Å—è—Ü–ì–æ–¥ –≤ —Ñ–æ—Ä–º–µ 201701
		// MonthName - –Ω–∞–∑–≤–∞–Ω–∏–µ –º–µ—Å—è—Ü–∞ –≤ —Ñ–æ—Ä–º–∞—Ç–µ –Ø–Ω–≤–∞—Ä—å
		// MonthInCalendar - –ú–µ—Å—è—Ü –≥–æ–¥ –≤ —Ñ–æ—Ä–º–∞—Ç–µ –Ø–Ω–≤ 2017
		// QuarterInCalendar - –ö–≤–∞—Ä—Ç–∞–ª–ì–æ–¥ –≤ —Ñ–æ—Ä–º–∞—Ç–µ Q1 2017
		// DayInWeek - –Ω–æ–º–µ—Ä –¥–Ω—è –Ω–µ–¥–µ–ª–∏
		// DayOfWeekName - –Ω–∞–∑–≤–∞–Ω–∏–µ –¥–Ω—è –Ω–µ–¥–µ–ª–∏
		// WeekEnding - –¥–∞—Ç–∞ –æ–∫–æ–Ω—á–∞–Ω–∏—è –Ω–µ–¥–µ–ª–∏
		// StartOfWeek - –¥–∞—Ç–∞ –Ω–∞—á–∞–ª–∞ –Ω–µ–¥–µ–ª–∏
		// StartOfMonth - –¥–∞—Ç–∞ –Ω–∞—á–∞–ª–∞ –º–µ—Å—è—Ü–∞
		// WeekOfYear - –Ω–æ–º–µ—Ä –Ω–µ–¥–µ–ª–∏ –≤ –≥–æ–¥—É
		// DayOfYear - –Ω–æ–º–µ—Ä –¥–Ω—è –æ—Ç –Ω–∞—á–∞–ª–∞ –≥–æ–¥–∞
		// SequentialMonthNumber - –Ω–æ–º–µ—Ä –º–µ—Å—è—Ü–∞ –≤ —Ç–∞–±–ª–∏—Ü–µ –ø–æ –ø–æ—Ä—è–¥–∫—É
		// SequentialMonthNumberReverse - –Ω–æ–º–µ—Ä –º–µ—Å—è—Ü–∞ –≤ —Ç–∞–±–ª–∏—Ü–µ –≤ –æ–±—Ä–∞—Ç–Ω–æ–º –ø–æ—Ä—è–¥–∫–µ
		// SequentialWeekNumber - –Ω–æ–º–µ—Ä –Ω–µ–¥–µ–ª–∏ –≤ —Ç–∞–±–ª–∏—Ü–µ –ø–æ –ø–æ—Ä—è–¥–∫—É
		// SequentialWeekNumberReverse - –Ω–æ–º–µ—Ä –Ω–µ–¥–µ–ª–∏ –≤ —Ç–∞–±–ª–∏—Ü–µ –≤ –æ–±—Ä–∞—Ç–Ω–æ–º –ø–æ—Ä—è–¥–∫–µ
		// SequentialDayNumber - –Ω–æ–º–µ—Ä –¥–Ω—è –≤ —Ç–∞–±–ª–∏—Ü–µ –ø–æ –ø–æ—Ä—è–¥–∫—É
		// SequentialDayNumberReverse - –Ω–æ–º–µ—Ä –¥–Ω—è –≤ —Ç–∞–±–ª–∏—Ü–µ –≤ –æ–±—Ä–∞—Ç–Ω–æ–º –ø–æ—Ä—è–¥–∫–µ
	
		( 
			StartDateParameter        as date, 
			EndDateParameter          as date, 
			CultureParameter          as nullable text, 
			IsRuHolidaysParameter     as nullable logical ) =>
		
		let
			MONTHS_ORDERED_BY_DEFAULT = {
				"–Ø–Ω–≤–∞—Ä—å", "–§–µ–≤—Ä–∞–ª—å", "–ú–∞—Ä—Ç",
				"–ê–ø—Ä–µ–ª—å", "–ú–∞–π", "–ò—é–Ω—å", 
				"–ò—é–ª—å", "–ê–≤–≥—É—Å—Ç", "–°–µ–Ω—Ç—è–±—Ä—å", 
				"–û–∫—Ç—è–±—Ä—å", "–ù–æ—è–±—Ä—å", "–î–µ–∫–∞–±—Ä—å"
			},
		
			getProductionCalendar = ( URL as text ) as nullable table =>
				let
					GetDataFromGovRu = Csv.Document(  Web.Contents( URL ), [ Delimiter  = ",", Encoding   = 65001, QuoteStyle = QuoteStyle.None ] ),
			
					#"–ü–æ–≤—ã—à–µ–Ω–Ω—ã–µ –∑–∞–≥–æ–ª–æ–≤–∫–∏"      = Table.PromoteHeaders( GetDataFromGovRu ),
					#"–ü–µ—Ä–µ–∏–º–µ–Ω–æ–≤–∞–ª–∏ –ø–æ–ª–µ –≤ –≥–æ–¥"  = Table.RenameColumns( #"–ü–æ–≤—ã—à–µ–Ω–Ω—ã–µ –∑–∞–≥–æ–ª–æ–≤–∫–∏", { {"–ì–æ–¥/–ú–µ—Å—è—Ü", "–ì–æ–¥"} }),
					#"–í—ã–±—Ä–∞–ª–∏ –≥–æ–¥ –∏ –º–µ—Å—è—Ü"       = Table.SelectColumns( #"–ü–µ—Ä–µ–∏–º–µ–Ω–æ–≤–∞–ª–∏ –ø–æ–ª–µ –≤ –≥–æ–¥",  { "–ì–æ–¥" } & MONTHS_ORDERED_BY_DEFAULT ),
					#"–°–ø—Ä—è–º–∏–ª–∏ –∫–∞–ª–µ–Ω–¥–∞—Ä—å"        = Table.UnpivotOtherColumns( #"–í—ã–±—Ä–∞–ª–∏ –≥–æ–¥ –∏ –º–µ—Å—è—Ü", { "–ì–æ–¥" }, "–ú–µ—Å—è—Ü", "–î–µ–Ω—å"),
					#"–î–æ–±–∞–≤–∏–ª–∏ –Ω–æ–º–µ—Ä –º–µ—Å—è—Ü–∞"     = Table.AddColumn( #"–°–ø—Ä—è–º–∏–ª–∏ –∫–∞–ª–µ–Ω–¥–∞—Ä—å", "–ù–æ–º–µ—Ä–ú–µ—Å—è—Ü–∞", each 1 + List.PositionOf( MONTHS_ORDERED_BY_DEFAULT, [–ú–µ—Å—è—Ü] ), type number),
					#"–ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–ª–∏ –≤ —Å–ø–∏—Å–æ–∫" 	 = Table.TransformColumns( #"–î–æ–±–∞–≤–∏–ª–∏ –Ω–æ–º–µ—Ä –º–µ—Å—è—Ü–∞",{ { "–î–µ–Ω—å", each Text.Split( _, "," ) }} ),
					#"–†–∞–∑–≤–µ—Ä–Ω—É–ª–∏ —Å–ø–∏—Å–æ–∫ –¥–Ω–µ–π"    = Table.ExpandListColumn( #"–ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–ª–∏ –≤ —Å–ø–∏—Å–æ–∫", "–î–µ–Ω—å" ),
					#"–î–æ–±–∞–≤–∏–ª–∏ —Å–æ–∫—Ä–∞—â–µ–Ω–Ω—ã–π –¥–µ–Ω—å" = Table.AddColumn( #"–†–∞–∑–≤–µ—Ä–Ω—É–ª–∏ —Å–ø–∏—Å–æ–∫ –¥–Ω–µ–π", "–°–æ–∫—Ä–∞—â–µ–Ω–Ω—ã–π –î–µ–Ω—å", each Text.Contains( [–î–µ–Ω—å], "*" ) ),
					#"–î–æ–±–∞–≤–∏–ª–∏ –≤—ã—Ö–æ–¥–Ω–æ–π –¥–µ–Ω—å"    = Table.AddColumn( #"–î–æ–±–∞–≤–∏–ª–∏ —Å–æ–∫—Ä–∞—â–µ–Ω–Ω—ã–π –¥–µ–Ω—å", "–í—ã—Ö–æ–¥–Ω–æ–π –î–µ–Ω—å", each not [–°–æ–∫—Ä–∞—â–µ–Ω–Ω—ã–π –î–µ–Ω—å] ),
					#"–£–¥–∞–ª–∏–ª–∏ –ø—Ä–∏–∑–Ω–∞–∫ —Å–æ–∫—Ä. –¥–Ω—è" = Table.ReplaceValue( #"–î–æ–±–∞–≤–∏–ª–∏ –≤—ã—Ö–æ–¥–Ω–æ–π –¥–µ–Ω—å", "*", "", Replacer.ReplaceText, { "–î–µ–Ω—å" } ),
					#"–£—Ç–æ—á–Ω–∏–ª–∏ —Ç–∏–ø –ø–æ–ª–µ–π" 		 = Table.TransformColumnTypes( #"–£–¥–∞–ª–∏–ª–∏ –ø—Ä–∏–∑–Ω–∞–∫ —Å–æ–∫—Ä. –¥–Ω—è",{
							{ "–ì–æ–¥", Int64.Type },
							{ "–î–µ–Ω—å", Int64.Type },
							{ "–ù–æ–º–µ—Ä–ú–µ—Å—è—Ü–∞", Int64.Type } }
						),
					#"–†–∞—Å—Å—á–∏—Ç–∞–ª–∏ –¥–∞—Ç—É" = Table.AddColumn( #"–£—Ç–æ—á–Ω–∏–ª–∏ —Ç–∏–ø –ø–æ–ª–µ–π", "–î–∞—Ç–∞", each #date( [–ì–æ–¥], [–ù–æ–º–µ—Ä–ú–µ—Å—è—Ü–∞], [–î–µ–Ω—å] ) )
				in
					#"–†–∞—Å—Å—á–∏—Ç–∞–ª–∏ –¥–∞—Ç—É",
		
		// –ü—Ä–∏–º–µ—á–∞–Ω–∏–µ: 
		//  –∏—Å—Ç–æ—á–Ω–∏–∫ –≤–∑—è—Ç –æ—Ç—Å—é–¥–∞: http://data.gov.ru/opendata/7708660670-proizvcalendar
		//  –ù–∞ –º–æ–º–µ–Ω—Ç 24.05.2018 –≤ –∫–∞–ª–µ–Ω–¥–∞—Ä–µ —Å–æ–¥–µ—Ä–∂–∞—Ç—Å—è –æ–ø–∏—Å–∞–Ω–∏–µ –ø—Ä–∞–∑–¥–Ω–∏–∫–æ–≤ —Å 1999 –≥–æ–¥–∞ –ø–æ 2025 –≥–æ–¥.
		
			PROD_–°ALENDAR_URL =
			"http://data.gov.ru/opendata/7708660670-proizvcalendar/data-20180410T1145-structure-20180410T1145.csv?encoding=UTF-8",
		
			ProductionCalendar = getProductionCalendar( PROD_–°ALENDAR_URL ),
		
			ListOfShortday = Table.SelectRows( ProductionCalendar, each [–°–æ–∫—Ä–∞—â–µ–Ω–Ω—ã–π –î–µ–Ω—å] = true )[–î–∞—Ç–∞],
			ListOfHoliday  = Table.SelectRows( ProductionCalendar, each [–í—ã—Ö–æ–¥–Ω–æ–π –î–µ–Ω—å] = true )[–î–∞—Ç–∞],
			
			CheckIfThereIsShortdayList = List.Buffer( try ListOfShortday otherwise {} ),
			CheckIfThereIsHolidayList  = List.Buffer( try ListOfHoliday otherwise {} ),

			DayCount      = Duration.Days( Duration.From( EndDateParameter - StartDateParameter ) ) + 1,
			MainList      = List.Dates( StartDateParameter, DayCount, #duration( 1, 0, 0, 0 ) ),
			TableFromList = Table.FromList( MainList, Splitter.SplitByNothing(), { "Date" } ),    
			ChangedType   = Table.TransformColumnTypes( TableFromList,  { {"Date", type date } } ),
			
			InsertYear    = Table.AddColumn( ChangedType,   "Year",           each Date.Year( [Date] ), Int64.Type ),
			InsertQuarter = Table.AddColumn( InsertYear,    "QuarterOfYear",  each Date.QuarterOfYear( [Date] ),Int64.Type),
			InsertMonth   = Table.AddColumn( InsertQuarter, "MonthOfYear",    each Date.Month( [Date] ),Int64.Type),
			InsertDay     = Table.AddColumn( InsertMonth,   "MonthDayNumber", each Date.Day( [Date] ),Int64.Type),
			InsertDayInt  = Table.AddColumn( InsertDay,     "DateInt",        each [Year] * 10000 + [MonthOfYear] * 100 + [MonthDayNumber],Int64.Type),

			InsertYearMonthNumber = Table.AddColumn( InsertDayInt, "YearMonthNumber",    each [Year] * 100 + [MonthOfYear] * 1, Int64.Type),
			InsertMonthName =       Table.AddColumn( InsertYearMonthNumber, "MonthName", each Date.ToText( [Date], "MMMM", CultureParameter ), type text),
			InsertCalendarMonth =   Table.AddColumn( InsertMonthName, "MonthInCalendar", each ( try ( Text.Range( [MonthName], 0, 3 ) ) otherwise [MonthName] ) & " " & Number.ToText( [Year] ), type text),
			InsertCalendarQtr =     Table.AddColumn( InsertCalendarMonth, "QuarterInCalendar", each "Q" & Number.ToText( [QuarterOfYear] ) & " " & Number.ToText( [Year] ), type text),

			// 1–ö–≤ 22
			InsertCalendarQtrRus = Table.AddColumn( InsertCalendarQtr,     "QuarterInCalendarR", each Number.ToText( [QuarterOfYear] ) & "–ö–≤" & " " & Number.ToText( [Year] ), type text),  
			InsertDayWeek        = Table.AddColumn( InsertCalendarQtrRus,  "DayInWeek",      each Date.DayOfWeek( [Date], Day.Monday ) + 1, Int64.Type ),
			InsertDayName        = Table.AddColumn( InsertDayWeek,         "DayOfWeekName",  each Date.ToText( [Date], "dddd", CultureParameter ), type text),
			InsertWeekEnding     = Table.AddColumn( InsertDayName,         "WeekEnding",     each Date.EndOfWeek( [Date], Day.Monday ), type date),
			InsertedStartofWeek  = Table.AddColumn( InsertWeekEnding,      "StartOfWeek",    each Date.StartOfWeek( [Date], Day.Monday ), type date),
			InsertedStartofMonth = Table.AddColumn( InsertedStartofWeek,   "StartOfMonth",   each Date.StartOfMonth( [Date] ), type date ),
			InsertWeekofYear     = Table.AddColumn( InsertedStartofMonth,  "WeekOfYear",     each Date.WeekOfYear( [Date], Day.Monday ), Int64.Type),
			InsertDayofYear      = Table.AddColumn( InsertWeekofYear,      "DayOfYear",      each Date.DayOfYear( [Date] ), Int64.Type),

			listBufferMonths 	= List.Buffer( List.Distinct( InsertDayofYear[StartOfMonth] ) ),
			
			AddedNumberOfMonth 	= Table.AddColumn( InsertDayofYear, "SequentialMonthNumber", each List.PositionOf( listBufferMonths, [StartOfMonth]) + 1, Int64.Type),
			
			SequentialMonthNumberReverse = 
				Table.AddColumn( AddedNumberOfMonth, "SequentialMonthNumberReverse", each
					List.PositionOf( List.Reverse( listBufferMonths ), [StartOfMonth]) + 1,
					Int64.Type
				),
			
			listBufferWeeks = List.Buffer( List.Distinct( SequentialMonthNumberReverse[StartOfWeek] ) ),
			
			AddedNumberOfWeeks 			= Table.AddColumn( SequentialMonthNumberReverse, "SequentialWeekNumber", each List.PositionOf( listBufferWeeks, [StartOfWeek] ) + 1, Int64.Type),
			AddedNumberOfWeeksReverse 	= Table.AddColumn( AddedNumberOfWeeks, "SequentialWeekNumberReverse", each List.PositionOf( List.Reverse( listBufferWeeks ), [StartOfWeek] ) + 1, Int64.Type),
			InsertSequentialDayNumber 	= Table.AddIndexColumn( AddedNumberOfWeeksReverse, "SequentialDayNumber", 1, 1 ),
		
			InsertSequentialDayNumberReverse =
				Table.AddIndexColumn( 
					InsertSequentialDayNumber,
					"SequentialDayNumberReverse",
					List.Max( InsertSequentialDayNumber[SequentialDayNumber] ),
					-1 
				),
		
			insertRuHolidaysColumn = 
				Table.AddColumn( InsertSequentialDayNumberReverse, "Holiday", each
					if List.Count( CheckIfThereIsHolidayList ) = 0 
						then null
						else 
					if List.Contains( CheckIfThereIsHolidayList, [Date]) 
						then true 
						else false
			),
		
			insertRuShortdaysColumn = 
				Table.AddColumn( insertRuHolidaysColumn, "Shortday", each
					if 	List.Count( CheckIfThereIsShortdayList ) = 0  then null else 
					if 	List.Contains( CheckIfThereIsShortdayList, [Date])  then true else false
			)
			
		in
			if IsRuHolidaysParameter
			then insertRuShortdaysColumn
			else InsertSequentialDayNumberReverse,


	fxComrad 	 = // + –ö–∞–ª–µ–Ω–¥–∞—Ä—å –¢–æ–≤–∞—Ä–∏—â–∞
		(StartDate as date, EndDate as date, optional Culture as nullable text) as table =>
		let
			// fxMultiAdd = (tbl as table, nms as list) as table => List.Accumulate(nms, tbl, (s, c) => Table.AddColumn(s, c{0}, c{1}, c{2}?)),
			// addColumns = fxMultiAdd(from3,{
			
			start  = StartDate, // Excel.CurrentWorkbook(){[Name = "–ü–∞—Ä–∞–º–µ—Ç—Ä—ã"]}[Content]{0}[–ó–Ω–∞—á–µ–Ω–∏–µ]
			finish = EndDate, 	// Excel.CurrentWorkbook(){[Name = "–ü–∞—Ä–∞–º–µ—Ç—Ä—ã"]}[Content]{1}[–ó–Ω–∞—á–µ–Ω–∏–µ]
			tab_generate = Table.FromList(
					{Number.From(start) .. Number.From(finish)}, 
					Splitter.SplitByNothing(), {"–î–∞—Ç–∞"} ), 

			col_type = Table.TransformColumnTypes( tab_generate, {{"–î–∞—Ç–∞", type date}} ), 
			
			tab_add_col_1 = Table.AddColumn( col_type, 		"–ì–æ–¥", 			each Date.Year([–î–∞—Ç–∞]), 					Int64.Type ), 
			tab_add_col_2 = Table.AddColumn( tab_add_col_1, "–ú–µ—Å—è—Ü", 		each Date.Month([–î–∞—Ç–∞]),					Int64.Type ), 
			tab_add_col_3 = Table.AddColumn( tab_add_col_2, "–î–µ–Ω—å", 		each Date.Day([–î–∞—Ç–∞]), 						Int64.Type ), 
			tab_add_col_4 = Table.AddColumn( tab_add_col_3, "–ö–≤–∞—Ä—Ç–∞–ª", 		each Date.QuarterOfYear([–î–∞—Ç–∞]), 			Int64.Type ), 
			tab_add_col_5 = Table.AddColumn( tab_add_col_4, "–ù–µ–¥–µ–ª—è –≥–æ–¥–∞", 	each Date.WeekOfYear([–î–∞—Ç–∞], Day.Monday), 	Int64.Type ), 
			tab_add_col_6 = Table.AddColumn( tab_add_col_5, "–î–µ–Ω—å –Ω–µ–¥–µ–ª–∏", 	each Date.DayOfWeek([–î–∞—Ç–∞], Day.Monday) + 1,Int64.Type )
		in  tab_add_col_6,

	
	fnDateTable2 = // + –ö–∞–ª–µ–Ω–¥–∞—Ä—å —Å —Å–∞–π—Ç–∞ –±—É—Ä–∂—É–π—Å–∫–æ–≥–æ
		// https://forum.enterprisedna.co/t/extended-date-table-power-query-m-function/6390
		[ 
			fnDateTable = 
				( 	StartDate as date, 
					EndDate as date, 
					optional FYStartMonthNum as number, 
					optional Holidays as list, 
					optional WDStartNum as number, 
					optional AddRelativeNetWorkdays as logical 
				) as table =>
				
				let
					FYStartMonth 	= List.Select( {1..12}, each _ = FYStartMonthNum ){0}? ?? 1,
					WDStart 		= List.Select( {0..1}, each _ = WDStartNum ){0}? ?? 0,
					CurrentDate 	= Date.From( DateTime.FixedLocalNow()),
					DayCount 		= Duration.Days( Duration.From( EndDate - StartDate)) +1,
					Source 			= List.Dates( StartDate, DayCount, #duration(1,0,0,0)),
					AddToday 		= if List.Contains(Source, CurrentDate) then Source else List.Combine( {Source, {CurrentDate}}),
					ToTable 		= Table.FromList(AddToday, Splitter.SplitByNothing(), type table [Date = Date.Type] ),
					InsertYear 		= Table.AddColumn(ToTable, "Year", each Date.Year([Date]), type number),
					InsertYearOffset = Table.AddColumn(InsertYear, "CurrYearOffset", each Date.Year([Date]) - Date.Year( Date.From(CurrentDate)), type number),
					InsertCompletedYear = Table.AddColumn(InsertYearOffset, "YearCompleted", each Date.EndOfYear([Date]) < Date.From( Date.EndOfYear(CurrentDate)), type logical),

					InsertQuarterNum		= Table.AddColumn(InsertCompletedYear, 	"Quarter Number", 	each Date.QuarterOfYear([Date]), type number),
					InsertQuarter 			= Table.AddColumn(InsertQuarterNum, 	"Quarter", 			each "Q" & Number.ToText([Quarter Number]), type text),
					InsertStartOfQuarter 	= Table.AddColumn(InsertQuarter,		"Start of Quarter", each Date.StartOfQuarter([Date]), type date),
					InsertEndOfQuarter 		= Table.AddColumn(InsertStartOfQuarter, "End of Quarter", 	each Date.EndOfQuarter([Date]), type date),
					InsertCalendarQtr 		= Table.AddColumn(InsertEndOfQuarter, 	"Quarter & Year", 	each "Q" & Number.ToText( Date.QuarterOfYear([Date])) & Date.ToText([Date], [Format = " yyyy"]), type text),
					InsertQuarternYear 		= Table.AddColumn(InsertCalendarQtr, 	"QuarternYear", 	each [Year] * 10 + [Quarter Number], type number),
					InsertQuarterOffset 	= Table.AddColumn(InsertQuarternYear, 	"CurrQuarterOffset", each ((4 * Date.Year([Date])) +  Date.QuarterOfYear([Date])) - ((4 * Date.Year(Date.From(CurrentDate))) +  Date.QuarterOfYear(Date.From(CurrentDate))), type number),
					InsertCompletedQuarter 	= Table.AddColumn(InsertQuarterOffset, 	"QuarterCompleted", each Date.EndOfQuarter([Date]) < Date.From(Date.EndOfQuarter(CurrentDate)), type logical),

					InsertMonth 		= Table.AddColumn(InsertCompletedQuarter, 	"Month", 			each Date.Month([Date]), type number),
					InsertStartOfMonth 	= Table.AddColumn(InsertMonth, 				"Start of Month", 	each Date.StartOfMonth([Date]), type date),
					InsertEndOfMonth 	= Table.AddColumn(InsertStartOfMonth, 		"End of Month", 	each Date.EndOfMonth([Date]), type date),
					InsertCalendarMonth = Table.AddColumn(InsertEndOfMonth, 		"Month & Year", 	each Text.Proper( Date.ToText([Date], [Format = "MMM yyyy"])), type text),
					InsertMonthnYear	= Table.AddColumn(InsertCalendarMonth , 	"MonthnYear", 		each [Year] * 100 + [Month], type number),
					InsertMonthOffset 	= Table.AddColumn(InsertMonthnYear, 		"CurrMonthOffset", 	each ((12 * Date.Year([Date])) +  Date.Month([Date])) - ((12 * Date.Year(Date.From(CurrentDate))) +  Date.Month(Date.From(CurrentDate))), type number),
					InsertCompletedMonth = Table.AddColumn(InsertMonthOffset, 		"MonthCompleted", 	each Date.EndOfMonth([Date]) < Date.From(Date.EndOfMonth(CurrentDate)), type logical),
					InsertMonthName 	= Table.AddColumn(InsertCompletedMonth, 	"Month Name", 		each Text.Proper( Date.ToText([Date], "MMMM")), type text),
					InsertMonthShort 	= Table.AddColumn( InsertMonthName, 		"Month Short", 		each Text.Proper( Date.ToText([Date], "MMM")), type text),
					InsertMonthInitial 	= Table.AddColumn(InsertMonthShort, 		"Month Initial", 	each Text.Start([Month Name], 1) & Text.Repeat( Character.FromNumber(8203), Date.Month([Date]) ), type text),
					InsertDayOfMonth 	= Table.AddColumn(InsertMonthInitial, 		"Day of Month", 	each Date.Day([Date]), type number),
				
					InsertWeekNumber = Table.AddColumn(InsertDayOfMonth, "Week Number", each
						if Number.RoundDown((Date.DayOfYear([Date])-(Date.DayOfWeek([Date], Day.Monday)+1)+10)/7)=0
						then Number.RoundDown((Date.DayOfYear(#date(Date.Year([Date])-1,12,31))-(Date.DayOfWeek(#date(Date.Year([Date])-1,12,31), Day.Monday)+1)+10)/7)
						else if (Number.RoundDown((Date.DayOfYear([Date])-(Date.DayOfWeek([Date], Day.Monday)+1)+10)/7)=53 and (Date.DayOfWeek(#date(Date.Year([Date]),12,31), Day.Monday)+1<4))
						then 1 else Number.RoundDown((Date.DayOfYear([Date])-(Date.DayOfWeek([Date], Day.Monday)+1)+10)/7), type number),
					InsertStartOfWeek = Table.AddColumn(InsertWeekNumber, "Start of Week", each Date.StartOfWeek([Date], Day.Monday), type date),
					InsertWeekEnding = Table.AddColumn(InsertStartOfWeek, "End of Week", each Date.EndOfWeek( [Date], Day.Monday), type date),
					InsertCalendarWk = Table.AddColumn(InsertWeekEnding, "Week & Year", each "W" & Text.PadStart( Text.From( [Week Number] ), 2, "0") & " " & Text.From(Date.Year( Date.AddDays( Date.StartOfWeek([Date], Day.Monday), 3 ))), type text ),
					InsertWeeknYear = Table.AddColumn(InsertCalendarWk, "WeeknYear", each Date.Year( Date.AddDays( Date.StartOfWeek([Date], Day.Monday), 3 )) * 100 + [Week Number],  Int64.Type),
					InsertWeekOffset = Table.AddColumn(InsertWeeknYear, "CurrWeekOffset", each (Number.From(Date.StartOfWeek([Date], Day.Monday))-Number.From(Date.StartOfWeek(CurrentDate, Day.Monday)))/7, type number),
					InsertCompletedWeek = Table.AddColumn(InsertWeekOffset, "WeekCompleted", each Date.EndOfWeek( [Date], Day.Monday) < Date.From(Date.EndOfWeek(CurrentDate, Day.Monday)), type logical),
				
					InsertDayWeek = Table.AddColumn(InsertCompletedWeek, "Day of Week Number", each Date.DayOfWeek([Date], Day.Monday) + WDStart, Int64.Type),
					InsertDayName = Table.AddColumn(InsertDayWeek, "Day of Week Name", each Text.Proper( Date.ToText([Date], "dddd" )), type text),
					InsertDayInitial = Table.AddColumn(InsertDayName, "Day of Week Initial", each Text.Proper(Text.Start([Day of Week Name], 1)) & Text.Repeat( Character.FromNumber(8203), Date.DayOfWeek([Date], Day.Monday) + WDStart ), type text),
					InsertDayOfYear = Table.AddColumn(InsertDayInitial, "Day of Year", each Date.DayOfYear([Date]), Int64.Type),
					InsertDayInt = Table.AddColumn(InsertDayOfYear, "DateInt", each [Year] * 10000 + [Month] * 100 + [Day of Month], type number),
					InsertDayOffset = Table.AddColumn(InsertDayInt, "CurrDayOffset", each Number.From([Date]) - Number.From(CurrentDate), type number),
					InsertIsAfterToday = Table.AddColumn(InsertDayOffset, "IsAfterToday", each not ([Date] <= Date.From(CurrentDate)), type logical),
					InsertIsWorkingDay = Table.AddColumn(InsertIsAfterToday, "IsWeekDay", each if Date.DayOfWeek([Date], Day.Monday) > 4 then false else true, type logical),
					InsertIsHoliday = Table.AddColumn(InsertIsWorkingDay, "IsHoliday", each if Holidays = null then "Unknown" else List.Contains( Holidays, [Date] ), if Holidays = null then type text else type logical),
					InsertIsBusinessDay = Table.AddColumn(InsertIsHoliday, "IsBusinessDay", each if [IsWeekDay] = true and [IsHoliday] <> true then true else false, type logical),
					InsertDayType = Table.AddColumn(InsertIsBusinessDay, "Day Type", each if [IsHoliday] = true then "Holiday" else if [IsWeekDay] = false then "Weekend" else if [IsWeekDay] = true then "Weekday" else null, type text),

					InsertISOYear    = Table.AddColumn( InsertDayType, 	 "ISO Year", 			each Date.Year( Date.AddDays( Date.StartOfWeek([Date], Day.Monday), 3 )), type number),
					InsertISOqNum    = Table.AddColumn(InsertISOYear, 	 "ISO Quarter Number", 	each if [Week Number] >39 then 4 else if [Week Number] >26 then 3 else if [Week Number] >13 then 2 else 1, Int64.Type),
					InsertISOqtr     = Table.AddColumn(InsertISOqNum, 	 "ISO Quarter", 		each "Q" & Number.ToText([ISO Quarter Number]), type text),
					InsertISOQuarter = Table.AddColumn(InsertISOqtr,     "ISO Quarter & Year", 	each "Q" & Number.ToText([ISO Quarter Number]) & " " & Number.ToText([ISO Year]), type text),
					InsertISOqNy     = Table.AddColumn(InsertISOQuarter, "ISO QuarternYear", 	each [ISO Year] * 10 + [ISO Quarter Number], type number),

					// BufferTable = Table.Buffer(Table.Distinct( InsertISOqNy[[ISO Year], [DateInt]])),
					// InsertISOday = Table.AddColumn(InsertISOqNy, "ISO Day of Year", (OT) => Table.RowCount( Table.SelectRows( BufferTable, (IT) => IT[DateInt] <= OT[DateInt] and IT[ISO Year] = OT[ISO Year])),  Int64.Type),
					AddFY 		= Table.AddColumn(InsertISOqNy, "Fiscal Year", each "FY" & (if [Month] >= FYStartMonth and FYStartMonth >1 then Text.From([Year] +1) else Text.From([Year])), type text),
					//AddFYs = Table.AddColumn(AddFY, "Fiscal Year short", each "FY" & (if [Month] >= FYStartMonth and FYStartMonth >1 then Text.PadEnd( Text.End( Text.From([Year] +1), 2), 2, "0") else Text.End( Text.From([Year]), 2)), type text),
					AddFQ 		= Table.AddColumn(AddFY, "Fiscal Quarter", each "FQ" & Text.From( Number.RoundUp( Date.Month( Date.AddMonths( [Date], - (FYStartMonth -1) )) / 3 )) & " " & (if [Month] >= FYStartMonth and FYStartMonth >1 then Text.From([Year] +1) else Text.From([Year])), type text),
					AddFQnYr 	= Table.AddColumn(AddFQ, "FQuarternYear", each (if [Month] >= FYStartMonth and FYStartMonth >1 then [Year] +1 else [Year]) * 10 + Number.RoundUp( Date.Month( Date.AddMonths( [Date], - (FYStartMonth -1) )) / 3 ), type number),
					AddFM 		= Table.AddColumn(AddFQnYr, "Fiscal Period Number", each if [Month] >= FYStartMonth and FYStartMonth >1 then [Month] - (FYStartMonth-1) else if [Month] >= FYStartMonth and FYStartMonth =1 then [Month] else [Month] + (12-FYStartMonth+1), type number),
					AddFP 		= Table.AddColumn(AddFM, "Fiscal Period", each "FP" & Text.PadStart( Text.From([Fiscal Period Number]), 2, "0") & " " & (if [Month] >= FYStartMonth and FYStartMonth >1 then Text.From([Year] +1) else Text.From([Year])), type text),
					AddFMnYr 	= Table.AddColumn(AddFP , "FPeriodnYear", each (if [Month] >= FYStartMonth and FYStartMonth >1 then [Year] +1 else [Year]) * 100 + [Fiscal Period Number], type number),
					FYCalendarStart = #date( Date.Year(StartDate)-1, FYStartMonth, 1 ),
					InsertFFD 	= Table.AddColumn( AddFMnYr, "FiscalFirstDay", each if [Month] >= FYStartMonth and FYStartMonth >1 then #date( Date.Year([Date])+1, FYStartMonth, 1) else #date( Date.Year([Date]), FYStartMonth, 1), type date ),

					InitTable 	= Table.FromList( List.Transform( {Number.From(FYCalendarStart) .. Number.From(EndDate)}, Date.From), Splitter.SplitByNothing(), type table [DateFW = Date.Type]),
					AddFFD 		= Table.AddColumn( InitTable, "FiscalFirstDay", each if Date.Month([DateFW]) < FYStartMonth then #date(Date.Year([DateFW]), FYStartMonth, 1) else #date(Date.Year([DateFW]) + 1, FYStartMonth, 1)),
					AddFWSD 	= Table.AddColumn( AddFFD, "FWStartDate", each Date.AddYears(Date.StartOfWeek([DateFW], Day.Monday), 1)),
					Group1 		= Table.Group( AddFWSD, {"FiscalFirstDay", "FWStartDate"}, {{"AllRows", each _, type table [DateFW = nullable date, FiscalFirstDay = date, FWStartDate = date]}}),
					Group2 		= Table.Group( Group1, {"FiscalFirstDay"}, {{"AllRows2", each _, type table [FiscalFirstDay = date, FWStartDate = date, AllRows = table]}}),
					AddIndex 	= Table.AddColumn( Group2, "Custom", each Table.AddIndexColumn([AllRows2], "Fiscal Week Number", 1, 1) )[[Custom]],
					ExpandG2 	= Table.ExpandTableColumn( AddIndex, "Custom", {"FiscalFirstDay", "FWStartDate", "AllRows", "Fiscal Week Number"}, {"FiscalFirstDay", "FWStartDate", "AllRows", "Fiscal Week Number"}), 
					ExpandG1 	= Table.ExpandTableColumn( ExpandG2, "AllRows", {"DateFW"}, {"DateFW"} )[[DateFW], [Fiscal Week Number]],
					MergeFYW 	= Table.Join( InsertFFD, {"Date"}, ExpandG1, {"DateFW"}, JoinKind.LeftOuter, JoinAlgorithm.SortMerge ),
					FWlogic 	= List.Contains( {null}, FYStartMonthNum),
					UpdateFYWeek = if FWlogic then Table.ReplaceValue(MergeFYW, each [Fiscal Week Number], each if FYStartMonth =1 then [Week Number] else [Fiscal Week Number], Replacer.ReplaceValue, {"Fiscal Week Number"}) else MergeFYW,
					AddFYW 		= Table.AddColumn( UpdateFYWeek, "Fiscal Week", each if FWlogic then "F" & [#"Week & Year"] else if FYStartMonth =1 then "FW" & Text.PadStart( Text.From([Fiscal Week Number]), 2, "0") & Date.ToText([Date], " yyyy") else if Date.Month([Date]) < FYStartMonth then "FW" & Text.PadStart( Text.From([Fiscal Week Number]), 2, "0") & Date.ToText([Date], " yyyy") else "FW" & Text.PadStart(Text.From([Fiscal Week Number]), 2, "0") & " " & Text.From( Date.Year([Date])+1), type text),
					InsertFWeeknYear = Table.AddColumn(AddFYW, "FWeeknYear", each if FWlogic then [WeeknYear] else (if FYStartMonth =1 then Date.Year([Date]) else if Date.Month([Date]) < FYStartMonth then Date.Year([Date]) else Date.Year([Date])+1) * 100 + [Fiscal Week Number],  Int64.Type),
					
					CurrentDateRecord 		= Table.SelectRows(InsertFWeeknYear, each ([Date] = CurrentDate)),
					CurrentISOyear 			= CurrentDateRecord{0}[ISO Year],
					CurrentISOqtr 			= CurrentDateRecord{0}[ISO Quarter Number],
					CurrentYear 			= CurrentDateRecord{0}[Year],
					CurrentMonth 			= CurrentDateRecord{0}[Month],
					CurrentFiscalFirstDay 	= CurrentDateRecord{0}[FiscalFirstDay],
					PrevFiscalFirstDay 		= Date.AddYears(CurrentFiscalFirstDay, -1),
					CurrentFY 				= CurrentDateRecord{0}[Fiscal Year],
					CurrentFQ 				= CurrentDateRecord{0}[FQuarternYear],
					CurrentFP 				= CurrentDateRecord{0}[FPeriodnYear],
					CurrentFW 				= CurrentDateRecord{0}[FWeeknYear],

					InsertISOYrOffset = Table.AddColumn(InsertFWeeknYear, "ISO CurrYearOffset", each [ISO Year] - CurrentISOyear, type number),
					InsertISOQtrOffset = Table.AddColumn(InsertISOYrOffset, "ISO CurrQuarterOffset", each ((4 * [ISO Year]) +  [ISO Quarter Number]) - ((4 * CurrentISOyear) + CurrentISOqtr), type number),
					InsertFYoffset = Table.AddColumn(InsertISOQtrOffset, "Fiscal CurrYearOffset", each try (if [Month] >= FYStartMonth then [Year]+1 else [Year]) - (if CurrentMonth >= FYStartMonth then CurrentYear+1 else CurrentYear) otherwise null, type number),
					InsertCurrentFY = Table.AddColumn(InsertFYoffset, "IsCurrentFY", each if [Fiscal Year] = CurrentFY then true else false, type logical),
					InsertCurrentFQ = Table.AddColumn(InsertCurrentFY, "IsCurrentFQ", each if [FQuarternYear] = CurrentFQ then true else false, type logical),
					InsertCurrentFP = Table.AddColumn(InsertCurrentFQ, "IsCurrentFP", each if [FPeriodnYear] = CurrentFP then true else false, type logical),
					InsertCurrentFW = Table.AddColumn(InsertCurrentFP, "IsCurrentFW", each if [FWeeknYear] = InsertISOYrOffset then true else false, type logical),
					InsertPYTD = Table.AddColumn(InsertCurrentFW, "IsPYTD", each if CurrentYear-1 = [Year] and [Day of Year] <= CurrentDateRecord{0}[Day of Year] then true else false, type logical),
						ListPrevFYDates = List.Buffer( Table.SelectRows( Table.ExpandTableColumn( Table.NestedJoin(
							Table.AddIndexColumn( Table.RenameColumns( Table.TransformColumnTypes( Table.FromList( List.Dates( PrevFiscalFirstDay, Number.From(CurrentFiscalFirstDay-PrevFiscalFirstDay),#duration(1,0,0,0)), Splitter.SplitByNothing()),{{"Column1", type date}}), {{"Column1", "DateFY"}}), "Index", 1, 1), {"Index"}, 
							Table.AddIndexColumn( Table.RenameColumns( Table.TransformColumnTypes( Table.FromList( List.Dates( Date.AddYears( PrevFiscalFirstDay, -1), Number.From( PrevFiscalFirstDay - Date.AddYears( PrevFiscalFirstDay, -1)),#duration(1,0,0,0)), Splitter.SplitByNothing()),{{"Column1", type date}}), {{"Column1", "DateFY"}}), "Index", 1, 1)
							, {"Index"}, "Table", JoinKind.LeftOuter), "Table", {"DateFY"}, {"PrevDateFY"}), each [DateFY] <= CurrentDate)[PrevDateFY] ),
					InsertPFYTD 		= Table.AddColumn(InsertPYTD, "IsPFYTD", each if [Fiscal CurrYearOffset] = -1 and List.Contains(ListPrevFYDates, [Date] ) then true else false, type logical),
					InsertNetWorkdays 	= if AddRelativeNetWorkdays = true then Table.AddColumn(InsertPFYTD, "Relative Networkdays", each fxNETWORKDAYS( StartDate, [Date], Holidays ), type number ) else InsertPFYTD,
					fxNETWORKDAYS 		= (StartDate, EndDate, optional Holidays as list) =>
						let
							ListOfDates 	= List.Dates( StartDate, Number.From(EndDate-StartDate)+1, Duration.From(1) ),
							DeleteHolidays 	= if Holidays = null then ListOfDates else List.Difference( ListOfDates, List.Transform(Holidays, Date.From )),
							DeleteWeekends 	= List.Select( DeleteHolidays, each Date.DayOfWeek( _, Day.Monday) < 5 ),
							CountDays 		= List.Count( DeleteWeekends)
						in
						CountDays,
					RemoveToday = Table.RemoveColumns( if EndDate < CurrentDate then Table.SelectRows(InsertNetWorkdays, each ([Date] <> CurrentDate)) else InsertNetWorkdays, {"Day of Year", "FiscalFirstDay"}), 
					ChType 		= Table.TransformColumnTypes(RemoveToday,{{"Year", Int64.Type}, {"Quarter Number", Int64.Type}, {"Month", Int64.Type}, {"Day of Month", Int64.Type}, {"DateInt", Int64.Type}, {"Day of Week Number", Int64.Type}, {"ISO CurrYearOffset", Int64.Type}, {"ISO QuarternYear", Int64.Type}, {"ISO CurrQuarterOffset", Int64.Type}, {"Week Number", Int64.Type}, {"WeeknYear", Int64.Type}, {"MonthnYear", Int64.Type}, {"QuarternYear", Int64.Type}, {"FQuarternYear", Int64.Type}, {"Fiscal Period Number", Int64.Type}, {"FPeriodnYear", Int64.Type}, {"CurrWeekOffset", Int64.Type}, {"CurrMonthOffset", Int64.Type}, {"CurrQuarterOffset", Int64.Type}, {"CurrYearOffset", Int64.Type}, {"Fiscal CurrYearOffset", Int64.Type}, {"Fiscal Week Number", Int64.Type}}),
					ReorderCols = Table.ReorderColumns(ChType,{"Date", "Year", "CurrYearOffset", "YearCompleted", "Quarter Number", "Quarter", "Start of Quarter", "End of Quarter", "Quarter & Year", "QuarternYear", "CurrQuarterOffset", "QuarterCompleted", "Month", "Start of Month", "End of Month", "Month & Year", "MonthnYear", "CurrMonthOffset", "MonthCompleted", "Month Name", "Month Short", "Month Initial", "Day of Month", "Week Number", "Start of Week", "End of Week", "Week & Year", "WeeknYear", "CurrWeekOffset", "WeekCompleted", "Day of Week Number", "Day of Week Name", "Day of Week Initial", "DateInt", "CurrDayOffset", "IsAfterToday", "IsWeekDay", "IsHoliday", "IsBusinessDay", "Day Type", "ISO Year", "ISO CurrYearOffset", "ISO Quarter Number", "ISO Quarter", "ISO Quarter & Year", "ISO QuarternYear", "ISO CurrQuarterOffset", "Fiscal Year", "Fiscal CurrYearOffset", "Fiscal Quarter", "FQuarternYear", "Fiscal Period Number", "Fiscal Period", "FPeriodnYear", "DateFW", "Fiscal Week Number", "Fiscal Week", "FWeeknYear", "IsCurrentFY", "IsCurrentFQ", "IsCurrentFP", "IsCurrentFW", "IsPYTD", "IsPFYTD"}),
					ListCols 	= if FWlogic then Table.RemoveColumns(ReorderCols,{"ISO Quarter Number", "Fiscal Year", "Fiscal Quarter", "FQuarternYear", "Fiscal Period Number", "Fiscal Period", "FPeriodnYear", "DateFW", "Fiscal Week Number", "Fiscal Week", "FWeeknYear", "Fiscal CurrYearOffset", "IsCurrentFQ", "IsCurrentFP", "IsCurrentFW"}) else Table.RemoveColumns(ReorderCols,{"Fiscal Period Number", "DateFW", "Fiscal Week Number", "ISO Quarter Number"})
				in  ListCols,
			
			Documentation = 
			[
				Documentation.Name =  			" fxCalendar", 
				Documentation.Description = 	" Date table function to create an ISO-8601 calendar", 
				Documentation.LongDescription = " Date table function to create an ISO-8601 calendar", 
				Documentation.Category = 		" Table", 
				Documentation.Version = 		" 2.02: full code review",
				Documentation.Source = 			" local", 
				Documentation.Author = 			" Melissa de Korte", 
				Documentation.Examples = { 
					[	Description =  " See: https://forum.enterprisedna.co/t/extended-date-table-power-query-m-function/6390", 
						Code = " Optional paramters: #(lf)
							(FYStartMonthNum) Month number the fiscal year starts, Januari if omitted #(lf) 
							(Holidays) Select a query (and column) that contains a list of holiday dates #(lf) 
							(WDStartNum) Switch default weekday numbering from 0-6 to 1-7 by entering a 1 #(lf)
							(AddRelativeNetWorkdays) if true adds a Relative Networkdays column to the date table #(lf)
							#(lf)
							Important to note: #(lf)
							[Fiscal Week] starts on a Monday and can contain less than 7 days in a First- and/or Last Week of a FY #(lf)
							[IsWeekDay] does not take holiday dates into account  #(lf)
							[IsBusinessDay] does take optional holiday dates into account  #(lf)
							[IsPYTD] and [IsPFYTD] compare Previous [Day of Year] with the Current [Day of Year] number, so dates don't align in leap years #(lf)
							IMPORTANT! No Fiscal columns will be added if the (FYStartMonthNum) is omitted", 
						Result = " " 
					] }
			],
				
			result = Value.ReplaceType( fnDateTable, Value.ReplaceMetadata( Value.Type( fnDateTable ), Documentation ))
		] [result],
	
	ISO Calendar = // https://gorilla.bi/power-query/create-iso-week-and-iso-year/
		let
			/*  The following Values are used for computing ISO Weeks */
			FxCurrentThursday = 
				(DateValue as date ) as date => 
					Date.AddDays( DateValue, 3 - Date.DayOfWeek( DateValue, Day.Monday)),
			
			FxFirstThursdayOfYear = 
				(DateValue as date ) as date => [ 
						CurrentThursday		= FxCurrentThursday( DateValue ),
						YearCurrThursday 	= Date.Year( CurrentThursday ),
						FirstThursdayOfYear = Date.AddDays( #date( YearCurrThursday, 1, 7), - Date.DayOfWeek( #date( YearCurrThursday, 1, 1), Day.Friday))
					][FirstThursdayOfYear],
			
			FxIsoYear 		= 
				( DateValue as date ) as number => [
					DaysDifference 	= Duration.Days( FxCurrentThursday(DateValue) - FxFirstThursdayOfYear(DateValue ) ),
					WeekNumber 		= ( DaysDifference / 7 ) + 1,
					ResultYear 		= Date.Year( Date.AddDays( DateValue, 26 - WeekNumber))
				] [ResultYear],
			CurrentIsoYear 	= FxIsoYear( Today ),
			FxIsoWeek 		= 
				( DateValue as date ) as number =>  
					Duration.Days(FxCurrentThursday(DateValue) - FxFirstThursdayOfYear( DateValue )) / 7 + 1,
			CurrentIsoWeek 	= FxIsoWeek( Today ),
			ISOStartYears 	= [ 
					StartYear 		= Date.Year( StartDate ),
					NumberOfYears 	= Date.Year( EndDate) - StartYear +1,
					Years 			=  { 0..NumberOfYears },
					Dates 			= List.Transform( Years, each #date( StartYear + _, 6, 1  ) ),
					ISOStartYears 	= List.Buffer( List.Transform( Dates, each Date.StartOfWeek( FxFirstThursdayOfYear( _ ) ) ) )
				] [ISOStartYears],
			______________________StartCalendar___________ = ISOStartYears,
			
			Today = Date.From(DateTime.LocalNow()),
			fxMultiAdd = (tbl as table, nms as list) as table => List.Accumulate(nms, tbl, (s, c) => Table.AddColumn(s, c{0}, c{1}, c{2}?)),
			
			// Sets the start date for your calendar
			// The calendar runs until the end of the current year. Change this if you need your calendar to run to another date. 
			StartDate 	= #date(2023,1,1 ),
			EndDate   	= Date.EndOfYear(Today) + #duration( 365,0,0,0),
			ListOfDates = List.Dates(StartDate, Duration.Days(EndDate - StartDate) + 1, #duration(1, 0, 0, 0)),
			MyDateTable = Table.FromList(ListOfDates, Splitter.SplitByNothing(), type table[Date = date], null, ExtraValues.Error),
			addColumns 	= fxMultiAdd(MyDateTable,{
				{ "DateAsInteger", 		each Number.From(Date.ToText([Date], "yyyyMMdd")), Int64.Type },
				{ "StartOfWeek", 		each Date.StartOfWeek([Date], Day.Monday), Date.Type },
				{ "EndOfWeek", 			each Date.EndOfWeek([Date]), Date.Type},
				/* Start ISO Calendar Fields. Some of these make use of the functions defined at the start of this query */    
				{ "ISO_Year", 			each FxIsoYear([Date]), Int64.Type},
				{ "ISO_YearLabel", 		each "ISO " & Text.From( [ISO_Year] ), Text.Type},
				{ "ISO_YearDefault", 	each if [ISO_Year] = CurrentIsoYear then "Current" else if [ISO_Year] = (CurrentIsoYear - 1) then "Previous" else [ISO_YearLabel], Text.Type},
				{ "ISO_StartOfYear", 	each Date.StartOfWeek( FxFirstThursdayOfYear([Date] ) ), Date.Type},
				{ "ISO_EndOfYear", 		(x)=> List.First( List.Select( ISOStartYears, each _ > x[ISO_StartOfYear] ) ) - #duration(1,0,0,0), Date.Type},
				{ "ISO_YearRangeLabel", each [ISO_YearLabel] & ": " & Date.ToText( [ISO_StartOfYear], "d MMM yyyy" ) & " - " & Date.ToText( [ISO_EndOfYear], "d MMM yyyy" ), type text },
				{ "ISO_Week", 			each FxIsoWeek([Date]), Int64.Type},
				{ "ISO_WeekLabel", 		each "ISO W" & Text.PadStart( Text.From( [ISO_Week] ), 2, "0" ), Text.Type},
				{ "ISO_WeekRangeLabel", each [ISO_WeekLabel] & ": " & Date.ToText( [StartOfWeek], "d MMM yyyy" ) & " - " & Date.ToText( [EndOfWeek], "d MMM yyyy" ), type text },
				{ "ISO_YearWeekLabel", 	each [ISO_YearLabel] & " W" & Text.PadStart( Text.From( [ISO_Week] ), 2, "0" ), Text.Type},
				{ "ISO_Quarter", 		each Number.RoundUp( List.Min( { [ISO_Week], 52 } ) / 13 ), Int64.Type },
				{ "ISO_QuarterLabel", 	each "ISO Q" & Text.From([ISO_Quarter]), Text.Type},
				{ "ISO_WeekOfQuarter", 	each [ISO_Week] - (( [ISO_Quarter] -1 ) * 13 ), Int64.Type },
				{ "ISO_YearQuarterLabel", each [ISO_YearLabel] & " Q" & Text.From([ISO_Quarter]), Text.Type},
				{ "ISO_YearOffset", 	each [ISO_Year] - CurrentIsoYear, Int64.Type },
				{ "ISO_QuarterOffset", 	each (([ISO_Year] - CurrentIsoYear) * 4) + ([ISO_Quarter] - Number.RoundUp( List.Min( {CurrentIsoWeek, 52} ) / 13)), Int64.Type},
				{ "ISO_TotalWeeks", 	each Number.RoundUp( Duration.Days( [ISO_EndOfYear] - [ISO_StartOfYear] ) / 7 ), Int64.Type },
				{ "ISO_StartOfQuarter", each Date.AddDays( FxFirstThursdayOfYear([Date]), ([ISO_Quarter] - 1) * 13 * 7  - 3 ), type date },
				// To make ISO end of quarter dates for years with 53 weeks show correctly, we use the ISO_EndOfYear calculation
				{ "ISO_EndOfQuarter", 	each if [ISO_Quarter] = 4 then [ISO_EndOfYear] else Date.AddDays( [ISO_StartOfQuarter], 7 * 13 -1 ), type date },
				{ "ISO_DayOfQuarter", 	each Number.From( [Date] - [ISO_StartOfQuarter]  ) +1, Int64.Type },
				{ "ISO_DayOfYear", 		each Number.From( [Date] - [ISO_StartOfYear]  ) +1, Int64.Type },
				{ "ISO_QuarterRangeLabel", each "ISO Q" & Text.From( [ISO_Quarter] ) & ": " & Date.ToText( [ISO_StartOfQuarter], "d MMM yyyy" ) & " - " & Date.ToText( [ISO_EndOfQuarter], "d MMM yyyy" ), type text }
			}),

			// Renames all columns so they have spaces between words. Also removes underscores.
			Rename = 
				Table.TransformColumnNames(addColumns, each 
				[	SplitTextByTransition 	= Splitter.SplitTextByCharacterTransition({"a".."z"}, {"A".."Z"})(_), 
					CombineValues 			= Text.Combine( SplitTextByTransition, " " ), 
					RemoveUnderscores 		= Text.Replace( CombineValues, "_", " ") 
				]  [RemoveUnderscores] )
		in
			Rename,
	myCalendarFunction = // –æ—á–µ–Ω—å –∏–Ω—Ç–µ—Ä–µ—Å–Ω—ã–π –ø–æ–¥—Ö–æ–¥ –∏–Ω–¥–∏–π—Ü–∞ (—Ñ–∞–π–ª —Å —Ç—Ä–∏–∫–∞–º–∏)
		( 	myDate as date, 
			optional myColumns as nullable list, 
			optional cultureCode as nullable text, 
			optional FiscalYearEndMonth as number 
		) as record =>

        let 
            // 1 myDate = #date(2024,1,1),
			// 2 When a user does not provide any columns to return, just return everything
			// 3 Make sure the 'Date' column always returns.
			// 4 By default we use the culture code "en-US" for formatting text values
			Today 		  = Date.From( DateTime.LocalNow()) ,	
            GivenColumns  = myColumns ?? Record.FieldNames( myRecord ),	
            selectColumns = ({"Date"} & List.RemoveItems( GivenColumns, {"Date"} ) ),	
            cultureCode   = cultureCode ?? "en-US",    	

        /* The following record contains the logic that computes each column.
           Since this solutions aims to provide an easy way for users to pick columns, each field in the record receives metadata information about the 'Data Type', 'Description', some 'Examples', a 'Category' and a 'Subcategory'. 
          Later when use these values, the metadata can be used to pass additional information ot our date table */ 

        myRecord = 
            [  
                Date                    = myDate                                                                            meta [Index = 1, Data Type = "Date",            Description = "The original date value",                             Examples = "2025-01-01, 2025-02-15, 2025-12-31", Category = "Date",              Subcategory = "Date"],
                DateAsInteger           = Number.From(Date.ToText(myDate, "yyyyMMdd"))                                      meta [Index = 2, Data Type = "Whole Number",    Description = "The date as an integer in 'yyyyMMdd' format",         Examples = "20250101, 20250215, 20251231",       Category = "Date",              Subcategory = "Date"],
                DateDayFormat           = Date.ToText(myDate,  "ddd, %d MMM yy")                                            meta [Index = 3, Data Type = "Text",            Description = "The date in format of 'ddd %d MMM yy'",               Examples = "Sat, 1 Jul 24, Sat, 2 Jul 24",       Category = "Date",              Subcategory = "Date"],
                Year                    = Date.Year(myDate)                                                                 meta [Index = 4, Data Type = "Whole Number",    Description = "The year part of the date",                           Examples = "2025, 2024, 2023",                   Category = "Year",              Subcategory = "Date Component"],
                YearDefault             = (if Date.IsInCurrentYear( myDate ) then "Current" else 
                                          if Date.IsInPreviousYear( myDate ) then "Previous" else Text.From(Year))          meta [Index = 5, Data Type = "Text",            Description = "Displays 'Current' if the year is this year",         Examples = "2025, Current, Previous, 2022",      Category = "Year",              Subcategory = "Dynamic Current Period"],
                DayOfYearNumber         = Date.DayOfYear(myDate)                                                            meta [Index = 6, Data Type = "Whole Number",    Description = "The day of the year as a number",                     Examples = "1, 46, 365",                         Category = "Day",               Subcategory = "Day Indicator"],
                DayOfMonthNumber        = Date.Day(myDate)                                                                  meta [Index = 7, Data Type = "Whole Number",    Description = "The day of the month as a number",                    Examples = "1, 15, 31",                          Category = "Day",               Subcategory = "Date Component"],
                DayName                 = Date.DayOfWeekName(myDate, cultureCode)                                           meta [Index = 8, Data Type = "Text",            Description = "The full name of the day",                            Examples = "Monday, Tuesday, Wednesday",         Category = "Day",               Subcategory = "Description"],
                DayNameShort            = Date.ToText(myDate, "ddd", cultureCode)                                           meta [Index = 9, Data Type = "Text",            Description = "The abbreviated name of the day",                     Examples = "Mon, Tue, Wed",                      Category = "Day",               Subcategory = "Description"],
                DayInitial              = Text.Start(Date.DayOfWeekName(myDate, cultureCode), 1)                            meta [Index = 10, Data Type = "Text",           Description = "The first letter of the day name",                    Examples = "M, T, W",                            Category = "Day",               Subcategory = "Description"],
                DayOfWeekNumber         = Date.DayOfWeek(myDate, Day.Monday)                                                meta [Index = 11, Data Type = "Whole Number",   Description = "The day of the week as a number (Monday = 0)",        Examples = "0, 1, 2",                            Category = "Day",               Subcategory = "Day Indicator"],
                IsWeekendFlag           = (Date.DayOfWeek(myDate, Day.Monday) >= 5)                                         meta [Index = 12, Data Type = "Boolean",        Description = "Returns 'true' if the date is a weekend",             Examples = "FALSE, TRUE, TRUE",                  Category = "Day",               Subcategory = "Information"],
                IsWeekdayFlag           = (Date.DayOfWeek(myDate, Day.Monday) < 5)                                          meta [Index = 13, Data Type = "Boolean",        Description = "Returns 'true' if the date is a weekday",             Examples = "TRUE, FALSE, FALSE",                 Category = "Day",               Subcategory = "Information"],

                MonthNumber             = Date.Month(myDate)                                                                meta [Index = 14, Data Type = "Whole Number",   Description = "The month part of the date as a number",              Examples = "1, 2, 3",                            Category = "Month",             Subcategory = "Date Component"],
                MonthName               = Date.MonthName(myDate, cultureCode)                                               meta [Index = 15, Data Type = "Text",           Description = "The full name of the month",                          Examples = "January, February, March",           Category = "Month",             Subcategory = "Description"],
                MonthNameShort          = Date.ToText(myDate, "MMM", cultureCode)                                           meta [Index = 17, Data Type = "Text",           Description = "The abbreviated name of the month",                   Examples = "Jan, Feb, Mar",                      Category = "Month",             Subcategory = "Description"],
                MonthInitial            = Text.Start(Date.ToText(myDate, "MMM", cultureCode), 1)                            meta [Index = 18, Data Type = "Text",           Description = "The first letter of the month name",                  Examples = "J, F, M",                            Category = "Month",             Subcategory = "Description"],
                DaysInMonth             = Date.DaysInMonth(myDate)                                                          meta [Index = 19, Data Type = "Whole Number",   Description = "The number of days in the month",                     Examples = "31, 28, 31",                         Category = "Month",             Subcategory = "Information"],
                MonthYearShort          = Date.ToText(myDate, "MMM yyyy", cultureCode)                                      meta [Index = 20, Data Type = "Text",           Description = "Month and year in 'MMM yyyy' format",                 Examples = "Jan 2025, Feb 2025, Mar 2025",       Category = "Month",             Subcategory = "Composite Time Periods"],
                YearMonthNumber         = Date.ToText(myDate, "yyyy-MM")                                                    meta [Index = 21, Data Type = "Text",           Description = "Year and month in 'yyyy-MM' format",                  Examples = "2025-01, 2025-02, 2025-03",          Category = "Month",             Subcategory = "Composite Time Periods"],
                YearMonthShort          = Date.ToText(myDate, "yyyy MMM", cultureCode )                                     meta [Index = 22, Data Type = "Text",           Description = "Year and month in 'yyyy-MMM' format",                 Examples = "2025 Jan, 2025 Feb, 2025 Mar",       Category = "Month",             Subcategory = "Composite Time Periods"]
        ],


        /* ____________________________________________________________________________________________________________________________________
        |   The above record still needs the relevant data types. The below setup helps me define the relevant data types for each value. I have separated the logic, so I can filter on the fields that users require. 
            Later I combine both the record value and record type using the Type.ForRecord function */ 

        myRecordTypeBase =
        [
            Date =                      [ Type = Date.Type,      Optional = false ],
            DateAsInteger =             [ Type = Int64.Type,     Optional = false ],
            DateDayFormat =             [ Type = Text.Type,      Optional = false ],
            
            Year =                      [ Type = Int64.Type,     Optional = false ],
            YearDefault =               [ Type = Text.Type,      Optional = false ],
            DayOfYearNumber =           [ Type = Int64.Type,     Optional = false ],
            DayOfMonthNumber =          [ Type = Int64.Type,     Optional = false ],
            DayName =                   [ Type = Text.Type,      Optional = false ],
            DayNameShort =              [ Type = Text.Type,      Optional = false ],
            DayInitial =                [ Type = Text.Type,      Optional = false ],
            DayOfWeekNumber =           [ Type = Int64.Type,     Optional = false ],
            IsWeekendFlag =             [ Type = Logical.Type,   Optional = false ],
            IsWeekdayFlag =             [ Type = Logical.Type,   Optional = false ],
            
            MonthNumber =               [ Type = Int64.Type,     Optional = false ],
            MonthName =                 [ Type = Text.Type,      Optional = false ],
            MonthNameShort =            [ Type = Text.Type,      Optional = false ],
            MonthInitial =              [ Type = Text.Type,      Optional = false ],
            DaysInMonth =               [ Type = Int64.Type,     Optional = false ],
            MonthYearShort =            [ Type = Text.Type,      Optional = false ],
            YearMonthNumber =           [ Type = Text.Type,      Optional = false ],
            YearMonthShort =            [ Type = Text.Type,      Optional = false ]
        ], 

            // Select only the relevant fields from the record with field name definitions
            mySelectedRecordTypeFields = Record.SelectFields( myRecordTypeBase, selectColumns ),
            myRecordType = Type.ForRecord( mySelectedRecordTypeFields, false ),

            // Select only the relevant field names from the record type definition
            mySelectedRecordFields = Record.SelectFields( myRecord, selectColumns ),

            // Now set the structured data type for record with our value definitions
            myRecordAndType = Value.ReplaceType( mySelectedRecordFields, myRecordType )

        in 
            myRecordAndType,
	–ó–∞–≥–ª—É—à–∫–∞ = 1
	],

Camwally   = [ // https://github.com/camwally/Power-Query/blob/master
	CreateTable  = //! —Ñ–æ—Ä–º–∏—Ä—É–µ—Ç –∫–æ–¥ —Ç–∞–±–ª–∏—Ü—ã –Ω–∞ M –ø–æ –¥–≤–æ–∏—á–Ω–æ–º—É –∫–æ–¥—É Binary.FromText("jVPbas...")
		(InputTable as table) as text =>
		let 
			Source 	 = Table.Schema(InputTable),
			SortRows = Table.Sort(Source,{{"Position", Order.Ascending}}),
			SimplifyTypeNameRec = 
				[
					#"Any.Type" 	 	= "any",
					#"Binary.Type" 	 	= "binary",
					#"Date.Type" 	 	= "date",
					#"DateTime.Type" 	= "datetime",
					#"DateTimeZone.Type" = "datetimezone",
					#"Duration.Type" 	= "duration",
					#"Function.Type" 	= "function",
					#"List.Type" 	 	= "list",
					#"Logical.Type"  	= "logical",
					#"None.Type" 	 	= "none",
					#"Null.Type" 	 	= "null",
					#"Number.Type" 	 	= "number",
					#"Record.Type" 	 	= "record",
					#"Table.Type" 	 	= "table",
					#"Text.Type" 	 	= "text",
					#"Time.Type" 	 	= "time",
					#"Type.Type" 	 	= "type"
				],

			SimplifyTypeNames = 
				Table.TransformColumns(SortRows,
					{{"TypeName", each Record.FieldOrDefault(SimplifyTypeNameRec,_,_), type text}}
				),
			RemoveColumns = Table.SelectColumns(SimplifyTypeNames,{"Name", "TypeName","IsNullable"}),
			AddCustom = 
				Table.AddColumn(
					RemoveColumns, 
					"TypeNames", 
					each 
					Expression.Identifier([Name]) & " = " & (if [IsNullable] then "nullable " else "") & [TypeName]
				),
			
			TableTypeRec =  "[" & Text.Combine(AddCustom[TypeNames], ", ") & "]",

			//Code above is based on a function by Chris Webb
			ValuesToConstant = Table.TransformColumns(InputTable,{},Expression.Constant),
			ValuesToConstLen = Table.TransformColumns(ValuesToConstant,{},Text.Length),
			MaxLengthEachCol = List.Buffer(List.Transform(Table.ToColumns(ValuesToConstLen),List.Max)),
			List = 	List.Transform(
						Table.ToRows(ValuesToConstant),
						(RowAsList)=> 
							let
								Zip 	= List.Zip({RowAsList,MaxLengthEachCol}),
								PadOut 	= List.Transform(Zip,each Function.Invoke(Text.PadEnd,_)),
								CombineValues = "{" & Text.Combine(PadOut,",") & "}"
							in 
								CombineValues
					),
			Body = "{" & Text.Combine(List,",#(lf)") & "}",
			Together =	"#table(type table" 
						& TableTypeRec
						& ",#(lf)"
						& Body
						& "#(lf))"
		in	Together,
	
	CreateTable2 = // –Ω–µ–º–Ω–æ–≥–æ –ø–æ –¥—Ä—É–≥–æ–º—É
		(inputTable as table) as text =>
		let
			source = Table.Schema(inputTable)
			,sortRows = Table.Sort(source,{{"Position", Order.Ascending}})
			,simplifyTypeNameRec = 
					[#"Any.Type" = "any"
					,#"Binary.Type" = "binary"
					,#"Date.Type" = "date"
					,#"DateTime.Type" = "datetime"
					,#"DateTimeZone.Type" = "datetimezone"
					,#"Duration.Type" = "duration"
					,#"Function.Type" = "function"
					,#"List.Type" = "list"
					,#"Logical.Type" = "logical"
					,#"None.Type" = "none"
					,#"Null.Type" = "null"
					,#"Number.Type" = "number"
					,#"Record.Type" = "record"
					,#"Table.Type" = "table"
					,#"Text.Type" = "text"
					,#"Time.Type" = "time"
					,#"Type.Type" = "type"]
			,simplifyTypeNames = Table.TransformColumns(sortRows,{{"TypeName", each Record.FieldOrDefault(simplifyTypeNameRec,_,_)}})
			,selectColumns = Table.SelectColumns(simplifyTypeNames,{"Name", "TypeName","IsNullable"})
			,addColOfTypeNames = 
					Table.AddColumn(
						selectColumns 
					,"TypeNames" 
					,each 
							Expression.Identifier([Name]) 
						& " = " 
						& (if [IsNullable] then "nullable " else "") 
						& [TypeName]
					)
			,tableTypeRec = "[" & Text.Combine(addColOfTypeNames[TypeNames], ", ") & "]" 

			//Code above is based on a function by Chris Webb

			,tableOfExpressions = Table.TransformColumns(inputTable,{},Expression.Constant)
			,listOfCols = Table.ToColumns(tableOfExpressions)
			,listOfColsOfPaddedText = 
					List.Transform(
						listOfCols
					,(col as list)=>
							let 
								buf = List.Buffer(col),
								maxTextLength = List.Max(List.Transform(buf,Text.Length)),
								paddedText = List.Transform(buf,each Text.PadEnd(_,maxTextLength))
							in
								paddedText
					)
			,listOfRowsOfPaddedText = List.Zip(listOfColsOfPaddedText)
			,bodyAsList = List.Transform(listOfRowsOfPaddedText, (row as list)=> "{"&Text.Combine(row,",")&"}")
			,bodyAsText = "{"&Text.Combine(bodyAsList,"#(lf),")&"#(lf)}"
			,together =   "#table(type table " 
						& tableTypeRec
						& ",#(lf)"
						& bodyAsText
						& ")"
		in together,
	
	CreateTable3 = // –Ω–µ–º–Ω–æ–≥–æ –ø–æ –¥—Ä—É–≥–æ–º—É + –∞—Ä–≥—É–º–µ–Ω—Ç –≤—Ç–æ—Ä–æ–π
		(inputTable as table, optional #"table type is vertical?" as nullable logical) as text =>
		let	
			vert = #"table type is vertical?" ?? false 
			,source = Table.Schema(inputTable)
			,sortRows = Table.Sort(source,{{"Position", Order.Ascending}})
			,simplifyTypeNameRec = 
				[#"Any.Type" = "any"
				,#"Binary.Type" = "binary"
				,#"Date.Type" = "date"
				,#"DateTime.Type" = "datetime"
				,#"DateTimeZone.Type" = "datetimezone"
				,#"Duration.Type" = "duration"
				,#"Function.Type" = "function"
				,#"List.Type" = "list"
				,#"Logical.Type" = "logical"
				,#"None.Type" = "none"
				,#"Null.Type" = "null"
				,#"Number.Type" = "number"
				,#"Record.Type" = "record"
				,#"Table.Type" = "table"
				,#"Text.Type" = "text"
				,#"Time.Type" = "time"
				,#"Type.Type" = "type"]
			,simplifyTypeNames = Table.TransformColumns(sortRows,{{"TypeName", each Record.FieldOrDefault(simplifyTypeNameRec,_,_)}})
			,selectColumns = Table.SelectColumns(simplifyTypeNames,{"Name", "TypeName","IsNullable"})
			,addColOfTypeNames = 
				Table.AddColumn(
						selectColumns 
					,"TypeNames" 
					,each 
							Expression.Identifier([Name]) 
							& " = " 
							& (if [IsNullable] then "nullable " else "") 
							& [TypeName]
				)
			,tableTypeRec = "[" & Text.Combine(addColOfTypeNames[TypeNames], if vert then "#(lf)," else ", ") & "]" 

			//Code above is based on a function by Chris Webb

			,tableOfExpressions = Table.TransformColumns(inputTable,{},Expression.Constant)
			,listOfCols = Table.ToColumns(tableOfExpressions)
			,listOfColsOfPaddedText = 
				List.Transform(
						listOfCols
					,(col as list)=>
					let 
							buf = List.Buffer(col),
							maxTextLength = List.Max(List.Transform(buf,Text.Length)),
							paddedText = List.Transform(buf,each Text.PadEnd(_,maxTextLength))
						in
							paddedText
				)
				,listOfRowsOfPaddedText = List.Zip(listOfColsOfPaddedText)
				,bodyAsList = List.Transform(listOfRowsOfPaddedText, (row as list)=> "{"&Text.Combine(row,",")&"}")
				,bodyAsText = "{"&Text.Combine(bodyAsList,"#(lf),")&"#(lf)}"
				,together =  
						"#table(type table"
					& (if vert then "#(lf)" else "")
					& tableTypeRec
					& ",#(lf)"
					& bodyAsText
					& ")"
		in	together,
	
	Table.ToRecordOfLists 	= 
		(table as table, optional buffer as nullable logical)=>
			let
				tab    = if buffer = true then Table.Buffer(table) else table,
				Name   = Table.ColumnNames(tab),
				Value  = Table.ToColumns(tab),
				Record = Record.FromTable(Table.FromColumns({Name, Value},{"Name","Value"}))
			in
				Record,

	Table.FromRecordOfLists = 
		(rec as record)=>
			let
				tab2col = Record.ToTable(rec),
				valuess_names = List.Reverse(Table.ToColumns(tab2col)),
				tab = Function.Invoke(Table.FromColumns, valuess_names)
			in
				tab,

	fClusteredIndex 	= 
		(Table as table, GroupOnCols as list) => 
			let
				Group = Table.Group(
							Table, 
							GroupOnCols, 
							{"ColumnOfTables",each Table.AddIndexColumn(_, "ClustIndex", 0, 1)}
						),
				Combine = Table.Combine(Group[ColumnOfTables])
			in
				Combine,
	
	fCombineJoins 		= 
		(	LeftTable as table, 	LeftKey as list,
			RightTable as table,	RightKey as list,
			ListOfJoins as list
		) =>
			let
				Func = each Table.NestedJoin(LeftTable, LeftKey, RightTable, RightKey,"Right",_),
				ListOfTables = List.Transform(ListOfJoins, Func),
				Combine = Table.Combine(ListOfTables)
			in
				Combine,
	
	fDistinctColumns 	= 
		/* 	–≠—Ç–∏ —Ñ—É–Ω–∫—Ü–∏–∏ –≤ –æ—Å–Ω–æ–≤–Ω–æ–º –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è—é—Ç —Å–æ–±–æ–π –≤–µ—Ä—Å–∏–∏ —Ñ—É–Ω–∫—Ü–∏–π, —Å–æ–∑–¥–∞–Ω–Ω—ã—Ö Microsoft. 
			–û–¥–Ω–∞–∫–æ —ç—Ç–∏ —Ñ—É–Ω–∫—Ü–∏–∏ –ø–æ–º–æ–≥–∞—é—Ç —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å –≤–æ–∑–≤—Ä–∞—â–∞–µ–º—ã–µ —Ç–∏–ø—ã —Ñ—É–Ω–∫—Ü–∏–π, –∫–æ—Ç–æ—Ä—ã–µ —Ç–∞–∫ –ª–µ–≥–∫–æ —Ç–µ—Ä—è—é—Ç—Å—è. 
			–û–¥–Ω–∏–º –∏–∑ –ø—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∏—Ö —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è —ç—Ç–∏—Ö —Ñ—É–Ω–∫—Ü–∏–π –≤ –≤–∞—à–∏—Ö –∑–∞–ø—Ä–æ—Å–∞—Ö —è–≤–ª—è–µ—Ç—Å—è —Ç–æ, 
			—á—Ç–æ —Å—Ç–æ–ª–±—Ü—ã –≤–∞—à–µ–π —Ç–∞–±–ª–∏—Ü—ã —Å –º–µ–Ω—å—à–µ–π –≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å—é –∏–∑–º–µ–Ω—è—Ç—Å—è –Ω–∞ –∫–∞–∫–æ–π-–ª–∏–±–æ —Ç–∏–ø  */

		(Table as table, optional MaxLength as number)=>
			let
				TableType 	= Value.Type(Table),
				ColNames 	= Table.ColumnNames(Table),
				ListOfCols 	= List.Transform(Table.ToColumns(Table), List.Distinct),
				Meta 		= List.Transform(List.Zip({ListOfCols,ColNames}), each _{0} meta [ColName = _{1}]),
				SelectList 	= List.Buffer(if MaxLength = null then Meta else List.Select(Meta, each List.Count(_)<=MaxLength)),
				NewColNames = List.Transform(SelectList, each Value.Metadata(_)[ColName]),
				NewTable 	= Table.FromColumns(SelectList,NewColNames)
			in
				NewTable,

	ReplaceUsingTable 	= // –∑–∞–º–µ–Ω–∞ –ø–æ —Å–ª–æ–≤–∞—Ä—é, –Ω–æ —á—Ç–æ —Ç–æ –Ω–µ —Ç–æ. –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –Ω–∞ –ø—Ä–∏–º–µ—Ä–∞—Ö
		/*
			—Ñ—É–Ω–∫—Ü–∏—è —Å–æ–∑–¥–∞–µ—Ç –º–µ—Ö–∞–Ω–∏–∑–º –∑–∞–º–µ–Ω—ã –∑–Ω–∞—á–µ–Ω–∏–π –Ω–∞ –æ—Å–Ω–æ–≤–µ –ø–µ—Ä–µ–¥–∞–Ω–Ω–æ–π —Ç–∞–±–ª–∏—Ü—ã, 
			–ø–æ–∑–≤–æ–ª—è—è –∑–∞–º–µ–Ω—è—Ç—å –∑–Ω–∞—á–µ–Ω–∏—è –ø–æ –∫–ª—é—á–∞–º –∏–∑ –ø–µ—Ä–≤–æ–≥–æ —Å—Ç–æ–ª–±—Ü–∞ —Ç–∞–±–ª–∏—Ü—ã

			–ü—Ä–∏–Ω–∏–º–∞–µ—Ç —Ç–∞–±–ª–∏—Ü—É: 
				–§—É–Ω–∫—Ü–∏—è –ø—Ä–∏–Ω–∏–º–∞–µ—Ç –ø–∞—Ä–∞–º–µ—Ç—Ä Table
			–°–æ–∑–¥–∞–Ω–∏–µ –∑–∞–ø–∏—Å–∏:
				Table.ToColumns(Table) 	–∏–∑–≤–ª–µ–∫–∞–µ—Ç –≤—Å–µ —Å—Ç–æ–ª–±—Ü—ã –∏–∑ —Ç–∞–±–ª–∏—Ü—ã.
				List.FirstN(..., 2) 	–±–µ—Ä—ë—Ç –ø–µ—Ä–≤—ã–µ –¥–≤–∞ —Å—Ç–æ–ª–±—Ü–∞ –∏–∑ —ç—Ç–æ–π —Ç–∞–±–ª–∏—Ü—ã.
				Table.FromColumns(...) 	—Å–æ–∑–¥–∞–µ—Ç –Ω–æ–≤—É—é —Ç–∞–±–ª–∏—Ü—É –∏–∑ –¥–≤—É—Ö –ø–µ—Ä–≤—ã—Ö —Å—Ç–æ–ª–±—Ü–æ–≤ —Å –∏–º–µ–Ω–∞–º–∏ "Name" –∏ "Value".
				Record.FromTable(...) 	–ø—Ä–µ–æ–±—Ä–∞–∑—É–µ—Ç —ç—Ç—É –Ω–æ–≤—É—é —Ç–∞–±–ª–∏—Ü—É –≤ –∑–∞–ø–∏—Å—å Rec, –≥–¥–µ –∫–ª—é—á–∞–º–∏ —è–≤–ª—è—é—Ç—Å—è –∑–Ω–∞—á–µ–Ω–∏—è 
										–∏–∑ –ø–µ—Ä–≤–æ–≥–æ —Å—Ç–æ–ª–±—Ü–∞ ("Name"), –∞ –∑–Ω–∞—á–µ–Ω–∏—è–º–∏ –∏–∑ –≤—Ç–æ—Ä–æ–≥–æ —Å—Ç–æ–ª–±—Ü–∞ ("Value").
			–í–æ–∑–≤—Ä–∞—â–∞–µ–º–∞—è —Ñ—É–Ω–∫—Ü–∏—è:
				–í–ª–æ–∂–µ–Ω–Ω–∞—è –∞–Ω–æ–Ω–∏–º–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –ø—Ä–∏–Ω–∏–º–∞–µ—Ç —Å—Ç—Ä–æ–∫—É Text –≤ –∫–∞—á–µ—Å—Ç–≤–µ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞.
				–ï—Å–ª–∏ Text —Ä–∞–≤–µ–Ω null, —Ñ—É–Ω–∫—Ü–∏—è –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç null.
				–í –ø—Ä–æ—Ç–∏–≤–Ω–æ–º —Å–ª—É—á–∞–µ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è Record.FieldOrDefault(Rec, Text, Text) –¥–ª—è –∏–∑–≤–ª–µ—á–µ–Ω–∏—è –∑–Ω–∞—á–µ–Ω–∏—è 
				–∏–∑ –∑–∞–ø–∏—Å–∏ Rec –ø–æ –∫–ª—é—á—É Text. –ï—Å–ª–∏ –∫–ª—é—á –Ω–µ –Ω–∞–π–¥–µ–Ω, –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç—Å—è —Å–∞–º Text.
		*/
		
		(Table as table)=>
			let 
				Rec = Record.FromTable(
						Table.FromColumns(
							List.FirstN(Table.ToColumns(Table),2),
							{"Name","Value"})
						)
			in 
				(Text as text)=> 
					if   Text = null 
					then null 
					else Record.FieldOrDefault(Rec,Text,Text),

	MultipleCombineColumnsRecord = // –∏–∑—É—á–∏—Ç—å, –∏–Ω—Ç–µ—Ä–µ—Å–Ω–æ
		/* 
		Example Control Table
			#table(
				type table [_Name = nullable text, Value = nullable number, Flag = nullable text],
				{
					{"Temperature Min"     ,"Temperature Min"     ,"Temperature Min Flag"     },
					{"Temperature Mean"    ,"Temperature Mean"    ,"Temperature Mean Flag"    },
					{"Temperature Max"     ,"Temperature Max"     ,"Temperature Max Flag"     },
					{"Precipitation Liquid","Precipitation Liquid","Precipitation Liquid Flag"},
					{"Precipitation Solid" ,"Precipitation Solid" ,"Precipitation Solid Flag" }
				}
			)
		*/

		(table as table, controlTable as table)=>
			let
				RecType 	  = Type.TableRow(Value.Type(Table.RemoveColumns(controlTable,"_Name"))),
				RecFieldNames = List.Buffer(Record.FieldNames(Type.RecordFields(RecType))),
				ControlVals   = 
					List.Transform(
						Table.ToRows(controlTable),
						each [ColName = _{0}, OriginalRecFieldNames = List.Skip(_)]
					),

				Next = 	
					List.Accumulate(
						ControlVals,
						table,
						(tab,cv)=>
							let	RenameCols  = Table.RenameColumns(tab,List.Zip({cv[OriginalRecFieldNames],RecFieldNames})),
								CombineCols = Table.CombineColumnsToRecord(RenameCols,cv[ColName],RecFieldNames)
							in	CombineCols
					)
			in
				Next,

	MonthlyRatios 	= // –≤ –¥–æ–ø—Å—Ç–æ–ª–±—Ü–µ % –æ—Ç –æ–±—â–µ–≥–æ —á–∏—Å–ª–∞ –¥–Ω–µ–π –≤ –∫–∞–∂–¥–æ–º –º–µ—Å—è—Ü–µ
		// –≤ –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ–º —Å—Ç–æ–ª–±—Ü–µ % –æ—Ç –æ–±—â–µ–≥–æ —á–∏—Å–ª–∞ –¥–Ω–µ–π –≤ –∫–∞–∂–¥–æ–º –º–µ—Å—è—Ü–µ (15-–µ —á–∏—Å–ª–æ –±—É–¥–µ—Ç = 50% –æ—Ç —á–∏—Å–ª–∞ –¥–Ω–µ–π)
		(start as date, end as date)=>
		let
			datesAsInt =  // —Å–ø–∏—Å–æ–∫ —Ü–µ–ª—ã—Ö –Ω–æ–º–µ—Ä–æ–≤ –º–µ—Å—è—Ü–µ–≤ –æ—Ç —Å–∞–º–æ–≥–æ –Ω–∞—á–∞–ª–∞ 
				let DateToInt = each Date.Year(_) * 12 + Date.Month(_) - 1 
				in 	{DateToInt(start)..DateToInt(end)},
			
			datesAsDate = 
				List.Buffer(
					Value.ReplaceType(
						List.Transform(
							datesAsInt, 
							each #date(Number.RoundDown(_/12), Number.Mod(_,12)+1,1)
						)
					, type {date}
					)
				),

			FracOfMonthToEnd            = (date as date) => Date.Day(date)/Date.DaysInMonth(date),
			FracOfMonthToDayBeforeStart = (date as date) => (Date.Day(date)-1)/Date.DaysInMonth(date),
			noOfDates = List.Count(datesAsDate),
			fracsOfMonths = 
				Value.ReplaceType(
					if start>end 
					then error "end date before start date" 
					else if noOfDates = 1 
							then 	{FracOfMonthToEnd(end)-FracOfMonthToDayBeforeStart(start)} 
							else 	{1-FracOfMonthToDayBeforeStart(start)}
								& List.Repeat({1},noOfDates-2)
								& {FracOfMonthToEnd(end)},
					type {Percentage.Type}
				),
			datesInTable = Table.FromColumns({datesAsDate, fracsOfMonths},{"Date","Fraction"}),
			addKey = Table.AddKey(datesInTable,{"Date"},true)
		in
			addKey,

	RunningTotal	= // —Ñ—É–Ω–∫—Ü–∏—è —Å–æ–∑–¥–∞–µ—Ç –Ω–æ–≤—ã–π —Å—Ç–æ–ª–±–µ—Ü —Å –Ω–∞–∫–æ–ø–∏—Ç–µ–ª—å–Ω–æ–π —Å—É–º–º–æ–π –¥–ª—è –∑–Ω–∞—á–µ–Ω–∏–π –≤ —É–∫–∞–∑–∞–Ω–Ω–æ–º —Å—Ç–æ–ª–±—Ü–µ —Ç–∞–±–ª–∏—Ü—ã
		// –Ω–µ –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å null –≤ —Å—Ç–æ–ª–±—Ü–µ
		(table as table, colToSum as text, colAsNew as text)=>
			let
				tableB 			= Table.Buffer(table),
				listToSum 		= List.Buffer(Table.Column(tableB,colToSum)),
				listToSumCount 	= List.Count(listToSum),
				runningTotalB 	= List.Buffer(List.Skip(
					List.Generate(
						()=> [item = 0, counter = 0],
						each [counter] <= listToSumCount,
						each [item    = [item]+listToSum{[counter]},
							  counter = [counter]+1],
						each [item]
					),1)),

				addIndex 		= Table.AddIndexColumn(tableB,"IndexUniqueName",0,1),
				addRunningTotal = Table.AddColumn(addIndex,colAsNew,each runningTotalB{[IndexUniqueName]}, type number),
				removeIndex 	= Table.RemoveColumns(addRunningTotal,{"IndexUniqueName"})
			in
				removeIndex,
	TextCleaner   	= // —Ñ—É–Ω–∫—Ü–∏—è —Å–ª—É–∂–∏—Ç –¥–ª—è –æ—á–∏—Å—Ç–∫–∏ —Ç–µ–∫—Å—Ç–∞ –æ—Ç –ª–∏—à–Ω–∏—Ö –ø—Ä–æ–±–µ–ª–æ–≤, –æ—Å—Ç–∞–≤–ª—è—è —Ç–æ–ª—å–∫–æ –æ–¥–∏–Ω –ø—Ä–æ–±–µ–ª –º–µ–∂–¥—É —Å–ª–æ–≤–∞–º–∏
		(text as nullable text) as nullable text =>
			let
				Space = Character.FromNumber(32),
				Words = Text.Split(text,Space) as list,
				GetRidOfWhitespace = (word as text) as text => Text.Combine(Splitter.SplitTextByWhitespace()(word)),
				Combined = Text.Combine(List.Transform(Words,GetRidOfWhitespace),Space)
			in
				if text is null 
				then null 
				else Combined,

	PrefixAllColsExcept = 
		(Table as table, Prefix as text, optional IgnoreCols as any) =>   
		let
			listIgnoreCols = 
				if IgnoreCols is list then IgnoreCols else
				if IgnoreCols is text then {IgnoreCols} else
				if IgnoreCols is null then {} else
				error "Invalid IgnoreCols Argument",

			ColNamesToChange = List.RemoveItems(Table.ColumnNames(Table), listIgnoreCols),
			ListOfLists 	 = List.Transform(ColNamesToChange, each {_, Prefix & _}),
			RenameCols  	 = Table.RenameColumns(Table,ListOfLists)
		in
			RenameCols,

	PrefixCols = // —É—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –ø—Ä–µ—Ñ–∏–∫—Å—ã –≤ —Å–ø–∏—Å–æ–∫ –∫–æ–ª–æ–Ω–æ–∫ 
		(Table as table, Prefix as text, Cols as list) =>   
			let
				ListOfLists = List.Transform(Cols, each {_, Prefix & _}),
				RenameCols  = Table.RenameColumns(Table, ListOfLists)
			in
				RenameCols,
		
	Logical_to_Display_SQL_to_M	= //! –æ—à–∏–±–∫–∞ —Ç—É—Ç 
		let
			Source = #table({},{}),	// –Ω–∞–¥–æ Source = SQL
			#"Added custom 5" 		= Table.AddColumn(Source, "Column Display Name if change", each if [Column Logical Name] = [Column Display Name] then null else [Column Display Name], type text),
			#"Added custom" 		= Table.AddColumn(#"Added custom 5", "Column Logical Name With Name Suffix", each _[Column Logical Name]&"name", type nullable text),
			#"Self Join" 			= Table.NestedJoin(#"Added custom",{"Table Logical Name","Column Logical Name With Name Suffix"},#"Added custom",{"Table Logical Name","Column Logical Name"},"Text Col",JoinKind.LeftOuter),
			#"Expanded Text Col 1" 	= Table.ExpandTableColumn(#"Self Join", "Text Col", {"Column Display Name if change"}, {"Column Display Name of Text Version"}),
			#"Removed columns 3" 	= Table.RemoveColumns(#"Expanded Text Col 1", {"Column Logical Name With Name Suffix"}),
			#"Sorted rows 1" 		= Table.Sort(#"Removed columns 3", {{"Column Id", Order.Ascending}}),
			#"Added custom 2" 		= Table.AddColumn(#"Sorted rows 1", "Make Unique", each [Column Display Name of Text Version] & " " & Record.FieldOrDefault([#"uniqueidentifier"="GUID",#"int"="ID",#"bit"="True/False"],[Column Type Name]), type nullable text), 
			#"Removed columns 1" 	= Table.RemoveColumns(#"Added custom 2", {"Column Display Name of Text Version"}),
			#"Added custom 6" 		= Table.AddColumn(#"Removed columns 1", "Status Columns", each Record.FieldOrDefault([statecode = "Status ID",statecodename = "Status",statuscode = "Status Reason ID",statuscodename = "Status Reason"],[Column Logical Name]), type nullable text),
			#"Added custom 3" 		= Table.AddColumn(#"Added custom 6", "Project ID Names", each if [Is First Primary Key] = true then [Table Display Name] & " GUID" else if [Column Display Name] = "Name" then [Table Display Name] else null, type nullable text),
			#"Renamed columns" 		= Table.RenameColumns(#"Added custom 3", {{"Column Display Name", "Column Display Name Original"}}),
			#"Added custom 1" 		= Table.AddColumn(#"Renamed columns", "Column Display Name", each [Project ID Names] ?? [Status Columns] ?? [Make Unique] ?? [Column Display Name if change], type nullable text),
			#"Removed columns 2"   	= Table.RemoveColumns(#"Added custom 1", {"Column Display Name if change", "Make Unique", "Status Columns", "Project ID Names", "Is First Primary Key"}),
			#"Reordered columns 2" 	= Table.ReorderColumns(#"Removed columns 2", {"Table Logical Name", "Table Display Name", "Column Logical Name", "Column Display Name Original", "Column Display Name", "Column Id", "Column Type Name", "Column Max Length"}),
			ColumnType = 
				type nullable table
					[ 	
						#"Table Logical Name" = nullable text,
						#"Table Display Name" = nullable text,
						#"Column Logical Name" = nullable text,
						#"Column Display Name Original" = nullable text,
						#"Column Display Name" = nullable text,
						#"Column Id" = nullable Int64.Type,
						#"Column Type Name" = nullable text,
						#"Column Max Length" = nullable Int64.Type
					], 
			#"Grouped rows" 		= Table.Group(#"Reordered columns 2", {"Table Logical Name", "Column Display Name"}, {{"Column Display Name Count", each Table.RowCount(_), Int64.Type}, {"Table", each _, ColumnType}}),
			#"Expanded Table" 		= Table.ExpandTableColumn(#"Grouped rows", "Table", {"Table Display Name", "Column Logical Name", "Column Display Name Original", "Column Id", "Column Type Name", "Column Max Length"}, {"Table Display Name", "Column Logical Name", "Column Display Name Original", "Column Id", "Column Type Name", "Column Max Length"}),
			#"Reordered columns" 	= Table.ReorderColumns(#"Expanded Table", {"Table Logical Name", "Table Display Name", "Column Logical Name", "Column Display Name Original", "Column Display Name", "Column Id", "Column Type Name", "Column Max Length","Column Display Name Count"}),
			#"Added custom 4" 		= Table.AddColumn(#"Reordered columns", "Custom", each let val = [Column Display Name] in if val = null then null else if [Column Display Name Count] > 1 then val & " (" & [Column Logical Name] & ")" else val, type nullable text),
			#"Reordered columns 1" 	= Table.ReorderColumns(#"Added custom 4", {"Custom", "Column Display Name"}),
			#"Removed columns" 		= Table.RemoveColumns(#"Reordered columns 1", {"Column Display Name", "Column Display Name Count"}),
			#"Renamed columns 1" 	= Table.RenameColumns(#"Removed columns", {{"Custom", "Column Display Name"}}),
			#"Sorted rows" 			= Table.Sort(#"Renamed columns 1", {{"Table Logical Name", Order.Ascending}, {"Column Id", Order.Ascending}})
		in
			#"Sorted rows",

	fStableSortAndOrderFirstOccurrence = //! –ø–æ–≤—Ç–æ—Ä, —Å–º –ø–æ GroupKind.Local, Comparer
		/*	It's a bit like Table.Sort, but:
				1) Sorts are stable
				2) If you neglect to put a Order.Ascending or a Order.Descending then ordered by first occurrence 
		*/
				
		(Table as table, List as list) =>
			let
				fMakeEfficientList = (List as list) =>
					let 
						ColName 	= List.Transform(List, each _{0}),
						Order 		= List.Transform(List, each _{1}?),
						TableForm 	= Table.FromColumns({ColName,Order},{"ColName","Order"}),
						Comparer 	= (a as record, b as record) => Number.From(a[Order] is null or b[Order] is null),
						PartionedTable = Table.Group(TableForm, {"Order"}, {{"NestedLists", each Table.ToRows(_), type list}},GroupKind.Local, Comparer),
						PartionedList = PartionedTable[NestedLists]
					in
						PartionedList,

				fReorder = (Table as table, List as list) =>
					let
						ListItem 		 = List.Buffer(List{0}) ,
						ListItemColNames = List.Buffer(List.Zip(ListItem){0}),
						GroupedTable 	 = Table.Group(Table, ListItemColNames, {{"NestedTables", each Table.RemoveColumns(_,ListItemColNames), type table}}),
						SortedTable 	 = if ListItem{0}{1} = null then GroupedTable else Table.Sort(GroupedTable,ListItem),
						fRecursion 	 	 = each if List.Count(List) > 1 then @fReorder(_, List.Skip(List)) else _,
						RecurseOnNestedTables = Table.Buffer(Table.TransformColumns(SortedTable, {"NestedTables", fRecursion})),
						Expand = Table.ExpandTableColumn(RecurseOnNestedTables, "NestedTables", Table.ColumnNames(RecurseOnNestedTables[NestedTables]{0}))
					in
						Expand,
					
				EfficientList 	= List.Buffer(fMakeEfficientList(List)),
				ReorderRows 	= fReorder(Table,EfficientList),
				ReclaimColOrder = Table.ReorderColumns(ReorderRows,Table.ColumnNames(Table)),
				ReclaimColTypes = Value.ReplaceType(ReclaimColOrder,Value.Type(Table))
			in
				ReclaimColTypes,
		
	fSyncTableTypeOfCol = 
		/*
			–ü—Ä–∏—Å–≤–∞–∏–≤–∞–µ—Ç —Ç–∏–ø —Å—Ç–æ–ª–±—Ü—É –Ω–∞ –æ—Å–Ω–æ–≤–µ –ø–µ—Ä–≤–æ–π —Ç–∞–±–ª–∏—Ü—ã –≤ —Å—Ç–æ–ª–±—Ü–µ –∫–∞–∫ 
			Table.TransformColumnTypes, –Ω–æ –Ω–µ —Ä–∞–±–æ—Ç–∞–µ—Ç —Å–æ —Å–ª–æ–∂–Ω—ã–º–∏ —Ç–∏–ø–∞–º–∏. –ù–∞–ø—Ä–∏–º–µ—Ä: type table[A=text, B=number]

			https://social.technet.microsoft.com/Forums/en-US/636e9b44-6820-4ff2-ab60-5dd6a5307bd2/type-conversion-mysteries
		*/
		(PreviousStep as table, ColName as text) =>
			Table.TransformColumns(
				PreviousStep, 
				{ColName, each {_}{0}, Value.Type(Table.Column(PreviousStep, ColName){0})}
			),
		
	fTableComparerSort 	= 
		//https://www.dingbatdata.com/2018/06/07/multilevel-sorting-comparers/
		//https://www.dingbatdata.com/2018/05/31/documentationsortcomparer/
		//Works like a Table.Sort, but also allows sorting using a comparer at the column level. 
		//One use of this is for culture sensitive sorting. 

		(	Table as table,
			comparisonCriteria as any,
			optional defaultcomparisonCriteria as any) =>
		let
			fMakeSureIsList = each if _ is list then _ else {_},
			
			Default =
				let
					List = 	fMakeSureIsList(defaultcomparisonCriteria),
					Sort = 	
						if  List{0} is number then List{0} else
						if (List{0} is null or List{0} is function) then Order.Ascending else 
						error "invalid defaultcomparisonCriteria",

					Comparer = 
						if List{0} is function then List{0} else 
						if List{1}? is function then List{1} else 
						if List{1}? is null then Value.Compare else 
						error "invalid defaultcomparisonCriteria",

					Record = [Sort = Sort, Comparer = Comparer]
				in
					Record,

			compCritListRecords = 
				let
					FirstCheck = 
						if 		Value.Type(comparisonCriteria{0}?) = type text 
							and Value.Type(comparisonCriteria{1}?) = type number 
						then {comparisonCriteria} 
						else comparisonCriteria,

					List 	 =  fMakeSureIsList(FirstCheck),
					ListList = List.Transform(List, fMakeSureIsList),
					
					fSort 	 = (Order) => 
						if Order = Order.Ascending  then 1 else 
						if Order = Order.Descending then -1 else 
						error "Order must be Order.Ascending or Order.Descending",

					ListRec =  
						List.Transform(ListList,
							each 
								let 
									ColNam = _{0} as text,
									Order  = _{1}? as nullable number,
									Comp   = _{2}? as nullable function
								in 
									[	
										ColNam = ColNam,
										Order  = fSort(if Order = null then Default[Sort] else Order),
										Comp   = if Comp = null then Default[Comparer] else Comp 
									]
						)
				in
					List.Buffer(ListRec as list),
						
			fComparer = (x as record, y as record) =>
				let 
					fFullCompare = (x,y, compCrit) => 
						let 
							cC = compCrit{0},
							comparison = cC[Comp](Record.Field(x,cC[ColNam]),Record.Field(y,cC[ColNam])),
							comparisonAllCols = 
								if comparison = 0 and List.Count(compCrit)>1 
								then @fFullCompare(x,y,List.Skip(compCrit)) 
								else comparison *cC[Order]
						in
							comparisonAllCols,
					
					CompareRec = fFullCompare(x,y,compCritListRecords)
				in
					CompareRec,

				Execute = Table.Sort(Table, fComparer)        
		in
			Execute,

	fTakeTypesAndTryApply = //! –ü—Ä–∏–ø–∏—Å—ã–≤–∞–µ—Ç —Ç–∏–ø—ã –∏–∑ –æ–¥–Ω–æ–π —Ç–∞–±–ª–∏—Ü—ã –∏ –ø—Ä–∏–º–µ–Ω—è–µ—Ç –∏—Ö –∫ –æ–¥–Ω–æ–∏–º–µ–Ω–Ω—ã–º —Å—Ç–æ–ª–±—Ü–∞–º –≤ –¥—Ä—É–≥–æ–π —Ç–∞–±–ª–∏—Ü–µ
		// –ü—Ä–∏–ø–∏—Å—ã–≤–∞–µ—Ç —Ç–∏–ø—ã –∏–∑ –æ–¥–Ω–æ–π —Ç–∞–±–ª–∏—Ü—ã –∏ –ø—Ä–∏–º–µ–Ω—è–µ—Ç –∏—Ö –∫ –æ–¥–Ω–æ–∏–º–µ–Ω–Ω—ã–º —Å—Ç–æ–ª–±—Ü–∞–º –≤ –¥—Ä—É–≥–æ–π —Ç–∞–±–ª–∏—Ü–µ
		(tblToAlter as table, tblGet as table) =>
			let
				typetblGet = Value.Type(tblGet),
				NameCols   = List.Intersect(
								{
									Table.ColumnNames(tblGet) ,
									Table.ColumnNames(tblToAlter)
								}
							),
			
				NameFuncTypes = List.Transform(
									NameCols, 
									(x) => { x, each {_}{0}, Type.TableColumn(typetblGet, x) } 
								),
				
				Transform = Table.TransformColumns(tblToAlter, NameFuncTypes)
			in
				Transform,
	
	fAddRandomColumn 	= // –¥–æ–±–∞–≤–ª—è–µ–º –∫–æ–ª–æ–Ω–∫—É —Å —Ä–∞–Ω–¥–æ–º–Ω—ã–º–∏ –∑–Ω–∞—á–µ–Ω–∏—è–º–∏
			/*
				Add column of random numbers between 0 and 1:			fAddRandomColumn(Source,"Random Number",0,1)
				Add column of random percentages between 0% and 100%:	fAddRandomColumn(Source,"Random Percentage",0,1,Percentage.Type)
				Retrieve random item from list:							fAddRandomColumn(Source, "Random Item",
																							0,
																							List.Count(ListOfItems),
																							{each ListOfItems{Number.RoundDown(_)}, type text}
																						)
					(ListOfItems would need to be buffered into memory for it to run quickly, e.g. ListOfItems = List.Buffer(SomeList))
			*/

			(	
				Table as table, 
				RandColName as text, 
				Min as number, 
				Max as number, 
				optional TransformAndTypeCriteria as any
			) =>

			let
				List = List.Buffer( 
						if not (TransformAndTypeCriteria is list)  then {TransformAndTypeCriteria} else
						if List.Count(TransformAndTypeCriteria)<=2 then TransformAndTypeCriteria else
						error "Invalid Criteria (Too many items)" ),
				
				TransformFunc = 
					if	List{0} is null or List{0} is type then null else
					if 	List{0} is function then List{0} else
					error "Invalid Criteria (Tranform)",

				ListLast = List.Last(List),
				
				Type = 
					if ListLast is null or ListLast is function then type number else  
					if ListLast is type then ListLast else
					error "Invalid Criteria (Type)",

				FirstName = Table.ColumnNames(Table){0},
				
				AddColumn = Table.AddColumn(Table,
								RandColName,
								each Number.RandomBetween(if Record.Field(_,FirstName)=null then Min else Min, Max),
								Type),
				Transform = 
					if TransformFunc = null 
					then AddColumn 
					else Table.TransformColumns(AddColumn,{RandColName, TransformFunc})
			in
				Transform,
	–ó–∞–≥–ª—É—à–∫–∞ = ""
	],
Monky  	   = [ // –∏–∑ –∫–Ω–∏–≥–∏ "–ü—Ä–∏—Ä—É—á–∏ –¥–∞–Ω–Ω—ã–µ"
	fnSmartFolder  = 1 // –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Ç–∞–±–ª–∏—Ü—É —Å –¥–∞–Ω–Ω—ã–º–∏ –æ —Ñ–∞–π–ª–∞—Ö –≤ –ø–∞–ø–∫–µ –∏–ª–∏ SharePoint –∏—Å–ø–æ–ª—å–∑—É—è Folder.Files –∏–ª–∏ Folder.Contents
	],
DataAnalys = [ // https://github.com/AnHerbWorm/DataAnalysis/tree/main/powerquery
	// –ø–æ–ª–µ–∑–Ω–æ–≥–æ –ø–æ —Å—É—Ç–∏ –º–∞–ª–æ, –Ω–æ –∏–Ω–µ—Ç–µ—Ä–µ—Å–Ω–æ –æ—Ñ–æ—Ä–º–ª–µ–Ω–∏–µ –∏ –ø—Ä–∏–º–µ–Ω–µ–Ω–∏–µ –Ω–µ–∫–æ—Ç–æ—Ä—ã—Ö —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã—Ö —Ñ—É–Ω–∫—Ü–∏–π Type. 
	// –∏–Ω—Ç–µ—Ä–µ—Å–Ω–æ–µ –≤ ClimateCanada_GetDailyWeather –≤ —á–∞—Å—Ç–∏ Climate.CSVSchema = type table [ - —Å—Ö–µ–º–∞ —Ç–∞–±–ª–∏—Ü—ã
	// –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ Type.ForFunction –∏–Ω—Ç–µ—Ä–µ—Å–Ω–æ–µ –≤ List_ValueCounts, Table_AddGroupIndex
	List_ValueCounts = // –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∏–∑ —Å–ø–∏—Å–∫–∞ —É–Ω–∏–∫–∞–ª—å–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è –∏ –∏—Ö –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –≤ –≤–∏–¥–µ —Ç–∞–±–ª–∏—Ü—ã, —Å–ø–∏—Å–∫–∞ –∏–ª–∏ –∑–∞–ø–∏—Å–∏
		/*
			* return distinct values and their count of occurrences within the source list as a table or list
			* @name List.ValueCounts
			* @categories list
			* @author https://github.com/AnHerbWorm
			* @source https://github.com/AnHerbWorm/DataAnalysis/tree/main/powerquery
			* @result table, list of lists, or list of records
		*/
		let
			Main.Func = (list as list, optional outputAs as nullable text) as any =>
				let
					ListAsTable = #table(type table [Value=any], List.Transform(list, each {_})),
					Grouped = Table.Group(ListAsTable, {"Value"}, {{"Count", Table.RowCount, Int64.Type}}),
					Results = [
						table   = Grouped,
						lists   = Table.ToList(table, each _),
						records = Table.ToRecords(table)
					],
					Format = if outputAs = null then "table" else Text.Lower(outputAs),
					Result = Record.FieldOrDefault(Results, Format, Grouped)
				in
					Result,
			Main.Type = Type.ForFunction(
				[
					ReturnType = type any,
					Parameters = [
						list = type list meta [
							Documentation.FieldCaption = "List"
						],
						outputAs = type nullable text meta [
							Documentation.FieldCaption = "Return Counts As",
							Documentation.AllowedValues = {"table", "lists", "records"}
						]
					]
				],
				1
				),
			Main.Docs = [
				Documentation.Name = "List_ValueCounts",
				Documentation.LongDescription = Text.Combine(
					{
						"–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —É–Ω–∏–∫–∞–ª—å–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è –∏ –∏—Ö –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –≤ –≤–∏–¥–µ —Ç–∞–±–ª–∏—Ü—ã, —Å–ø–∏—Å–∫–∞ –∏–ª–∏ –∑–∞–ø–∏—Å–∏<br>",
						"Counts each occurrence of distinct values in the input list.<br><br>",
						"<b>Args</b><br>",
						"<i>list</i>: Source list for value counts.<br>",
						"<i>outputAs</i>: Text representation of how to return the value counts. Options are ",
						"'lists'/'records'/'table'. Default 'table' will be applied if omitted or a non-allowed value is",
						"entered. See examples for more details.<br><br>",
						"<b>Returns</b><br>",
						"Nested list where the inner list has structure: item{0} = value and item{1} = count<br>",
						"–í–ª–æ–∂–µ–Ω–Ω—ã–π —Å–ø–∏—Å–æ–∫, –≥–¥–µ –≤–Ω—É—Ç—Ä–µ–Ω–Ω—è—è —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ –∏–º–µ–µ—Ç –≤–∏–¥: item{0} = –∑–Ω–∞—á–µ–Ω–∏–µ –∏ item{1} = –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ."
					},
					""
				),
				Documentation.Examples = {
					[
						Description = "Return as table (DEFAULT)",
						Code = "List_ValueCounts({0, 0, 1, 4, 4, 4, 4, 4, 7, 8})",
						Result = Text.Combine({
							"#table(type table [Value=any, Count=number], ",
							"{ {0, 2}, {1, 1}, {4, 5}, {7, 1}, {8, 1} })"},
							"#(lf)"
						)
					],
					[
						Description = "Return as list of lists",
						Code = "List_ValueCounts({0, 0, 1, 4, 4, 4, 4, 4, 7, 8}, ""lists"")",
						Result = "{ {0, 2}, {1, 1}, {4, 5}, {7, 1}, {8, 1} }"
					],
					[
						Description = "Return as list of records",
						Code = "List_ValueCounts({0, 0, 1, 4, 4, 4, 4, 4, 7, 8}, ""records"")",
						Result = Text.Combine({
							"{ [Value=0, Count=2], [Value=1, Count=1], [Value=4, Count=5],",
							"  [Value=7, Count=1], [Value=8, Count=1] }"},
							"#(lf)"
						)
					]
				}
				]
		in
			Value.ReplaceType(Main.Func, Main.Type meta Main.Docs),

	ClimateCanada_GetDailyWeather = // –∏–º–ø–æ—Ä—Ç –∏–∑ CSV –≥—Ä–∞–º–æ—Ç–Ω—ã–π!!!
        /*
            * Queries climate.weather.gc.ca for daily bulk data (in csv format) for a given climate station and date range. Station
            * IDs are available from climate.weather.gc.ca google drive
            *   https://drive.google.com/drive/folders/1WJCDEU34c60IfOnG4rv5EPZ4IhhW9vZH/
            *
            * the csv schema is hard-coded within this query and will need adjusted if the format changes.
            *
            * @name ClimateCanada.GetDailyWeather
            * @categories weather
            * @license MIT (c) 2021 W Bohm
            * @author https://github.com/AnHerbWorm
            * @source https://github.com/AnHerbWorm/DataAnalysis/tree/main/powerquery
            * @result table
        */
        let
            /*
                CLIMATE FUNCTIONS
                    Functions and Types related to climate.weather.gc.ca

                Climate.CSVSchema: Table type of bulk .csv data downloads
                Climate.ApplySchema: Transform table column types to match those of Climate.CSVSchema
                Climate.MakeURL: Construct url to bulk download the entire year's daily data for a given station id
                Climate.ReadURL: Download data and clean up into a table of type Climate.CSVSchema
            */
            Climate.CSVSchema = type table [
                    #"Longitude (x)" =  number,
                    #"Latitude (y)" =  number,
                    #"Station Name" =  text,
                    #"Climate ID" = Int64.Type,
                    #"Date/Time" =  date,
                    #"Year" = Int64.Type,
                    #"Month" = Int64.Type,
                    #"Day" = Int64.Type,
                    #"Data Quality" =  text,
                    #"Max Temp (¬∞C)" =  number,
                    #"Max Temp Flag" =  text,
                    #"Min Temp (¬∞C)" =  number,
                    #"Min Temp Flag" =  text,
                    #"Mean Temp (¬∞C)" =  number,
                    #"Mean Temp Flag" =  text,
                    #"Heat Deg Days (¬∞C)" =  number,
                    #"Heat Deg Days Flag" =  text,
                    #"Cool Deg Days (¬∞C)" =  number,
                    #"Cool Deg Days Flag" =  text,
                    #"Total Rain (mm)" =  text,
                    #"Total Rain Flag" =  text,
                    #"Total Snow (cm)" =  text,
                    #"Total Snow Flag" =  text,
                    #"Total Precip (mm)" =  number,
                    #"Total Precip Flag" =  text,
                    #"Snow on Grnd (cm)" = Int64.Type,
                    #"Snow on Grnd Flag" =  text,
                    #"Dir of Max Gust (10s deg)" = Int64.Type,
                    #"Dir of Max Gust Flag" =  text,
                    #"Spd of Max Gust (km/h)" = Int64.Type,
                    #"Spd of Max Gust Flag" =  text
                ],
            Climate.ApplySchema = (table as table) as table => 
                    Table.TransformColumnTypes(
                        table,
                        List.Transform(
                            Type.TableSchema(Climate.CSVSchema)[Name], 
                            each {_, Type.TableColumn(Climate.CSVSchema, _)}
                        )
                    ),  
            Climate.MakeURL = (stationID as number, year as number) as text => 
                Text.Combine(
                    {
                        "http://climate.weather.gc.ca/climate_data/bulk_data_e.html?format=csv&",
                        Text.Format("stationID=#[id]&Year=#[yr]", [id=stationID, yr=year]),
                        "&Month=12&Day=31&timeframe=2"
                    },
                    ""
                ),
            Climate.ReadURL = (url as text) as table => 
                let
                    Source      = Csv.Document(
                                    Web.Contents(url),
                                    [Delimiter=",", Columns=31, Encoding=65001, QuoteStyle=QuoteStyle.None]
                                  ),
                    Headers     = Table.PromoteHeaders(Source, [PromoteAllScalars=true]),
                    ApplySchema = Climate.ApplySchema(Headers)
                in
                    ApplySchema,
            /* HELPER FUNCTIONS MakeDateRange: Return table of inclusive dates between start/end. Single column is named "Date" */
            MakeDateRange = (start as date, end as date) as table => 
                #table(
                    type table [Date=date],
                    List.Generate(
                        ()=>0,
                        each _ <= Duration.TotalDays(end - start),
                        each _ + 1,
                        each {Date.AddDays(start, _)}
                    )
                ),
            /* MAIN FUNCTION */
            Main.Func = (stationID as number, startDate as date, endDate as date) as table =>
                let
                    AllDates = MakeDateRange(startDate, endDate),
                    AllYears = List.Distinct(List.Transform(AllDates[Date], Date.Year)),
                    
                    URLS = List.Transform(AllYears, each Climate.MakeURL(stationID, _)),
                    ClimateData = Table.Combine(List.Transform(URLS, Climate.ReadURL)),
                    FilterToRange = Table.Join(
                        AllDates,
                        {"Date"},
                        ClimateData,
                        {"Date/Time"}
                    ),
                    RemoveJoinColumn = Table.RemoveColumns(FilterToRange, "Date")
                in
                    RemoveJoinColumn,
            Main.Docs = [
                Documentation.Name = "ClimateCanada_GetDailyWeather",
                Documentation.LongDescription = Text.Combine(
                    {
                        "Queries climate.weather.gc.ca for daily bulk data (in csv format) for a given climate station and",
                        "date range.<br><br>",
                        
                        "<b>Args<br>------</b><br>",
                        "<i>stationID</i>: Climate Station ID. A list of all stationIDs can be found at",
                        "https://drive.google.com/drive/folders/1WJCDEU34c60IfOnG4rv5EPZ4IhhW9vZH/<br>",
                        "<i>startDate</i>: First date to include in the download (inclusive).<br>",
                        "<i>endDate</i>: Last date to include in the download (inclusive).<br><br>",

                        "<b>NOTE<br>-------</b><br>",
                        "Table schema is set within this query and must be adjusted if the bulk data format changes."
                    },
                    " "
                ),
                Documentation.Examples = {
                    [
                        Description = "First two days of 2021, Edmonton International Airport (#27793)",
                        Code = "GetDailyClimateData(27793, #date(2021, 1, 1), #date(2021, 1, 2))",
                        Result = Text.Combine({
                            "Note: Columns truncated for this example#(lf,lf)",
                            "Table.FromRecords({",
                            "#(lf)  [Date/Time = 2021/01/01, Max Temp = -4.0, Min Temp = -13.4],",
                            "#(lf)  [Date/Time = 2021/01/02, Max Temp = 4.1, Min Temp = -12.0]",
                            "#(lf)})"},
                            ""
                        )
                    ]
                }
             ],
            Main.Type = Type.ForFunction(
                [
                    ReturnType = Climate.CSVSchema,
                    Parameters = [
                        stationID = type number meta [
                            Documentation.FieldCaption = "Climate Station ID",
                            Documentation.SampleValues = {27793}
                        ],
                        startDate = type date meta [
                            Documentation.FieldCaption = "First Date to Import"
                        ],
                        endDate = type date meta [
                            Documentation.FieldCaption = "Last Date to Import"
                        ]
                    ]
                ],
                3
             )
        in
            Value.ReplaceType(Main.Func, Main.Type meta Main.Docs),

    CurrentWorkbook_NamedRange = // —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø–æ–≥–æ–¥—ã –≤ –ö–∞–Ω–∞–¥–µ 
        /* 
            * return the value referenced by the workbook scoped named range. The return type is inferred from the structure of
            * [Content] for the named range, and M detects the type for literals.
            *
            * support for worksheet scoped named ranges is provided through the optional 'sheet' parameter
            *
            * @name CurrentWorkbook.NamedRange
            * @categories excel, currentworkbook
            * @license MIT (c) 2021 W Bohm
            * @author https://github.com/AnHerbWorm
            * @source https://github.com/AnHerbWorm/DataAnalysis/tree/main/powerquery
            * @result literal, table, or list
        */
        let
            Param.Name.Error = (name as text) as record =>
                Error.Record(
                    "Argument Error",
                    Text.Format("'#[nm]' is not a valid named range for this workbook.",[nm = name]),
                    Text.Combine(
                        {
                            "Check that the spelling is correct, and that the named range is scoped to the",
                            "workbook. Worksheet scoped named ranges can still be accessed using the optional",
                            "sheet parameter."
                        },
                        " "
                    )
                ),

            Main.Func = (name as text, optional sheet as nullable text) as any =>
                let
                    Name = if sheet = null then name else Text.Format("#[sh]![nm]", [sh=sheet, nm=name]),
                    Content =
                        try 
                            Excel.CurrentWorkbook(){[Name=Name]}[Content]
                        otherwise
                            error Param.Name.Error(name),
                    Output =
                        if Table.ColumnNames(Content) = {"Column1"} then
                            if Table.RowCount(Content) = 1 then
                                Content{0}[Column1]
                            else
                                Content[Column1]
                        else
                            Content
                in
                    Output,
            Main.Type = Type.ForFunction(
                [
                    ReturnType = type any,
                    Parameters = [
                        name = type text meta [
                            Documentation.FieldCaption = "name: named range",
                            Documentation.AllowedValues = Excel.CurrentWorkbook()[Name]
                        ],
                        optional sheet = type nullable text meta [
                            Documentation.FieldCaption = "sheet: worksheet scope"
                        ]
                    ]
                ],
                Type.FunctionRequiredParameters(Value.Type(Main.Func))
            ),
            Main.Docs = [
                Documentation.Name = "CurrentWorkbook.NamedRange",
                Documentation.LongDescription = Text.Combine(
                    {
                        "Return the value referenced by the workbook named range.",
                        "Worksheet scoped ranges can be accessed by also providing the 'sheet' parameter.<br><br>",
                        
                        "<b>Args</b><br>-----<br>",
                        "<b>name</b> as text: named range<br>",
                        "<b>sheet</b> as nullable text: [Optional] sheet name for worksheet scoped named ranges<br><br>",
                        
                        "<b>Returns</b><br>---------<br>Values are inferred to be:<br>",
                        "+ A literal if Content is a 1x1 table with 'Column1'<br>",
                        "+ A list if Content is a 1xN table with 'Column1'<br>",
                        "+ A table if neither of the above is true<br><br>",
                        "The table return format is the default for Excel.CurrentWorkbook()[Content] records and will return a",
                        "table with no column types transformed.<br><br>",
                        
                        "<b>Raises</b><br>-------<br>",
                        "Argument Error: the named range does not exist in the workbook scope"
                    },
                    " "
                ),
                Documentation.Examples = {
                    [
                        Description = "Name refers to a single cell",
                        Code = "CurrentWorkbook_NamedRange(""TheNumberFour"")",
                        Result = "4"
                    ],
                    [
                        Description = "Name refers to a single cell, forceTable=true",
                        Code = "CurrentWorkbook_NamedRange(""TheNumberFour"", null, true)",
                        Result = "Column1#(lf)-------#(lf)4"
                    ],
                    [
                        Description = "Name refers to a range of cells",
                        Code = "CurrentWorkbook_NamedRange(""Alphabet"")",
                        Result = "{""A"",""B"",""C"",""D"", ..., ""Z""}"
                    ],
                    [
                        Description = "Name refers to a range of cells, forceTable=true",
                        Code = "CurrentWorkbook_NamedRange(""Alphabet"", null, true)",
                        Result = "Column1#(lf)-------#(lf)A#(lf)B#(lf)C#(lf)..#(lf)Z"
                    ],
                    [
                        Description = "Name refers to a table only scoped to sheet 'abc'",
                        Code = "CurrentWorkbook_NamedRange(""AlphabetWithPosition"", ""abc"")",
                        Result = Text.Combine(
                            {
                                "Pos | Letter#(lf)",
                                "------------#(lf)",
                                "  1 |  A#(lf)",
                                "  2 |  B#(lf)",
                                "  3 |  C#(lf)",
                                " .. | ..#(lf)",
                                " 26 |  Z"
                            }
                        )
                    ]
                }
            ]
        in
            Value.ReplaceType(Main.Func, Main.Type meta Main.Docs),

    Template_FuncWithDocs = // —à–∞–±–ª–æ–Ω –¥–æ–∫—É–º–µ–Ω—Ç–∏—Ä–æ–≤–∞–Ω–∏—è —Ñ—É–Ω–∫—Ü–∏–∏ 
        /*
            * Short, one sentence query description
            * Long query description. Should also be added to Documentation.LongDescription in the Main.Docs record.
            *
            * @name QueryName
            * @categories relevant tag, another relevant tag
            * @author https://github.com/AnHerbWorm
            * @source https://github.com/AnHerbWorm/DataAnalysis/tree/main/powerquery
            * @result result type
        */
            let
                /* Sub-Calcs Section 
                
                SubCalc.Type -> type:
                SubCalc.FuncA -> any:
                SubCalc.FuncB -> any:
                */
                SubCalc.Type = ...,
                SubCalc.FuncA = ...,
                SubCalc.FuncB = ...,

                /* Main Function
                
                Main.Func -> any: the calculations and return value for the query
                Main.Type -> type: parameter definitions used in Main.Func, along with documentation for the Query Editor
                Main.Docs -> record: meta information for Query Editor documentation
                */
                Main.Func = (p1 as any, optional p2 as any) as any =>
                    let
                        Source = ...
                    in
                        Source,
                Main.Type = Type.ForFunction(
                    [
                        ReturnType = type any,
                        Parameters = [
                            p1 = type any meta [
                                Documentation.FieldCaption = "short caption to display",
                                Documentation.SampleValues = {"list of text displayed in the entry field"},
                                Documentation.AllowedValues = {"list of values (any type) to display in dropdown"}
                            ],
                            optional p2 = type any meta [
                                Documentation.FieldCaption = "short caption to display",
                                Documentation.SampleValues = {"list of text displayed in the entry field"},
                                Documentation.AllowedValues = {"list of values (any type) to display in dropdown"}
                            ]
                        ]
                    ],
                    Type.FunctionRequiredParameters(Value.Type(Main.Func))
                ),
                Main.Docs = [
                    Documentation.Name = "short name of entire function, shows at top",
                    Documentation.LongDescription = "long description of entire function",
                    Documentation.Examples = {
                        [
                            Description = "description of the example",
                            Code = "show under ""usage"" section",
                            Result = "show under ""result"" section"
                        ]
                    }
                ]
            in
                Value.ReplaceType(Main.Func, Main.Type meta Main.Docs),

    Table_GroupWithTotals = // –∑–∞—Ç–æ—á–µ–Ω–æ –ø–æ–¥ –∫–∞–Ω–∞–¥—É, —Ç–æ–ª—å–∫–æ –¥–ª—è –∏–∑—É—á–µ–Ω–∏—è –∫–æ–¥–∞, –º–æ–∂–µ—Ç –ø—Ä–∏–º–µ–Ω–∏—Ç—å –∫ —á–µ–º—É –µ—â–µ 
        /*
            compute and combine Table.Group() calls on subsets of sourceTable with sub/grand totals added
            
            performs initial checks on parameter values to ensure the function will complete as it can be
            expensive to find out late in the calculation sequence that a combination fails
            
            @name Table.GroupWithTotals
            @categories table
            @license MIT (c) 2021 W Bohm
            @author https://github.com/AnHerbWorm
            @source https://github.com/AnHerbWorm/DataAnalysis/tree/main/powerquery
            @result table
        */
        let
            /* 
                Subset Functions
                A subset is a non-nullable list of subtotals, where each subtotal has length > 0

                Subset.Type -> type: type definition for reference only. It is not ascribed anywhere but describes the list {record} structure
                Subset.Columns -> list: all column field values in the subset
                Subset.IsValid -> logical: column field values are distinct and all required columns are present
                Subset.ToTable -> table: sourceTable with subtotal application for each record in the subset.
                    Can return a table with 0 rows if the subtotals do not have any overlap in the results of their selector functions
                Subset.Combinations -> list: list of all combinations of subsets of length n
            */
            Subset.Type = type {[column = text, alias = text, selector = function]},
            Subset.Columns = (subset as list) as list => List.Transform(subset, each _[column]),
            Subset.IsValid = (subset as list, requiredColumns as nullable list) as logical =>
                if requiredColumns = null then
                    List.IsDistinct(Subset.Columns(subset))
                else
                    List.IsDistinct(Subset.Columns(subset))
                    and List.MatchesAll(requiredColumns, each List.Contains(Subset.Columns(subset), _)),
            Subset.ToTable = (subset as list, iter as number, tbl as table) as table =>
                let
                    Curr = subset{iter},
                    Recur = iter < List.Count(subset),
                    ContTable = Table.TransformColumns(
                        Table.SelectRows(tbl, each Curr[selector](Table.Column(_, Curr[column]))),
                        {
                            {Curr[column], each Curr[alias], type text}
                        }
                    )
                in
                    if Recur then
                        @Subset.ToTable(subset, iter + 1, ContTable)
                    else
                        tbl,
            Subset.Combinations = (s as list, n as number) as list =>
                if n = 0 then
                    {{}}
                else if List.Count(s) = 0 then
                    {}
                else
                    List.Transform(@Subset.Combinations(List.Skip(s), n - 1), each {List.First(s)} & _)
                    &
                    @Subset.Combinations(List.Skip(s), n),
            // Validation Checks
            Param.KeyColumns = (keyColumns, subtotals) =>
                let
                    NotKeys = List.Select(
                        List.Transform(subtotals, each _{0}),
                        each not List.Contains(keyColumns, _)
                    ),
                    Details = 
                        if keyColumns = null then
                            [IsNull=true]
                        else
                            [Not Keys=Text.Combine(List.Distinct(NotKeys), ", ")],
                    Err = Error.Record(
                        "Parameter Error",
                        "keyColumns cannot be null and must contain all columns listed in subtotals",
                        Details
                    ),
                    Param = 
                        if List.Count(NotKeys) = 0 then
                            keyColumns
                        else
                            error Err
                in
                    Param,
            Param.Subtotals = (subtotals, keyColumns) =>
                let
                    Columns = List.Transform(subtotals, each _{0}),
                    Aliases = List.Transform(subtotals, each _{1}),
                    AliasByColumn = List.Accumulate(
                        List.Zip({Columns, Aliases}),
                        // generating a record of each column used with an empty list value
                        // so that these lists can be populated with each alias used for duplication checking
                        Record.FromList(
                            List.Repeat({{}}, List.Count(List.Distinct(Columns))),
                            List.Distinct(Columns)
                        ),
                        (state, current) => Record.TransformFields(state, {current{0}, each _ & {current{1}}})
                    ),
                    ColumnsWithDupes = Table.SelectRows(Record.ToTable(AliasByColumn), (tb) => not List.IsDistinct(tb[Value])),
                    Err = Error.Record(
                        "Parameter Error",
                        "each distinct subtotals column cannot reuse an alias",
                        [column=ColumnsWithDupes[Name]{0}, alias="..."]
                    ),
                    Param = 
                        if Table.RowCount(ColumnsWithDupes) = 0 then
                            subtotals
                        else
                            error Err
                    in
                        Param,
            Param.TotalsOnly = (totalsOnlyColumns, subtotals) =>
                let
                    NotSubtotal = List.Select(
                        totalsOnlyColumns,
                        each not List.Contains(List.Transform(subtotals, each _{0}), _)),
                    Err = Error.Record(
                        "Parameter Error",
                        "totalsOnlyColumns must be null or only contain columns listed in subtotals",
                        [Not Subtotals=Text.Combine(List.Distinct(NotSubtotal), ", ")]
                    ),
                    Param = 
                        if totalsOnlyColumns = null or List.Count(NotSubtotal) = 0 then
                            totalsOnlyColumns
                        else
                            error Err
                in
                    Param,
            // Main Function
            Main.Func = (sourceTable as table,
                        keyColumns as list,
                        subtotals as list,
                        aggregatedColumns as list,
                        optional totalsOnlyColumns as nullable list
                        ) as table =>
                let
                    KeyColumns = Param.KeyColumns(keyColumns, subtotals),
                    Subtotals = Param.Subtotals(subtotals, keyColumns),
                    TotalsOnly = Param.TotalsOnly(totalsOnlyColumns, subtotals),
                
                    SubtotalsAsRecords = List.Transform(Subtotals, each Record.FromList(_, {"column", "alias", "selector"})),
                    // the max number of elements in a subset is equal to the number of columns where a total is applied
                    // the min number of elements in a subset is equal to the number of totalsOnlyColumns columns, 
                    // or 1 if totalsOnlyColumns is null
                    MaxSubsetSize = List.Count(List.Distinct(Subset.Columns(SubtotalsAsRecords))),
                    MinSubsetSize = List.Min({MaxSubsetSize, try List.Count(TotalsOnly) otherwise 1}),
                    AllSubsets = List.Accumulate(
                        {MinSubsetSize..MaxSubsetSize},
                        {},
                        (state, current) => state & Subset.Combinations(SubtotalsAsRecords, current)
                    ),
                    ValidSubsets = List.Buffer(List.Select(AllSubsets, each Subset.IsValid(_, TotalsOnly))),
                    BufferedSource = Table.Buffer(sourceTable),
                    CreateAndCombineSubsetTables = Table.Combine(
                        List.Transform(ValidSubsets, each Subset.ToTable(_, 0, BufferedSource))
                    ),
                    // apply standard Table.Group()
                    // in cases where TotalsOnly is null, we also need to compute measures on the base table
                    BaseMeasures = Table.Group(
                        BufferedSource,
                        KeyColumns,
                        aggregatedColumns
                    ),
                    CombinationMeasures = Table.Group(
                        CreateAndCombineSubsetTables,
                        KeyColumns,
                        aggregatedColumns
                    ),
                    OutputMeasures =
                        if TotalsOnly = null then
                            CombinationMeasures & BaseMeasures
                        else
                            CombinationMeasures
                in
                    OutputMeasures,
            
            Main.Type = Type.ForFunction(
                [
                    ReturnType = type table,
                    Parameters = [
                        sourceTable = type table meta [Documentation.FieldCaption = "table to group"],
                        keyColumns = type list meta [Documentation.FieldCaption = "list of column names to group on"],
                        subtotals = type list meta [Documentation.FieldCaption = "subtotals"],
                        aggregatedColumns = type list meta [Documentation.FieldCaption = "aggregatedColumns"],
                        optional totalsOnlyColumns = type nullable list meta [Documentation.FieldCaption = "totalsOnlyColumns"]
                    ]
                ],
                4
            ),
            Main.Docs = [
                Documentation.Name = "Table.GroupWithTotals",
                Documentation.LongDescription = Text.Combine(
                    {
                        "Create and combine the results of Table.Group() on all combinations of user-defined subsets",
                        "of the table.<br><br>",
                    
                        "<b>Args</b><br>----<br>",
                        "<code>sourceTable</code>: table to group<br>",
                        "<code>keyColumns</code>: list of column names to group on<br>",
                        "<code>subtotals</code>: nested list of 3-element lists where each inner list is the specifications",
                        "for creating a total.<br>",
                        "sublist{0} <i>column as text</i>: name of the column to base the subtotal on. Must be in keyColumns.<br>",
                        "sublist{1} <i>alias as text</i>: value that refers to the subtotal. All values in the column get",
                        "replaced by this alias after selection. An error is raised if a column attempts to use the same",
                        "alias twice.<br>",
                        "sublist{2} <i>selector as function</i>: function that returns true/false when applied to each column value.<br>",
                        "<code>aggregatedColumns</code>: see M Documentation https://docs.microsoft.com/en-us/powerquery-m/table-group.",
                        "Columns used in aggregate calculations should not also be used for subtotals. The query will likely",
                        "complete but produce error values within the final table.<br>",
                        "<code>totalsOnlyColumns</code>: [Optional] list of column names where only the subtotals will be returned,",
                        "instead of the typical behaviour of Table.Group that groups on each distinct value within keyColumns.<br>",
                        
                        "<br><b>Dependencies</b><br>----------------<br>",
                        "List.Combinations (as List_Combinations)"
                    },
                    " "
                ),
                Documentation.Examples = {
                    [
                        Description = "5 Largest Canadian Cities by Province with subtotals",
                        Code = Text.Combine({
                            "Table_GroupWithTotals(#(lf)",
                            "  Table.FromRecords({#(lf)",
                            "    [City=""Toronto"" , Province=""ON"", Pop=2.73],#(lf)",
                            "    [City=""Montreal"", Province=""QC"", Pop=1.70],#(lf)",
                            "    [City=""Calgary"" , Province=""AB"", Pop=1.24],#(lf)",
                            "    [City=""Ottawa""  , Province=""ON"", Pop=0.93],#(lf)",
                            "    [City=""Edmonton"", Province=""AB"", Pop=0.93]}#(lf)",
                            "  ),#(lf)",
                            "  {""Province""},#(lf)",
                            "  {#(lf)",
                            "    {""Province"", ""Canada"", each true},#(lf)",
                            "    {""Province"", ""West"", (prov) => List.Contains({""BC"", ""AB"", ""SK"", ""MB""}, prov)}#(lf)",
                            "  },#(lf)",
                            "  {#(lf)",
                            "    {""cities"", Table.RowCount, Int64.Type},#(lf)",
                            "    {""avg pop"", each List.Average([Pop]), type number}#(lf)",
                            "  },#(lf)",
                            "  null#(lf)",
                            ")"
                        }),
                        Result = Text.Combine({
                            "#table(#(lf)",
                            "  {""Province"", ""cities"", ""avg pop""},#(lf)",
                            "  {#(lf)",
                            "    {""Canada"", 5, ""1.506""},#(lf)",
                            "    {""West"", 2, 1.085},#(lf)",
                            "    {""ON"", ""2"", 1.83}#(lf)",
                            "    {""QC"", 1, 1.70},#(lf)",
                            "    {""AB"", 2, 1.085}#(lf)",
                            "  }#(lf)",
                            ")"
                        })
                    ],
                    [
                        Description = "5 Largest Canadian Cities by Province, subtotals only",
                        Code = Text.Combine({
                            "Table_GroupWithTotals(#(lf)",
                            "  Table.FromRecords({#(lf)",
                            "    [City=""Toronto"" , Province=""ON"", Pop=2.73],#(lf)",
                            "    [City=""Montreal"", Province=""QC"", Pop=1.70],#(lf)",
                            "    [City=""Calgary"" , Province=""AB"", Pop=1.24],#(lf)",
                            "    [City=""Ottawa""  , Province=""ON"", Pop=0.93],#(lf)",
                            "    [City=""Edmonton"", Province=""AB"", Pop=0.93]}#(lf)",
                            "  ),#(lf)",
                            "  {""Province""},#(lf)",
                            "  {#(lf)",
                            "    {""Province"", ""Canada"", each true},#(lf)",
                            "    {""Province"", ""West"", (prov) => List.Contains({""BC"", ""AB"", ""SK"", ""MB""}, prov)}#(lf)",
                            "  },#(lf)",
                            "  {#(lf)",
                            "    {""cities"", Table.RowCount, Int64.Type},#(lf)",
                            "    {""avg pop"", each List.Average([Pop]), type number}#(lf)",
                            "  },#(lf)",
                            "  {""Province""}#(lf)",
                            ")"
                        }),
                        Result = Text.Combine({
                            "#table(#(lf)",
                            "  {""Province"", ""cities"", ""avg pop""},#(lf)",
                            "  {#(lf)",
                            "    {""Canada"", 5, ""1.506""},#(lf)",
                            "    {""West"", 2, 1.085}#(lf)",
                            "  }#(lf)",
                            ")"
                        })
                    ]
                }
            ]
        in
            Value.ReplaceType(Main.Func, Main.Type meta Main.Docs)
            ,

    Table_AddGroupIndex   = // –¥–æ–±–∞–≤–ª—è–µ—Ç –Ω–æ–≤—ã–π –∏–Ω–¥–µ–∫—Å–Ω—ã–π —Å—Ç–æ–ª–±–µ—Ü, –∫–æ—Ç–æ—Ä—ã–π –æ–ø—Ä–µ–¥–µ–ª—è–µ—Ç, –∫ –∫–∞–∫–æ–π –≥—Ä—É–ø–ø–µ –ø—Ä–∏–Ω–∞–¥–ª–µ–∂–∏—Ç –∫–∞–∂–¥–∞—è —Å—Ç—Ä–æ–∫–∞ –≤ –∏—Å—Ö–æ–¥–Ω–æ–π —Ç–∞–±–ª–∏—Ü–µ
        /* 
            * chains Table.ExpandTableColumn(Table.AddIndexColumn(Table.Group)) functions to append a new index column
            * identifying which group each row in the source table belongs to
            *
            * @name Table.AddGroupIndex
            * @categories table
            * @author https://github.com/AnHerbWorm
            * @source https://github.com/AnHerbWorm/DataAnalysis/tree/main/powerquery
            * @result table
        */
            let
                Main.Func = (table as table, key as anynonnull, newColumnName as text) as table =>
                    Table.ExpandTableColumn(
                        Table.AddIndexColumn(
                            Table.Group(table, key, {{"rows", each _, Value.Type(table)}}),
                            newColumnName
                        ),
                        "rows",
                        List.RemoveItems(
							Table.ColumnNames(table), 
							if key is list then key else {key}
						)
                ),

                Main.Type = Type.ForFunction(
                    [
                        ReturnType = type table,
                        Parameters = [
                            table 		  = type table 		meta [Documentation.FieldCaption = "source table"],
                            key 		  = type anynonnull meta [Documentation.FieldCaption = "column(s) to group on"],
                            newColumnName = type text 		meta [Documentation.FieldCaption = "column name for index"]
                        ]
                    ],
                    Type.FunctionRequiredParameters(Value.Type(Main.Func))
                ),
                Main.Docs = [
                    Documentation.Name = "Table.AddGroupIndex",
                    Documentation.LongDescription = Text.Combine(
                        {
                            "Appends <code>newColumnName</code> to <code>table</code> where each index value identifies",
                            "which group that record belongs to after grouping on <code>key</code>.",
                            "Indexes start at 0, increment by 1, and are numbered in the order observed.<br><br>",
                            
                            "<b>Args:</b><br>",
                            "<code>table</code>: table to group and index<br>",
                            "<code>key</code>: column name(s) to group on<br>",
                            "<code>newColumnName</code>: name of the index column appended<br><br>",
                            
                            "<b>Returns:</b><br>",
                            "The source table with one index column appended. The index column starts at 0, increments by 1."
                        },
                        " "
                    	),
                    Documentation.Examples = {
                        [
                            Description = "Basic example",
                            Code = 
								Text.Combine(
									{
										"Table_AddGroupIndex(#(lf)",
										"  #table(type table#(lf)",
										"    [One=text, Two=text, Val=number],#(lf)",
										"    {#(lf)",
										"      {""A"", ""A"", 1},#(lf)",
										"      {""A"", ""A"", 2},#(lf)",
										"      {""A"", ""B"", 1},#(lf)",
										"      {""B"", ""B"", 5}#(lf)",
										"    }#(lf)",
										"  ),#(lf)",
										"  {""One"", ""Two""},#(lf)",
										"  ""OneTwoKey""#(lf))"
									}
								),
                            Result = 
								Text.Combine(
									{
										"#table(type table#(lf)",
										"  [One=text, Two=text, Val=number, OneTwoKey=number],#(lf)",
										"  {#(lf)",
										"    {""A"", ""A"", 1, 0},#(lf)",
										"    {""A"", ""A"", 2, 0},#(lf)",
										"    {""A"", ""B"", 1, 1},#(lf)",
										"    {""B"", ""B"", 5, 2}#(lf)",
										"  }#(lf)",
										")"
									}
								)
                        ]
                    }
                ]
            in
                Value.ReplaceType(Main.Func, Main.Type meta Main.Docs),

    List_Combinations     = // –≥–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç –≤—Å–µ –Ω–µ–ø–æ–≤—Ç–æ—Ä—è—é—â–∏–µ—Å—è –∫–æ–º–±–∏–Ω–∞—Ü–∏–∏ —Ä–∞–∑–º–µ—Ä–æ–º combinationSize –∏–∑ —Å–ø–∏—Å–∫–∞
        /*
            –°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –≤—Å–µ –Ω–µ–ø–æ–≤—Ç–æ—Ä—è—é—â–∏–µ—Å—è –∫–æ–º–±–∏–Ω–∞—Ü–∏–∏ —Ä–∞–∑–º–µ—Ä–æ–º combinationSize –∏–∑ —Å–ø–∏—Å–∫–∞, 
			–∏–ª–∏ –µ—Å–ª–∏ —É–∫–∞–∑–∞–Ω–æ —Ç–æ–ª—å–∫–æ —Ä–∞–∑–º–µ—Ä, –≤—Å–µ –∫–æ–º–±–∏–Ω–∞—Ü–∏–∏ –Ω–µ–ø–æ–≤—Ç–æ—Ä—è—é—â–∏—Ö—Å—è –∏–Ω–¥–µ–∫—Å–æ–≤ –æ—Ç 0 –¥–æ (—Ä–∞–∑–º–µ—Ä - 1).
			–ï—Å–ª–∏ –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª–µ–Ω —Å–ø–∏—Å–æ–∫, —Å–æ–¥–µ—Ä–∂–∞—â–∏–π –¥—É–±–ª–∏–∫–∞—Ç—ã, –æ–Ω–∏ –±—É–¥—É—Ç –≤–∫–ª—é—á–µ–Ω—ã –≤ –ø–æ–¥–º–Ω–æ–∂–µ—Å—Ç–≤–∞ –∫–æ–º–±–∏–Ω–∞—Ü–∏–π.

			generate all non-repeating combinations of size 'combinationSize' from a list, or if only a size is provided,
            all combinations of non-repeating indexes from 0 to (size - 1)
            
            if a list containing duplicates is provided, they will be carried through to the subset combinations
            
            @name List_Combinations
            @categories list
            @author https://github.com/AnHerbWorm
            @source https://github.com/AnHerbWorm/DataAnalysis/tree/main/powerquery
            @result list of combinations (as lists)
        */
        let
            Main.Func = (setOrSize as anynonnull, combinationSize as number) as list =>
                let
                    SetSize = if setOrSize is number then setOrSize else List.Count(setOrSize),
                    Set = {0..SetSize-1},

                    MakeCombins = (n as number, set as list) as list =>
                        if n = 0 then
                            {{}}
                        else if List.Count(set) = 0 then
                            {}
                        else
                            List.Transform(@MakeCombins(n - 1, List.Skip(set, 1)), each {set{0}} & _)
                            &
                            @MakeCombins(n, List.Skip(set, 1)),
                    
                    Combins = MakeCombins(combinationSize, Set),
                    CombinValues = List.Transform(
                            Combins,
                            (innerList) => List.Transform(innerList, each setOrSize{_})
                        )
                in
                    if setOrSize is list then CombinValues else Combins,

            Main.Type = Type.ForFunction(
                [
                    ReturnType = type list,
                    Parameters = [
                        setOrSize = type anynonnull meta [
                            Documentation.FieldCaption = "list or size of list"
                        ],
                        combinationSize = type number meta [
                            Documentation.FieldCaption = "the size of each combination subset"
                        ]
                    ]
                ],
                2
            ),
            Main.Docs = [
                Documentation.Name = "List.Combinations",
                Documentation.LongDescription = Text.Combine(
                    {
                        "Generate a list of non-repeating combination subsets of length <code>combinationSize</code> from the",
                        "set. If <code>setOrSize</code> is an integer, a list of index positions will be generated, otherwise",
                        "combinations from the input list will be created.<br>",

                        "The function will generate nCr # of combinations, which can be calculated in Power Query as",
                        "<code>Number.Combinations(List.Count(set), combinationSize)</code><br><br>",

                        "<b>Args:</b><br>",
                        "<code>setOrSize</code>: list, or integer set size, to create combinations of",
                        "<code>combinationSize</code>: number of elements in each combination subset<br>",
                        
                        "<b>Returns:</b><br>",
                        "A list of all non-repeating combinations of length <code>combinationSize</code> from the source list",
                        "of if an integer <code>setOrSize</code> was provided, a list of all non-repeating index combinations",
                        "from 0 to <code>setOrSize - 1</code>."
                    },
                    " "
                ),
                Documentation.Examples = {
                    [
                        Description = "Subsets of 4 from ABCDE (5 choose 4)",
                        Code 		= "List_Combinations({""A"", ""B"", ""C"", ""D"", ""E""}, 4)",
                        Result 		= "{#(lf)  {""ABCD""},#(lf)  {""BCDE""}#(lf)}"
                    ],
                    [
                        Description = "Subsets of 2 from 4 possible values (4 choose 2)",
                        Code 		= "List_Combinations(4, 2)",
                        Result 		= "{#(lf)  {0,1},#(lf)  {0,2},#(lf)  {0,3},#(lf)  {1,2},#(lf)  {1,3},#(lf)  {2,3}#(lf)}"
                    ]
                }
            ]
        in
            Value.ReplaceType(Main.Func, Main.Type meta Main.Docs)
	],
Grech  	   = [ // https://github.com/SpyrosMauro/PowerQuery-Functions/blob/master - —Å–ª–æ–∂–Ω—ã–µ –∏ –ø–æ–∫–∞ –Ω–µ –∑–Ω–∞—é, –≥–¥–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å
	/*
		---------------------------------------------------------------------------------------------------------------
		Function						Description
		---------------------------------------------------------------------------------------------------------------
		Table.CombineMultipleColumns	For double headers. Combine columns by any setSize in one step.
		Table.DistinctMerge				Combines two tables based on duplicate keys keeping only one item per row.
		Table.GenerateColumns			To add multiple columns based on similar functions.
										Have you thought about just unpivoting and adding one column afterwards?
		Table.InferColumnTypes			Infer column types.
										Supply a tableName to get back code as text.
		Table.ReplaceValuesFromTable	Optimised mass replace values in columns.
		Table.ToTableView				Automatically apply a Table.View function based on Table.Schema
		---------------------------------------------------------------------------------------------------------------
		*/
	// 	Table
		Table.CombineMultipleColumns = 
			let
				// Function
				TableCombineMultipleColumnsFunction = (table as table, optional skipStart as nullable number, optional skipEnd as nullable number, optional setSize as number, optional combiner as function, optional delimiter as nullable text, optional columnNameDelimiter as nullable text) as table =>
					let
						// 	Define things
							Names = List.RemoveLastN(Table.ColumnNames(table), skipEnd??0),
							groupSize = setSize??2,
							sep = delimiter??", ",
							afterN = skipStart??0,
							columnDelimiter = columnNameDelimiter??" & ",
						
						// 	Define Helper Functions
							TextCombiner = combiner??((x) => 
								let
									t = Text.AfterDelimiter( List.Accumulate(x, "", (s,c) => s & sep & (Text.From(c)??"" ) ), sep )
								in
									if t = sep then null else t),

						GetK = (k) => List.Accumulate(List.Range(Names, k, groupSize), {}, (s, c) =>  s & {c}),
						ColumnNameGenarator = 
							(l as list) as text => 
								Text.AfterDelimiter(
									List.Accumulate(l, "", (s, c) => s & columnDelimiter & c), 
									columnDelimiter
								),

						// Error Handling
						CheckValues = [
							Check = (skipEnd??0)<0 or (setSize??2) <2 or (skipStart??0)<0, 
							Error = error 
								[Reason = "Incorrect values",
								Message = "Please supply positive values for skipStart and skipEnd and a setSize >= 2",
								Detail = [#"Skip Start" = skipStart, #"Skip End" = skipEnd, #"Set Size" = setSize]]
						],
						
						// Generate a list of the columns to be combined
						CombineList = List.Generate( () => [N = GetK(afterN), k = groupSize+afterN], each [k]-groupSize<List.Count(Names), each [N = GetK([k]), k = [k] + groupSize], each [N]),

						// Recursively combine columns. If in the end they're less, they will still be combined
						CombineColumns = (table, CombineList, k) => if List.IsEmpty(CombineList) then table else @CombineColumns(Table.CombineColumns(table, CombineList{0}, TextCombiner, ColumnNameGenarator(CombineList{0})), List.RemoveFirstN(CombineList, 1), k+1),
						
						Result = if CheckValues[Check] then CheckValues[Error] else CombineColumns(table, CombineList, 0)
					in
						Result,
					

				// Documentation
				TableCombineMultipleColumnsType = 
					type function (
						table as (type table meta [
							Documentation.FieldCaption ="Target table",
							Documentation.FieldDescription = "The target table"
							]),
						optional skipStart as (type nullable number meta [
							Documentation.FieldCaption ="Skip first N",
							Documentation.FieldDescription = "Number of columns to skip from start"
							]),
						optional skipEnd as (type nullable number meta [
							Documentation.FieldCaption ="Skip last N",
							Documentation.FieldDescription = "Number of columns to skip from end"
							]),
						optional setSize as (type nullable number meta [
							Documentation.FieldCaption ="Group size",
							Documentation.FieldDescription = "Number of columns combine together"
							]),
						optional combiner as (type function meta [
							Documentation.FieldCaption ="Combiner Function",
							Documentation.FieldDescription = "Optional Combiner"
							]),
						optional delimiter as (type nullable text meta [
							Documentation.FieldCaption ="Delimiter",
							Documentation.FieldDescription = "Delimiter to use when combining columns"
							]),
						optional columnNameDelimiter as (type nullable text meta [
							Documentation.FieldCaption ="Column Delimiter",
							Documentation.FieldDescription = "Delimiter to use when combining column names"
							])
					)
					as table meta
					[
						Documentation.Name = "Table.CombineMultipleColumns",
						Documentation.Description = "Combines multiple columns at once using group size",
						Documentation.LongDescription = "Combines multiple columns at once using an optional <code>Group size</code>. Default group size is 2. If there are trailing columns less than <code>Group size</code> they will be combined in a smaller group.",
						Documentation.Category = "Table",
						Documentation.Author = "Spyros Mavroforos",
						Documentation.Source = "https://github.com/SpyrosMauro/powerquery",
						Documentation.Version = "1",
						Documentation.Examples = {[
							Description = "Combine all columns by 2",
							Code = "let
									StartingTable =
										Table.FromRecords({
											[a = 1, b = 2],
											[a = 2, b = 2],
											[a = 3, b = 4],
											[a = 4, b = 5]
										})
								in
									Table.CombineMultipleColumns( StartingTable )",
							Result = "Table.FromRecords({
									[#""a & b"" = 1, 2],
									[#""a & b"" = 2, 2],
									[#""a & b"" = 3, 4],
									[#""a & b"" = 4, 5]
								})"
							],[
								Description = "Combine all columns by 2, adding them",
								Code = "let
											StartingTable =
												Table.FromRecords({
													[a = 1, b = 2],
													[a = 2, b = 2],
													[a = 3, b = 4],
													[a = 4, b = 5]
												})
										in
											Table.CombineMultipleColumns( StartingTable, null, null, null, List.Sum )",
								Result = "Table.FromRecords({
											[#""a & b"" = 3],
											[#""a & b"" = 4],
											[#""a & b"" = 7],
											[#""a & b"" = 9]
										})"
							],[
								Description = "Combine all columns by 2, skipping first 2",
								Code = "let
											StartingTable =
												Table.FromRecords({
													[a = 1, b = 2, c = ""apple"", d=  ""banana""],
													[a = 1, b = 2, c = ""cherry"", d=  ""chocolate""],
													[a = 1, b = 2, c = ""chocolate"", d=  ""banana""],
													[a = 1, b = 2, c = """", d=  ""banana""]
												})
										in
											Table.CombineMultipleColumns( StartingTable, 2 )",
								Result = "Table.FromRecords({
										[a = 1, b = 2, #""c & d"" = ""apple, banana""],
										[a = 1, b = 2, #""c & d"" = ""cherry, chocolate""],
										[a = 1, b = 2, #""c & d"" = ""chocolate, banana""],
										[a = 1, b = 2, #""c & d"" = "", banana""]
									})"
							]}
					]

			in
				Value.ReplaceType(TableCombineMultipleColumnsFunction, TableCombineMultipleColumnsType),
		Table.DistinctMerge 	= 
			let
				// Function
				TableDistinctMergeFunction = (table1 as table, key1 as list, table2 as table, key2 as list, optional expandColumns as list, optional prefix as text, optional joinKind as number) as table =>
					let
						//Define combiner
						combiner =
						let
							fn = (x) => List.Zip( { x{0}??{}, x{1}??{} } )
						in
							if (joinKind??JoinKind.LeftOuter) = JoinKind.LeftOuter
								then (x) => List.FirstN( fn(x), x{2} )
							else if joinKind = JoinKind.RightOuter
								then (x) => List.FirstN( fn(x), x{3} )
							else if joinKind = JoinKind.Inner
								then (x) => List.FirstN( fn(x), List.Min( { x{2}, x{3} } ) )
							else if joinKind = JoinKind.LeftAnti
								then (x) => List.Select( fn(x), (y) => y{1}? = null )
							else if joinKind = JoinKind.RightAnti
								then (x) => List.Select( fn(x), (y) => y{0}? = null )
							else fn,

						table1columns = Table.ColumnNames(table1),
						table2Columns = expandColumns??Table.ColumnNames(table2),
						newTable2Columns =
							if prefix = null then
								let
									names = List.Union({List.Intersect({key1, key2}), List.Intersect({table1columns, table2Columns})}),
									fixNames = if names <> {}
										then List.ReplaceMatchingItems(table2Columns, List.Transform(names, each {_, Text.Combine({_, ".1"})}))
										else table2Columns
								in
									fixNames
							else List.Transform(table2Columns, each Text.Combine({prefix, ".", _})),
						joinKindfixed =
							if joinKind = JoinKind.LeftAnti or joinKind = null then JoinKind.LeftOuter
							else if joinKind = JoinKind.RightAnti then JoinKind.RightOuter
							else joinKind,


						GroupTable1 = Table.Group(table1, key1, {{"tableList1", Table.ToRecords, type list}, {"tableCount1", Table.RowCount, Int64.Type}}),
						GroupTable2 = Table.Group(Table.SelectColumns(table2, List.Union({table2Columns, key2})), key2, {{"tableList2", Table.ToRecords, type list}, {"tableCount2", Table.RowCount, Int64.Type}}),

						MergeTables = Table.ExpandTableColumn(Table.NestedJoin(GroupTable1, key1, GroupTable2, key2, "Data", joinKindfixed), "Data", {"tableList2", "tableCount2"}, {"tableList2", "tableCount2"}),

						MagicallyCombine = Table.CombineColumns(MergeTables,
							{"tableList1", "tableList2", "tableCount1", "tableCount2"},
							combiner,
							"Combined"),
						ExpandData =
							let
								combinedColumn = 
									let c = Table.ExpandListColumn(MagicallyCombine, "Combined")[#"Combined"]
									in if (joinKind??JoinKind.LeftOuter) <> joinKindfixed then List.RemoveNulls(c) else c,
								ExpandList = Table.FromList(combinedColumn, (x) => x, {"Table1 Data", "Table2 Data"}),
								#"Table1 Data" = Table.ExpandRecordColumn(ExpandList, "Table1 Data", table1columns, table1columns)
							in
								Table.ExpandRecordColumn(#"Table1 Data", "Table2 Data", table2Columns, newTable2Columns),

						fixTypes = 
							let
								table1type = Value.Type(table1),
								table2type = Value.Type(Table.RenameColumns(Table.SelectColumns(table2, table2Columns), List.Zip({table2Columns, newTable2Columns}))),
								table1record = Record.FromList(List.Transform(table1columns, each [ Type = Type.TableColumn(table1type, _), Optional = false ]), table1columns),
								table2record = Record.FromList(List.Transform(newTable2Columns, each [ Type = Type.TableColumn(table2type, _), Optional = false ]), newTable2Columns),

								newTableType = type table Type.ForRecord(table1record & table2record, false)
							in
								Value.ReplaceType(ExpandData, newTableType)
					in
						fixTypes,


				// Documentation
				TableDistinctMergeFromTableType = 
					type function (
						table1 as (type table meta [
							Documentation.FieldCaption ="Left side table",
							Documentation.FieldDescription = "The table on the left side of the merge"
							]),
						key1 as (type {text} meta [
							Documentation.FieldCaption ="Left side key",
							Documentation.FieldDescription = "Columns use as key on the left table."
							]),
						table2 as (type table meta [
							Documentation.FieldCaption ="Right side table",
							Documentation.FieldDescription = "The table on the left side of the merge"
							]),
						key2 as (type {text} meta [
							Documentation.FieldCaption ="Right side key",
							Documentation.FieldDescription = "Columns use as key on the right table."
							]),
						optional expandColumns as (type {text} meta [
							Documentation.FieldCaption ="Columns to expand",
							Documentation.FieldDescription = "The columns to expand after merge"
							]),
						optional prefix as (type text meta [
							Documentation.FieldCaption ="prefix",
							Documentation.FieldDescription = "prefix to be used on new column names"
							]),
						optional joinKind as (JoinKind.Type)
						)
					as table meta
					[
						Documentation.Name = "Table.DistinctMerge",
						Documentation.Description = "Combines two tables based on duplicate keys keeping only one item per row",
						Documentation.LongDescription = "To be used when trying to combine two tables where both sides have duplicates but one wouldn't like to assign more than one value to each row.<p><code>Table.DistinctMerge</code> takes each duplicate key and uses an injective function based solely on row positions:<p><i>Example:</i><p><table><tr><td>key | </td><td>table1 | </td><td>table2</td><td></td><td></td><td>=>  </td><td>key | </td><td>table1&amp;2</td></tr><tr><td>x</td><td>[...]</td><td>[...]</td><td></td><td></td><td>}  </td><td> x</td><td>[...] &amp; [...]</td></tr><tr><td>x</td><td>[...]</td><td>[...]</td><td></td><td></td><td>}  </td><td> x</td><td>[...] &amp; [...]</td></tr><tr><td>x</td><td>[...]</td><td>[...]</td><td></td><td></td><td>}  </td><td> x</td><td>[...] &amp; [...]</td></tr><tr><td>x</td><td></td><td>[...]</td><td></td><td></td><td></td><td></td><td></td></tr></table>",
						Documentation.Category = "Table",
						Documentation.Author = "Spyros Mavroforos",
						Documentation.Source = "https://github.com/SpyrosMauro/powerquery",
						Documentation.Version = "1",
						Documentation.Examples = {[
							Description = "Force a distinct merge of those two",
							Code = "let
								StartingTable =
									Table.FromRecords({
										[a = ""a"", b = 2],
										[a = ""b"", b = 2],
										[a = ""c"", b = 3],
										[a = ""d"", b = 3]
									}),

								OtherTable = 
									Table.FromRecords({
										[check = 2, ID = ""A""],
										[check = 2, ID = ""B""],
										[check = 3, ID = ""C""],
										[check = 3, ID = ""D""]
									})
							in
								Table.DistinctMerge(StartingTable, {""b""}, OtherTable, {""check""})",
											Result = "Table.FromRecords({
										[a = ""a"", b = 2, check = 2, ID = ""A""],
										[a = ""b"", b = 2, check = 2, ID = ""B""],
										[a = ""c"", b = 3, check = 3, ID = ""C""],
										[a = ""d"", b = 3, check = 3, ID = ""D""]
									})"
											]}
									]

			in
				Value.ReplaceType(TableDistinctMergeFunction, TableDistinctMergeFromTableType),
		Table.GenerateColumns 	= 
			let
				// Function
				TableGenerateColumnsFunction = (table as table, columns as list, newName as function, forEach as function, optional newColumnType as type) =>
					let
						// Helper Functions
						// functionParameterCount
						functionparameterCount = (f as function) as number => Record.FieldCount(Type.FunctionParameters(Value.Type(f))),

						nameGeneratorParameterCount = functionparameterCount(newName),
						forEachParameterCount = functionparameterCount(forEach),
						columnCount = List.Count(columns),


						newNameList =
							let newList = if nameGeneratorParameterCount = 2
								then List.Transform(List.Zip({columns, {1..columnCount}}), each newName(_{0}, _{1}))
								else List.Transform(columns, newName)
							in Value.ReplaceType(newList, type {text}),

						recordGenerator =
							if forEachParameterCount = 2 then
								(rec) =>
								Record.FromList(
									List.Transform(List.Zip({columns, {1..columnCount}}), (c) => Function.Invoke(forEach, {
										Record.Combine({rec,
											[_ = [Value = Record.Field(rec, c{0}),
											Name = c{0}]]}),
											c{1}})),
									newNameList
									)
							else (rec) =>
								Record.FromList(
									List.Transform(columns, (c) => Function.Invoke(forEach, {
										Record.Combine({rec,
											[_ = [Value = Record.Field(rec, c),
											Name = c]]})})),
									newNameList
									),

						recordType =
							if newColumnType = null then type record
							else
								let listTypes = List.Transform({1..columnCount}, each [Type = newColumnType, Optional = false])
								in Type.ForRecord(Record.FromList(listTypes, newNameList), false),


						AddRecordColumn = Table.AddColumn(table, "__New Columns__",
							recordGenerator,
							recordType
							),

						ExpandNewColumns = Table.ExpandRecordColumn(AddRecordColumn, "__New Columns__", newNameList, newNameList)

						// Some error handling
						, Check = [
							tryList = try newNameList,
							Result =
								if tryList[HasError] then error [Reason= "Error in newName function", Message = tryList[Error][Message], Detail = tryList[Error][Detail]]
								else if List.IsDistinct(tryList[Value]) 
									then [Check = try ExpandNewColumns, 
										Res =
											if Check[HasError] then
												if Text.Contains(Check[Error][Message], "already exists in the record.")
													then error [Reason = "Expression.Error", Message = "Column '" & Check[Error][Detail][Name] & "' already exists in the table.", Detail= [Table = table]]
												else error Check[Error]
											else Check[Value]][Res]
								else error [Reason= "Error in newName function", Message = "Names generated are not distinct", Detail = [#"New names" = tryList[Value]]]
						]

					in
						Check[Result],
						

				// Documentation
				TableGenerateColumnsType = 
					type function (
						table as (type table meta [
							Documentation.FieldCaption ="Target Table",
							Documentation.FieldDescription = "The target table"
							]),
						columns as (type list meta [
							Documentation.FieldCaption = "Columns",
							Documentation.FieldDescription = "Columns used to generate new columns"
						]),
						newName as ((type function( _ as any ) as any ) meta [
							Documentation.FieldCaption = "New name function",
							Documentation.FieldDescription = "Name generator"
						]),
						forEach as ((type function( _ as any ) as any ) meta [
							Documentation.FieldCaption = "New column function",
							Documentation.FieldDescription = "Column generator"
						]),
						optional newColumnType as ((type type) meta [
							Documentation.FieldCaption = "newColumnType",
							Documentation.FieldDescription = "Type of new columns"
							])
					)
					as table meta
					[
						Documentation.Name = "Table.GenerateColumns",
						Documentation.Description = "Generates multiple columns",
						Documentation.LongDescription = "Generates multiple columns using a name generator and a column generator. Use <code>[_][Value]</code> for current column value and <code>[_][Name]</code> for current column name.<p><i>Note: If a column named <code>_</code> already exists in the table it won't work.</i>",
						Documentation.Category = "Table",
						Documentation.Author = "Spyros Mavroforos",
						Documentation.Source = "https://github.com/SpyrosMauro/powerquery",
						Documentation.Version = "1",
						Documentation.Examples = {[
							Description = "Generate columns named <code>""Start of Month *""</code>",
							Code = "let
										StartingTable =
											Table.FromRecords({
												[id = 1, DateCreated = #date(2020,6,30), DateResolved = #date(2020, 6, 30)],
												[id = 1, DateCreated = #date(2020,5,25), DateResolved = #date(2020, 6, 12)],
												[id = 1, DateCreated = #date(2020,2,1), DateResolved = #date(2020, 7, 3)]
											})
									in
										Table.GenerateColumns ( StartingTable, {""DateCreated"", ""DateResolved""}, (t) => ""Start of Month"" & t, each Date.StartOfMonth([_][Value]) )",
													Result = "Table.FromRecords({
										[id = 1, DateCreated = #date(2020,6,30), DateResolved = #date(2020, 6, 30), #""Start of Month DateCreated"" = #date(2020,6,1), #""Start of Month DateResolved"" = #date(2020, 6, 1)],
										[id = 1, DateCreated = #date(2020,5,25), DateResolved = #date(2020, 6, 12), #""Start of Month DateCreated"" = #date(2020,5,1), #""Start of Month DateResolved"" = #date(2020, 6, 1)],
										[id = 1, DateCreated = #date(2020,2,1), DateResolved = #date(2020, 7, 3), #""Start of Month DateCreated"" = #date(2020,2,1), #""Start of Month DateResolved"" = #date(2020, 7, 1)]
									})"
												],[
													Description = "Generate columns based on same Column",
													Code = "let
										StartingTable = #table({""a""}, {{10}})
									in
										Table.GenerateColumns ( StartingTable, {""a"", ""a"", ""a""}, (t, k) => t & ""*"" & Text.From(k*10), (rec, k) => rec[_][Value] * k * 10 )",
													Result = "Table.FromRecords({
										[a = 10, #""a*10"" = 100, #""a*20"" = 200, #""a*30"" = 300]
									})"
												]}
											]
			in
				Value.ReplaceType(TableGenerateColumnsFunction, TableGenerateColumnsType),
		Table.InferColumnTypes 	= 
			let
				// Function
				TableInferColumnTypesFunction = (table as table, optional columns as list, optional precision as number, optional applyOnlyNormalTypes as logical, optional tableName as text) as any =>
					let
						// Helper Functions
						// typeFinder: finds the main type of a list
						typeFinder = (x as list, optional crazyMode as logical) =>
							let
								startingList = List.Select(x, each _ <> type any),
								listMode = List.Mode(startingList),
								listDistinct = List.Distinct(startingList),
								countDistinct = List.Count(listDistinct),
								removeInts = List.RemoveItems(listDistinct, {Int64.Type, Int32.Type, Int8.Type})
							in
							if countDistinct = 0 then type any
							else if countDistinct = 1 then listDistinct{0}
							// Five extra steps here for abstract types
							else if List.AllTrue(List.Transform(listDistinct, each Type.Is(_, type number))) then type number
							else if List.AllTrue(List.Transform(listDistinct, each Type.Is(_, type [...]))) then type nullable [...]
							else if List.AllTrue(List.Transform(listDistinct, each Type.Is(_, type table))) then type nullable table
							else if List.AllTrue(List.Transform(listDistinct, each Type.Is(_, type list))) then type nullable list
							else if List.AllTrue(List.Transform(listDistinct, each Type.Is(_, type function))) then type nullable function
							/* // crazyMode is just for testing. Really, it just tries to assign the type found the most in the list. Don't use that.
							else if crazyMode??false then listMode */
							else if countDistinct = 2 then
								if List.Contains(listDistinct, type text) then type text
								else if List.ContainsAll(listDistinct, {type date, type datetime}) then type datetime
								else if List.ContainsAll(listDistinct, {type date, type datetimezone}) then type datetimezone
								else if List.ContainsAll(listDistinct, {type datetime, type datetimezone}) then type datetimezone
								else if removeInts{0}? = type duration then type duration
								else type any
							else if countDistinct = 3 then
								if List.ContainsAll(listDistinct, {type datetimezone, type datetime, type date}) then type datetimezone
								else if removeInts = {} then Int64.Type
								else type any
							else  type any,

						// checkInt
						checkInt = (x as number) as type => if (Number.Mod(x, 1)??0) = 0 then Int64.Type else type number,
						// replaceWithType: custom replacer
						replaceWithType = (x,y,z) =>
							let
								// nulls were a bother. Now Completely removed.
								typ = if (x??"") = "" then type any else Value.Type(x)
							in
								if Type.Is(typ, type number) then checkInt(x)
								// next step is for excel and other sources which store time as '31/12/1899 hh:mm:ss'. Thankfully, pq also sees this as time if Time.From is used
								else if Type.Is(typ, type datetime) then if Date.From(DateTime.From(x))=#date(1899,12,31) then type time else type datetime
								else if Type.Is(typ, type text) then
									if not (try Logical.FromText(x))[HasError] then type logical
									else if not (try Number.FromText(x))[HasError] then checkInt(Number.From(x))
									else if not (try Time.FromText(x))[HasError] then type time
									else if not (try Date.FromText(x))[HasError] then type date
									else if not (try DateTime.FromText(x))[HasError] then type datetime
									else if not (try DateTimeZone.FromText(x))[HasError] then type datetimezone
									else if not (try Duration.FromText(x))[HasError] then type duration
									else type text
								else typ,

						// typeToText
						typeToText = (typ as type, optional prim as logical) => let schema = Type.TableSchema(type table [a = typ]){0} in if prim??false then schema[Kind] else schema[TypeName],

						// Not allowed types
						typeList = { type null, type function, type list, type record, type table, type type },
						excludeTypes = (t as any) as logical => List.AllTrue(List.Transform(typeList, each not Type.Is(t, _))),

						// fakeFunction: takes a type and makes a function that returns this type, to be used for non appliable types
						// when Table.TransformColumnTypes is able to ascribe these 6 types then it will be redundant
						fakeFunction = (Type as type) as function =>
							if Type.Is(Type, type null) then (x) as null => null
							else if Type.Is(Type, type function) then (x) as nullable function => x
							else if Type.Is(Type, type list) then (x) as nullable list => x
							else if Type.Is(Type, type record) then (x) as nullable record => x
							else if Type.Is(Type, type table) then (x) as nullable table => x
							else if Type.Is(Type, type type) then (x) as nullable type => x
							else (x) => x,


						// Get types
						bufferTable = Table.Buffer(table),
						rowsToGet = List.Min({Table.RowCount(bufferTable), precision??500, 1000}),
						firstN = Table.FirstN((if columns = null then bufferTable else Table.SelectColumns(bufferTable, columns)), rowsToGet),
						columnNames = columns??Table.ColumnNames(firstN),

						tableValuesToType = Table.ReplaceValue(firstN, null, null, replaceWithType, columnNames),
						FindBestType = Table.CombineColumns(
							Table.Transpose(tableValuesToType),
							List.Transform({1..rowsToGet}, each "Column"&Text.From(_)),
							typeFinder,
							"Types"
							),
						
						// Apply transformations
						allTransformations = List.Zip({columnNames, FindBestType[Types]}),
						applicableTransformations = List.Select(allTransformations,
							each excludeTypes( _{1} )),
						applySimpleTransformations = if applicableTransformations <> {} then Table.TransformColumnTypes(bufferTable, applicableTransformations) else bufferTable,
						
						applyAllList = List.Transform(List.RemoveItems(allTransformations, applicableTransformations), each {_{0}, fakeFunction(_{1}), _{1}}),
						applyOthers = if applyAllList <> {} then Table.TransformColumns(applySimpleTransformations, applyAllList) else applySimpleTransformations,

						textCode = let
							normalTypes = "Table.TransformColumnTypes( " & Expression.Identifier(tableName) & ", { "
								& Text.Combine( List.Transform( applicableTransformations, each "{ """ & _{0} & """, " & typeToText(_{1}) & " }" ), ", " )
								& " } )",
							abnormalTypes = Text.Combine( List.Transform( applyAllList, each  "{ """ & _{0} & """, (x) as nullable " & typeToText(_{2}, true) & " => x , type nullable " & typeToText(_{2}, true) & " }" ), ", " )
								& " } )"
							in if applicableTransformations <> {} and applyAllList <> {} then
									"let#(lf)#(tab)" & "normalTypes = " & normalTypes
									& ",#(lf)#(tab)abnormalTypes = Table.TransformColumns( normalTypes, { " & abnormalTypes
									& "#(lf)in#(lf)#(tab)abnormalTypes"
								else if applicableTransformations <> {} then normalTypes
								else if applyAllList <> {} then  "Table.TransformColumns( "& Expression.Identifier(tableName) &", { " & abnormalTypes
								else null,

						Result = if tableName <> null then textCode else if applyOnlyNormalTypes??false then applySimpleTransformations else applyOthers
					in
						Result,


				// Documentation
				TableInferColumnTypesType =
					type function (
						table as (type table meta [
							Documentation.FieldCaption = "Target table",
							Documentation.FieldDescription = "The table to make type replacements"
							]),
						optional columns as (type list meta [
							Documentation.FieldCaption = "Columns",
							Documentation.FieldDescription = "The columns to make type replacements"
							]),
						optional precision as (type number meta [
							Documentation.FieldCaption = "precision",
							Documentation.FieldDescription = "First <code>n</code> rows to check for best type match. Default: <code>500<c/ode>."
							]),
						optional applyOnlyNormalTypes as (type logical meta [
							Documentation.FieldCaption = "applyOnlyNormalTypes",
							Documentation.FieldDescription = "Switch to not do extra replacements for special types (e.g. type type). Default: <code>false</code>."
						]),
						optional tableName as (type text meta [
							Documentation.FieldCaption = "tableName",
							Documentation.FieldDescription = "Give a table name in case of text return."
						])
					)
					as any meta
					[
						Documentation.Name = "Table.InferColumnTypes",
						Documentation.Description = "Infers column types",
						Documentation.LongDescription = "Infers column types. Optional <code>precision</code>.<p>Supply a <code>tableName</code> to get back code as text.",
						Documentation.Category = "Table",
						Documentation.Author = "Spyros Mavroforos",
						Documentation.Source = "https://github.com/SpyrosMauro/powerquery",
						Documentation.Version = "1",
						Documentation.Examples = {[
							Description = "Infer table type",
							Code = "let
									StartTable = Table.FromRecords({
										[start = #datetime(2020,7,1,0,0,0), diff = #duration(0,15,0,0), list = {1}],
										[start = #datetime(2020,7,1,5,0,0), diff = #duration(0,16,0,0), list = null],
										[start = #datetime(2020,7,1,8,0,0), diff = #duration(1,0,0,0), list = {4}],
										[start = #datetime(2020,7,1,16,0,0), diff = #duration(0,8,0,0), list = {3,4}]
									})
								in
									Table.InferColumnTypes ( StartTable )",
												Result = "type table [
									#""start"" = DateTime.Type,
									#""diff"" = Duration.Type,
									#""list"" = List.Type
								]"
											],[
												Description = "Infer table type",
												Code = "let
									startTable = #table(
										{""n"", ""fun"", ""rec"", ""tb"", ""l"", ""bin"", ""typ""},
										{{1, (x) => x, [a = 1], #table({""a""}, {{1}}), {1..3}, #binary(""""), type text}}
										)
								in
									Table.InferColumnTypes ( StartTable )",
												Result = "type table [
									#""n"" = Int64.Type,
									#""fun"" = Function.Type,
									#""rec"" = Record.Type,
									#""tb"" = Table.Type,
									#""l"" = List.Type,
									#""bin"" = Binary.Type,
									#""typ"" = Type.Type
								]"
											],[
												Description = "get M code",
												Code = "let
									#""Start Table"" = #table(
										{""n"", ""fun"", ""rec"", ""tb"", ""l"", ""bin"", ""typ""},
										{{1, (x) => x, [a = 1], #table({""a""}, {{1}}), {1..3}, #binary(""""), type text}}
										)
								in
									Table.InferColumnTypes ( #""Start Table"" , null, null, null, ""Start Table"")",
												Result = """let
									normalTypes = Table.TransformColumnTypes( #""Start Table"", { { ""n"", Int64.Type }, { ""bin"", Binary.Type } } ),
									abnormalTypes = Table.TransformColumns( normalTypes, { { ""fun"", (x) as nullable function => x , type nullable function }, { ""rec"", (x) as nullable record => x , type nullable record }, { ""tb"", (x) as nullable table => x , type nullable table }, { ""l"", (x) as nullable list => x , type nullable list }, { ""typ"", (x) as nullable type => x , type nullable type }, { ""tb typ"", (x) as nullable type => x , type nullable type } } )
								in
									abnormalTypes"""
											]}
										]

			in 
				Value.ReplaceType(TableInferColumnTypesFunction, TableInferColumnTypesType),
		Table.ReplaceValuesFromTable = 
			let
				func = 
					(	table as table, 
						transformationTable as table, 
						optional columns as list, 
						optional specifyTransformationColumns as list, 
						optional missingField as nullable number) as table =>
					let
						// 	Buffer Transformation Table to call it only once
							BufferedTransformationTable = Table.Buffer(transformationTable),

						// 	Step to add error handling for given table & columns
							tryTransformationColumnNames = try
								let
									temp = Table.ColumnNames(BufferedTransformationTable),
									countTargetColumns = List.Count(temp),
									countSpecifiedColumns = try List.Count(specifyTransformationColumns) otherwise 0
								in
										 if countTargetColumns < 2 then error [Reason = "", Message = "The transformation table needs to have at least two columns", Detail = [TransformationColumns = temp] ]
									else if countSpecifiedColumns = 0 then {temp{0}, temp{1}}
									else if countSpecifiedColumns = 2 then
										let
											l = List.Intersect({specifyTransformationColumns, temp})
										in
											if List.Count(l) = 2 
											then l 
											else error  [Reason = "", Message = "The transformation table does not contain the 2 specified columns", Detail = [TransformationColumns = temp, SpecifiedColumns = specifyTransformationColumns] ]
									else error [Reason = "Error in specified transformation columns", Message = "Please specify exactly 2 columns", Detail = [SpecifiedColumns = specifyTransformationColumns ]],
						
							TransformationColumnNames = tryTransformationColumnNames[Value],

						// 	Define Replacer Function to trick Table.ReplaceValue
							CustomReplacer =
								(value as any, old as any, new as any) as any =>
									let
										getvalue = try
												Expression.Evaluate(
													"tbl{["
													& TransformationColumnNames{0}
													& " = t]}["
													& TransformationColumnNames{1}
													& "]",
													[ tbl = BufferedTransformationTable, t = value ]
												),
										newvalue = 
											if getvalue[HasError] then 
												if Text.Contains(getvalue[Error][Message], "The key matched more than one row in the table") then error [Reason = "An error occured in the Transformation Table", Message = "More than one replacements were found for the specified value", Detail = [ValueToReplace = value]]
												else if (missingField??1) = 0 then
													if Text.Contains(getvalue[Error][Message], "The key didn't match any rows in the table") then error [Reason = "An error occured in the Transformation Table", Message = "A replacement cannot be found for the specified value", Detail = [ValueToReplace = value]]
													else error getvalue[Error]
												else if (missingField??1) = 2 then null
												else value
											else getvalue[Value]
									in
										newvalue,

						// 	If table and columns ok, call Table.ReplaceValue
							Result = 
								if tryTransformationColumnNames[HasError] 
								then error tryTransformationColumnNames[Error] 
								else Table.ReplaceValue( table, null, null, CustomReplacer, columns??Table.ColumnNames(table) )
					in
						Result,
				types = 
					type function (
						table as (type table meta [
							Documentation.FieldCaption ="Target table",
							Documentation.FieldDescription = "The table to make replacements"
							]),
						transformationTable as (type table meta [
							Documentation.FieldCaption ="Transformation table",
							Documentation.FieldDescription = "The lookup table for replacements"
							]),
						optional columns as (type {text} meta [
							Documentation.FieldCaption ="Columns",
							Documentation.FieldDescription = "The columns in which to replace values"
							]),
						optional specifyTransformationColumns as (type {text} meta [
							Documentation.FieldCaption ="Transformation columns",
							Documentation.FieldDescription = "Columns to check on Transformation Table. If not specified, Column1 and Column2 are used."
							]),
						optional missingField as MissingField.Type
						)
					as table meta
					[
						Documentation.Name = "Table.ReplaceValuesFromTable",
						Documentation.Description = "Replaces multiple values at once using a lookup table",
						Documentation.LongDescription = "Replaces multiple values at once using a lookup table.<p>If no columns are specified for the <code>Transformation table</code>, the first column is used a a lookup and the second as a replacement. <p>If no columns are specified in the <code>Target table</code> then the default is <i>all columns</i>.",
						Documentation.Category = "Table",
						Documentation.Author = "Spyros Mavroforos",
						Documentation.Source = "https://github.com/SpyrosMauro/powerquery",
						Documentation.Version = "1",
						Documentation.Examples = {[
							Description = "Replace values on all columns",
							Code = "let
										StartingTable =
											Table.FromRecords({
												[a = 1, b = 2],
												[a = 2, b = 2],
												[a = 3, b = 4],
												[a = 4, b = 5]
											}),

										transformationTable = 
											Table.FromRecords({
												[check = 1, replace = ""A""],
												[check = 2, replace = ""B""],
												[check = 3, replace = ""C""],
												[check = 4, replace = ""D""]
											})
									in
										Table.ReplaceValuesFromTable(StartingTable, transformationTable)",
													Result = "Table.FromRecords({
												[a = ""A"", b = ""B""],
												[a = ""B"", b = ""B""],
												[a = ""C"", b = ""D""],
												[a = ""D"", b = 5]
											})"
													],[
													Description = "Replace values on column <code>a</code>",
													Code = "let
										StartingTable =
											Table.FromRecords({
												[a = 1, b = 2],
												[a = 2, b = 2],
												[a = 3, b = 4],
												[a = 4, b = 5]
											}),

										transformationTable = 
											Table.FromRecords({
												[check = 1, replace = ""A""],
												[check = 2, replace = ""B""],
												[check = 3, replace = ""C""],
												[check = 4, replace = ""D""]
											})
									in
										Table.ReplaceValuesFromTable(StartingTable, transformationTable, {""a""})",
													Result = "Table.FromRecords({
												[a = ""A"", b = 2],
												[a = ""B"", b = 2],
												[a = ""C"", b = 3],
												[a = ""D"", b = 5]
											})"
													],[
													Description = "Replace values on column <code>b</code> by using <code>Column2</code> column as lookup and <code>Column1</code> as replacement",
													Code = "let
										StartingTable =
											Table.FromRecords({
												[a = ""A"", b = ""B""],
												[a = ""B"", b = ""B""],
												[a = ""C"", b = ""D""],
												[a = ""D"", b = 5]
											}),

										transformationTable = 
											Table.FromRecords({
												[Column1 = 1, Column2 = ""A""],
												[Column1 = 2, Column2 = ""B""],
												[Column1 = 3, Column2 = ""C""],
												[Column1 = 4, Column2 = ""D""]
											})
									in
										Table.ReplaceValuesFromTable(StartingTable, transformationTable, {""b""}, {""replace"", ""check""}, MissingField.Error)",
												Result = "Table.FromRecords({
												[a = ""A"", b = 2],
												[a = ""B"", b = 2],
												[a = ""C"", b = 4],
												[a = ""D"", b = error [Reason = """", Message = ""A replacement cannot be found for the specified value"", Detail = [ValueToReplace = 5]]
											})"
												]}
											]

			in
				Value.ReplaceType(func, types),
		Table.ToTableView = 
			let
				// Function
				TableToTableViewFunction = (table as table, optional rowsToShow, optional primitive as logical, optional useOptimise as logical) as table =>
					let
						// Record with Types
						allTypes = [
							Any.Type = Any.Type,
							Binary.Type = Binary.Type,
							Byte.Type = Byte.Type,
							Character.Type = Character.Type,
							Currency.Type = Currency.Type,
							Date.Type = Date.Type,
							DateTime.Type = DateTime.Type,
							DateTimeZone.Type = DateTimeZone.Type,
							Day.Type = Day.Type,
							Decimal.Type = Decimal.Type,
							Double.Type = Double.Type,
							Duration.Type = Duration.Type,
							Function.Type = Function.Type,
							Guid.Type = Guid.Type,
							Int16.Type = Int16.Type,
							Int32.Type = Int32.Type,
							Int64.Type = Int64.Type,
							Int8.Type = Int8.Type,
							List.Type = List.Type,
							Logical.Type = Logical.Type,
							None.Type = None.Type,
							Null.Type = Null.Type,
							Number.Type = Number.Type,
							Password.Type = Password.Type,
							Percentage.Type = Percentage.Type,
							Record.Type = Record.Type,
							Single.Type = Single.Type,
							Table.Type = Table.Type,
							Text.Type = Text.Type,
							Time.Type = Time.Type,
							Type.Type = Type.Type,
							Uri.Type = Uri.Type
						],
						// addTabs: make text readable.
						addTabs = (t as text, optional tabsNumber as number) as text => Text.Replace ( t, "#(lf)", "#(lf)" & Text.Repeat("#(tab)", tabsNumber??1 ) ),

						// Not allowed types
						typeList = 
								if primitive??false then { "binary", "function", "list", "record", "table", "type" }
								else { "Binary.Type", "Function.Type", "List.Type", "Record.Type", "Table.Type", "Type.Type" },
						excludeTypes = (t as text) as logical => List.AllTrue(List.Transform(typeList, each t <> _)),

						typeToText = 
							if primitive??false then (x as list) as text => "#""" & x{0} &"""" & " = ( type " & x{1} & " )"
							else (x as list) as text => "#""" & x{0} &"""" & " = " & x{1},

						// Schema columns
						schemaColumns = if primitive??false then {"Name", "Kind"} else {"Name", "TypeName"},

						// Calculations
						fixTableName = "#""" & "" & """",

						schema = Table.SelectColumns(Table.Schema(table), schemaColumns),
						columnNames = schema[Name],

						findType = Table.SelectRows( schema, each excludeTypes( Record.Field(_, schemaColumns{1}) ) ),

						columnsToRemove = List.RemoveItems(columnNames, findType[Name]),
						removeColumns = List.Count(columnsToRemove) > 0,

						mainTableCall =
							let tbCall = 
								if removeColumns
									then "Table.RemoveColumns ( "& fixTableName & ", { " & Text.Combine(List.Transform(columnsToRemove, each """"&_&""""), ", ") & " } , MissingField.Ignore )"
								else fixTableName
							in
								if useOptimise??false then "Value.Optimize ( " & tbCall & " )" else tbCall,

						tableType =
								"type table [#(lf)#(tab)"
								& Text.Combine( Table.ToList( findType, typeToText ), ",#(lf)#(tab)" )
								& "#(lf)]",
						
						getType = "GetType = () =>#(lf)#(tab)" & addTabs(tableType),

						getRows = "GetRows = () =>#(lf)#(tab)" & addTabs(mainTableCall),
						
						onTake =
							let
								tbl = "#table (#(lf)#(tab)" & addTabs(tableType) & ",#(lf)#(tab){}#(lf))",
								countText = if rowsToShow = null then "count" else Text.From(rowsToShow),
								main =
									if rowsToShow = 0 then tbl
									else "if count = 0 then#(lf)#(tab)" & addTabs(tbl) & "#(lf)else Table.FirstN ( " & mainTableCall & ", " & countText & " )"
							in
								"OnTake = (count as number) =>#(lf)#(tab)" & addTabs(main),


						tableView =
							"Table.View (#(lf)#(tab)null,#(lf)#(tab)"
							& "[#(lf)#(tab)#(tab)" & addTabs(getType, 2)
							& ",#(lf)#(tab)#(tab)" & addTabs(getRows, 2)
							& ",#(lf)#(tab)#(tab)" & addTabs(onTake, 2) & "#(lf)#(tab)]" & "#(lf))",

						rec = 
						Record.Combine({
							[
								Table.View = Table.View,
								Table.FirstN = Table.FirstN,
								Table.RemoveColumns = Table.RemoveColumns,
								MissingField.Ignore = MissingField.Ignore,
								#"" = table
							],
							allTypes
						})
					in
					Expression.Evaluate(tableView, rec),


				// Documentation
				TableToTableViewType =
					type function (
						table as (type table meta [
							Documentation.FieldCaption = "Target table",
							Documentation.FieldDescription = "The table for which to generate <code>Table.View</code>"
							]),
						optional rowsToShow as (type number meta [
							Documentation.FieldCaption = "rowsToShow",
							Documentation.FieldDescription = "Show first n rows when asking for 1000"
							]),
						optional primitive as (type logical meta [
							Documentation.FieldCaption = "primitive",
							Documentation.FieldDescription = "Only primitive types"
							]),
						optional useOptimise as (type logical meta [
							Documentation.FieldCaption = "useOptimise",
							Documentation.FieldDescription = "Use Value.Optimize"
							])
					)
					as table meta
					[
						Documentation.Name = "Table.ToTableView",
						Documentation.Description = "Generates <code>Table.View</code> to trick model asking for evaluation",
						Documentation.LongDescription = "Executes <code>Table.View</code> to trick model asking for evaluation.<p>Creates <code>Table.View</code> based on <code>Table.Schema</code> and executes it.<p> <b>Skipping:</b> <i>Lists, Tables, Records, Binaries, Functions and Types</i>",
						Documentation.Category = "Table",
						Documentation.Author = "Spyros Mavroforos",
						Documentation.Source = "https://github.com/SpyrosMauro/powerquery",
						Documentation.Version = "1",
						Documentation.Examples = {[
							Description = "For examples of how this code is generated see:",
							Code = "Get.TableView",
							Result = "Expression.Evaluate of generated table view." ]}
					]

			in
				Value.ReplaceType(TableToTableViewFunction, TableToTableViewType),
	// 	Time Intelligence
		Duration.To 	= // –ø–µ—Ä–µ–≤–æ–¥ –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏ –≤ —Å–µ–∫—É–Ω–¥—ã, –º–∏–Ω—É—Ç—ã, ... –º–µ—Å—è—Ü—ã, –∫–≤–∞—Ä—Ç–∞–ª—ã, –≥–æ–¥—ã
			// DateTime Diff using Excluded Dates list and Start Time / End Time.
			let
				// Function
				DurationToFunction = (duration as nullable duration, durationTo as text) as nullable number =>
					let
						// durationTotal = Fix a Duration.TotalX function dependent on durationTo
						durationTotal = 
							let 
								d = Text.Lower(durationTo)
							in
									 if d = "seconds" 	then Duration.TotalSeconds
								else if d = "minutes" 	then Duration.TotalMinutes
								else if d = "hours" 	then Duration.TotalHours
								else if d = "days" 		then Duration.TotalDays
								else if d = "weeks" 	then (m) => Value.Divide(Duration.TotalDays(m), 7)
								else if d = "months" 	then (m) => Value.Divide(Duration.TotalDays(m), 30)
								else if d = "quarters" 	then (m) => Value.Divide(Duration.TotalDays(m), 121)
								else 						 (m) => Value.Divide(Duration.TotalDays(m), 365),

						Result = durationTotal(duration)
					in
						Result,


				// Documentation
				DurationToType =
					type function (
						duration as (type nullable duration meta [
							Documentation.FieldCaption = "duration",
							Documentation.FieldDescription = "duration to transform"
						]),
						durationTo as (type text meta [
							Documentation.FieldCaption = "Duration in",
							Documentation.FieldDescription = "Transform duration to",
							Documentation.AllowedValues = {"Seconds", "Minutes", "Hours", "Days", "Weeks", "Months", "Quarters", "Years"}
						])
					)
					as nullable number meta
					[
						Documentation.Name = "Duration.To",
						Documentation.Description = "All duration functions in one",
						Documentation.LongDescription = "Transforms a given <code>duration</code> to a given interval (<code>durationTo</code>).<p>Default values:<table>
								<tr>
									<td><i>Transformation</i></td>
									<td><i>Days</i></td>
								</tr>
								<tr>
									<td>Weeks</td>
									<td><code>7</code></td>
								</tr>
								<tr>
									<td>Months<br></td>
									<td><code>30</code></td>
								</tr>
								<tr>
									<td>Quarters</td>
									<td><code>121</code></td>
								</tr>
								<tr>
									<td>Years</td>
									<td><code>365</code></td>
								</tr>
							</table>",
						Documentation.Category = "Duration",
						Documentation.Author = "Spyros Mavroforos",
						Documentation.Source = "https://github.com/SpyrosMauro/powerquery",
						Documentation.Version = "1",
						Documentation.Examples = {[
							Description = "Duration to <code>months</code>",
							Code 		= "Duration.To(#duration(15,0,0,0), ""Months"")",
							Result 		= "0.5"
							]}
					]

			in
				Value.ReplaceType(DurationToFunction, DurationToType),
		DateTime.Diff 	= // DateTime Diff using Excluded Dates list and Start Time / End Time.
			let
				// Function
				DateTimeDiffFunction = (dateStart as nullable datetime, dateEnd as nullable datetime, optional excludedDays as list, optional timeStart as time, optional timeEnd as time) as nullable duration =>
					let
						// Helper Functions
						// dayIn: find relevant times in day
						dayIn = (timeStart, timeEnd) as list =>
							let
								times = { timeStart??#time(0,0,0) , timeEnd??#time(24,0,0) }
							in
								if times{0} >= times{1}
									then error [Reason= "Incorrect time limits", Message = "'Start time' must be smaller than 'End time'", Detail = [#"Start time" = timeStart, #"End time" = timeEnd]]
								else times,

						// dayDuration
						dayDuration = (times) as duration => ( #date(2020,1,1) & times{1} ) - ( #date(2020,1,1) & times{0} ),

						// findExcludedDuration: Find duration to exclude based on excludedDays
						findExcludedDuration = (dates as list, startDateTime as datetime, endDateTime as datetime, optional times as list) as duration =>
							let
								wholeDate = dayDuration(times),
								limitDurations = [
									check = startDate = endDate,
									start = (startDate & times{1} - startDateTime),
									end =  (endDateTime - (endDate & times{0})) ],
								result =
									if limitDurations[check] then List.Count(List.Select(dates, each _ = startDate)) * (endDateTime - startDateTime)
									else List.Accumulate(dates, #duration(0,0,0,0),
										(sum, current) =>
											if current < startDate or current > endDate then sum
											else if current = startDate then sum + limitDurations[start]
											else if current = endDate then sum + limitDurations[end]
											else sum + wholeDate )
							in
								result,
							

						// Start finding things
						// Sort datetimes and keep direction
						dateSort = List.Sort({dateStart, dateEnd}),
						direction = if (dateStart = dateSort{0}) then 1 else -1,

						// Find relevant times in day
						times = dayIn(timeStart, timeEnd),

						// Calculate date components to use
						startDate = DateTime.Date(dateSort{0}),
						endDate = DateTime.Date(dateSort{1}),

						// Truncate datetimes
						startDateTime = startDate & List.Median(times & {DateTime.Time(dateSort{0})}),
						endDateTime = endDate & List.Median(times & {DateTime.Time(dateSort{1})}),
						
						// Find duration
						calcDuration =
							let
								ExcludedDuration = findExcludedDuration(excludedDays??{}, startDateTime, endDateTime, times),
								AllDuration = endDateTime - startDateTime,
								NonWorkingDuration = Duration.Days(endDate - startDate) * (#duration(1,0,0,0) - dayDuration(times))
							in
								AllDuration - NonWorkingDuration - ExcludedDuration,
						fixDuration = calcDuration * direction,

						Result = if dateStart = null or dateEnd = null then null else fixDuration
					in
						Result,


				// Documentation
				DateTimeDiffType =
					type function (
						dateStart as (type nullable datetime meta [
							Documentation.FieldCaption = "Start date",
							Documentation.FieldDescription = "DateTime Start"
						]),
						dateEnd as (type nullable datetime meta [
							Documentation.FieldCaption = "End date",
							Documentation.FieldDescription = "DateTime End"
						]),
						optional excludedDays as (type {date} meta [
							Documentation.FieldCaption = "Excluded Dates",
							Documentation.FieldDescription = "A list of dates to exclude"
						]),
						optional timeStart as (type time meta [
							Documentation.FieldCaption = "Start time",
							Documentation.FieldDescription = "When a day starts counting"
						]),
						optional timeEnd as (type time meta [
							Documentation.FieldCaption = "End time",
							Documentation.FieldDescription = "When a day stops counting"
						])
					)
					as nullable duration meta
					[
						Documentation.Name = "DateTime.Diff",
						Documentation.Description = "Finds the difference between two datetimes",
						Documentation.LongDescription = "Finds the difference between two datetimes. Optional <code>'Excluded Dates'</code> list. Optional <code>'Start time'</code> and <code>'End time'</code>.",
						Documentation.Category = "Duration",
						Documentation.Author = "Spyros Mavroforos",
						Documentation.Source = "https://github.com/SpyrosMauro/powerquery",
						Documentation.Version = "1",
						Documentation.Examples = {[
							Description = "Diff using excluded date list",
							Code = "let
										StartingTable =
											Table.FromRecords({
												[start = #datetime(2020,7,1,0,0,0), end = #datetime(2020,7,2,15,0,0)],
												[start = #datetime(2020,7,1,5,0,0), end = #datetime(2020,7,2,19,0,0)],
												[start = #datetime(2020,7,1,8,0,0), end = #datetime(2020,7,2,16,0,0)],
												[start = #datetime(2020,7,1,16,0,0), end = #datetime(2020,7,3,7,0,0)]
											}),
										holidays = {#date(2020,7,2)}
									in
										Table.AddColumns( StartingTable, ""diff"", each DateTime.Diff( [end], [start], holidays ) )",
													Result = "Table.FromRecords({
										[start = #datetime(2020,7,1,0,0,0), end = #datetime(2020,7,2,15,0,0), diff = #duration(1,0,0,0)],
										[start = #datetime(2020,7,1,5,0,0), end = #datetime(2020,7,2,19,0,0), diff = #duration(19,0,0,0)],
										[start = #datetime(2020,7,1,8,0,0), end = #datetime(2020,7,3,16,0,0), diff = #duration(1,8,0,0)],
										[start = #datetime(2020,7,1,16,0,0), end = #datetime(2020,7,3,7,0,0), diff = #duration(0,15,0,0)]
									})"
						],[
							Description = "Diff using excluded date list and time limits",
							Code = "let
										StartingTable =
											Table.FromRecords({
												[start = #datetime(2020,7,1,0,0,0), end = #datetime(2020,7,2,15,0,0)],
												[start = #datetime(2020,7,1,5,0,0), end = #datetime(2020,7,2,19,0,0)],
												[start = #datetime(2020,7,1,8,0,0), end = #datetime(2020,7,2,16,0,0)],
												[start = #datetime(2020,7,1,16,0,0), end = #datetime(2020,7,3,7,0,0)]
											}),
										holidays = {#date(2020,7,2)}
									in
										Table.AddColumns( StartingTable, ""diff"", each DateTime.Diff( [end], [start], holidays, #time(8,0,0), #time(16,0,0) ) )",
													Result = "Table.FromRecords({
										[start = #datetime(2020,7,1,0,0,0), end = #datetime(2020,7,2,15,0,0), diff = #duration(0,8,0,0)],
										[start = #datetime(2020,7,1,5,0,0), end = #datetime(2020,7,2,19,0,0), diff = #duration(0,8,0,0)],
										[start = #datetime(2020,7,1,8,0,0), end = #datetime(2020,7,3,16,0,0), diff = #duration(0,16,0,0)],
										[start = #datetime(2020,7,1,16,0,0), end = #datetime(2020,7,3,7,0,0), diff = #duration(0,0,0,0)]
									})"
						],[
							Description = "Diff using time limits",
							Code = "
								let
									StartingTable =
										Table.FromRecords({
											[start = #datetime(2020,7,1,0,0,0), end = #datetime(2020,7,2,15,0,0)],
											[start = #datetime(2020,7,1,5,0,0), end = #datetime(2020,7,2,19,0,0)],
											[start = #datetime(2020,7,1,8,0,0), end = #datetime(2020,7,2,16,0,0)],
											[start = #datetime(2020,7,1,16,0,0), end = #datetime(2020,7,3,7,0,0)]
										})
								in
									Table.AddColumns( StartingTable, ""diff"", each DateTime.Diff( [end], [start], null, #time(8,0,0), #time(16,0,0) ) )",
												Result = "Table.FromRecords({
									[start = #datetime(2020,7,1,0,0,0), end = #datetime(2020,7,2,15,0,0), diff = #duration(0,15,0,0)],
									[start = #datetime(2020,7,1,5,0,0), end = #datetime(2020,7,2,19,0,0), diff = #duration(0,16,0,0)],
									[start = #datetime(2020,7,1,8,0,0), end = #datetime(2020,7,3,16,0,0), diff = #duration(1,0,0,0)],
									[start = #datetime(2020,7,1,16,0,0), end = #datetime(2020,7,3,7,0,0), diff = #duration(0,8,0,0)]
								})"
						]}
					]

			in
				Value.ReplaceType(DateTimeDiffFunction, DateTimeDiffType),

		Date.Diff 		= // Date Diff using Excluded Dates list.
			let
				// Function
				DateDiffFunction = (dateStart as nullable date, dateEnd as nullable date, optional excludedDays as list) as nullable duration =>
					let
						// Helper Functions
						// findExcludedDuration: Find duration to exclude based on excludedDays
						findExcludedDuration = 
							(dates as list, startDate as date, endDate as date) as duration =>
							let
								countDays = List.Count(List.Select(excludedDays??{}, each _>= startDate and _ <= endDate)),
								result = countDays * #duration(1,0,0,0)
							in
								result,
							
						// Start finding things
						// Sort dates and keep direction
						dateSort = List.Sort({dateStart, dateEnd}),
						direction = if (dateStart = dateSort{0}) then 1 else -1,

						// Calculate dates to use
						startDate = dateSort{0},
						endDate = dateSort{1},
						
						// Find duration
						calcDuration =
							let
								ExcludedDuration = findExcludedDuration(excludedDays??{}, startDate, endDate),
								AllDuration = endDate - startDate
							in
								if AllDuration = #duration(0,0,0,0) then AllDuration else AllDuration - ExcludedDuration,
						fixDuration = calcDuration * direction,

						Result = if dateStart = null or dateEnd = null then null else fixDuration
					in
						Result,


				// Documentation
				DateDiffType =
					type function (
						dateStart as (type nullable date meta [
							Documentation.FieldCaption = "Start date",
							Documentation.FieldDescription = "Date Start"
						]),
						dateEnd as (type nullable date meta [
							Documentation.FieldCaption = "End date",
							Documentation.FieldDescription = "Date End"
						]),
						optional excludedDays as (type {date} meta [
							Documentation.FieldCaption = "Excluded Dates",
							Documentation.FieldDescription = "A list of dates to exclude"
						])
					)
					as nullable duration meta
					[
						Documentation.Name = "Date.Diff",
						Documentation.Description = "Finds the difference between two dates",
						Documentation.LongDescription = "Finds the difference between two dates. Optional <code>'Excluded Dates'</code> list.",
						Documentation.Category = "Duration",
						Documentation.Author = "Spyros Mavroforos",
						Documentation.Source = "https://github.com/SpyrosMauro/powerquery",
						Documentation.Version = "1",
						Documentation.Examples = {[
							Description = "Diff using excluded date list",
							Code = "let
										StartingTable =
											Table.FromRecords({
												[start = #date(2020,7,1), end = #date(2020,7,2)],
												[start = #date(2020,7,1), end = #date(2020,7,3)],
												[start = #date(2020,7,5), end = #date(2020,7,2)]
											}),
										holidays = {#date(2020,7,2), #date(2020,7,4)}
									in
										Table.AddColumns( StartingTable, ""diff"", each DateTime.Diff( [end], [start], holidays ) )",
							Result = "Table.FromRecords({
										[start = #date(2020,7,1), end = #datetime(2020,7,2), diff = #duration(0,0,0,0)],
										[start = #date(2020,7,1), end = #datetime(2020,7,3), diff = #duration(1,0,0,0)],
										[start = #date(2020,7,5), end = #datetime(2020,7,2), diff = #duration(-1,0,0,0)]
									})"
						]}
					]

			in
				Value.ReplaceType(DateDiffFunction, DateDiffType),
	// 	Types
		Type.TableType 	= // Get text of non abstract table type.
			let
				// Function
				TypeTableTypeFunction = (table as table, optional precision as number, optional primitive as logical) as any =>
					let
					// 	addTabs: make text readable.
						addTabs = 
							(t as text, optional tabsNumber as number) as text => 
								Text.Replace ( t, "#(lf)", "#(lf)" & Text.Repeat("#(tab)", tabsNumber??1 ) ),

					// 	typeToText: format types
						typeToText = 
							if primitive ?? false 
							then (x as list) as text => if Text.StartsWith(x{1}, "type table [") then "#""" & x{0} &"""" & " = ( " & x{1} & " )" else "#""" & x{0} &"""" & " = ( type " & x{1} & " )"
							else (x as list) as text => "#""" & x{0} &"""" & " = " & x{1},

					// 	typeFinder: finds the main type of a list
						typeFinder = 
							(x as list, optional crazyMode as logical) =>
								let
									startingList  = List.Select(x, each _ <> type any),
									listMode 	  = List.Mode(startingList),
									listDistinct  = List.Distinct(startingList),
									countDistinct = List.Count(listDistinct),
									removeInts 	  = List.RemoveItems(listDistinct, {Int64.Type, Int32.Type, Int8.Type})
								in
										 if countDistinct = 0 then type any
							 		else if countDistinct = 1 then listDistinct{0}
									// Five extra steps here for abstract types
									else if List.AllTrue(List.Transform(listDistinct, each Type.Is(_, type number))) then type number
									else if List.AllTrue(List.Transform(listDistinct, each Type.Is(_, type [...]))) then type nullable [...]
									else if List.AllTrue(List.Transform(listDistinct, each Type.Is(_, type table))) then type nullable table
									else if List.AllTrue(List.Transform(listDistinct, each Type.Is(_, type list))) then type nullable list
									else if List.AllTrue(List.Transform(listDistinct, each Type.Is(_, type function))) then type nullable function
									/* // crazyMode is just for testing. Really, it just tries to assign the type found the most in the list. Don't use that.
									else if crazyMode??false then listMode */
									else if countDistinct = 2 then
											 if List.Contains(listDistinct, type text) then type text
										else if List.ContainsAll(listDistinct, {type date, type datetime}) then type datetime
										else if List.ContainsAll(listDistinct, {type date, type datetimezone}) then type datetimezone
										else if List.ContainsAll(listDistinct, {type datetime, type datetimezone}) then type datetimezone
										else if removeInts{0}? = type duration then type duration
										else type any
									else 
										if countDistinct = 3 then
										if List.ContainsAll(listDistinct, {type datetimezone, type datetime, type date}) then type datetimezone
										else if removeInts = {} then Int64.Type
										else type any
									else  type any,


					// 	Not allowed types
						typeList = 
							[
								Text =
									if primitive??false 
									then { "null", "function", "list", "record", "table", "type" }
									else { "Type.Null", "Type.Function", "Type.List", "Type.Record", "Type.Table", "Type.Type" },
								Type = { type null, type function, type list, type record, type table, type type }
							],
						excludeTypes = (t as any, textOrType as text) as logical =>
							if textOrType = "text" 
							then List.AllTrue(List.Transform(Record.Field(typeList, textOrType), each t <> _))
							else List.AllTrue(List.Transform(Record.Field(typeList, textOrType), each not Type.Is(t, _))),

					// 	fakeFunction: takes a type and makes a function that returns this type, to be used for non appliable types
					// 	when Table.TransformColumnTypes is able to ascribe these 6 types then it will be redundant
						fakeFunction = (Type as type) as function =>
								 if Type.Is(Type, type null) then (x) as null => null
							else if Type.Is(Type, type function) then (x) as nullable function => x
							else if Type.Is(Type, type list) then (x) as nullable list => x
							else if Type.Is(Type, type record) then (x) as nullable record => x
							else if Type.Is(Type, type table) then (x) as nullable table => x
							else if Type.Is(Type, type type) then (x) as nullable type => x
							else (x) => x,

					// 	checkInt
						checkInt = (x as number) as type => 
							if primitive??false 
							then type number 
							else if (Number.Mod(x, 1)??0) = 0 then Int64.Type else type number,
					// 	replaceWithType: custom replacer
						replaceWithType = (x,y,z) =>
							let
								// nulls were a bother. Now Completely removed.
								typ = if (x??"") = "" then type any else Value.Type(x)
							in
								if Type.Is(typ, type number) then checkInt(x)
								// next step is for excel and other sources which store time as '31/12/1899 hh:mm:ss'. Thankfully, pq also sees this as time if Time.From is used
								else if Type.Is(typ, type datetime) then if Date.From(DateTime.From(x))=#date(1899,12,31) then type time else type datetime
								else if Type.Is(typ, type text) then
										 if not (try Logical.FromText(x))[HasError] then type logical
									else if not (try Number.FromText(x))[HasError] then checkInt(Number.From(x))
									else if not (try Time.FromText(x))[HasError] then type time
									else if not (try Date.FromText(x))[HasError] then type date
									else if not (try DateTime.FromText(x))[HasError] then type datetime
									else if not (try DateTimeZone.FromText(x))[HasError] then type datetimezone
									else if not (try Duration.FromText(x))[HasError] then type duration
									else type text
								else typ,

						tableTypeFromSchema = (schema as table) as text =>
							"type table [#(lf)#(tab)"
							& Text.Combine( Table.ToList( schema, (t) => addTabs(typeToText(t)) ), ",#(lf)#(tab)" )
							& "#(lf)]",


					// 	Schema columns
						schemaColumns = if primitive??false then {"Name", "Kind"} else {"Name", "TypeName"},
						findType  =
							if (precision??0) > 0 then
								let
									rowsToGet 	= List.Min({Table.RowCount(table), precision??50, 1000}),
									firstN 		= Table.FirstN(table, rowsToGet),
									columnNames = Table.ColumnNames(firstN),
									tableValuesToType = Table.ReplaceValue(firstN, null, null, replaceWithType, columnNames),
									FindBestType = Table.CombineColumns(
										Table.Transpose(tableValuesToType),
										List.Transform({1..rowsToGet}, each "Column"&Text.From(_)),
										typeFinder,
										"Types"
										),
									
									allTransformations = 
										List.Zip({	
											columnNames, 
											List.Transform(FindBestType[Types], each if Type.Is(_, type null) then type any else _)
										}),

									applicableTransformations = List.Select( allTransformations, each excludeTypes(_{1}, "Type")),
									fakeTable = #table(List.Transform(allTransformations, each _{0}), {}),
									applySimpleTransformations = 
										if applicableTransformations <> {} 
										then Table.TransformColumnTypes(fakeTable, applicableTransformations) 
										else fakeTable,

									notAllowedList = 
										List.Transform(
											List.RemoveItems(allTransformations, applicableTransformations), 
											each {_{0}, fakeFunction(_{1}), _{1}}
										),
									checkExtraTypes = 
										if notAllowedList <> {} 
										then Table.TransformColumns(applySimpleTransformations, notAllowedList) 
										else applySimpleTransformations,
									schema = Table.SelectColumns(Table.Schema(checkExtraTypes), schemaColumns),
									result =
										if primitive??false
										then Table.RemoveColumns(
												Table.AddColumn(schema, "Deep Dive", each 
													if [Kind] = "table" 
													then let name = [Name] 
														 in tableTypeFromSchema(
																Table.SelectColumns(
																	Type.TableSchema(List.Select(notAllowedList, each _{0} = name){0}{2}), 
																	schemaColumns
																)
															)
													else [Kind], type text)
												,{"Kind"})
										else schema
								in
									result
							else
								Table.SelectColumns(Table.Schema(table), schemaColumns),

						tableType = tableTypeFromSchema(findType)
					in
						tableType,

				// Documentation
				TypeTableTypeType =
					type function (
						table as (type table meta [
							Documentation.FieldCaption = "Target table",
							Documentation.FieldDescription = "The table for which to generate <code>Table.View</code>"
							]),
						optional precision as (type number meta [
							Documentation.FieldCaption = "precision",
							Documentation.FieldDescription = "First <code>n</code> rows to check for best type match"
							]),
						optional primitive as (type logical meta [
							Documentation.FieldCaption = "primitive",
							Documentation.FieldDescription = "Only primitive types"
							])
					)
					as text meta
					[
						Documentation.Name = "Type.TableType",
						Documentation.Description = "Generates the text of non abstract table type",
						Documentation.LongDescription = "Generates <b>text of</b> <code>non abstract type table</code>. Optional <code>precision</code>.",
						Documentation.Category = "Type",
						Documentation.Author = "Spyros Mavroforos",
						Documentation.Source = "https://github.com/SpyrosMauro/powerquery",
						Documentation.Version = "1",
						Documentation.Examples = {[
								Description = "Table type to text",
								Code = "let
											StartTable = Table.FromRecords({
												[start = #datetime(2020,7,1,0,0,0), tb = #table(type table [a = number], {{1}}), list = {1}],
												[start = #datetime(2020,7,1,5,0,0), tb = #table(type table [a = number], {{2}}), list = null],
												[start = #datetime(2020,7,1,8,0,0), tb = #table(type table [a = number], {{3}}), list = {4}],
												[start = #datetime(2020,7,1,16,0,0), tb = null, list = {3,4}]
											})
										in
											Type.TableType ( StartTable, 10, true )",
								Result = """type table [
											#""start"" = ( type datetime ),
											#""diff"" = ( type table [
											#(tab)#(tab)#""a"" = ( type any )
											#(tab)] ),
											#""list"" = ( type list )
										]"""
							],[
								Description = "Table type to text",
								Code = "let
											startTable = #table(
												{""n"", ""fun"", ""rec"", ""tb"", ""l"", ""bin"", ""typ""},
												{{1, (x) => x, [a = 1], #table({""a""}, {{1}}), {1..3}, #binary(""), type text}}
												)
										in
											Type.TableType ( StartTable )",
								Result = """type table [
											#""n"" = Int64.Type,
											#""fun"" = Function.Type,
											#""rec"" = Record.Type,
											#""tb"" = Table.Type,
											#""l"" = List.Type,
											#""bin"" = Binary.Type,
											#""typ"" = Type.Type
										]"""
							]}
					]

			in
				Value.ReplaceType(TypeTableTypeFunction, TypeTableTypeType),
		Type.ToText 	= // Get text representation of any type.
			let
				// Function
				typeToTextFunction = (typ as type, optional primitive as logical) as text => 
					let
						schema = Type.TableSchema(type table [a = typ]){0},
						result = if primitive??false then "type " & schema[Kind] else schema[TypeName]
					in
						result,


				// Documentation
				typeToTextType =
					type function (
						typ as ((type type) meta [
							Documentation.FieldCaption = "Type",
							Documentation.FieldDescription = "Type to get as text"
							]),
						optional primitive as (type logical meta [
							Documentation.FieldCaption = "primitive",
							Documentation.FieldDescription = "Give primitive type"
							])
					)
					as text meta
					[
						Documentation.Name = "Type.ToText",
						Documentation.Description = "Gives text representation of given type",
						Documentation.LongDescription = "Gives text representation of given type. Optional <code>primitive</code> mode.",
						Documentation.Category = "Type",
						Documentation.Author = "Spyros Mavroforos",
						Documentation.Source = "https://github.com/SpyrosMauro/powerquery",
						Documentation.Version = "1",
						Documentation.Examples = {[
							Description = "<code>type text</code> to text",
							Code = "Type.ToText ( type text ) ",
							Result = """Text.Type"""
						],[
							Description = "Primitive <code>type text</code> to text",
							Code = "Type.ToText ( type text , true ) ",
							Result = """type text"""
						]}
					]

			in 
				Value.ReplaceType(typeToTextFunction, typeToTextType),
		Get.TableView 	= // Get formatted Table.View function based on Table.Schema or by infering types.
			let
				// Function
				GetTableViewFunction_ = 1,
				GetTableViewFunction = (table as table, tableName as text, optional precision as number, optional rowsToShow, optional primitive as logical, optional useOptimise as logical) as text =>
					let
						// addTabs: make text readable.
						addTabs = (t as text, optional tabsNumber as number) as text => Text.Replace ( t, "#(lf)", "#(lf)" & Text.Repeat("#(tab)", tabsNumber??1 ) ),

						// typeFinder: finds the main type of a list
						typeFinder = (x as list, optional crazyMode as logical) =>
							let
								startingList = List.Select(x, each _ <> type any),
								listMode = List.Mode(startingList),
								listDistinct = List.Distinct(startingList),
								countDistinct = List.Count(listDistinct),
								removeInts = List.RemoveItems(listDistinct, {Int64.Type, Int32.Type, Int8.Type})
							in
							if countDistinct = 0 then type any
							else if countDistinct = 1 then listDistinct{0}
							// Five extra steps here for abstract types
							else if List.AllTrue(List.Transform(listDistinct, each Type.Is(_, type number))) then type number
							else if List.AllTrue(List.Transform(listDistinct, each Type.Is(_, type [...]))) then type nullable [...]
							else if List.AllTrue(List.Transform(listDistinct, each Type.Is(_, type table))) then type nullable table
							else if List.AllTrue(List.Transform(listDistinct, each Type.Is(_, type list))) then type nullable list
							else if List.AllTrue(List.Transform(listDistinct, each Type.Is(_, type function))) then type nullable function
							/* // crazyMode is just for testing. Really, it just tries to assign the type found the most in the list. Don't use that.
							else if crazyMode??false then listMode */
							else if countDistinct = 2 then
								if List.Contains(listDistinct, type text) then type text
								else if List.ContainsAll(listDistinct, {type date, type datetime}) then type datetime
								else if List.ContainsAll(listDistinct, {type date, type datetimezone}) then type datetimezone
								else if List.ContainsAll(listDistinct, {type datetime, type datetimezone}) then type datetimezone
								else if removeInts{0}? = type duration then type duration
								else type any
							else if countDistinct = 3 then
								if List.ContainsAll(listDistinct, {type datetimezone, type datetime, type date}) then type datetimezone
								else if removeInts = {} then Int64.Type
								else type any
							else  type any,

						// checkInt
						checkInt = (x as number) as type => if (Number.Mod(x, 1)??0) = 0 then Int64.Type else type number,
						// replaceWithType: custom replacer
						replaceWithType = (x,y,z) =>
							let
								// nulls were a bother. Now Completely removed.
								typ = if (x??"") = "" then type any else Value.Type(x)
							in
								if Type.Is(typ, type number) then checkInt(x)
								// next step is for excel and other sources which store time as '31/12/1899 hh:mm:ss'. Thankfully, pq also sees this as time if Time.From is used
								else if Type.Is(typ, type datetime) then if Date.From(DateTime.From(x))=#date(1899,12,31) then type time else type datetime
								else if Type.Is(typ, type text) then
									if not (try Logical.FromText(x))[HasError] then type logical
									else if not (try Number.FromText(x))[HasError] then checkInt(Number.From(x))
									else if not (try Time.FromText(x))[HasError] then type time
									else if not (try Date.FromText(x))[HasError] then type date
									else if not (try DateTime.FromText(x))[HasError] then type datetime
									else if not (try DateTimeZone.FromText(x))[HasError] then type datetimezone
									else if not (try Duration.FromText(x))[HasError] then type duration
									else type text
								else typ,


						// Not allowed types
						typeList = 
							[
								Text =
									if primitive??false then { "binary", "function", "list", "record", "table", "type" }
								else { "Binary.Type", "Function.Type", "List.Type", "Record.Type", "Table.Type", "Type.Type" },
								Type = {type binary, type function, type list, type record, type table, type type, type [...]}
							],
						excludeTypes = (t as any, textOrType as text) as logical =>
							if textOrType = "Text" then List.AllTrue(List.Transform(Record.Field(typeList, textOrType), each t <> _))
							else List.AllTrue(List.Transform(Record.Field(typeList, textOrType), each not Type.Is(t, _))),

						// typeToText: format types to #"Name" = type
						typeToText = 
							if primitive??false then (x as list) as text => "#""" & x{0} &"""" & " = ( type " & x{1} & " )"
							else (x as list) as text => "#""" & x{0} &"""" & " = " & x{1},

						// Schema columns
						schemaColumns = if primitive??false then {"Name", "Kind"} else {"Name", "TypeName"},

						// Calculations
						fixTableName = if Text.StartsWith(tableName, "#") then tableName else "#""" & tableName & """",
						columnNames = Table.ColumnNames(table),

						findType =
							if (precision??0) > 0 then
								let
									rowsToGet = List.Min({Table.RowCount(table), precision??50, 1000}),

									tableValuesToType = Table.ReplaceValue(Table.FirstN(table, rowsToGet), null, null, replaceWithType, columnNames),
									FindBestType = Table.CombineColumns(
										Table.Transpose(tableValuesToType),
										List.Transform({1..rowsToGet}, each "Column"&Text.From(_)),
										typeFinder,
										"Types"
										),

									RemoveExtra = List.Select(
										List.Zip({columnNames, List.Transform(FindBestType[Types], each if Type.Is(_, type null) then type any else _)}),
										each excludeTypes(_{1}, "Type")),
									realFakeTables = Table.TransformColumnTypes(#table(List.Transform(RemoveExtra, each _{0}), {}), RemoveExtra),
									schema = Table.SelectColumns(Table.Schema(realFakeTables), schemaColumns)
								in
									schema
							else
								Table.SelectRows(
									Table.SelectColumns(Table.Schema(table), schemaColumns),
									each excludeTypes(Record.Field(_, schemaColumns{1}), "Text") ),

						columnsToRemove = List.RemoveItems(columnNames, findType[Name]),
						removeColumns = List.Count(columnsToRemove) > 0,

						mainTableCall =
							let tbCall = 
								if removeColumns
									then "Table.RemoveColumns ( "& fixTableName & ", { " & Text.Combine(List.Transform(columnsToRemove, each """"&_&""""), ", ") & " } , MissingField.Ignore )"
								else fixTableName
							in
								if useOptimise??false then "Value.Optimize ( " & tbCall & " )" else tbCall,

						tableType =
							"type table [#(lf)#(tab)"
							& Text.Combine(Table.ToList(findType, typeToText ), ",#(lf)#(tab)")
							& "#(lf)]",
						
						getType = "GetType = () =>#(lf)#(tab)" & addTabs(tableType),

						getRows = "GetRows = () =>#(lf)#(tab)" & addTabs(mainTableCall),
						
						onTake =
							let
								tbl = "#table (#(lf)#(tab)" & addTabs(tableType) & ",#(lf)#(tab){}#(lf))",
								countText = if rowsToShow = null then "count" else Text.From(rowsToShow),
								main =
									if rowsToShow = 0 then tbl
									else "if count = 0 then#(lf)#(tab)" & addTabs(tbl) & "#(lf)else Table.FirstN ( " & mainTableCall & ", " & countText & " )"
							in
								"OnTake = (count as number) =>#(lf)#(tab)" & addTabs(main),


						tableView =
							"= Table.View (#(lf)#(tab)null,#(lf)#(tab)"
							& "[#(lf)#(tab)#(tab)" & addTabs(getType, 2)
							& ",#(lf)#(tab)#(tab)" & addTabs(getRows, 2)
							& ",#(lf)#(tab)#(tab)" & addTabs(onTake, 2) & "#(lf)#(tab)]" & "#(lf))"
					in
						tableView,


				// Documentation
				GetTableViewType =
					type function (
						table as (type table meta [
							Documentation.FieldCaption = "Target table",
							Documentation.FieldDescription = "The table for which to generate <code>Table.View</code>"
							]),
						tableName as (type text meta [
							Documentation.FieldCaption = "Table name",
							Documentation.FieldDescription = "The name of the table in text"
							]),
						optional precision as (type number meta [
							Documentation.FieldCaption = "precision",
							Documentation.FieldDescription = "First <code>n</code> rows to check for best type match"
							]),
						optional rowsToShow as (type number meta [
							Documentation.FieldCaption = "rowsToShow",
							Documentation.FieldDescription = "Show first n rows when asking for 1000"
							]),
						optional primitive as (type logical meta [
							Documentation.FieldCaption = "primitive",
							Documentation.FieldDescription = "Only primitive types"
							]),
						optional useOptimise as (type logical meta [
							Documentation.FieldCaption = "useOptimise",
							Documentation.FieldDescription = "Use Value.Optimize"
							])
					)
					as text meta
						[
							Documentation.Name = "Get.TableView",
							Documentation.Description = "Generates <code>Table.View</code> to trick model asking for evaluation",
							Documentation.LongDescription = "Generates <code>Table.View</code> to trick model asking for evaluation. Optional <code>precision</code> and <code>rowsToShow</code>.<p> <b>Skipping:</b> <i>Lists, Tables, Records, Binaries, Functions and Types</i>",
							Documentation.Category = "Model",
							Documentation.Author = "Spyros Mavroforos",
							Documentation.Source = "https://github.com/SpyrosMauro/powerquery",
							Documentation.Version = "1",
							Documentation.Examples = {
								[
									Description = "Generate table view of last step by infering type on 4 rows",
									Code = "
										let
											StartTable = Table.FromRecords({
												[start = #datetime(2020,7,1,0,0,0), diff = #duration(0,15,0,0), list = {1}],
												[start = #datetime(2020,7,1,5,0,0), diff = #duration(0,16,0,0), list = null],
												[start = #datetime(2020,7,1,8,0,0), diff = #duration(1,0,0,0), list = {4}],
												[start = #datetime(2020,7,1,16,0,0), diff = #duration(0,8,0,0), list = {3,4}]
											})
										in
											Get.TableView ( StartTable , ""StartTable"", 4 )"
										,
									Result = 
										"
											""= Table.View (
												null,
												[
													GetType = () =>
														type table [
															#""start"" = ( type datetime ),
															#""diff"" = ( type duration )
														],
													GetRows = () =>
														Table.RemoveColumns ( #""StartTable"", { ""list"" } , MissingField.Ignore ),
													OnTake = (count as number) =>
														if count = 0 then
															#table (
																type table [
																	#""start"" = ( type datetime ),
																	#""diff"" = ( type duration )
																],
																{}
															)
														else Table.FirstN ( Table.RemoveColumns ( #""StartTable"", { ""list"" } , MissingField.Ignore ), count )
												]
											)""
										"
								],
								[
									Description = "Generate table view of last step",
									Code = 
										"
											let
												StartTable = Table.FromRecords({
													[start = #datetime(2020,7,1,0,0,0), diff = #duration(0,15,0,0), list = {1}],
													[start = #datetime(2020,7,1,5,0,0), diff = #duration(0,16,0,0), list = null],
													[start = #datetime(2020,7,1,8,0,0), diff = #duration(1,0,0,0), list = {4}],
													[start = #datetime(2020,7,1,16,0,0), diff = #duration(0,8,0,0), list = {3,4}]
												})
											in
												Get.TableView ( StartTable , ""StartTable"")
										",
									Result = 
										"
											""= Table.View (
												null,
												[
													GetType = () =>
														type table [
															#""start"" = ( type any ),
															#""diff"" = ( type any ),
															#""list"" = ( type any )
														],
													GetRows = () =>
														#""StartTable"",
													OnTake = (count as number) =>
														if count = 0 then
															#table (
																type table [
																	#""start"" = ( type any ),
																	#""diff"" = ( type any ),
																	#""list"" = ( type any )
																],
																{}
															)
														else Table.FirstN ( #""StartTable"", count )
												]
											)""
										"
								]}
						]

			in
				Value.ReplaceType(GetTableViewFunction_, GetTableViewType)
		],
World  	   = [ //* –ò–ù–¢–ï–†–ï–°–ù–û https://github.com/alendaris/power-query/blob/main/functions/ISO-3166-1.pq
	WorldDataSet = // –∫–æ–¥—ã —Å—Ç—Ä–∞–Ω –º–∏—Ä–∞. –•–æ—Ä–æ—à–∏–µ –ø—Ä–∏–µ–º—ã: –æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã -
		let
			defaultCountries = 
					#table(
					type table [
						#"Country Code (numeric)" = Int64.Type,
						#"Country Code" = Text.Type,
						#"Country Code (alpha3)" = Text.Type,
						#"Country Name" = Text.Type
					],
					{
						{"4", "AF", "AFG", "Afghanistan"},
						{"8", "AL", "ALB", "Albania"},
						{"12", "DZ", "DZA", "Algeria"},
						{"20", "AD", "AND", "Andorra"},
						{"24", "AO", "AGO", "Angola"},
						{"28", "AG", "ATG", "Antigua and Barbuda"},
						{"32", "AR", "ARG", "Argentina"},
						{"51", "AM", "ARM", "Armenia"},
						{"36", "AU", "AUS", "Australia"},
						{"40", "AT", "AUT", "Austria"},
						{"31", "AZ", "AZE", "Azerbaijan"},
						{"44", "BS", "BHS", "Bahamas"},
						{"48", "BH", "BHR", "Bahrain"},
						{"50", "BD", "BGD", "Bangladesh"},
						{"52", "BB", "BRB", "Barbados"},
						{"112", "BY", "BLR", "Belarus"},
						{"56", "BE", "BEL", "Belgium"},
						{"84", "BZ", "BLZ", "Belize"},
						{"204", "BJ", "BEN", "Benin"},
						{"64", "BT", "BTN", "Bhutan"},
						{"68", "BO", "BOL", "Bolivia (Plurinational State of)"},
						{"70", "BA", "BIH", "Bosnia and Herzegovina"},
						{"72", "BW", "BWA", "Botswana"},
						{"76", "BR", "BRA", "Brazil"},
						{"96", "BN", "BRN", "Brunei Darussalam"},
						{"100", "BG", "BGR", "Bulgaria"},
						{"854", "BF", "BFA", "Burkina Faso"},
						{"108", "BI", "BDI", "Burundi"},
						{"132", "CV", "CPV", "Cabo Verde"},
						{"116", "KH", "KHM", "Cambodia"},
						{"120", "CM", "CMR", "Cameroon"},
						{"124", "CA", "CAN", "Canada"},
						{"140", "CF", "CAF", "Central African Republic"},
						{"148", "TD", "TCD", "Chad"},
						{"152", "CL", "CHL", "Chile"},
						{"156", "CN", "CHN", "China"},
						{"170", "CO", "COL", "Colombia"},
						{"174", "KM", "COM", "Comoros"},
						{"178", "CG", "COG", "Congo"},
						{"180", "CD", "COD", "Congo, Democratic Republic of the"},
						{"188", "CR", "CRI", "Costa Rica"},
						{"384", "CI", "CIV", "C√¥te d'Ivoire"},
						{"191", "HR", "HRV", "Croatia"},
						{"192", "CU", "CUB", "Cuba"},
						{"196", "CY", "CYP", "Cyprus"},
						{"203", "CZ", "CZE", "Czechia"},
						{"208", "DK", "DNK", "Denmark"},
						{"262", "DJ", "DJI", "Djibouti"},
						{"212", "DM", "DMA", "Dominica"},
						{"214", "DO", "DOM", "Dominican Republic"},
						{"218", "EC", "ECU", "Ecuador"},
						{"818", "EG", "EGY", "Egypt"},
						{"222", "SV", "SLV", "El Salvador"},
						{"226", "GQ", "GNQ", "Equatorial Guinea"},
						{"232", "ER", "ERI", "Eritrea"},
						{"233", "EE", "EST", "Estonia"},
						{"748", "SZ", "SWZ", "Eswatini"},
						{"231", "ET", "ETH", "Ethiopia"},
						{"242", "FJ", "FJI", "Fiji"},
						{"246", "FI", "FIN", "Finland"},
						{"250", "FR", "FRA", "France"},
						{"266", "GA", "GAB", "Gabon"},
						{"270", "GM", "GMB", "Gambia"},
						{"268", "GE", "GEO", "Georgia"},
						{"276", "DE", "DEU", "Germany"},
						{"288", "GH", "GHA", "Ghana"},
						{"300", "GR", "GRC", "Greece"},
						{"308", "GD", "GRD", "Grenada"},
						{"320", "GT", "GTM", "Guatemala"},
						{"324", "GN", "GIN", "Guinea"},
						{"624", "GW", "GNB", "Guinea-Bissau"},
						{"328", "GY", "GUY", "Guyana"},
						{"332", "HT", "HTI", "Haiti"},
						{"340", "HN", "HND", "Honduras"},
						{"348", "HU", "HUN", "Hungary"},
						{"352", "IS", "ISL", "Iceland"},
						{"356", "IN", "IND", "India"},
						{"360", "ID", "IDN", "Indonesia"},
						{"364", "IR", "IRN", "Iran (Islamic Republic of)"},
						{"368", "IQ", "IRQ", "Iraq"},
						{"372", "IE", "IRL", "Ireland"},
						{"376", "IL", "ISR", "Israel"},
						{"380", "IT", "ITA", "Italy"},
						{"388", "JM", "JAM", "Jamaica"},
						{"392", "JP", "JPN", "Japan"},
						{"400", "JO", "JOR", "Jordan"},
						{"398", "KZ", "KAZ", "Kazakhstan"},
						{"404", "KE", "KEN", "Kenya"},
						{"296", "KI", "KIR", "Kiribati"},
						{"408", "KP", "PRK", "Korea (Democratic People's Republic of)"},
						{"410", "KR", "KOR", "Korea, Republic of"},
						{"414", "KW", "KWT", "Kuwait"},
						{"417", "KG", "KGZ", "Kyrgyzstan"},
						{"418", "LA", "LAO", "Lao People's Democratic Republic"},
						{"428", "LV", "LVA", "Latvia"},
						{"422", "LB", "LBN", "Lebanon"},
						{"426", "LS", "LSO", "Lesotho"},
						{"430", "LR", "LBR", "Liberia"},
						{"434", "LY", "LBY", "Libya"},
						{"438", "LI", "LIE", "Liechtenstein"},
						{"440", "LT", "LTU", "Lithuania"},
						{"442", "LU", "LUX", "Luxembourg"},
						{"450", "MG", "MDG", "Madagascar"},
						{"454", "MW", "MWI", "Malawi"},
						{"458", "MY", "MYS", "Malaysia"},
						{"462", "MV", "MDV", "Maldives"},
						{"466", "ML", "MLI", "Mali"},
						{"470", "MT", "MLT", "Malta"},
						{"584", "MH", "MHL", "Marshall Islands"},
						{"478", "MR", "MRT", "Mauritania"},
						{"480", "MU", "MUS", "Mauritius"},
						{"484", "MX", "MEX", "Mexico"},
						{"583", "FM", "FSM", "Micronesia (Federated States of)"},
						{"498", "MD", "MDA", "Moldova, Republic of"},
						{"492", "MC", "MCO", "Monaco"},
						{"496", "MN", "MNG", "Mongolia"},
						{"499", "ME", "MNE", "Montenegro"},
						{"504", "MA", "MAR", "Morocco"},
						{"508", "MZ", "MOZ", "Mozambique"},
						{"104", "MM", "MMR", "Myanmar"},
						{"516", "NA", "NAM", "Namibia"},
						{"520", "NR", "NRU", "Nauru"},
						{"524", "NP", "NPL", "Nepal"},
						{"528", "NL", "NLD", "Netherlands"},
						{"554", "NZ", "NZL", "New Zealand"},
						{"558", "NI", "NIC", "Nicaragua"},
						{"562", "NE", "NER", "Niger"},
						{"566", "NG", "NGA", "Nigeria"},
						{"807", "MK", "MKD", "North Macedonia"},
						{"578", "NO", "NOR", "Norway"},
						{"512", "OM", "OMN", "Oman"},
						{"586", "PK", "PAK", "Pakistan"},
						{"585", "PW", "PLW", "Palau"},
						{"591", "PA", "PAN", "Panama"},
						{"598", "PG", "PNG", "Papua New Guinea"},
						{"600", "PY", "PRY", "Paraguay"},
						{"604", "PE", "PER", "Peru"},
						{"608", "PH", "PHL", "Philippines"},
						{"616", "PL", "POL", "Poland"},
						{"620", "PT", "PRT", "Portugal"},
						{"634", "QA", "QAT", "Qatar"},
						{"642", "RO", "ROU", "Romania"},
						{"643", "RU", "RUS", "Russian Federation"},
						{"646", "RW", "RWA", "Rwanda"},
						{"659", "KN", "KNA", "Saint Kitts and Nevis"},
						{"662", "LC", "LCA", "Saint Lucia"},
						{"670", "VC", "VCT", "Saint Vincent and the Grenadines"},
						{"882", "WS", "WSM", "Samoa"},
						{"674", "SM", "SMR", "San Marino"},
						{"678", "ST", "STP", "Sao Tome and Principe"},
						{"682", "SA", "SAU", "Saudi Arabia"},
						{"686", "SN", "SEN", "Senegal"},
						{"688", "RS", "SRB", "Serbia"},
						{"690", "SC", "SYC", "Seychelles"},
						{"694", "SL", "SLE", "Sierra Leone"},
						{"702", "SG", "SGP", "Singapore"},
						{"703", "SK", "SVK", "Slovakia"},
						{"705", "SI", "SVN", "Slovenia"},
						{"90", "SB", "SLB", "Solomon Islands"},
						{"706", "SO", "SOM", "Somalia"},
						{"710", "ZA", "ZAF", "South Africa"},
						{"728", "SS", "SSD", "South Sudan"},
						{"724", "ES", "ESP", "Spain"},
						{"144", "LK", "LKA", "Sri Lanka"},
						{"729", "SD", "SDN", "Sudan"},
						{"740", "SR", "SUR", "Suriname"},
						{"752", "SE", "SWE", "Sweden"},
						{"756", "CH", "CHE", "Switzerland"},
						{"760", "SY", "SYR", "Syrian Arab Republic"},
						{"762", "TJ", "TJK", "Tajikistan"},
						{"834", "TZ", "TZA", "Tanzania, United Republic of"},
						{"764", "TH", "THA", "Thailand"},
						{"626", "TL", "TLS", "Timor-Leste"},
						{"768", "TG", "TGO", "Togo"},
						{"776", "TO", "TON", "Tonga"},
						{"780", "TT", "TTO", "Trinidad and Tobago"},
						{"788", "TN", "TUN", "Tunisia"},
						{"792", "TR", "TUR", "T√ºrkiye"},
						{"795", "TM", "TKM", "Turkmenistan"},
						{"798", "TV", "TUV", "Tuvalu"},
						{"800", "UG", "UGA", "Uganda"},
						{"804", "UA", "UKR", "Ukraine"},
						{"784", "AE", "ARE", "United Arab Emirates"},
						{"826", "GB", "GBR", "United Kingdom of Great Britain and Northern Ireland"},
						{"840", "US", "USA", "United States of America"},
						{"858", "UY", "URY", "Uruguay"},
						{"860", "UZ", "UZB", "Uzbekistan"},
						{"548", "VU", "VUT", "Vanuatu"},
						{"862", "VE", "VEN", "Venezuela (Bolivarian Republic of)"},
						{"704", "VN", "VNM", "Viet Nam"},
						{"887", "YE", "YEM", "Yemen"},
						{"894", "ZM", "ZMB", "Zambia"},
						{"716", "ZW", "ZWE", "Zimbabwe"}
					}
				),
			additionalDefaultCountries = 
				#table(
					type table [
						#"Country Code" = Text.Type,
						#"Country Code (alpha3)" = Text.Type,
						#"Country Name" = Text.Type,
						#"Country Code (numeric)" = Int64.Type
					],
					{
						{"AS", "ASM", "American Samoa", 16},
						{"AI", "AIA", "Anguilla", 660},
						{"AQ", "ATA", "Antarctica", 10},
						{"AW", "ABW", "Aruba", 533},
						{"BM", "BMU", "Bermuda", 60},
						{"BQ", "BES", "Bonaire, Sint Eustatius and Saba", 535},
						{"BV", "BVT", "Bouvet Island", 74},
						{"IO", "IOT", "British Indian Ocean Territory", 86},
						{"VG", "VGB", "British Virgin Islands", 92},
						{"KY", "CYM", "Cayman Islands", 136},
						{"HK", "HKG", "China, Hong Kong Special Administrative Region", 344},
						{"MO", "MAC", "China, Macao Special Administrative Region", 446},
						{"CX", "CXR", "Christmas Island", 162},
						{"CC", "CCK", "Cocos (Keeling) Islands", 166},
						{"CK", "COK", "Cook Islands", 184},
						{"CW", "CUW", "Cura√ßao", 531},
						{"FK", "FLK", "Falkland Islands (Malvinas)", 238},
						{"FO", "FRO", "Faroe Islands", 234},
						{"GF", "GUF", "French Guiana", 254},
						{"PF", "PYF", "French Polynesia", 258},
						{"TF", "ATF", "French Southern Territories", 260},
						{"GI", "GIB", "Gibraltar", 292},
						{"GL", "GRL", "Greenland", 304},
						{"GP", "GLP", "Guadeloupe", 312},
						{"GU", "GUM", "Guam", 316},
						{"GG", "GGY", "Guernsey", 831},
						{"HM", "HMD", "Heard Island and McDonald Islands", 334},
						{"VA", "VAT", "Holy See", 336},
						{"IM", "IMN", "Isle of Man", 833},
						{"JE", "JEY", "Jersey", 832},
						{"MQ", "MTQ", "Martinique", 474},
						{"YT", "MYT", "Mayotte", 175},
						{"MS", "MSR", "Montserrat", 500},
						{"NC", "NCL", "New Caledonia", 540},
						{"NU", "NIU", "Niue", 570},
						{"NF", "NFK", "Norfolk Island", 574},
						{"MP", "MNP", "Northern Mariana Islands", 580},
						{"PN", "PCN", "Pitcairn", 612},
						{"PR", "PRI", "Puerto Rico", 630},
						{"RE", "REU", "R√©union", 638},
						{"BL", "BLM", "Saint Barth√©lemy", 652},
						{"SH", "SHN", "Saint Helena", 654},
						{"MF", "MAF", "Saint Martin (French Part)", 663},
						{"PM", "SPM", "Saint Pierre and Miquelon", 666},
						{"CQ", "CRQ", "Sark", 680},
						{"SX", "SXM", "Sint Maarten (Dutch part)", 534},
						{"GS", "SGS", "South Georgia and the South Sandwich Islands", 239},
						{"PS", "PSE", "State of Palestine", 275},
						{"SJ", "SJM", "Svalbard and Jan Mayen Islands", 744},
						{"TK", "TKL", "Tokelau", 772},
						{"TC", "TCA", "Turks and Caicos Islands", 796},
						{"UM", "UMI", "United States Minor Outlying Islands", 581},
						{"VI", "VIR", "United States Virgin Islands", 850},
						{"WF", "WLF", "Wallis and Futuna Islands", 876},
						{"EH", "ESH", "Western Sahara", 732},
						{"AX", "ALA", "√Öland Islands", 248}
					}
				) meta [
					QueryFolding = [
							IsFolded = false,
							HasNativeQuery = false,
							Kind = "",
							Path = ""
						]
				],
			defaultPossibleNames = 
				#table(
					type table [#"Country Code" = Text.Type, #"Possible Name" = Text.Type],
					{
						{"AF", "4"},
						{"AF", "AFG"},
						{"AF", "Afghanistan"},
						{"AF", "AF"},
						{"AL", "8"},
						{"AL", "ALB"},
						{"AL", "Albania"},
						{"AL", "AL"},
						{"DZ", "12"},
						{"DZ", "DZA"},
						{"DZ", "Algeria"},
						{"DZ", "DZ"},
						{"AD", "20"},
						{"AD", "AND"},
						{"AD", "Andorra"},
						{"AD", "AD"},
						{"AO", "24"},
						{"AO", "AGO"},
						{"AO", "Angola"},
						{"AO", "AO"},
						{"AG", "28"},
						{"AG", "ATG"},
						{"AG", "Antigua and Barbuda"},
						{"AG", "AG"},
						{"AR", "32"},
						{"AR", "ARG"},
						{"AR", "Argentina"},
						{"AR", "AR"},
						{"AM", "51"},
						{"AM", "ARM"},
						{"AM", "Armenia"},
						{"AM", "AM"},
						{"AU", "36"},
						{"AU", "AUS"},
						{"AU", "Australia"},
						{"AU", "AU"},
						{"AT", "40"},
						{"AT", "AUT"},
						{"AT", "Austria"},
						{"AT", "AT"},
						{"AZ", "31"},
						{"AZ", "AZE"},
						{"AZ", "Azerbaijan"},
						{"AZ", "AZ"},
						{"BS", "44"},
						{"BS", "BHS"},
						{"BS", "Bahamas"},
						{"BS", "BS"},
						{"BH", "48"},
						{"BH", "BHR"},
						{"BH", "Bahrain"},
						{"BH", "BH"},
						{"BD", "50"},
						{"BD", "BGD"},
						{"BD", "Bangladesh"},
						{"BD", "BD"},
						{"BB", "52"},
						{"BB", "BRB"},
						{"BB", "Barbados"},
						{"BB", "BB"},
						{"BY", "112"},
						{"BY", "BLR"},
						{"BY", "Belarus"},
						{"BY", "BY"},
						{"BE", "56"},
						{"BE", "BEL"},
						{"BE", "Belgium"},
						{"BE", "BE"},
						{"BZ", "84"},
						{"BZ", "BLZ"},
						{"BZ", "Belize"},
						{"BZ", "BZ"},
						{"BJ", "204"},
						{"BJ", "BEN"},
						{"BJ", "Benin"},
						{"BJ", "BJ"},
						{"BT", "64"},
						{"BT", "BTN"},
						{"BT", "Bhutan"},
						{"BT", "BT"},
						{"BO", "68"},
						{"BO", "BOL"},
						{"BO", "Bolivia (Plurinational State of)"},
						{"BO", "BO"},
						{"BA", "70"},
						{"BA", "BIH"},
						{"BA", "Bosnia and Herzegovina"},
						{"BA", "BA"},
						{"BW", "72"},
						{"BW", "BWA"},
						{"BW", "Botswana"},
						{"BW", "BW"},
						{"BR", "76"},
						{"BR", "BRA"},
						{"BR", "Brazil"},
						{"BR", "BR"},
						{"BN", "96"},
						{"BN", "BRN"},
						{"BN", "Brunei Darussalam"},
						{"BN", "BN"},
						{"BG", "100"},
						{"BG", "BGR"},
						{"BG", "Bulgaria"},
						{"BG", "BG"},
						{"BF", "854"},
						{"BF", "BFA"},
						{"BF", "Burkina Faso"},
						{"BF", "BF"},
						{"BI", "108"},
						{"BI", "BDI"},
						{"BI", "Burundi"},
						{"BI", "BI"},
						{"CV", "132"},
						{"CV", "CPV"},
						{"CV", "Cabo Verde"},
						{"CV", "CV"},
						{"KH", "116"},
						{"KH", "KHM"},
						{"KH", "Cambodia"},
						{"KH", "KH"},
						{"CM", "120"},
						{"CM", "CMR"},
						{"CM", "Cameroon"},
						{"CM", "CM"},
						{"CA", "124"},
						{"CA", "CAN"},
						{"CA", "Canada"},
						{"CA", "CA"},
						{"CF", "140"},
						{"CF", "CAF"},
						{"CF", "Central African Republic"},
						{"CF", "CF"},
						{"TD", "148"},
						{"TD", "TCD"},
						{"TD", "Chad"},
						{"TD", "TD"},
						{"CL", "152"},
						{"CL", "CHL"},
						{"CL", "Chile"},
						{"CL", "CL"},
						{"CN", "156"},
						{"CN", "CHN"},
						{"CN", "China"},
						{"CN", "CN"},
						{"CO", "170"},
						{"CO", "COL"},
						{"CO", "Colombia"},
						{"CO", "CO"},
						{"KM", "174"},
						{"KM", "COM"},
						{"KM", "Comoros"},
						{"KM", "KM"},
						{"CG", "178"},
						{"CG", "COG"},
						{"CG", "Congo"},
						{"CG", "CG"},
						{"CD", "180"},
						{"CD", "COD"},
						{"CD", "Congo, Democratic Republic of the"},
						{"CD", "CD"},
						{"CR", "188"},
						{"CR", "CRI"},
						{"CR", "Costa Rica"},
						{"CR", "CR"},
						{"CI", "384"},
						{"CI", "CIV"},
						{"CI", "C√¥te d'Ivoire"},
						{"CI", "CI"},
						{"HR", "191"},
						{"HR", "HRV"},
						{"HR", "Croatia"},
						{"HR", "HR"},
						{"CU", "192"},
						{"CU", "CUB"},
						{"CU", "Cuba"},
						{"CU", "CU"},
						{"CY", "196"},
						{"CY", "CYP"},
						{"CY", "Cyprus"},
						{"CY", "CY"},
						{"CZ", "203"},
						{"CZ", "CZE"},
						{"CZ", "Czechia"},
						{"CZ", "CZ"},
						{"DK", "208"},
						{"DK", "DNK"},
						{"DK", "Denmark"},
						{"DK", "DK"},
						{"DJ", "262"},
						{"DJ", "DJI"},
						{"DJ", "Djibouti"},
						{"DJ", "DJ"},
						{"DM", "212"},
						{"DM", "DMA"},
						{"DM", "Dominica"},
						{"DM", "DM"},
						{"DO", "214"},
						{"DO", "DOM"},
						{"DO", "Dominican Republic"},
						{"DO", "DO"},
						{"EC", "218"},
						{"EC", "ECU"},
						{"EC", "Ecuador"},
						{"EC", "EC"},
						{"EG", "818"},
						{"EG", "EGY"},
						{"EG", "Egypt"},
						{"EG", "EG"},
						{"SV", "222"},
						{"SV", "SLV"},
						{"SV", "El Salvador"},
						{"SV", "SV"},
						{"GQ", "226"},
						{"GQ", "GNQ"},
						{"GQ", "Equatorial Guinea"},
						{"GQ", "GQ"},
						{"ER", "232"},
						{"ER", "ERI"},
						{"ER", "Eritrea"},
						{"ER", "ER"},
						{"EE", "233"},
						{"EE", "EST"},
						{"EE", "Estonia"},
						{"EE", "EE"},
						{"SZ", "748"},
						{"SZ", "SWZ"},
						{"SZ", "Eswatini"},
						{"SZ", "SZ"},
						{"ET", "231"},
						{"ET", "ETH"},
						{"ET", "Ethiopia"},
						{"ET", "ET"},
						{"FJ", "242"},
						{"FJ", "FJI"},
						{"FJ", "Fiji"},
						{"FJ", "FJ"},
						{"FI", "246"},
						{"FI", "FIN"},
						{"FI", "Finland"},
						{"FI", "FI"},
						{"FR", "250"},
						{"FR", "FRA"},
						{"FR", "France"},
						{"FR", "FR"},
						{"GA", "266"},
						{"GA", "GAB"},
						{"GA", "Gabon"},
						{"GA", "GA"},
						{"GM", "270"},
						{"GM", "GMB"},
						{"GM", "Gambia"},
						{"GM", "GM"},
						{"GE", "268"},
						{"GE", "GEO"},
						{"GE", "Georgia"},
						{"GE", "GE"},
						{"DE", "276"},
						{"DE", "DEU"},
						{"DE", "Germany"},
						{"DE", "DE"},
						{"GH", "288"},
						{"GH", "GHA"},
						{"GH", "Ghana"},
						{"GH", "GH"},
						{"GR", "300"},
						{"GR", "GRC"},
						{"GR", "Greece"},
						{"GR", "GR"},
						{"GD", "308"},
						{"GD", "GRD"},
						{"GD", "Grenada"},
						{"GD", "GD"},
						{"GT", "320"},
						{"GT", "GTM"},
						{"GT", "Guatemala"},
						{"GT", "GT"},
						{"GN", "324"},
						{"GN", "GIN"},
						{"GN", "Guinea"},
						{"GN", "GN"},
						{"GW", "624"},
						{"GW", "GNB"},
						{"GW", "Guinea-Bissau"},
						{"GW", "GW"},
						{"GY", "328"},
						{"GY", "GUY"},
						{"GY", "Guyana"},
						{"GY", "GY"},
						{"HT", "332"},
						{"HT", "HTI"},
						{"HT", "Haiti"},
						{"HT", "HT"},
						{"HN", "340"},
						{"HN", "HND"},
						{"HN", "Honduras"},
						{"HN", "HN"},
						{"HU", "348"},
						{"HU", "HUN"},
						{"HU", "Hungary"},
						{"HU", "HU"},
						{"IS", "352"},
						{"IS", "ISL"},
						{"IS", "Iceland"},
						{"IS", "IS"},
						{"IN", "356"},
						{"IN", "IND"},
						{"IN", "India"},
						{"IN", "IN"},
						{"ID", "360"},
						{"ID", "IDN"},
						{"ID", "Indonesia"},
						{"ID", "ID"},
						{"IR", "364"},
						{"IR", "IRN"},
						{"IR", "Iran (Islamic Republic of)"},
						{"IR", "IR"},
						{"IQ", "368"},
						{"IQ", "IRQ"},
						{"IQ", "Iraq"},
						{"IQ", "IQ"},
						{"IE", "372"},
						{"IE", "IRL"},
						{"IE", "Ireland"},
						{"IE", "IE"},
						{"IL", "376"},
						{"IL", "ISR"},
						{"IL", "Israel"},
						{"IL", "IL"},
						{"IT", "380"},
						{"IT", "ITA"},
						{"IT", "Italy"},
						{"IT", "IT"},
						{"JM", "388"},
						{"JM", "JAM"},
						{"JM", "Jamaica"},
						{"JM", "JM"},
						{"JP", "392"},
						{"JP", "JPN"},
						{"JP", "Japan"},
						{"JP", "JP"},
						{"JO", "400"},
						{"JO", "JOR"},
						{"JO", "Jordan"},
						{"JO", "JO"},
						{"KZ", "398"},
						{"KZ", "KAZ"},
						{"KZ", "Kazakhstan"},
						{"KZ", "KZ"},
						{"KE", "404"},
						{"KE", "KEN"},
						{"KE", "Kenya"},
						{"KE", "KE"},
						{"KI", "296"},
						{"KI", "KIR"},
						{"KI", "Kiribati"},
						{"KI", "KI"},
						{"KP", "408"},
						{"KP", "PRK"},
						{"KP", "Korea (Democratic People's Republic of)"},
						{"KP", "KP"},
						{"KR", "410"},
						{"KR", "KOR"},
						{"KR", "Korea, Republic of"},
						{"KR", "KR"},
						{"KW", "414"},
						{"KW", "KWT"},
						{"KW", "Kuwait"},
						{"KW", "KW"},
						{"KG", "417"},
						{"KG", "KGZ"},
						{"KG", "Kyrgyzstan"},
						{"KG", "KG"},
						{"LA", "418"},
						{"LA", "LAO"},
						{"LA", "Lao People's Democratic Republic"},
						{"LA", "LA"},
						{"LV", "428"},
						{"LV", "LVA"},
						{"LV", "Latvia"},
						{"LV", "LV"},
						{"LB", "422"},
						{"LB", "LBN"},
						{"LB", "Lebanon"},
						{"LB", "LB"},
						{"LS", "426"},
						{"LS", "LSO"},
						{"LS", "Lesotho"},
						{"LS", "LS"},
						{"LR", "430"},
						{"LR", "LBR"},
						{"LR", "Liberia"},
						{"LR", "LR"},
						{"LY", "434"},
						{"LY", "LBY"},
						{"LY", "Libya"},
						{"LY", "LY"},
						{"LI", "438"},
						{"LI", "LIE"},
						{"LI", "Liechtenstein"},
						{"LI", "LI"},
						{"LT", "440"},
						{"LT", "LTU"},
						{"LT", "Lithuania"},
						{"LT", "LT"},
						{"LU", "442"},
						{"LU", "LUX"},
						{"LU", "Luxembourg"},
						{"LU", "LU"},
						{"MG", "450"},
						{"MG", "MDG"},
						{"MG", "Madagascar"},
						{"MG", "MG"},
						{"MW", "454"},
						{"MW", "MWI"},
						{"MW", "Malawi"},
						{"MW", "MW"},
						{"MY", "458"},
						{"MY", "MYS"},
						{"MY", "Malaysia"},
						{"MY", "MY"},
						{"MV", "462"},
						{"MV", "MDV"},
						{"MV", "Maldives"},
						{"MV", "MV"},
						{"ML", "466"},
						{"ML", "MLI"},
						{"ML", "Mali"},
						{"ML", "ML"},
						{"MT", "470"},
						{"MT", "MLT"},
						{"MT", "Malta"},
						{"MT", "MT"},
						{"MH", "584"},
						{"MH", "MHL"},
						{"MH", "Marshall Islands"},
						{"MH", "MH"},
						{"MR", "478"},
						{"MR", "MRT"},
						{"MR", "Mauritania"},
						{"MR", "MR"},
						{"MU", "480"},
						{"MU", "MUS"},
						{"MU", "Mauritius"},
						{"MU", "MU"},
						{"MX", "484"},
						{"MX", "MEX"},
						{"MX", "Mexico"},
						{"MX", "MX"},
						{"FM", "583"},
						{"FM", "FSM"},
						{"FM", "Micronesia (Federated States of)"},
						{"FM", "FM"},
						{"MD", "498"},
						{"MD", "MDA"},
						{"MD", "Moldova, Republic of"},
						{"MD", "MD"},
						{"MC", "492"},
						{"MC", "MCO"},
						{"MC", "Monaco"},
						{"MC", "MC"},
						{"MN", "496"},
						{"MN", "MNG"},
						{"MN", "Mongolia"},
						{"MN", "MN"},
						{"ME", "499"},
						{"ME", "MNE"},
						{"ME", "Montenegro"},
						{"ME", "ME"},
						{"MA", "504"},
						{"MA", "MAR"},
						{"MA", "Morocco"},
						{"MA", "MA"},
						{"MZ", "508"},
						{"MZ", "MOZ"},
						{"MZ", "Mozambique"},
						{"MZ", "MZ"},
						{"MM", "104"},
						{"MM", "MMR"},
						{"MM", "Myanmar"},
						{"MM", "MM"},
						{"NA", "516"},
						{"NA", "NAM"},
						{"NA", "Namibia"},
						{"NA", "NA"},
						{"NR", "520"},
						{"NR", "NRU"},
						{"NR", "Nauru"},
						{"NR", "NR"},
						{"NP", "524"},
						{"NP", "NPL"},
						{"NP", "Nepal"},
						{"NP", "NP"},
						{"NL", "528"},
						{"NL", "NLD"},
						{"NL", "Netherlands"},
						{"NL", "NL"},
						{"NZ", "554"},
						{"NZ", "NZL"},
						{"NZ", "New Zealand"},
						{"NZ", "NZ"},
						{"NI", "558"},
						{"NI", "NIC"},
						{"NI", "Nicaragua"},
						{"NI", "NI"},
						{"NE", "562"},
						{"NE", "NER"},
						{"NE", "Niger"},
						{"NE", "NE"},
						{"NG", "566"},
						{"NG", "NGA"},
						{"NG", "Nigeria"},
						{"NG", "NG"},
						{"MK", "807"},
						{"MK", "MKD"},
						{"MK", "North Macedonia"},
						{"MK", "MK"},
						{"NO", "578"},
						{"NO", "NOR"},
						{"NO", "Norway"},
						{"NO", "NO"},
						{"OM", "512"},
						{"OM", "OMN"},
						{"OM", "Oman"},
						{"OM", "OM"},
						{"PK", "586"},
						{"PK", "PAK"},
						{"PK", "Pakistan"},
						{"PK", "PK"},
						{"PW", "585"},
						{"PW", "PLW"},
						{"PW", "Palau"},
						{"PW", "PW"},
						{"PA", "591"},
						{"PA", "PAN"},
						{"PA", "Panama"},
						{"PA", "PA"},
						{"PG", "598"},
						{"PG", "PNG"},
						{"PG", "Papua New Guinea"},
						{"PG", "PG"},
						{"PY", "600"},
						{"PY", "PRY"},
						{"PY", "Paraguay"},
						{"PY", "PY"},
						{"PE", "604"},
						{"PE", "PER"},
						{"PE", "Peru"},
						{"PE", "PE"},
						{"PH", "608"},
						{"PH", "PHL"},
						{"PH", "Philippines"},
						{"PH", "PH"},
						{"PL", "616"},
						{"PL", "POL"},
						{"PL", "Poland"},
						{"PL", "PL"},
						{"PT", "620"},
						{"PT", "PRT"},
						{"PT", "Portugal"},
						{"PT", "PT"},
						{"QA", "634"},
						{"QA", "QAT"},
						{"QA", "Qatar"},
						{"QA", "QA"},
						{"RO", "642"},
						{"RO", "ROU"},
						{"RO", "Romania"},
						{"RO", "RO"},
						{"RU", "643"},
						{"RU", "RUS"},
						{"RU", "Russian Federation"},
						{"RU", "RU"},
						{"RW", "646"},
						{"RW", "RWA"},
						{"RW", "Rwanda"},
						{"RW", "RW"},
						{"KN", "659"},
						{"KN", "KNA"},
						{"KN", "Saint Kitts and Nevis"},
						{"KN", "KN"},
						{"LC", "662"},
						{"LC", "LCA"},
						{"LC", "Saint Lucia"},
						{"LC", "LC"},
						{"VC", "670"},
						{"VC", "VCT"},
						{"VC", "Saint Vincent and the Grenadines"},
						{"VC", "VC"},
						{"WS", "882"},
						{"WS", "WSM"},
						{"WS", "Samoa"},
						{"WS", "WS"},
						{"SM", "674"},
						{"SM", "SMR"},
						{"SM", "San Marino"},
						{"SM", "SM"},
						{"ST", "678"},
						{"ST", "STP"},
						{"ST", "Sao Tome and Principe"},
						{"ST", "ST"},
						{"SA", "682"},
						{"SA", "SAU"},
						{"SA", "Saudi Arabia"},
						{"SA", "SA"},
						{"SN", "686"},
						{"SN", "SEN"},
						{"SN", "Senegal"},
						{"SN", "SN"},
						{"RS", "688"},
						{"RS", "SRB"},
						{"RS", "Serbia"},
						{"RS", "RS"},
						{"SC", "690"},
						{"SC", "SYC"},
						{"SC", "Seychelles"},
						{"SC", "SC"},
						{"SL", "694"},
						{"SL", "SLE"},
						{"SL", "Sierra Leone"},
						{"SL", "SL"},
						{"SG", "702"},
						{"SG", "SGP"},
						{"SG", "Singapore"},
						{"SG", "SG"},
						{"SK", "703"},
						{"SK", "SVK"},
						{"SK", "Slovakia"},
						{"SK", "SK"},
						{"SI", "705"},
						{"SI", "SVN"},
						{"SI", "Slovenia"},
						{"SI", "SI"},
						{"SB", "90"},
						{"SB", "SLB"},
						{"SB", "Solomon Islands"},
						{"SB", "SB"},
						{"SO", "706"},
						{"SO", "SOM"},
						{"SO", "Somalia"},
						{"SO", "SO"},
						{"ZA", "710"},
						{"ZA", "ZAF"},
						{"ZA", "South Africa"},
						{"ZA", "ZA"},
						{"SS", "728"},
						{"SS", "SSD"},
						{"SS", "South Sudan"},
						{"SS", "SS"},
						{"ES", "724"},
						{"ES", "ESP"},
						{"ES", "Spain"},
						{"ES", "ES"},
						{"LK", "144"},
						{"LK", "LKA"},
						{"LK", "Sri Lanka"},
						{"LK", "LK"},
						{"SD", "729"},
						{"SD", "SDN"},
						{"SD", "Sudan"},
						{"SD", "SD"},
						{"SR", "740"},
						{"SR", "SUR"},
						{"SR", "Suriname"},
						{"SR", "SR"},
						{"SE", "752"},
						{"SE", "SWE"},
						{"SE", "Sweden"},
						{"SE", "SE"},
						{"CH", "756"},
						{"CH", "CHE"},
						{"CH", "Switzerland"},
						{"CH", "CH"},
						{"SY", "760"},
						{"SY", "SYR"},
						{"SY", "Syrian Arab Republic"},
						{"SY", "SY"},
						{"TJ", "762"},
						{"TJ", "TJK"},
						{"TJ", "Tajikistan"},
						{"TJ", "TJ"},
						{"TZ", "834"},
						{"TZ", "TZA"},
						{"TZ", "Tanzania, United Republic of"},
						{"TZ", "TZ"},
						{"TH", "764"},
						{"TH", "THA"},
						{"TH", "Thailand"},
						{"TH", "TH"},
						{"TL", "626"},
						{"TL", "TLS"},
						{"TL", "Timor-Leste"},
						{"TL", "TL"},
						{"TG", "768"},
						{"TG", "TGO"},
						{"TG", "Togo"},
						{"TG", "TG"},
						{"TO", "776"},
						{"TO", "TON"},
						{"TO", "Tonga"},
						{"TO", "TO"},
						{"TT", "780"},
						{"TT", "TTO"},
						{"TT", "Trinidad and Tobago"},
						{"TT", "TT"},
						{"TN", "788"},
						{"TN", "TUN"},
						{"TN", "Tunisia"},
						{"TN", "TN"},
						{"TR", "792"},
						{"TR", "TUR"},
						{"TR", "T√ºrkiye"},
						{"TR", "TR"},
						{"TM", "795"},
						{"TM", "TKM"},
						{"TM", "Turkmenistan"},
						{"TM", "TM"},
						{"TV", "798"},
						{"TV", "TUV"},
						{"TV", "Tuvalu"},
						{"TV", "TV"},
						{"UG", "800"},
						{"UG", "UGA"},
						{"UG", "Uganda"},
						{"UG", "UG"},
						{"UA", "804"},
						{"UA", "UKR"},
						{"UA", "Ukraine"},
						{"UA", "UA"},
						{"AE", "784"},
						{"AE", "ARE"},
						{"AE", "United Arab Emirates"},
						{"AE", "AE"},
						{"GB", "826"},
						{"GB", "GBR"},
						{"GB", "United Kingdom of Great Britain and Northern Ireland"},
						{"GB", "GB"},
						{"GB", "United Kingdom"},
						{"GB", "Great Britain"},
						{"GB", "UK"},
						{"US", "840"},
						{"US", "USA"},
						{"US", "United States of America"},
						{"US", "US"},
						{"UY", "858"},
						{"UY", "URY"},
						{"UY", "Uruguay"},
						{"UY", "UY"},
						{"UZ", "860"},
						{"UZ", "UZB"},
						{"UZ", "Uzbekistan"},
						{"UZ", "UZ"},
						{"VU", "548"},
						{"VU", "VUT"},
						{"VU", "Vanuatu"},
						{"VU", "VU"},
						{"VE", "862"},
						{"VE", "VEN"},
						{"VE", "Venezuela (Bolivarian Republic of)"},
						{"VE", "VE"},
						{"VN", "704"},
						{"VN", "VNM"},
						{"VN", "Viet Nam"},
						{"VN", "VN"},
						{"YE", "887"},
						{"YE", "YEM"},
						{"YE", "Yemen"},
						{"YE", "YE"},
						{"ZM", "894"},
						{"ZM", "ZMB"},
						{"ZM", "Zambia"},
						{"ZM", "ZM"},
						{"ZW", "716"},
						{"ZW", "ZWE"},
						{"ZW", "Zimbabwe"},
						{"ZW", "ZW"}
					}
				),
			defaultContinents =
				#table(
					type table [
						#"Global Code" = Int64.Type,
						#"Global Name" = Text.Type,
						#"Region Code" = Int64.Type,
						#"Region Name" = Text.Type,
						#"Sub-region Code" = Int64.Type,
						#"Sub-region Name" = Text.Type,
						#"Intermediate Region Code" = Int64.Type,
						#"Intermediate Region Name" = Text.Type,
						#"ISO-alpha2 Code" = Text.Type
					],
					{
						{1, "World", 2, "Africa", 15, "Northern Africa", null, "", "DZ"},
						{1, "World", 2, "Africa", 15, "Northern Africa", null, "", "EG"},
						{1, "World", 2, "Africa", 15, "Northern Africa", null, "", "LY"},
						{1, "World", 2, "Africa", 15, "Northern Africa", null, "", "MA"},
						{1, "World", 2, "Africa", 15, "Northern Africa", null, "", "SD"},
						{1, "World", 2, "Africa", 15, "Northern Africa", null, "", "TN"},
						{1, "World", 2, "Africa", 15, "Northern Africa", null, "", "EH"},
						{1, "World", 2, "Africa", 202, "Sub-Saharan Africa", 14, "Eastern Africa", "IO"},
						{1, "World", 2, "Africa", 202, "Sub-Saharan Africa", 14, "Eastern Africa", "BI"},
						{1, "World", 2, "Africa", 202, "Sub-Saharan Africa", 14, "Eastern Africa", "KM"},
						{1, "World", 2, "Africa", 202, "Sub-Saharan Africa", 14, "Eastern Africa", "DJ"},
						{1, "World", 2, "Africa", 202, "Sub-Saharan Africa", 14, "Eastern Africa", "ER"},
						{1, "World", 2, "Africa", 202, "Sub-Saharan Africa", 14, "Eastern Africa", "ET"},
						{1, "World", 2, "Africa", 202, "Sub-Saharan Africa", 14, "Eastern Africa", "TF"},
						{1, "World", 2, "Africa", 202, "Sub-Saharan Africa", 14, "Eastern Africa", "KE"},
						{1, "World", 2, "Africa", 202, "Sub-Saharan Africa", 14, "Eastern Africa", "MG"},
						{1, "World", 2, "Africa", 202, "Sub-Saharan Africa", 14, "Eastern Africa", "MW"},
						{1, "World", 2, "Africa", 202, "Sub-Saharan Africa", 14, "Eastern Africa", "MU"},
						{1, "World", 2, "Africa", 202, "Sub-Saharan Africa", 14, "Eastern Africa", "YT"},
						{1, "World", 2, "Africa", 202, "Sub-Saharan Africa", 14, "Eastern Africa", "MZ"},
						{1, "World", 2, "Africa", 202, "Sub-Saharan Africa", 14, "Eastern Africa", "RE"},
						{1, "World", 2, "Africa", 202, "Sub-Saharan Africa", 14, "Eastern Africa", "RW"},
						{1, "World", 2, "Africa", 202, "Sub-Saharan Africa", 14, "Eastern Africa", "SC"},
						{1, "World", 2, "Africa", 202, "Sub-Saharan Africa", 14, "Eastern Africa", "SO"},
						{1, "World", 2, "Africa", 202, "Sub-Saharan Africa", 14, "Eastern Africa", "SS"},
						{1, "World", 2, "Africa", 202, "Sub-Saharan Africa", 14, "Eastern Africa", "UG"},
						{1, "World", 2, "Africa", 202, "Sub-Saharan Africa", 14, "Eastern Africa", "TZ"},
						{1, "World", 2, "Africa", 202, "Sub-Saharan Africa", 14, "Eastern Africa", "ZM"},
						{1, "World", 2, "Africa", 202, "Sub-Saharan Africa", 14, "Eastern Africa", "ZW"},
						{1, "World", 2, "Africa", 202, "Sub-Saharan Africa", 17, "Middle Africa", "AO"},
						{1, "World", 2, "Africa", 202, "Sub-Saharan Africa", 17, "Middle Africa", "CM"},
						{1, "World", 2, "Africa", 202, "Sub-Saharan Africa", 17, "Middle Africa", "CF"},
						{1, "World", 2, "Africa", 202, "Sub-Saharan Africa", 17, "Middle Africa", "TD"},
						{1, "World", 2, "Africa", 202, "Sub-Saharan Africa", 17, "Middle Africa", "CG"},
						{1, "World", 2, "Africa", 202, "Sub-Saharan Africa", 17, "Middle Africa", "CD"},
						{1, "World", 2, "Africa", 202, "Sub-Saharan Africa", 17, "Middle Africa", "GQ"},
						{1, "World", 2, "Africa", 202, "Sub-Saharan Africa", 17, "Middle Africa", "GA"},
						{1, "World", 2, "Africa", 202, "Sub-Saharan Africa", 17, "Middle Africa", "ST"},
						{1, "World", 2, "Africa", 202, "Sub-Saharan Africa", 18, "Southern Africa", "BW"},
						{1, "World", 2, "Africa", 202, "Sub-Saharan Africa", 18, "Southern Africa", "SZ"},
						{1, "World", 2, "Africa", 202, "Sub-Saharan Africa", 18, "Southern Africa", "LS"},
						{1, "World", 2, "Africa", 202, "Sub-Saharan Africa", 18, "Southern Africa", "NA"},
						{1, "World", 2, "Africa", 202, "Sub-Saharan Africa", 18, "Southern Africa", "ZA"},
						{1, "World", 2, "Africa", 202, "Sub-Saharan Africa", 11, "Western Africa", "BJ"},
						{1, "World", 2, "Africa", 202, "Sub-Saharan Africa", 11, "Western Africa", "BF"},
						{1, "World", 2, "Africa", 202, "Sub-Saharan Africa", 11, "Western Africa", "CV"},
						{1, "World", 2, "Africa", 202, "Sub-Saharan Africa", 11, "Western Africa", "CI"},
						{1, "World", 2, "Africa", 202, "Sub-Saharan Africa", 11, "Western Africa", "GM"},
						{1, "World", 2, "Africa", 202, "Sub-Saharan Africa", 11, "Western Africa", "GH"},
						{1, "World", 2, "Africa", 202, "Sub-Saharan Africa", 11, "Western Africa", "GN"},
						{1, "World", 2, "Africa", 202, "Sub-Saharan Africa", 11, "Western Africa", "GW"},
						{1, "World", 2, "Africa", 202, "Sub-Saharan Africa", 11, "Western Africa", "LR"},
						{1, "World", 2, "Africa", 202, "Sub-Saharan Africa", 11, "Western Africa", "ML"},
						{1, "World", 2, "Africa", 202, "Sub-Saharan Africa", 11, "Western Africa", "MR"},
						{1, "World", 2, "Africa", 202, "Sub-Saharan Africa", 11, "Western Africa", "NE"},
						{1, "World", 2, "Africa", 202, "Sub-Saharan Africa", 11, "Western Africa", "NG"},
						{1, "World", 2, "Africa", 202, "Sub-Saharan Africa", 11, "Western Africa", "SH"},
						{1, "World", 2, "Africa", 202, "Sub-Saharan Africa", 11, "Western Africa", "SN"},
						{1, "World", 2, "Africa", 202, "Sub-Saharan Africa", 11, "Western Africa", "SL"},
						{1, "World", 2, "Africa", 202, "Sub-Saharan Africa", 11, "Western Africa", "TG"},
						{1, "World", 19, "Americas", 419, "Latin America and the Caribbean", 29, "Caribbean", "AI"},
						{1, "World", 19, "Americas", 419, "Latin America and the Caribbean", 29, "Caribbean", "AG"},
						{1, "World", 19, "Americas", 419, "Latin America and the Caribbean", 29, "Caribbean", "AW"},
						{1, "World", 19, "Americas", 419, "Latin America and the Caribbean", 29, "Caribbean", "BS"},
						{1, "World", 19, "Americas", 419, "Latin America and the Caribbean", 29, "Caribbean", "BB"},
						{1, "World", 19, "Americas", 419, "Latin America and the Caribbean", 29, "Caribbean", "BQ"},
						{1, "World", 19, "Americas", 419, "Latin America and the Caribbean", 29, "Caribbean", "VG"},
						{1, "World", 19, "Americas", 419, "Latin America and the Caribbean", 29, "Caribbean", "KY"},
						{1, "World", 19, "Americas", 419, "Latin America and the Caribbean", 29, "Caribbean", "CU"},
						{1, "World", 19, "Americas", 419, "Latin America and the Caribbean", 29, "Caribbean", "CW"},
						{1, "World", 19, "Americas", 419, "Latin America and the Caribbean", 29, "Caribbean", "DM"},
						{1, "World", 19, "Americas", 419, "Latin America and the Caribbean", 29, "Caribbean", "DO"},
						{1, "World", 19, "Americas", 419, "Latin America and the Caribbean", 29, "Caribbean", "GD"},
						{1, "World", 19, "Americas", 419, "Latin America and the Caribbean", 29, "Caribbean", "GP"},
						{1, "World", 19, "Americas", 419, "Latin America and the Caribbean", 29, "Caribbean", "HT"},
						{1, "World", 19, "Americas", 419, "Latin America and the Caribbean", 29, "Caribbean", "JM"},
						{1, "World", 19, "Americas", 419, "Latin America and the Caribbean", 29, "Caribbean", "MQ"},
						{1, "World", 19, "Americas", 419, "Latin America and the Caribbean", 29, "Caribbean", "MS"},
						{1, "World", 19, "Americas", 419, "Latin America and the Caribbean", 29, "Caribbean", "PR"},
						{1, "World", 19, "Americas", 419, "Latin America and the Caribbean", 29, "Caribbean", "BL"},
						{1, "World", 19, "Americas", 419, "Latin America and the Caribbean", 29, "Caribbean", "KN"},
						{1, "World", 19, "Americas", 419, "Latin America and the Caribbean", 29, "Caribbean", "LC"},
						{1, "World", 19, "Americas", 419, "Latin America and the Caribbean", 29, "Caribbean", "MF"},
						{1, "World", 19, "Americas", 419, "Latin America and the Caribbean", 29, "Caribbean", "VC"},
						{1, "World", 19, "Americas", 419, "Latin America and the Caribbean", 29, "Caribbean", "SX"},
						{1, "World", 19, "Americas", 419, "Latin America and the Caribbean", 29, "Caribbean", "TT"},
						{1, "World", 19, "Americas", 419, "Latin America and the Caribbean", 29, "Caribbean", "TC"},
						{1, "World", 19, "Americas", 419, "Latin America and the Caribbean", 29, "Caribbean", "VI"},
						{1, "World", 19, "Americas", 419, "Latin America and the Caribbean", 13, "Central America", "BZ"},
						{1, "World", 19, "Americas", 419, "Latin America and the Caribbean", 13, "Central America", "CR"},
						{1, "World", 19, "Americas", 419, "Latin America and the Caribbean", 13, "Central America", "SV"},
						{1, "World", 19, "Americas", 419, "Latin America and the Caribbean", 13, "Central America", "GT"},
						{1, "World", 19, "Americas", 419, "Latin America and the Caribbean", 13, "Central America", "HN"},
						{1, "World", 19, "Americas", 419, "Latin America and the Caribbean", 13, "Central America", "MX"},
						{1, "World", 19, "Americas", 419, "Latin America and the Caribbean", 13, "Central America", "NI"},
						{1, "World", 19, "Americas", 419, "Latin America and the Caribbean", 13, "Central America", "PA"},
						{1, "World", 19, "Americas", 419, "Latin America and the Caribbean", 5, "South America", "AR"},
						{1, "World", 19, "Americas", 419, "Latin America and the Caribbean", 5, "South America", "BO"},
						{1, "World", 19, "Americas", 419, "Latin America and the Caribbean", 5, "South America", "BV"},
						{1, "World", 19, "Americas", 419, "Latin America and the Caribbean", 5, "South America", "BR"},
						{1, "World", 19, "Americas", 419, "Latin America and the Caribbean", 5, "South America", "CL"},
						{1, "World", 19, "Americas", 419, "Latin America and the Caribbean", 5, "South America", "CO"},
						{1, "World", 19, "Americas", 419, "Latin America and the Caribbean", 5, "South America", "EC"},
						{1, "World", 19, "Americas", 419, "Latin America and the Caribbean", 5, "South America", "FK"},
						{1, "World", 19, "Americas", 419, "Latin America and the Caribbean", 5, "South America", "GF"},
						{1, "World", 19, "Americas", 419, "Latin America and the Caribbean", 5, "South America", "GY"},
						{1, "World", 19, "Americas", 419, "Latin America and the Caribbean", 5, "South America", "PY"},
						{1, "World", 19, "Americas", 419, "Latin America and the Caribbean", 5, "South America", "PE"},
						{1, "World", 19, "Americas", 419, "Latin America and the Caribbean", 5, "South America", "GS"},
						{1, "World", 19, "Americas", 419, "Latin America and the Caribbean", 5, "South America", "SR"},
						{1, "World", 19, "Americas", 419, "Latin America and the Caribbean", 5, "South America", "UY"},
						{1, "World", 19, "Americas", 419, "Latin America and the Caribbean", 5, "South America", "VE"},
						{1, "World", 19, "Americas", 21, "Northern America", null, "", "BM"},
						{1, "World", 19, "Americas", 21, "Northern America", null, "", "CA"},
						{1, "World", 19, "Americas", 21, "Northern America", null, "", "GL"},
						{1, "World", 19, "Americas", 21, "Northern America", null, "", "PM"},
						{1, "World", 19, "Americas", 21, "Northern America", null, "", "US"},
						{1, "World", null, "", null, "", null, "", "AQ"},
						{1, "World", 142, "Asia", 143, "Central Asia", null, "", "KZ"},
						{1, "World", 142, "Asia", 143, "Central Asia", null, "", "KG"},
						{1, "World", 142, "Asia", 143, "Central Asia", null, "", "TJ"},
						{1, "World", 142, "Asia", 143, "Central Asia", null, "", "TM"},
						{1, "World", 142, "Asia", 143, "Central Asia", null, "", "UZ"},
						{1, "World", 142, "Asia", 30, "Eastern Asia", null, "", "CN"},
						{1, "World", 142, "Asia", 30, "Eastern Asia", null, "", "HK"},
						{1, "World", 142, "Asia", 30, "Eastern Asia", null, "", "MO"},
						{1, "World", 142, "Asia", 30, "Eastern Asia", null, "", "KP"},
						{1, "World", 142, "Asia", 30, "Eastern Asia", null, "", "JP"},
						{1, "World", 142, "Asia", 30, "Eastern Asia", null, "", "MN"},
						{1, "World", 142, "Asia", 30, "Eastern Asia", null, "", "KR"},
						{1, "World", 142, "Asia", 35, "South-eastern Asia", null, "", "BN"},
						{1, "World", 142, "Asia", 35, "South-eastern Asia", null, "", "KH"},
						{1, "World", 142, "Asia", 35, "South-eastern Asia", null, "", "ID"},
						{1, "World", 142, "Asia", 35, "South-eastern Asia", null, "", "LA"},
						{1, "World", 142, "Asia", 35, "South-eastern Asia", null, "", "MY"},
						{1, "World", 142, "Asia", 35, "South-eastern Asia", null, "", "MM"},
						{1, "World", 142, "Asia", 35, "South-eastern Asia", null, "", "PH"},
						{1, "World", 142, "Asia", 35, "South-eastern Asia", null, "", "SG"},
						{1, "World", 142, "Asia", 35, "South-eastern Asia", null, "", "TH"},
						{1, "World", 142, "Asia", 35, "South-eastern Asia", null, "", "TL"},
						{1, "World", 142, "Asia", 35, "South-eastern Asia", null, "", "VN"},
						{1, "World", 142, "Asia", 34, "Southern Asia", null, "", "AF"},
						{1, "World", 142, "Asia", 34, "Southern Asia", null, "", "BD"},
						{1, "World", 142, "Asia", 34, "Southern Asia", null, "", "BT"},
						{1, "World", 142, "Asia", 34, "Southern Asia", null, "", "IN"},
						{1, "World", 142, "Asia", 34, "Southern Asia", null, "", "IR"},
						{1, "World", 142, "Asia", 34, "Southern Asia", null, "", "MV"},
						{1, "World", 142, "Asia", 34, "Southern Asia", null, "", "NP"},
						{1, "World", 142, "Asia", 34, "Southern Asia", null, "", "PK"},
						{1, "World", 142, "Asia", 34, "Southern Asia", null, "", "LK"},
						{1, "World", 142, "Asia", 145, "Western Asia", null, "", "AM"},
						{1, "World", 142, "Asia", 145, "Western Asia", null, "", "AZ"},
						{1, "World", 142, "Asia", 145, "Western Asia", null, "", "BH"},
						{1, "World", 142, "Asia", 145, "Western Asia", null, "", "CY"},
						{1, "World", 142, "Asia", 145, "Western Asia", null, "", "GE"},
						{1, "World", 142, "Asia", 145, "Western Asia", null, "", "IQ"},
						{1, "World", 142, "Asia", 145, "Western Asia", null, "", "IL"},
						{1, "World", 142, "Asia", 145, "Western Asia", null, "", "JO"},
						{1, "World", 142, "Asia", 145, "Western Asia", null, "", "KW"},
						{1, "World", 142, "Asia", 145, "Western Asia", null, "", "LB"},
						{1, "World", 142, "Asia", 145, "Western Asia", null, "", "OM"},
						{1, "World", 142, "Asia", 145, "Western Asia", null, "", "QA"},
						{1, "World", 142, "Asia", 145, "Western Asia", null, "", "SA"},
						{1, "World", 142, "Asia", 145, "Western Asia", null, "", "PS"},
						{1, "World", 142, "Asia", 145, "Western Asia", null, "", "SY"},
						{1, "World", 142, "Asia", 145, "Western Asia", null, "", "TR"},
						{1, "World", 142, "Asia", 145, "Western Asia", null, "", "AE"},
						{1, "World", 142, "Asia", 145, "Western Asia", null, "", "YE"},
						{1, "World", 150, "Europe", 151, "Eastern Europe", null, "", "BY"},
						{1, "World", 150, "Europe", 151, "Eastern Europe", null, "", "BG"},
						{1, "World", 150, "Europe", 151, "Eastern Europe", null, "", "CZ"},
						{1, "World", 150, "Europe", 151, "Eastern Europe", null, "", "HU"},
						{1, "World", 150, "Europe", 151, "Eastern Europe", null, "", "PL"},
						{1, "World", 150, "Europe", 151, "Eastern Europe", null, "", "MD"},
						{1, "World", 150, "Europe", 151, "Eastern Europe", null, "", "RO"},
						{1, "World", 150, "Europe", 151, "Eastern Europe", null, "", "RU"},
						{1, "World", 150, "Europe", 151, "Eastern Europe", null, "", "SK"},
						{1, "World", 150, "Europe", 151, "Eastern Europe", null, "", "UA"},
						{1, "World", 150, "Europe", 154, "Northern Europe", null, "", "AX"},
						{1, "World", 150, "Europe", 154, "Northern Europe", 830, "Channel Islands", "GG"},
						{1, "World", 150, "Europe", 154, "Northern Europe", 830, "Channel Islands", "JE"},
						{1, "World", 150, "Europe", 154, "Northern Europe", 830, "Channel Islands", ""},
						{1, "World", 150, "Europe", 154, "Northern Europe", null, "", "DK"},
						{1, "World", 150, "Europe", 154, "Northern Europe", null, "", "EE"},
						{1, "World", 150, "Europe", 154, "Northern Europe", null, "", "FO"},
						{1, "World", 150, "Europe", 154, "Northern Europe", null, "", "FI"},
						{1, "World", 150, "Europe", 154, "Northern Europe", null, "", "IS"},
						{1, "World", 150, "Europe", 154, "Northern Europe", null, "", "IE"},
						{1, "World", 150, "Europe", 154, "Northern Europe", null, "", "IM"},
						{1, "World", 150, "Europe", 154, "Northern Europe", null, "", "LV"},
						{1, "World", 150, "Europe", 154, "Northern Europe", null, "", "LT"},
						{1, "World", 150, "Europe", 154, "Northern Europe", null, "", "NO"},
						{1, "World", 150, "Europe", 154, "Northern Europe", null, "", "SJ"},
						{1, "World", 150, "Europe", 154, "Northern Europe", null, "", "SE"},
						{1, "World", 150, "Europe", 154, "Northern Europe", null, "", "GB"},
						{1, "World", 150, "Europe", 39, "Southern Europe", null, "", "AL"},
						{1, "World", 150, "Europe", 39, "Southern Europe", null, "", "AD"},
						{1, "World", 150, "Europe", 39, "Southern Europe", null, "", "BA"},
						{1, "World", 150, "Europe", 39, "Southern Europe", null, "", "HR"},
						{1, "World", 150, "Europe", 39, "Southern Europe", null, "", "GI"},
						{1, "World", 150, "Europe", 39, "Southern Europe", null, "", "GR"},
						{1, "World", 150, "Europe", 39, "Southern Europe", null, "", "VA"},
						{1, "World", 150, "Europe", 39, "Southern Europe", null, "", "IT"},
						{1, "World", 150, "Europe", 39, "Southern Europe", null, "", "MT"},
						{1, "World", 150, "Europe", 39, "Southern Europe", null, "", "ME"},
						{1, "World", 150, "Europe", 39, "Southern Europe", null, "", "MK"},
						{1, "World", 150, "Europe", 39, "Southern Europe", null, "", "PT"},
						{1, "World", 150, "Europe", 39, "Southern Europe", null, "", "SM"},
						{1, "World", 150, "Europe", 39, "Southern Europe", null, "", "RS"},
						{1, "World", 150, "Europe", 39, "Southern Europe", null, "", "SI"},
						{1, "World", 150, "Europe", 39, "Southern Europe", null, "", "ES"},
						{1, "World", 150, "Europe", 155, "Western Europe", null, "", "AT"},
						{1, "World", 150, "Europe", 155, "Western Europe", null, "", "BE"},
						{1, "World", 150, "Europe", 155, "Western Europe", null, "", "FR"},
						{1, "World", 150, "Europe", 155, "Western Europe", null, "", "DE"},
						{1, "World", 150, "Europe", 155, "Western Europe", null, "", "LI"},
						{1, "World", 150, "Europe", 155, "Western Europe", null, "", "LU"},
						{1, "World", 150, "Europe", 155, "Western Europe", null, "", "MC"},
						{1, "World", 150, "Europe", 155, "Western Europe", null, "", "NL"},
						{1, "World", 150, "Europe", 155, "Western Europe", null, "", "CH"},
						{1, "World", 9, "Oceania", 53, "Australia and New Zealand", null, "", "AU"},
						{1, "World", 9, "Oceania", 53, "Australia and New Zealand", null, "", "CX"},
						{1, "World", 9, "Oceania", 53, "Australia and New Zealand", null, "", "CC"},
						{1, "World", 9, "Oceania", 53, "Australia and New Zealand", null, "", "HM"},
						{1, "World", 9, "Oceania", 53, "Australia and New Zealand", null, "", "NZ"},
						{1, "World", 9, "Oceania", 53, "Australia and New Zealand", null, "", "NF"},
						{1, "World", 9, "Oceania", 54, "Melanesia", null, "", "FJ"},
						{1, "World", 9, "Oceania", 54, "Melanesia", null, "", "NC"},
						{1, "World", 9, "Oceania", 54, "Melanesia", null, "", "PG"},
						{1, "World", 9, "Oceania", 54, "Melanesia", null, "", "SB"},
						{1, "World", 9, "Oceania", 54, "Melanesia", null, "", "VU"},
						{1, "World", 9, "Oceania", 57, "Micronesia", null, "", "GU"},
						{1, "World", 9, "Oceania", 57, "Micronesia", null, "", "KI"},
						{1, "World", 9, "Oceania", 57, "Micronesia", null, "", "MH"},
						{1, "World", 9, "Oceania", 57, "Micronesia", null, "", "FM"},
						{1, "World", 9, "Oceania", 57, "Micronesia", null, "", "NR"},
						{1, "World", 9, "Oceania", 57, "Micronesia", null, "", "MP"},
						{1, "World", 9, "Oceania", 57, "Micronesia", null, "", "PW"},
						{1, "World", 9, "Oceania", 57, "Micronesia", null, "", "UM"},
						{1, "World", 9, "Oceania", 61, "Polynesia", null, "", "AS"},
						{1, "World", 9, "Oceania", 61, "Polynesia", null, "", "CK"},
						{1, "World", 9, "Oceania", 61, "Polynesia", null, "", "PF"},
						{1, "World", 9, "Oceania", 61, "Polynesia", null, "", "NU"},
						{1, "World", 9, "Oceania", 61, "Polynesia", null, "", "PN"},
						{1, "World", 9, "Oceania", 61, "Polynesia", null, "", "WS"},
						{1, "World", 9, "Oceania", 61, "Polynesia", null, "", "TK"},
						{1, "World", 9, "Oceania", 61, "Polynesia", null, "", "TO"},
						{1, "World", 9, "Oceania", 61, "Polynesia", null, "", "TV"},
						{1, "World", 9, "Oceania", 61, "Polynesia", null, "", "WF"}
					}
				),
			createWorld = 
				let
					NewWorld = (world as record) => 
						[
							countryInfo = 
								let
									// Define the function type
									countryInfoType = type function (
										optional code as (type text meta [
											Documentation.FieldCaption = "Country Code",
											Documentation.FieldDescription = "The country code to lookup (e.g. US, FR, JP)",
											Documentation.SampleValues = {"US", "FR", "JP"}
										]))
										as record meta [
											Documentation.Name = "countryInfo",
											Documentation.LongDescription = "Retrieves information about a country, including its numeric code, alpha3 code, and name.",
											Documentation.Examples = {[
												Description = "Returns information about the United States of America",
												Code = "countryInfo(""US"")",
												Result = "[#" & """Country Code (numeric)" & """ = ""840""," & """Country Code""" & " = ""US""," & """Country Code (alpha3)""" & " = ""USA""," & """Country Name""" & " = ""United States of America""]"
											],[
												Description = "Returns information about France",
												Code = "countryInfo(""FR"")",
												Result = "[#" & """Country Code (numeric)" & """ = ""250""," & """Country Code""" & " = ""FR""," & """Country Code (alpha3)""" & " = ""FRA""," & """Country Name""" & " = ""France""]"
											]}
										],

									// Define the function implementation
									countryInfoImpl = (optional code as text) =>
										world[Countries]{[Country Code = code]},

									fn = Value.ReplaceType(countryInfoImpl, countryInfoType)
								in
									fn,

							findCountry = 
								let
									// Define the function type
									findCountryType = type function (
										name as (type text meta [
											Documentation.FieldCaption = "Country Name",
											Documentation.FieldDescription = "The name of the country to search for",
											Documentation.SampleValues = {"Brazil", "Japan", "Spain"}
										]))
										as (type nullable text) meta [
											Documentation.Name = "findCountry",
											Documentation.LongDescription = "<b>FOR BEST RESULTS: Add a new query that references this function within your ISO-3166 object.</b>#(cr)#(cr)Returns the ISO 3166-1 alpha-2 code for the given country name, or an error if the country is not found.",
											Documentation.Examples = {[
												Description = "Returns 'BR' for Brazil",
												Code = "findCountry(""Brazil"")",
												Result = """BR"""
											],[
												Description = "Returns 'JP' for Japan",
												Code = "findCountry(""Japan"")",
												Result = """JP"""
											]}
										],

									// Define the function implementation
									findCountryImpl = (name as text) as nullable text =>
										try world[Possible Names]{[Possible Name = Text.Proper(name)]}[Country Code] otherwise Error.Record("Country Missing","Could not find country in list of possible names",name),

									fn = Value.ReplaceType(findCountryImpl, findCountryType)
								in
									fn,

							addCountryName = 
								let
									// Define the function type
									addCountryNameType = type function (
										code as (type text meta [
											Documentation.FieldCaption = "Country Code",
											Documentation.FieldDescription = "The ISO 3166-1 alpha-2 code for the country",
											Documentation.SampleValues = {"US", "FR", "CN"}
										]),
										name as (type text meta [
											Documentation.FieldCaption = "Country Name",
											Documentation.FieldDescription = "The name of the country to add",
											Documentation.SampleValues = {"United States", "France", "China"}
										]))
										as (type any) meta [
											Documentation.Name = "addCountryName",
											Documentation.LongDescription = "Adds a country name to the internal world record, if it doesn't already exist.",
											Documentation.Examples = {[
												Description = "Adds 'United States' to the list of possible names for the US country code",
												Code 		= "addCountryName(""US"", ""United States"")",
												Result 		= "<i>Updated ISO-3166-1 object</i>"
											],[
												Description = "Attempts to add 'United States' to the list of possible names again and fails",
												Code 		= "addCountryName(""US"", ""United States"")",
												Result 		= "<i>Error</i>"
											]}
										],

									// Define the function implementation
									addCountryNameImpl = (code as text, name as text) =>
										if not List.Contains(try world[Possible Names][Possible Name] otherwise {},name) then
											@NewWorld(
												world & 
												[Possible Names = Table.AddKey(Table.FromRecords((try Table.ToRecords(world[Possible Names]) otherwise {}) & {[Country Code = Text.Upper(code), Possible Name = Text.Proper(name)]}),{"Possible Name"},true)]
											)
										else
											error "Name exists",

									fn = Value.ReplaceType(addCountryNameImpl, addCountryNameType)
								in
									fn,
							
							bulkAddCountryNames = 
								let
									// Define the function type
									bulkAddCountryNamesType = 
										type function (
											namesToAdd as (type list meta [
												Documentation.FieldCaption = "Names to add",
												Documentation.FieldDescription = "List of records to add to the world record. Each record should have 'Country Code' and 'Possible Name' fields."
											])
										) as any meta [
											Documentation.Name = "bulkAddCountryNames",
											Documentation.LongDescription = "Adds new potential country names in bulk.",
											Documentation.Examples = {[
												Description = "Adds multiple country names to the world record",
												Code 		= "bulkAddCountryNames([ [Country Code = ""US"", Possible Name = ""United States""], [Country Code = ""CA"", Possible Name = ""Canada""] ])",
												Result 		= "Table representing the updated world record"
											]}
										],

									// Define the function implementation
									bulkAddCountryNamesImpl = (namesToAdd as list) =>
										List.Accumulate(
											namesToAdd,
											@NewWorld(world),
											(state,current) => state[addCountryName](current[Country Code], current[Possible Name])
										),
									fn = Value.ReplaceType(bulkAddCountryNamesImpl, bulkAddCountryNamesType)
								in
									fn,
									
							countryDimension = 
								let
									// Define the function implementation
									countryDimensionImpl = () as table =>
										Table.RemoveColumns(
											Table.ExpandTableColumn(
												Table.NestedJoin(world[Countries],"Country Code",world[Continents],"ISO-alpha2 Code","Continent"),
												"Continent",
												Table.ColumnNames(world[Continents])
											),
											"ISO-alpha2 Code"
										),

									// Define the function type
									countryDimensionType = type function () as table 
										meta [
											Documentation.Name = "countryDimension",
											Documentation.LongDescription = "Returns a table with all countries ",
											Documentation.Examples = {[
												Description = "Returns a table with all countries and their respective regions and sub-regions",
												Code = "countryDimension()",
												Result = "#table({""Country Code (numeric)"", ""Country Code"", ""Country Code (alpha3)"", ""Country Name"", ""Global Code"", ""Global Name"", ""Region Code"", ""Region Name"", ""Sub-region Code"", ""Sub-region Name"", ""Intermediate Region Code"", ""Intermediate Region Name""}, {{44, ""BS"", ""BHS"", ""Bahamas"", 1, ""World"", 19, ""Americas"", 419, ""Latin America and the Caribbean"", 29, ""Caribbean""}, ...})"
											]}
										],
									fn = Value.ReplaceType(countryDimensionImpl, countryDimensionType)
								in
									fn,
									
							Countries = Table.SelectColumns(countryDimension(),{"Country Code", "Country Code (alpha3)", "Country Name", "Region Name", "Sub-region Name", "Intermediate Region Name"})
						] meta [
							world = world,
							New Possible Names = 
								Table.RemoveMatchingRows(
									world[Possible Names],
									world[Original Possible Names]
								)
						],
					initialState = [
						Countries 		= Table.Combine({defaultCountries,additionalDefaultCountries}),
						Possible Names 	= defaultPossibleNames,
						Continents 		= defaultContinents,
						Original Possible Names = Table.ToRecords(#"Possible Names")
					]
				in
					NewWorld(initialState)
		in
			createWorld
	],
Table      = [ // —à–∞–±–ª–æ–Ω—ã —Å–ø–∏—Å–∫–æ–≤, —Ç–∞–±–ª–∏—Ü, –∑–∞–ø–∏—Å–µ–π
	TABLE_LIST_RECORD = "TABLE_LIST_RECORD",
	// 	LIST
		// 	–º–µ—Å—è—Ü—ã
			months_list = {"—è–Ω–≤–∞—Ä—å", "—Ñ–µ–≤—Ä–∞–ª—å", "–º–∞—Ä—Ç", "–∞–ø—Ä–µ–ª—å", "–º–∞–π", "–∏—é–Ω—å", "–∏—é–ª—å", "–∞–≤–≥—É—Å—Ç", "—Å–µ–Ω—Ç—è–±—Ä—å", "–æ–∫—Ç—è–±—Ä—å", "–Ω–æ—è–±—Ä—å", "–¥–µ–∫–∞–±—Ä—å"},
			
			lst1 = List.Transform({1..12}, each Text.From(_)), 							// {"1".."12"}
			lst2 = List.Transform({1..12}, each Date.ToText(#date(2024,_,1),"MMMM")), 	// {"–Ø–Ω–≤–∞—Ä—å".."–î–µ–∫–∞–±—Ä—å"}
			lst3 = List.Transform({1..12}, each Date.MonthName(#date(2024,_,1))),		// {"–Ø–Ω–≤–∞—Ä—å".."–î–µ–∫–∞–±—Ä—å"}
			
			month_0 = List.Transform({1..12}, (x)=> Text.Lower(Date.MonthName(#date(2024,x,1), "ru-RU"))), // {"—è–Ω–≤–∞—Ä—å".."–¥–µ–∫–∞–±—Ä—å"}
			month_1 = List.Transform({1..12}, (x)=> Date.ToText(#date(2022, x, 1), "MMM", "en-US")), // {"Jan".."Dec"}
			month_2 = List.Transform(List.Dates(#date(2024,1,1), 12, #duration(32,0,0,0)), (x)=>Text.Lower(Date.MonthName(x, "ru-RU"))), // {"—è–Ω–≤–∞—Ä—å".."–¥–µ–∫–∞–±—Ä—å"}
			month_3 = List.Generate(()=>#date(2016,1,1), (x)=>x<#date(2017,1,1), (x)=>Date.AddMonths(x,1), (x)=>Text.Lower(Date.MonthName(x, "en-US"))), // {"january".."december"}
			month_4 = List.TransformMany({1..12}, (x)=>{#date(2016,x,1)}, (x,y)=>Number.ToText(x)&" - "&Text.Lower(Date.MonthName(y))), // {"1 - —è–Ω–≤–∞—Ä—å".."12 - –¥–µ–∫–∞–±—Ä—å"}
			month_5 = List.TransformMany({2023..2024}, (x)=>{1..12}, (x,y)=>{x,y}),		// —Å–ø–∏—Å–æ–∫ —Å–ø–∏—Å–∫–æ–≤ {–ì–æ–¥, –ú–µ—Å—è—Ü}, 24 —Å—Ç—Ä–æ–∫–∏
			month_6 = List.TransformMany({2023..2024}, (month)=>{1..12}, (year,month)=>{year,month}), // —Ç–æ–∂–µ —Å–∞–º–æ–µ
		//	–¥–Ω–∏ –Ω–µ–¥–µ–ª–∏
			days_list   = {"–ø–æ–Ω–µ–¥–µ–ª—å–Ω–∏–∫","–≤—Ç–æ—Ä–Ω–∏–∫","—Å—Ä–µ–¥–∞","—á–µ—Ç–≤–µ—Ä–≥","–ø—è—Ç–Ω–∏—Ü–∞","—Å—É–±–±–æ—Ç–∞","–≤–æ—Å–∫—Ä–µ—Å–µ–Ω—å–µ"},	// {"–ø–æ–Ω–µ–¥–µ–ª—å–Ω–∏–∫".."–≤–æ—Å–∫—Ä–µ—Å–µ–Ω—å–µ"}
			days2 = Text.Split("–ø–æ–Ω–µ–¥–µ–ª—å–Ω–∏–∫|–≤—Ç–æ—Ä–Ω–∏–∫|—Å—Ä–µ–¥–∞|—á–µ—Ç–≤–µ—Ä–≥|–ø—è—Ç–Ω–∏—Ü–∞|—Å—É–±–±–æ—Ç–∞|–≤–æ—Å–∫—Ä–µ—Å–µ–Ω—å–µ","|"),		// {"–ø–æ–Ω–µ–¥–µ–ª—å–Ω–∏–∫".."–≤–æ—Å–∫—Ä–µ—Å–µ–Ω—å–µ"}
			days3 = List.Accumulate({1..7}, {}, (x,y)=> x & {Date.DayOfWeekName(y+1)}), 					// {"–ø–æ–Ω–µ–¥–µ–ª—å–Ω–∏–∫".."–≤–æ—Å–∫—Ä–µ—Å–µ–Ω—å–µ"}
			days4 = List.Transform(
						List.Dates(#date(2024,1,1), 10, #duration(1,0,0,0)),
						(x)=>{x, Date.Month(x), Date.Year(x)} // —Å–ø–∏—Å–æ–∫ –∏–∑ 10 —Å–ø–∏—Å–∫–æ–≤: –î–∞—Ç–∞, –ù–æ–º–µ—Ä –ú–µ—Å—è—Ü—è, –ì–æ–¥
					), 
	
	// 	TABLE
		//  –æ–ø–∏—Å–∞–Ω–∏–µ —Ñ—É–Ω–∫—Ü–∏–π –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è —Ç–∞–±–ª–∏—Ü
			/* 
				–†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏:
					–í–∞—Ä–∏–∞–Ω—Ç —Å —Ç–∏–ø–∏–∑–∞—Ü–∏–µ–π —Å—Ç–æ–ª–±—Ü–æ–≤:
					= #table( type table [ID = number, Name = text], {{1, "–†–∞–∑–¥–µ–ª 1"}, {2, "–†–∞–∑–¥–µ–ª 2"}})
					= Table.FromList({2016..2024}, Splitter.SplitByNothing(), type table [–ì–æ–¥ = number])
					= Table.FromColumns({ List.Times( #time(0, 0, 0), 60*24, #duration(0, 0, 1, 0) ) }, type table [ –í—Ä–µ–º—è = time ])
				
				–§—É–Ω–∫—Ü–∏–∏:
					#table				( columnNames as list, 	rows as list											)
					Table.FromColumns	( columns as list, 		optional columnNames as list							) as table
					Table.FromRows		( rows as list, 		optional columnNames as list							) as table
					Table.FromList		( list as list, 		optional splitter as any, 		optional columns as any	) as table
					Table.FromRecords	( records as list																) as table
				
				–ü—Ä–∏–º–µ—Ä—ã:
					myTable = #table({"Column1", "Column2"}, {{1, "A"}, {2, "B"}})						–∏–ª–∏ Table.FromColumns({{1,2,3}}) 	–∏–ª–∏ #table({},{})
					myTable = Table.FromColumns({{1, 2, 3}, {"A", "B", "C"}}, {"Column1", "Column2"}) 	–∏–ª–∏ Table.FromColumns({{1,2,3}}) 	–∏–ª–∏ Table.FromColumns({{}})
					myTable = Table.FromRows({{1, "–ú–∏—à–∞"}, {2, "–ú–∞—à–∞"}}, {"ID", "Name"})				–∏–ª–∏ Table.FromRows({{1,2,3}})		–∏–ª–∏ Table.FromRows({{}})
					myTable = Table.FromList({1, 2, 3}, Splitter.SplitByNothing(), {"Numbers"})			–∏–ª–∏ Table.FromList({"1","2","3"})	–∏–ª–∏ Table.FromList({})
					myTable = Table.FromRecords({[ID = 1, Name = "–ú–∏—à–∞"], [ID = 2, Name = "–ú–∞—à–∞"]})		–∏–ª–∏	Table.FromRecords({[], []})		–∏–ª–∏ Table.FromRecords({})
			*/
		//	–ø—É—Å—Ç—ã–µ —Ç–∞–±–ª–∏—Ü—ã 
			table1	= #table({},{}), 												// –∑–∞–≥–æ–ª–æ–≤–∫–æ–≤ –Ω–µ—Ç, —Å—Ç—Ä–æ–∫ –Ω–µ—Ç
			table2  = #table({"Column1", "Column2"}, {}), 	 		    			// –∑–∞–≥–æ–ª–æ–≤–∫–∏ –µ—Å—Ç—å, —Å—Ç—Ä–æ–∫ –Ω–µ—Ç
			table3  = #table({"Column1", "Column2"}, {{null, null},{null, null}}), 	// –∑–∞–≥–æ–ª–æ–≤–∫–∏ –µ—Å—Ç—å, 2 —Å—Ç—Ä–æ–∫–∏ –µ—Å—Ç—å
			table4 	= #table(type table [a = text, b = number], {} ), 				// –∑–∞–≥–æ–ª–æ–≤–∫–∏ –µ—Å—Ç—å + —Ç–∏–ø, —Å—Ç—Ä–æ–∫ –Ω–µ—Ç
			table5  = #table({{"Column1", type text}, {"Column2", type number}}, {}), 			  // –∑–∞–≥–æ–ª–æ–≤–∫–∏ –µ—Å—Ç—å + —Ç–∏–ø, —Å—Ç—Ä–æ–∫ –Ω–µ—Ç
    		table6 	= Table.FromColumns(List.Transform({"a","b"}, each {}), {"a","b"}), 		  // –∑–∞–≥–æ–ª–æ–≤–∫–∏ –µ—Å—Ç—å, —Å—Ç—Ä–æ–∫ –Ω–µ—Ç
			table7 	= Table.FromColumns(List.Repeat( {{""}}, List.Count({"a","b"}) ), {"a","b"}), // –∑–∞–≥–æ–ª–æ–≤–∫–∏ –µ—Å—Ç—å, —Å—Ç—Ä–æ–∫–∞ –µ—Å—Ç—å
			table71	= Table.FromColumns({Text.ToList("abbccde")},{"a"}), 						  // –∑–∞–≥–æ–ª–æ–≤–∫–∏ –µ—Å—Ç—å, –æ–¥–Ω–∞ –∫–æ–ª–æ–Ω–∫–∞, –≤ —Å—Ç—Ä–æ–∫–∞—Ö –±—É–∫–≤—ã
			table8  = Table.FromList({1, 2, 3, 4, 5}, Splitter.SplitByNothing(), {"Numbers"} ),   // –∑–∞–≥–æ–ª–æ–≤–∫–∏ (1), —Å—Ç—Ä–æ–∫–∏ (5), –∑–Ω–∞—á–µ–Ω–∏—è (1..5))
			table9  = Table.FromList(List.Repeat({null}, 10), Splitter.SplitByNothing(), {"Column1"}), // –∑–∞–≥–æ–ª–æ–≤–∫–∏ –µ—Å—Ç—å, 10 —Å—Ç—Ä–æ–∫ —Å Null
			table10	= Table.FromRecords({[Column1 = null]}), // 1 —Å—Ç–æ–ª–±–µ—Ü, 1 —Å—Ç—Ä–æ–∫–∞ —Å null
		
		//	–Ω–µ–º–Ω–æ–≥–æ –∑–∞–ø–æ–ª–Ω–µ–Ω–Ω—ã–µ
			table01	= #table(type table [Value=any], List.Transform({0, 1, 2, 3}, each {_})), // —Å—Ç–æ–ª–±–µ—Ü 1, —Å—Ç—Ä–æ–∫ 4 + —Ñ—É–Ω–∫—Ü–∏—è
			table02 = #table(type table [TestName = text],{{"A"}, {"B"}, {"C"}} ), // 1 —Å—Ç–æ–ª–±–µ—Ü "TestName", 3 —Å—Ç—Ä–æ–∫–∏ {"–ê","–ë","–°"}
			table03	= #table({"a".."d"},List.Repeat({{1..4}},5)), 	// 4 —Å—Ç–æ–ª–±—Ü–∞, 5 —Å—Ç—Ä–æ–∫: a = 1, b = 2, c = 3, d = 4
			table04 = #table({"x", "x^2"}, {{1,1}, {2,4}, {3,9}}),	// 2 —Å—Ç–æ–ª–±—Ü–∞, 3 —Å—Ç—Ä–æ–∫–∏: —á–∏—Å–ª–æ, –∫–≤–∞–¥—Ä–∞—Ç —á–∏—Å–ª–∞
			table05	= #table({"—á—Ç–æ","–Ω–∞ —á—Ç–æ"},{{"a","A"},{"aa","A"},{"aaa","A"},{"b","B"},{"c","C"}}), 	// —Å–ª–æ–≤–∞—Ä—å: —á—Ç–æ –º–µ–Ω—è—Ç—å, –Ω–∞ —á—Ç–æ –º–µ–Ω—è—Ç—å
			table06	= Table.FromList({"–º–∞–º–∞,–º—ã–ª–∞,—Ä–∞–º—É,1", "–ø–∞–ø–∞,–µ–ª,–∫–∞—à—É,2", "—Å–∞—à–∞,–º–∞—à–∞,–º–∏—à–∞,3"}), 		// 3 —Å—Ç—Ä–æ–∫–∏ 4 —Å—Ç–æ–ª–±—Ü–∞
			BlankTable 	= Table.FromRows({},{"Content","Name","Extension","Date accesssed","Date modified","Date created","Attributes","Folder Path"}),
			table07     = Table.FromRows({{"USD", 100},{"EUR", 200},{"GBP", 300}},type table [Currency=text, Amount=number]),
			table08	= 
				#table(
					type table [Entry = Text.Type, Category = Text.Type, SubCategory = Text.Type, Amount = Currency.Type], 
					{
						{"Expense", "Travel", null, 1500},
						{"Expense", null, "Airfare", 500},
						{"Expense", null, "Hotel", 1000}
					}
				),
		
		//	—Ç–∞–±–ª–∏—Ü—ã —Å –¥–∞—Ç–∞–º–∏ –∏ –ø–µ—Ä–∏–æ–¥–∞–º–∏
			table_date0	= Table.FromList({2016..2024}, Splitter.SplitByNothing(), type table [–ì–æ–¥ = number]), // —Å —Ç–∏–ø–æ–º –∏ –Ω–∞–∑–≤–∞–Ω–∏–µ–º!
			table_date2	= Table.FromList(List.Accumulate({1..7}, {}, (accum,x)=> accum & {Date.DayOfWeekName(x+1)}), null, {"–î–µ–Ω—å–ù–µ–¥–µ–ª–∏"}), // –¥–Ω–∏ –Ω–µ–¥–µ–ª–∏
			table_date3	= Table.FromList(Text.Split("–ø–æ–Ω–µ–¥–µ–ª—å–Ω–∏–∫|–≤—Ç–æ—Ä–Ω–∏–∫|—Å—Ä–µ–¥–∞|—á–µ—Ç–≤–µ—Ä–≥|–ø—è—Ç–Ω–∏—Ü–∞|—Å—É–±–±–æ—Ç–∞|–≤–æ—Å–∫—Ä–µ—Å–µ–Ω—å–µ","|"), null, type table [–î–µ–Ω—å–ù–µ–¥–µ–ª–∏ = text]),
			table_date4	= // 1 —Å—Ç–æ–ª–±–µ—Ü —Å–æ —Å–ø–∏—Å–∫–æ–º –∏–∑ 12-—Ç–∏ –º–µ—Å—è—Ü–µ–≤ (–∏–∑–º–µ–Ω—è–µ—Ç—Å—è —Ñ–æ—Ä–º–∞—Ç –Ω–∞–ø–∏—Å–∞–Ω–∏—è –º–µ—Å—è—Ü–∞)
				Table.Combine(
					List.Transform(
						{1..12}, 
						each Table.FromValue(Date.ToText(#date(2000,_,1),"MMMM"))
					)
				),
			table_date5	= // 3 —Å—Ç–æ–ª–±—Ü–∞ –î–∞—Ç–∞, –ú–µ—Å—è—Ü, –ì–æ–¥ (–∏–∑–º–µ–Ω—è—Ç—å –º–æ–∂–Ω–æ —á–∏—Å–ª–æ —Å—Ç—Ä–æ–∫ –∏ —à–∞–≥)
				#table(type table
					[Date=date, Month=number, Year=number],
					List.Transform(
						List.Dates( #date(2024,1,1), 10, #duration(1,0,0,0) ),
						(x) => { x, Date.Month(x), Date.Year(x) }
					)
				),
			table_date6 = // –≤—Å–µ –≤–∏–¥—ã –¥–∞—Ç–∞/–≤—Ä–µ–º—è {"date", "time", "datetime", "datetimezone", "duration"}
				#table(
					{"date", "time", "datetime", "datetimezone", "duration"},
					{
						{  
							#date(2021, 9, 1) + #duration(1, 12, 0, 0),
							#time(23,58,00) + #duration(0, 0, 2, 0),
							#datetime(2021, 9, 1, 23, 58, 0) + #duration(1, 1, 2, 0),
							#datetimezone(2021, 9, 1, 23, 58, 0, 3, 0) + #duration(1, 0, 0, 0),
							#duration(1, 12, 0, 0) + #duration(0, 12, 0, 0)
						},
						{	
							#date(2021, 9, 1) - #duration(1, 12, 0, 0),
							#time(23,58,00) - #duration(0, 0, 2, 0),
							#datetime(2021, 9, 1, 23, 58, 0) - #duration(1, 1, 2, 0),
							#datetimezone(2021, 9, 1, 23, 58, 0, 3, 0) - #duration(1, 0, 0, 0),
							#duration(1, 12, 0, 0) - #duration(0, 12, 0, 0) 
						}
					}
				),
		//  —Ç–∞–±–ª–∏—Ü—ã —Å –≤—Ä–µ–º–µ–Ω–µ–º
			TimeMinSec  = // —Ç–∞–±–ª–∏—Ü–∞ –≤ –≤—Ä–µ–º–µ–Ω–µ–º –æ—Ç —Å–µ–∫—É–Ω–¥—ã –¥–æ —Å—É—Ç–æ–∫
				/*
					–í–∞—Ä–∏–∞–Ω—Ç –Ω–∞—á–∞–ª–∞:
						StartTime = #time(0, 0, 0),
						TimeList  = List.Times(StartTime, 24*60*60, #duration(0, 0, 1, 0)),
						TimeTable = Table.FromList(TimeList, Splitter.SplitByNothing(), null, null, ExtraValues.Error),
						Rename    = Table.RenameColumns(TimeTable,{{"Column1", "Time"}}),
					
					–§–æ—Ä–º–∞—Ç 24/12 "AM/PM" 
						{"Hour (24)",  each Time.Hour([Time])},
						{"Hour (12)",  each if [#"Hour (24)"] = 0 then 12 else if [#"Hour (24)"] > 12 then [#"Hour (24)"] - 12 else [#"Hour (24)"]},
						{"AM/PM", 	   each if [#"Hour (24)"] < 12 then "AM" else "PM"},
						{"Hour AM/PM", each Text.From([#"Hour (12)"]) & " " & [#"AM/PM"], type text},

					–î–æ–±–∞–≤–ª—è–µ–º —Å—Ç–æ–ª–±–µ—Ü "–°–µ–∫—É–Ω–¥—ã–°—É—Ç–æ–∫", –∫–æ—Ç–æ—Ä—ã–π –æ—Ç–æ–±—Ä–∞–∂–∞–µ—Ç —Å–µ–∫—É–Ω–¥—É —Å –Ω–∞—á–∞–ª–∞ —Å—É—Ç–æ–∫ - –¥–ª—è —ç—Ç–æ–≥–æ –≤—Ä–µ–º—è –µ—Å—Ç—å!
					SecondOfDay = 	Table.AddColumn(MinuteOfDay, "–°–µ–∫—É–Ω–¥—ã–°—É—Ç–æ–∫", each 
										Time.Hour([–í—Ä–µ–º—è]) * 3600 + Time.Minute([–í—Ä–µ–º—è]) * 60 + Time.Second([–í—Ä–µ–º—è])
									, Int64.Type)
				*/
				let
					fxMultiAdd = (tbl as table, nms as list) as table => List.Accumulate(nms, tbl, (s, c) => Table.AddColumn(s, c{0}, c{1}, c{2}?)),
					from1  	   = Table.FromColumns({List.Times(#time(0, 0, 0), 60, 		 #duration(0, 1, 0, 0))}, type table [–í—Ä–µ–º—è=time] ), // —á–∞—Å—ã - 24 —Å—Ç—Ä–æ–∫–∏
					from2  	   = Table.FromColumns({List.Times(#time(0, 0, 0), 60*24, 	 #duration(0, 0, 1, 0))}, type table [–í—Ä–µ–º—è=time] ), // –º–∏–Ω—É—Ç—ã - 60 —Å—Ç—Ä–æ–∫
					from3      = Table.FromColumns({List.Times(#time(0, 0, 0), 60*60*24, #duration(0, 0, 0, 1))}, type table [–í—Ä–µ–º—è=time] ), // —Å–µ–∫—É–Ω–¥—ã - 
					addColumns = fxMultiAdd(from3,{
						{"–ß–∞—Å—ã",   		 each Time.Hour  ( [–í—Ä–µ–º—è] ), Int64.Type},
						{"–ú–∏–Ω—É—Ç—ã", 		 each Time.Minute( [–í—Ä–µ–º—è] ), Int64.Type},
						{"–ú–∏–Ω—É—Ç—ã–°—É—Ç–æ–∫",  each Time.Hour  ( [–í—Ä–µ–º—è] ) * 60 + Time.Minute([–í—Ä–µ–º—è]), Int64.Type},
						{"–°–µ–∫—É–Ω–¥—ã", 	 each Time.Second( [–í—Ä–µ–º—è] ), Int64.Type},
						{"–°–µ–∫—É–Ω–¥—ã–°—É—Ç–æ–∫", each Time.Hour  ( [–í—Ä–µ–º—è] ) * 3600 + Time.Minute([–í—Ä–µ–º—è]) * 60 + Time.Second([–í—Ä–µ–º—è]), Int64.Type}
					})
				in
					addColumns,
	
			table_time1 = // —Å–ø–∏—Å–æ–∫ –º–∏–Ω—É—Ç
				Table.FromColumns(
					{ List.Times( #time(0, 0, 0), 60*24, #duration(0, 0, 1, 0) ) },
					type table [ –í—Ä–µ–º—è = time ] 
				),

			table_time2 = 
				Table.FromColumns(
					{ List.Times( #time(0, 0, 0), 60*60*24, #duration(0, 0, 0, 1)) },
					type table [ –í—Ä–µ–º—è = time ]
				),
		//	—Ç–∞–±–ª–∏—Ü—ã —Å –¥–∞–Ω–Ω—ã–º–∏
			table_bal0 	= // –ë–∞–ª–∞–Ω—Å –æ–±—Ä–∞–±–æ—Ç–∞–Ω–Ω—ã–π (—Å—Ç–æ–ª–±—Ü—ã {"–î–∞—Ç–∞", "–°—Ç–∞—Ç—å—è", "–°—Ç—Ä–æ–∫–∞", "–ù–∞ –Ω–∞—á–∞–ª–æ", "–ù–∞ –∫–æ–Ω–µ—Ü"})
				F[Table.JsonDecodeWithHead]("7VxLb9tGEP4rhE4poATcF7nMLWgOzSWnohfHCPQ82a7R1oegyH8PxV2G33LJ2jseq6RFH2iJ2sfMN7PzpPTv6tc/bx5u7z5vbg9/r95frT5u/jms1qsvD7mW4nTV8nRVefda75rrcWCYboapQ3PduIlfP330I8Xe3cmaf3tYt+xeq61bYnW99rT9/u2+o+3d6V293oe7b+3Lzw+328NfQ+/qJeo5m3ru1U/OZC7zt0K+VaL++CqFUdGwpQVQ7xiV3R3tqDeZG3rv3jVX3c32W/kNB+kYRVKIvB2fhue6Xjm/ruc+E4rfgKddf5wyjmXbJ8AtMACSH7SBNWyHjt4moiOp6FjDgE2zr8SFm2sBkO07FvXR0SazTkH8DDdbdXe84gDfno0XR1RTERUFF6K4/BEGCwpDkn6AcsWmJOcS9jrrUPMLgjlCnlXZv+M3Rb0dIEB3PHiFDvZBDC3s43Yo4L5NlCP5qCvNJUaZR9pogFxn8reOLPexgg+a17rqINAGpOXw8+zb/qqt60nETJF1v2JzHcHKTvUDImJrKGAeWtdYMx2khwwEImEhB+MuOmmeUET/4N+gP/PUgFdvvd7IEXErBiQgPqA9arfOonsCCJUDY1XHgj+ATr0Ujk3UELK5v3u4ueGyjps+FH7KJpLciI30s46oSwYwtX25aDjDLSC4BLIc2+7Ywe8jSj2jieIwVHEUiuPE8kgjjIo1nCj0P3uQAJyV0NskBFeJSBdk08gbEyAnBjgcyi+Ao0eSDMeLdfP2wH0UMwTsATGe5m18pP6TVp1Ca6LISqrIZGm5hOYdBOq8RYXlPTy8sb205NjecsdQTid8xHkP6oggVBny0FyPHQiBj0yEQpP9npQvkRPEIc+YYrwgJmTnI3TJZhXBugTHSHSsDiQ2BgiK/XLg2nEJ24Hv4fXVi+wNTDeAMsDmY4gt8IIi8sGZ6A9ql/glUTpkhyXKnO3wovdFtJGzBL9vI5Zlf2RrXhPRIps6lsyn2Zct5wcToZ0Wlv29USSejtGoIEh44kwdJQYEB9FZkDptR4gpAN7EONjQk30xzTA4CAzQcoHZboMtG+cgrmrgKEw06wW5AMaZ4sFhmHbNpCB7QcXmA499Cs8QabIZmUS4yUG9smXU3xAX2uqxeVR8J0DxSls9ZeTRqWqytHocokIoLkin0uuxho2lpdfTjPxfej1DIQtRjpfT7BFRzEx2HsHKTveXZs/8mz2m5DKOS6vn2a0eUeZsvmrp9ZzLnSztnvO1e1TU7qEK7TLbPfxR1Ctq93CkBXNv90iOcgPsvLR7IunQ2z1V3IyjHt7X3+4xXFgt7R6A92ztHkZXP5sOhaE7M7aC+WzAordz2FLepZvzlG6ONGzfH2CuMTyhczvpSkNBfwrcxO30iRR+LlgotojKP9ST0qAlm49cD1Qo9zoMHe6BjhKQQguisk+J7aeKrpaS4ymPrP5rPk7odSY3pAQ1is8Vhz38ySPGomMl64GMCb26goMHzZ12mn1CPTwdP00NdaqK7UEu3lOSeEwk+ZiUomL7/hozBIkYaDIG6lRmPy8GwMmjQPyRGPnTcWA1mFAb0dE0nzlCkB9Ur3braA1vX7wRgjvlI2vYjoJgvS2AggEBou/GJ3ttqj1XlWa150FWv493bK5BrzCw0g4z7EGixiajoqhWOn42hwsU7DYFzyKgO4dHlzxfO380+7odRK6Y8Y5UsHyfun2WE8u+JtJaAwjF3a5DqjSoPrPg+GrDsIYe4NZAASnr84VVg+QkVBlysZ/DYQ4jMM3KW1FHmTSs+A/uaIlkR0r5qIBYcsQ+yWArMcQoyCGG1fHPJVCLBTPNS6uKoxo97bxUFhyF0YvNS5WxbL3TmealhY0DjYlAcL68VJfnVgPgZDp5qTSsFnNJTAm/chT/FBaDCGaemKq4G8UFypKYpnsMjm/wzDoxtRyd+8tITF9AWWaembI94jTTxFScHle8/v4D"),
			table_bal1 	= // –ë–∞–ª–∞–Ω—Å –Ω–µ–æ–±—Ä–∞–±–æ—Ç–∞–Ω–Ω—ã–π –∏—Å—Ö–æ–¥–Ω—ã–π 
				Table.FromRows(Json.Document(Binary.Decompress(Binary.FromText("vVjtbhNHFH2VEb+CFEX7ves+AbxA/iDewY8QJ6W0CiWBgkqDCIRK5QeVurazZHHszSvMvlHPPTP7GdssApHE3ux65n6fc+/4wYM7d3arv4e7/TsX/3h4+XgFfKLk5/6e0i/0uX6t/8D7hX6H9w/6jf6oXyp9qs/0e/1KP9cfu8L0eTnRK13omV6VxzpT5WSsM31ZTspDPEuxznUd0ZQ4kVwCz+HGe1i11ClWZWOd61Rfl0+sCNws8DzXs/JY9nuyPx7hLQmN0he6KB9B6WW1Y6avcfsJMlc6L0/wQFXSy4Mt4pXI90W+eVH6TOHjQi9V+RjCJhCd/aS+9w/0r2B2xkDl5S+4L/BkBaNh/kpiiI9z+JTDk0KWlU9ordsO/w3ck6VLSDqEP+XPFJzC1wmzUujP8JirVkjLsdqBP7m+4rK5Tu9SpteXWYjvEqzL7xVq6vHbep6vkQR1eDqnw8aK9ZICh5Ul8tyoLoq1W/shWeuGyAmdbmEftpZYK0SMPJw3gnqGRR0ha2wyCb6E1CkUo9DKA9i1MI+vIM6EwKptZz7uiH7by9KgsCVtESjCV0D1uQBe6RtdqDHWX9G26/JI3ZcdI4J3NErkEnpuizCEMc7AE6cQcvY1nPEn1NzA4QmN8iw/hCQkqZEfh0Kl+iRkLHLJO1EsF8e3BSZQBKCwuqkGJZFF2Mrf+GEq1aRzJX+ycKGLsWCTQjsgE4RLtkEB4/LXKtki9WaMqyBUwFsRaUEJHfjMqUEwztIharH+CBn/xeApV/WCA+tYIMQfJkLFvjOKKam9yJg9x79H7crn3nAjSVz1Ehp9AQO3anNX1Uy2Yg0KTB63kXeJ3Jworkktg6VkzVw0erau/cB2iHe0hsQlTk3hDkIjWSofSa0brioInJlI8A2hMO+2QVmo2zzLyikTdm3tOiqfKqanaHO0QZJkUeRPx0LMtSPLVkYga7mreJ0y6ub+SGod5s7lXiwj1YVxHc8z2WJq6zuwikfWA7dIbUVVqa/V8VVs6lVEGFRVkLHmP9Vzgsl3NSiwWn+HwpkFEqPMnka36r3IX3evKCM1en7C/xNLkOOmQBcb/ekxpFcxpJvYUvoiSwpNeqTJKIkE47EX+tXWZ6DB1/r0nr4g4kyRJZG5xnHQnc92xN9ysjdG/qd7d40fF9D9DO/vwaQvQa5Cr38J857qtzQNGmCj4rL/QK7Cxy+h9V+76RSSsRzFznId78n9G4Tcd01sF1KCKJgT5Tkens0JjHTrMqdZdnvEHDRwSgeRFjLEv14D+ZuZT+3QiQFnQQLK+fCabaTTK9/A+gILrhtWITJwk1rUCu4qmabB96QyHoHXkXshCLcV3OKq1FAwKnrH4i6X4aanYtlXkMksFvgdDe/YJtCdNrtKfvA881YzrqGqqs7X7TPAD7yIF1uKEipiZVITclYRXtNncnh9LHMeHBRgAhUCMdTuIZVJ+cqNPKZTpuBHccA5K7G6PkhjF4PWyO2IYFeSzEnvrbLTJnHmpjsf/WMNn7GrdmgrZ6usunVmTidCsgFnnYGwv8/FDrtOzIbqeqNOee9vO1JtQ+ug9rmw+ckNSeaG5z/rJYks7CIA/ZLgLw/28Ik0xKfY+slGlFiY4PfIxhJreN24f4ty0y+3BdwW416vb+jPVvN0kP8CvROOAYfMyZOmlbADt485plEtleWAQzYT019Dr+kdvvt1s/9GE0RuF8j1kXXQOBIaUDt9HsAyObVW2DTTR3nSCGq8y0w4u4eaYYeGrW51Dji3UcJ5pgWTfdlDlHhhK8QEyP72A8RQhGweVr6AkWgjRqKqxofINZK6eNk8pLV6zvoMSCI3ZEA0dTvQlmGwZePwcTDyzWEsYrOO3R/6lciNMUQ6F89TCzMSs71cyuCB98et52LJDR1Z0UuJ1AlBHfFbksBJQl5i2xjJC6khIuxNDSMUUqmt04YR0P1KRDY2BMCNmFcnnNwPLJNE/HrDD9kL/JZKmZQ5ENjvRiSSwIapNeTkUUOOOFLw7AjBGb3LrGH4hCqkRUUjFkLLtKKBvhKhNZFHflhPtZ4XtrYMpEc5EliNprlx7O8MPZIRuCOHIHJaVhPxjsS1VYY2QTzlWBiY7aLsLrXFnbDXdLW8Vc+1ffxmQuYKW6vnm9jrGw+ZUfANhB6Rh2MOC9/G6FG0mdG3MNY2To84OfmeqdwkdgZNQPusC9mZuBwik8itxvvuuSded+55+D8=", BinaryEncoding.Base64), Compression.Deflate)), let _t = ((type nullable text) meta [Serialized.Text = true]) in type table [#"–ê –ö –¢ –ò –í –´                " = _t, #"–ö–æ–¥               —Å—Çp. " = _t, #"–ù–∞ 31 –¥–µ–∫–∞–±—Ä—è 2021 –≥–æ–¥–∞" = _t, #"–ù–∞ 31 –¥–µ–∫–∞–±—Ä—è 2020 –≥–æ–¥–∞" = _t]),
			table_bal2 	= // —Å–ø—Ä–∞–≤–æ—á–Ω–∏–∫ —Ä–∞–∑–¥–µ–ª–æ–≤ –±–∞–ª–∞–Ω—Å–∞
				#table(type table
					[–†–∞–∑–¥–µ–ª_ID = number, –†–∞–∑–¥–µ–ª–ü—Ä–µ—Ñ–∏–∫—Å = text, –†–∞–∑–¥–µ–ª–ò–º—è = text, –†–∞–∑–¥–µ–ª–ò–º—è–ü–æ–ª–Ω–æ–µ = text, –†–∞–∑–¥–µ–ª–ò–º—è–ê–±–±—Ä–µ–≤–∏–∞—Ç—É—Ä–∞ = text],
					{	{1,"–†–∞–∑–¥–µ–ª 1","–î–æ–ª–≥–æ—Å—Ä–æ—á–Ω—ã–µ –∞–∫—Ç–∏–≤—ã"        ,"–†–∞–∑–¥–µ–ª 1 –î–æ–ª–≥–æ—Å—Ä–æ—á–Ω—ã–µ –∞–∫—Ç–∏–≤—ã"        ,"–î–ê"},
						{2,"–†–∞–∑–¥–µ–ª 2","–ö—Ä–∞—Ç–∫–æ—Å—Ä–æ—á–Ω—ã–µ –∞–∫—Ç–∏–≤—ã"       ,"–†–∞–∑–¥–µ–ª 2 –ö—Ä–∞—Ç–∫–æ—Å—Ä–æ—á–Ω—ã–µ –∞–∫—Ç–∏–≤—ã"       ,"–ö–ê"},
						{3,"–†–∞–∑–¥–µ–ª 3","–°–æ–±—Å—Ç–≤–µ–Ω–Ω—ã–π –∫–∞–ø–∏—Ç–∞–ª"        ,"–†–∞–∑–¥–µ–ª 3 –°–æ–±—Å—Ç–≤–µ–Ω–Ω—ã–π –∫–∞–ø–∏—Ç–∞–ª"        ,"–°–ö"},
						{4,"–†–∞–∑–¥–µ–ª 4","–î–æ–ª–≥–æ—Å—Ä–æ—á–Ω—ã–µ –æ–±—è–∑–∞—Ç–µ–ª—å—Å—Ç–≤–∞" ,"–†–∞–∑–¥–µ–ª 4 –î–æ–ª–≥–æ—Å—Ä–æ—á–Ω—ã–µ –æ–±—è–∑–∞—Ç–µ–ª—å—Å—Ç–≤–∞" ,"–î–û"},
						{5,"–†–∞–∑–¥–µ–ª 5","–ö—Ä–∞—Ç–∫–æ—Å—Ä–æ—á–Ω—ã–µ –æ–±—è–∑–∞—Ç–µ–ª—å—Å—Ç–≤–∞","–†–∞–∑–¥–µ–ª 5 –ö—Ä–∞—Ç–∫–æ—Å—Ä–æ—á–Ω—ã–µ –æ–±—è–∑–∞—Ç–µ–ª—å—Å—Ç–≤–∞","–ö–û"}
					}
				),
			table_bal3 	= // Balance key
					let –ò—Å—Ç–æ—á–Ω–∏–∫ = Table.FromRows(Json.Document(Binary.Decompress(Binary.FromText("VdHLDcQgDEXRXlizCP6SWqL038YMBCTuCg4GPVs8T2ntKrW0+ypv/UsgpdqQbgmkpwzvHAoooQ7dQ3p9ktmn3Fujl3H2SSCFDHIoTgkSFDLIoYAS6hAmGmstc2tzOFvXTCCFDHIooIQ6NBvJ1YjPdF81F0ghgxwKCAkxE2LVQiClxseGbgmkkEEOBZRQP2VIdyighDBfrq98fw==", BinaryEncoding.Base64), Compression.Deflate)), let _t = ((type nullable text) meta [Serialized.Text = true]) in type table [Stroke_Key = _t, Parent_Stroke_Key = _t]),
						to = Table.TransformColumnTypes(–ò—Å—Ç–æ—á–Ω–∏–∫,{{"Stroke_Key", Int64.Type}, {"Parent_Stroke_Key", Int64.Type}})
					in  to,
			table_tab1	= // —Ç–∞–±–ª–∏—Ü–∞ –ª–∏–∫–≤–∏–¥–Ω–æ—Å—Ç–∏
				let
					–ò—Å—Ç–æ—á–Ω–∏–∫ = Table.FromRows(Json.Document(Binary.Decompress(Binary.FromText("nZRfTttAEMavsrKEVCSD7N2Y0NeqfeAMKHchKeKPAmor9aEKUiEV4pkYQhNHia8wcyO+md1NoKpBspSddXZ3Zn+e+caHh0m+a+iaVlTRPf2lex7QlBY0M2KwWMI+0pJW3MfWLEmTHOMDjfLdfNvQCBuXfMzHNOMTHJ3SkgdGg1T8lc8xz5tDwf0PXeEBP4dhJXxaqLVFuCtLemkLTBsxbSMmTXgo5/kIgd/G/BExPaKNbOm+2m57Thc5HTjHOLCiCQYO8VCgHgUW4yku1HAeyA1CNqafdO3J8izLZCoy/wdWH2Xs6GYrvk7k64LvFttLeC65jxilAmlCK1oIzi3drWHCtTKtOYr1qrDYBhYIp6+vOOdTxC5f0BSexqr4/keDAFN4TFFTeZMnTxWKpxhpFJZXmtV3bImzF3HeEFktIfkIUoMPfzNbRlFrxMYdXl6hhJ1/e+BVC7Tg60Y+18wnapKCn6nQAmFlvnw6+Ozhfm+St0mZC8XYUzTXpKpa64A+owVfvNLVvkdzWskbDwPviXhujvKFwWIlPtoapSDd0PeoshCoE3VeeH21hfoYoew7UKq4ifqVmjds0QOtjN5WI43ihwp73jGNwlcu9GjgDu0g1mWtqTWAYrv3cikNI92hrqqCuSf8FfkinkcrPJrYTpH0es8=", BinaryEncoding.Base64), Compression.Deflate)), let _t = ((type nullable text) meta [Serialized.Text = true]) in type table [ID_–ì—Ä—É–ø–ø–∞ = _t, ID_KPI = _t, #"–ü–æ–ª–Ω–æ–µ –Ω–∞–∑–≤–∞–Ω–∏–µ" = _t, #"–ö—Ä–∞—Ç–∫–æ–µ –Ω–∞–∑–≤–∞–Ω–∏–µ" = _t, –û–ø–∏—Å–∞–Ω–∏–µ = _t, MIN = _t, #"–ù–∏–∑–∫–∏–π —Ä–∏—Å–∫" = _t, #"–°—Ä–µ–¥–Ω–∏–π —Ä–∏—Å–∫" = _t, #"–í—ã—Å–æ–∫–∏–π —Ä–∏—Å–∫" = _t, #"–ö—Ä–∏—Ç–∏—á–µ—Å–∫–∏–π —Ä–∏—Å–∫" = _t, MAX = _t]),
					
					tr = Table.TransformColumnTypes(–ò—Å—Ç–æ—á–Ω–∏–∫,{
						{"ID_–ì—Ä—É–ø–ø–∞", type text}, 
						{"ID_KPI", Int64.Type}, 
						{"–ü–æ–ª–Ω–æ–µ –Ω–∞–∑–≤–∞–Ω–∏–µ", type text}, 
						{"–ö—Ä–∞—Ç–∫–æ–µ –Ω–∞–∑–≤–∞–Ω–∏–µ", type text}, 
						{"–û–ø–∏—Å–∞–Ω–∏–µ", type text}, 
						{"MIN", Int64.Type}, 
						{"–ù–∏–∑–∫–∏–π —Ä–∏—Å–∫", type number}, 
						{"–°—Ä–µ–¥–Ω–∏–π —Ä–∏—Å–∫", type number}, 
						{"–í—ã—Å–æ–∫–∏–π —Ä–∏—Å–∫", type number}, 
						{"–ö—Ä–∏—Ç–∏—á–µ—Å–∫–∏–π —Ä–∏—Å–∫", type number}, 
						{"MAX", Int64.Type}
					}),
					
					Unpivot = Table.UnpivotOtherColumns(tr, 
						{"ID_–ì—Ä—É–ø–ø–∞", "ID_KPI", "–ü–æ–ª–Ω–æ–µ –Ω–∞–∑–≤–∞–Ω–∏–µ", "–ö—Ä–∞—Ç–∫–æ–µ –Ω–∞–∑–≤–∞–Ω–∏–µ", "–û–ø–∏—Å–∞–Ω–∏–µ"}, 
						"–ê—Ç—Ä–∏–±—É—Ç", "–ó–Ω–∞—á–µ–Ω–∏–µ"
					)
				in
					Unpivot,
			table_Sales =
		 		Table.FromColumns(
					{
						List.Transform({1..12}, each Text.Start(Date.MonthName(#date(2014,_,1),"en-US"),3)), // —Å–ø–∏—Å–æ–∫ –º–µ—Å—è—Ü–µ–≤
						{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12}
					}, 
					type table [Month=text, Sales=number]
				),
		//	—Ç–∞–±–ª–∏—Ü—ã —Å —Ç–∏–ø–∞–º–∏ –¥–∞–Ω–Ω—ã—Ö
			table_type_5 = // –≤—Å–µ —Ç–∏–ø—ã 
				#table( type table [ #"Type Name" = text, Type = type, #"Type Expression" = text ],
					{
						{ "Text", type text, "text"},
						{ "String", type text, "text"},
						{ "Number", type number, "number"},
						{ "Decimal", type number, "number"},
						{ "Decimal Number", type number, "number"},
						{ "Currency", Currency.Type, "Currency.Type"},
						{ "Int64", Int64.Type, "Int64.Type"},
						{ "Whole Number", Int64.Type, "Int64.Type"},
						{ "Percentage", Percentage.Type, "Percentage.Type"},
						{ "DateTime", type datetime, "datetime"},
						{ "Date", type date, "date"},
						{ "Time", type time, "time"},
						{ "DateTimeZone", type datetimezone, "datetimezone"},
						{ "Duration", type duration, "duration"},
						{ "Logical", type logical, "logical"},
						{ "Boolean", type logical, "logical"},
						{ "Type", type type, "type"},
						{ "", type any, "any"},
						{ null, type any, "any"},
						{ "List", type list, "list"},
						{ "Record", type record, "record"},
						{ "Guid", Guid.Type, "Guid.Type"},
						{ "Binary", type binary,"binary"},
						{ "Table", type table,"table"},
						{ "Int8", Int8.Type, "Int8.Type"},
						{ "UInt8", Byte.Type, "Byte.Type"},
						{ "Int16", Int16.Type, "Int16.Type"},
						{ "Int32", Int32.Type, "Int32.Type"},
						{ "Single", Single.Type, "Single.Type"},
						{ "Double", Double.Type, "Double.Type"}}),
			table_type_0 = // —Ç–∏–ø—ã –≤ –æ–¥–Ω–æ–π —Å—Ç—Ä–æ–∫–µ
				#table(
					{"n", "fun", "rec", "tb", "l", "bin", "typ"},
					{
						{1, (x) => x, [a = 1], #table({"a"}, {{1}}), {1..3}, #binary(""), type text}
					}
				),
			table_type_1 = // –≤—Å–µ —Ç–∏–ø—ã –¥–∞–Ω–Ω—ã—Ö –≤ –æ–¥–Ω–æ–π –∫–æ–ª–æ–Ω–∫–µ (—á–µ—Ä–µ–∑ #table)
				#table(
					{"val"},
					{
						{null},
						{1.23},
						{"—Ç–µ–∫—Å—Ç"},
						{false},
						{#date(2024,2,3)},
						{#datetime(2024,2,3,12,34,56)},
						{{1..3}},
						{[a=1]},
						{#table({},{})},
						{(x)=>x}}
				),
			table_type_2 = // –≤—Å–µ —Ç–∏–ø—ã –¥–∞–Ω–Ω—ã—Ö –≤ –¥–≤—É—Ö —Å—Ç—Ä–æ–∫–∞—Ö (—á–µ—Ä–µ–∑ #table)
				#table(
					type table [
						Null = null,
						Logical = logical,
						Number  = number,
						Time    = time,
						Date    = date,
						Datetime = datetime,
						Datetimezone = datetimezone,
						Duration = duration,
						Type = type,
						Text = text,
						List = list,
						Record = record,
						Table = table,
						Binary = binary
					], 
					{
						{
							null,
							true,
							1,
							#time(20,43,12),
							#date(2015, 1, 1),
							#datetime(2015, 1, 1, 21, 49, 18),
							#datetimezone(2015, 1, 1, 21, 49, 18, 3, 0),
							#duration(0, 0, 5, -30),
							type {type},
							"Hello World!",
							{null, false, 2, #time(20,43,12), "Goodbye World!"},
							[A = 1, B = "2"],
							#table({"x", "x^2"}, {{1,1}, {2,4}, {3,9}}),
							#binary({0x00, 0x01, 0x02, 0x03})
						},
						{
							null,
							false,
							2,
							#time(12,55,1),
							#date(2035, 1, 1),
							#datetime(2035, 5, 5, 15, 55, 55),
							#datetimezone(2015, 1, 1, 21, 49, 18, 3, 0),
							#duration(0, 0, 5, -30),
							type {type},
							"Hello World!",
							{null, false, 2, #time(20,43,12), "Goodbye World!"},
							[A = 1, B = "2"],
							#table({"x", "x^2"}, {{1,1}, {2,4}, {3,9}}),
							#binary({0x00, 0x01, 0x02, 0x03})
						}
					}
				),
			table_type_3 = // –≤—Å–µ —Ç–∏–ø—ã –¥–∞–Ω–Ω—ã—Ö –≤ –¥–≤—É—Ö —Å—Ç—Ä–æ–∫–∞—Ö (—á–µ—Ä–µ–∑ Table.FromRecords)
					Table.FromRecords( 
						{ 
							[   CustomerlD  = 1,
								JerseyNo	= 45,
								Name	    = "Rohit",
								LastName	= "Sharma",
								Phone	    = "123-4567",
								Datel	    = "1/1/2020",
								Date2	    = "1/1/2020"
							], 
							[ 	CustomerlD	= 2,
								JerseyNo	= 10,
								Name        = "Sachin",
								LastName    = "Tendulkar",
								Phone       = "123-4567",
								Datel       = "1/1/2020",
								Date2       = "1/1/2020"
							] 
						}, 
						type table 
							[   CustomerlD  = Number.Type, 
								JerseyNo    = Number.Type, 
								Name        = Text.Type, 
								LastName    = Text.Type, 
								Datel       = Date.Type, 
								Date2       = Date.Type
							]
					),
						
			table_type_4 = // —Ç–∞–±–ª–∏—Ü–∞ —Å –ø—Ä–æ–ø—É—Å–∫–∞–º–∏ –∏ —Ä–∞–∑–Ω—ã–º–∏ —Ç–∏–ø–∞–º–∏ –¥–∞–Ω–Ω—ã—Ö
					#table( {"a","b","c","d","e","f"},
						{
							{"text",null,null,null,"—Ç–µ–∫—Å—Ç",null},
							{null,"text",null,null,null,null},
							{null,null,"–ù–∞–∏–º–µ–Ω–æ–≤–∞–Ω–∏–µ","–¶–µ–Ω–∞","–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ","–°—É–º–º–∞"},
							{null,null,"–∫–ª–∞–≤–∏–∞—Ç—É—Ä–∞",100,2,200},
							{null,null,"–º—ã—à—å",50,10,500}
						}
					),
			table_type_Ext = // —Ç–∞–±–ª–∏—Ü–∞ —Å —Ä–∞—à–∏—Ä–µ–Ω–∏—è–º–∏
				// {  ".xls" ,  ".xlsm", ".xlsx", ".csv", ".zip" }
				#table( type table [ Extension = text],
					{	{ "xls" },
						{ "xlsb" },
						{ "xlsm" },
						{ "xlsx" },
						{ "csv" }
					}),
		//	—Ç–∞–±–ª–∏—Ü—ã —Å –≤–ª–æ–∂–µ–Ω–Ω—ã–º–∏ –ø–æ–¥—Ç–∞–±–ª–∏—Ü–∞–º–∏, —Å–ø–∏—Å–∫–∞–º–∏, –∑–∞–ø–∏—Å—è–º–∏
			table_into_1 = // –≤–ª–æ–∂–µ–Ω–Ω—ã–π list –≤–æ –≤—Ç–æ—Ä–æ–π –∫–æ–ª–æ–Ω–∫–µ
				#table(
					{"Name", "Record"},
					{
						{ "Item1", {#table({"Col1"}, {{1}}), "Value2"				} },
						{ "Item2", {"Value3", 				 "Value4"				} },
						{ "Item3", {5, 						 #table({"Col1"},{{2}})	} }
					}
				),
			table_into_2 = // –≤–ª–æ–∂–µ–Ω–Ω—ã–π record –≤–æ –≤—Ç–æ—Ä–æ–π –∫–æ–ª–æ–Ω–∫–µ
				#table(
					{"Name", "Record"},
					{
						{"Item1", [Field1 = #table({"Col1"}, {{1}}), Field2 = "Value2"]},
						{"Item2", [Field1 = "Value3", Field3 = "Value4"]},
						{"Item3", [Field2 = 5, Field4 = #table({"Col1"}, {{2}})]}
					}
				),			
			table_into_3 = // –≤–ª–æ–∂–µ–Ω–Ω—ã–π table –≤–æ –≤—Ç–æ—Ä–æ–π –∫–æ–ª–æ–Ω–∫–µ
				let Source = Table.FromRecords({
						[ID = 1, Name = "Item 1", SubTable = Table.FromRecords({[SubID = 101, Value = "A"], [SubID = 102, Value = "B"]})],
						[ID = 2, Name = "Item 2", SubTable = Table.FromRecords({[SubID = 201, Value = "C"], [SubID = 202, Value = "D"]})],
						[ID = 3, Name = "Item 3", SubTable = Table.FromRecords({[SubID = 301, Value = "E"], [SubID = 302, Value = "F"]})]
					})
				in Source,

			table_into_4 = // —Ç–∞–±–ª–∏—Ü–∞ —Å –ø–æ–¥—Ç–∞–±–ª–∏—Ü–∞–º–∏
				let	Source = #table(
						{"ID", "Name", "Data"},
						{
							{1, "Alpha", #table({"SubID", "Value", "Category"}, {{1, 100, "A"}, {2, 200, "B"}, {3, 150, "A"}})},
							{2, "Beta",  #table({"SubID", "Value", "Category"}, {{1, 300, "B"}, {2, 400, "C"}, {3, 250, "A"}})},
							{3, "Gamma", #table({"SubID", "Value", "Category"}, {{1, 500, "A"}, {2, 600, "B"}, {3, 450, "C"}})}
						}
					)
				in	Source,

		//	—Ç–∞–±–ª–∏—Ü—ã —Ä–∞–∑–Ω—ã–µ (—á–µ—Ä–µ–∑ Binary)
			table_bin_2 = // –ø–ª–∞–Ω, —Ñ–∞–∫—Ç, –¥–∞—Ç–∞, –≤–∞—Ä–∏–∞–Ω—Ç (–ø–æ–ª–Ω—ã–π –≥–æ–¥, 8 –º–µ—Å)
					Table.FromRows(Json.Document(Binary.Decompress(Binary.FromText("7ZRLboMwFEW3ghhHlT9A7bWg7CVJq04qla1QEqQ2KWQLzzuq/QwJler4o46qTJACue9zfa7rOhdVvsopkeaZqQYG6KBVG9VkjDCSwf5Bf4EzjHCCQb3Cp36lfxzy9arOKS2NjhVW/Qw9dGoDLZzC9EIYIaUohy9svIM2rDXD1sRqWzjrxn1cY1JdGwfJpJ136vmh3vRfwowiaBEpr8rASSnHbrSY9+xgr57UNtgn7GyLZGqrLRrUTp/ze/AZMzSaTAOMcIzUkx8LDDBGqa3Z3PIJBz3/UZsQrJcoL0gi3sWCsXi8pZU/JuAtDSkWt3i4kTIuIuGe6KRVPN0lJpjH0y1NM0FT2S7xZMoiGW6Lx2xVAttoFpNpbE+XAkllWy7Oy8W2prY1a2XCoNBrcxv1YkC2I2AypA9wTxFL+Hwt/sr57QqSo438Ju6eISy9bDFElA+IAHff7B49RQuYcCbAZyGiwJknCR4bzRDeLPg2EXMRdx58y/BLCUckfGdJLwWcqfBY8VfZEPds3LPxj7Kx/gY=", BinaryEncoding.Base64), Compression.Deflate)), let _t = ((type nullable text) meta [Serialized.Text = true]) in type table [–ø–ª–∞–Ω = _t, —Ñ–∞–∫—Ç = _t, –¥–∞—Ç–∞ = _t, –≤–∞—Ä–∏–∞–Ω—Ç = _t]),
		//	—Ç–∞–±–ª–∏—Ü—ã —Ä–∞–∑–Ω—ã–µ
			table_other_1 = // 10 –∫–æ–ª–æ–Ω–æ–∫, 10 —Å—Ç—Ä–æ–∫. –í—Å–µ —á–∏—Å–ª–∞. –° –∏—Ç–æ–≥–∞–º–∏ —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∞—Ç—å—Å—è
				let	from = 
						Table.FromColumns({
							{1, 2, 3, 4, 5, 6, 7, 8, 9, 10},  // –£—Ä–æ–≤–µ–Ω—å
							{3000, 6300, 9650, 17500, 21000, 31000, 46000, 69000, 105000, 150000},  // –í–µ—Ç–∫–∞ 1
							{4500, 9450, 14775, 26250, 31500, 46500, 69000, 103500, 157500, 225000},  // –í–µ—Ç–∫–∞ 2
							{6000, 12600, 19700, 35000, 42000, 62000, 92000, 136000, 210000, 300000},  // –í–µ—Ç–∫–∞ 3
							{7500, 15750, 24625, 43750, 52500, 77500, 115000, 172500, 262500, 375000},  // –í–µ—Ç–∫–∞ 4
							{12000, 25200, 39400, 70000, 64000, 124000, 164000, 276000, 420000, 600000},  // –í–µ—Ç–∫–∞ 5
							{16500, 34650, 54175, 96250, 115500, 170500, 253000, 379500, 577500, 625000},  // –í–µ—Ç–∫–∞ 6
							{21000, 44100, 68950, 122500, 147000, 217000, 322000, 463000, 735000, 1050000},  // –í–µ—Ç–∫–∞ 7
							{25500, 53550, 83725, 146750, 176500, 263500, 391000, 566500, 692500, 1275000},  // –í–µ—Ç–∫–∞ 8
							{31500, 66150, 103425, 163750, 220500, 325500, 483000, 724500, 1102500, 1575000},  // –í–µ—Ç–∫–∞ 9
							{37500, 76750, 123125, 216750, 262500, 367500, 575000, 662500, 1312500, 1675000}   // –í–µ—Ç–∫–∞ 10
						}, 
							{"–£—Ä–æ–≤–µ–Ω—å"} & List.Transform({1..10}, (x)=>"–í–µ—Ç–∫–∞ " & Number.ToText(x))	// –Ω–∞–∑–≤–∞–Ω–∏—è —Å—Ç–æ–ª–±—Ü–æ–≤
						) 
				in	from,
	// 	RECORD
		//	—Ä–∞–∑
			rec_1 = #table({},{}),
		//	–¥–≤–∞
			rec_2 = #table({},{}),
	//	–∑–∞–≥–ª—É—à–∫–∞
			–ó–∞–≥–ª—É—à–∫–∞ = #table({},{})
		],

Return     =   // –≤–æ–∑–≤—Ä–∞—â–∞–µ–º —Ç–æ–ª—å–∫–æ —Ñ—É–Ω–∫—Ü–∏–∏
		–ü–∞—Ä–∞–º–µ—Ç—Ä—ã &
		FinReport &
		MyPack &
		UTIL & 
		extLibrary & 
		LibPQ &
		buch &	
		Camwally &
		Zelensky &
		Calendar &
		Table &
		World &
		// Grech &
		// DataAnalys &
		Connectors
		
 in 
 	Return