// TO DO / –ó–∞–¥–∞—á–∏       üìù üöß üîú üîÑ ‚è≥ üîπ
// –û—à–∏–±–∫–∏ / –ü—Ä–æ–±–ª–µ–º—ã    ‚ùó  ‚ùå ‚ö†Ô∏è üï≥Ô∏è üõ†Ô∏è üî•
// –°—Ç–∞—Ç—É—Å—ã / –ó–∞–≤–µ—Ä—à–µ–Ω–æ  üéØ üèÅ üîÑ üëç üèóÔ∏è ‚úÖ
// –ü–æ–∏—Å–∫ / –ê–Ω–∞–ª–∏–∑       üîç üßê üïµÔ∏è üìä üí° üìå
// –§–∞–π–ª—ã / –ü—Ä–æ–µ–∫—Ç—ã      üìÇ üìÅ üèóÔ∏è üè∑Ô∏è üìé
// –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è          üöÄ üîß üé® üïí üèÜ ‚ö°

//  –≤–æ –≤—Å–µ—Ö —Ç–∞–±–ª–∏—Ü–∞—Ö –ø–æ–¥–Ω—è—Ç—å –∑–∞–≥–æ–ª–æ–≤–∫–∏
    let from = Excel.Workbook(File.Contents("....\–ò—Å—Ö–æ–¥–Ω–∏–∫.xlsx")),
        sel  = Table.SelectRows(from, (x)=>x[Item]="–ü–æ–∫—É–ø–∞—Ç–µ–ª–∏" and x[Kind]="Sheet")[Data],
        to   = Table.Combine(List.Transform(sel,Table.PromoteHeaders))
    in  to

//  –∫–∞–∫ –æ–±–æ–∑–Ω–∞—á–∏—Ç—å –∫–æ–ª–æ–Ω–∫–∏, –æ—Ç –∫–æ—Ç–æ—Ä—ã—Ö –∑–∞–≤–∏—Å–∏—Ç —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏—è –≤ —Ç–∞–±–ª–∏—Ü–µ, —á—Ç–æ–±—ã –æ–±—Ä–∞—â–∞—Ç—å—Å—è –∫ –Ω–∏–º –Ω–µ –Ω–∞–ø—Ä—è–º—É—é (–∫–∞–∫ —ç—Ç–æ –Ω–∞ –ø—Ä–∏–º–µ—Ä–µ –Ω–∏–∂–µ), –∞ —á–µ—Ä–µ–∑ —Å–ø–∏—Å–æ–∫ (lst), –∫–æ—Ç–æ—Ä—ã–π —Å–æ–¥–µ—Ä–∂–∏—Ç –∏–º–µ–Ω–∞ —ç—Ç–∏—Ö –∫–æ–ª–æ–Ω–æ–∫ (–∫–æ–ª–æ–Ω–æ–∫ –º–æ–∂–µ—Ç –±—ã—Ç—å –∏ –±–æ–ª—å—à–µ). –ï—Å–ª–∏ –≤–æ–∑–º–æ–∂–Ω–æ, —Ç–æ –Ω–µ—Å–∫–æ–ª—å–∫–æ –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤ –ø–æ–¥—Å–∫–∞–∂–∏—Ç–µ –ø–æ–∂–∞–ª—É–π—Å—Ç–∞.
    lst = {"–¢–ó1", "–¢–ó2", "–¢–ó3"},
    –æ—Ç–±–æ—Ä = Table.SelectRows(–ò—Å—Ç–æ—á–Ω–∏–∫, each List.NonNullCount({[–¢–ó1], [–¢–ó2], [–¢–ó3]}) > 0)

    let
        Source = #table(
            {"id", "b", "c", "d", "e"}, 
            {
                {1, null, null, null, null},
                {2, null, 4, null, null},
                {3, null, null, null, 5}
            }
        ), 
        lst = {"c", "d", "e"},
        nulls = List.Buffer(List.Repeat({null}, List.Count(lst))),
        rec_nulls = Record.FromList(nulls, lst),
        sel01 = Table.SelectRows(Source, each Record.ToList(Record.SelectFields(_, lst)) <> nulls),
        sel02 = Table.SelectRows(Source, each List.NonNullCount(Record.ToList(Record.SelectFields(_, lst))) > 0),
        sel03 = Table.SelectRows(Source, each List.Distinct(Record.ToList(Record.SelectFields(_, lst))) <> {null}),
        sel04 = Table.SelectRows(Source, each not List.IsEmpty(List.Skip(Record.ToList(Record.SelectFields(_, lst)), each _ is null))),
        sel05 = Table.SelectRows(Source, each not List.IsEmpty(List.RemoveNulls(Record.ToList(Record.SelectFields(_, lst))))), 
        sel06 = Table.SelectRows(Source, each Record.SelectFields(_, lst) <> rec_nulls),
        sel07 = Table.RemoveMatchingRows(Source, {rec_nulls}, lst)
    in
        sel07


//  —Ñ—É–Ω–∫—Ü–∏—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ —Å–ø–∏—Å–∫–∞ –¥–∞—Ç! –†–∞–±–æ—Ç–∞–µ—Ç
    let
        fxListDatesCustom = (startDate as date, n as number, dur as duration) as list => List.Dates(startDate, n, dur),
        DocumentationMetaData = [
            Documentation.Name          = "fxListDatesCustom",
            Documentation.Description   = "This function generates a list of dates starting with a specified start date going for n number of dur periods.",
            Documentation.Examples      = {
                [ 
                    Description = "Generate a list of continuous dates from 06.04.2025 to 10.04.2025.",
                    Code        = "fxLoistDatesCustom(#date(2025, 4, 6), 5, #duration(1, 0, 0, 0)",
                    Result      = "06.04.2025#(lf)07.04.2025#(lf)08.04.2025#(lf)09.04.2025#(lf)10.04.2025"
                ]
            }
        ]
    in
        Value.ReplaceType(
            fxListDatesCustom, 
            Value.ReplaceMetadata(
                Value.Type(fxListDatesCustom), 
                DocumentationMetaData
            )
        )

//  —Ñ—É–Ω–∫—Ü–∏—è –≤ –∞—Ä–≥—É–º–µ–Ω—Ç–∞–º–∏ Meta // –•–û–†–û–®–û
    let 
        Func = (input as record) => 
            let 
                one = input[Server], 
                two = input[Timeout], 
                tre = input[CutOff]
            in  
                {one,two,tre},

        NewType = type function ( input as [   
                Server           = (type text   meta [Documentation.SampleValues = { "localhost"}]), 
                optional Timeout = (type number meta [Documentation.FieldCaption = "Time Out [in seconds]",Documentation.AllowedValues = { 10, 60, 360 }]), 
                optional CutOff  = (type text   meta [Documentation.SampleValues = { "test"}])
            ]) as any, 

        Ascribed = Value.ReplaceType(Func, NewType) 
    in 
        Ascribed
        

//  –û—Ç–ª–æ–≤ –Ω–µ–≤–µ—Ä–Ω–æ–≥–æ –∞—Ä–≥—É–º–µ–Ω—Ç–∞ –≤ —Ñ—É–Ω–∫—Ü–∏–∏!
    let 
        f = (input as record) =>
        let 
            //  –ó–Ω–∞—á–µ–Ω–∏—è –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
                defaultOptions = [
                    Path = "",              // –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–π –ø–∞—Ä–∞–º–µ—Ç—Ä
                    FileExtension = "xlsx", // —Ä–∞—Å—à–∏—Ä–µ–Ω–∏–µ —Ñ–∞–π–ª–∞
                    SubFolders = false      // –±–µ—Ä–µ–º —Ñ–∞–π–ª—ã —Ç–µ–∫—É—â–µ–π –ø–∞–ø–∫–∏, –≤ –ø–æ–¥–ø–∞–ø–∫–∏ –Ω–µ —Å–º–æ—Ç—Ä–∏–º
                ],

            //  –°–ø–∏—Å–æ–∫ –¥–æ–ø—É—Å—Ç–∏–º—ã—Ö –∏–º–µ–Ω –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤
                validArguments = Record.FieldNames(defaultOptions),

            //  –ü—Ä–æ–≤–µ—Ä–∫–∞ –≤—Ö–æ–¥–Ω–æ–≥–æ —Ä–µ–∫–æ—Ä–¥–∞ –Ω–∞ –Ω–µ–¥–æ–ø—É—Å—Ç–∏–º—ã–µ –ø–æ–ª—è
                inputFields   = if input <> null then Record.FieldNames(input) else {},
                invalidFields = List.Difference(inputFields, validArguments),

            //  –í—ã–±—Ä–æ—Å –æ—à–∏–±–∫–∏, –µ—Å–ª–∏ –µ—Å—Ç—å –Ω–µ–¥–æ–ø—É—Å—Ç–∏–º—ã–µ –ø–æ–ª—è
                checkArguments = 
                    if List.Count(invalidFields) > 0 
                    then error "Invalid argument(s): " & Text.Combine(invalidFields, ", ") & ". Valid arguments are: " & Text.Combine(validArguments, ", ")
                    else input,

            //  –°–æ–≤–º–µ—â–∞–µ–º –æ–ø—Ü–∏–∏, –µ—Å–ª–∏ –Ω–µ—Ç –æ—à–∏–±–æ–∫
                finalOptions =  if checkArguments = null 
                                then defaultOptions 
                                else Record.Combine({defaultOptions, checkArguments})
        in 
                finalOptions,

        // –¢–µ—Å—Ç–æ–≤—ã–π –≤—ã–∑–æ–≤
        result = f([Path1 = "D:\1"]) // –î–æ–ª–∂–Ω–∞ –±—ã—Ç—å –æ—à–∏–±–∫–∞
    in 
        result

//  –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ
    https://baguzin.ru/wp/yazyk-m-power-query-metadannye/
    GetPage = (url as text) as table =>
        let
            Response = Json.Document(Web.Contents(url)),
            Table    = Table.FromRecords(Response[Data])
        in
            Table meta [NextLink = Response[Next]],

//  –ò–µ—Ä–∞—Ä—Ö–∏—è. –ò–Ω—Ç–µ—Ä–µ—Å–Ω—ã–π –∫–æ–¥
        let
            from = Table.FromRows(
            {
                {"Citizens Bank-Operating" ,"Total Company Cash" ,"Total Current Assets" ,"Total Assets" },
                {"Bill.com Money Out Clearing" ,"Total Company Cash" ,"Total Current Assets" ,"Total Assets" },
                {"Small Business Line (0026) - 3" ,"Total Company Cash" ,"Total Current Assets" ,"Total Assets" },

                {"Undeposited Funds" ,"Total Company Cash" ,"Total Current Assets" ,"Total Assets" },
                {"Accounts Receivable (A/R)" ,"Total Accounts Receivable" ,"Total Current Assets" ,"Total Assets" },
                {"Office furniture & Equipment" ,"Total Fixed Assets" ,"Total Fixed Assets" ,"Total Assets" },
                {"Software" ,"Total Fixed Assets" ,"Total Fixed Assets" ,"Total Assets" },

                {"Uncategorized Asset" ,"Total Other Assets" ,"Total Other Assets" ,"Total Assets" },
                {"Accounts Payable (A/P)" ,"Total Accounts Payable" ,"Total Current Liabilities" ,"Total Liabilities & Equity" },


                {"Chase Card-1916" ,"Credit Card" ,"Total Current Liabilities" ,"Total Liabilities & Equity" },
                {"Chase Card-4331" ,"Credit Card" ,"Total Current Liabilities" ,"Total Liabilities & Equity" },
                {"Chase Card-8512" ,"Credit Card" ,"Total Current Liabilities" ,"Total Liabilities & Equity" },


                {"Accrued 401K Employee Contribution" ,"Accured Expenses" ,"Total Current Liabilities" ,"Total Liabilities & Equity" },
                {"Accrued Expenses" ,"Accured Expenses" ,"Total Current Liabilities" ,"Total Liabilities & Equity" },
                {"Accrued Owner's Salary" ,"Accured Expenses" ,"Total Current Liabilities" ,"Total Liabilities & Equity" },
                {"Accrued Payroll" ,"Accured Expenses" ,"Total Current Liabilities" ,"Total Liabilities & Equity" },

                {"Balboa Capital Loan" ,"Accured Expenses" ,"Total Current Liabilities" ,"Total Liabilities & Equity" },
                {"Barclay Card" ,"Accured Expenses" ,"Total Current Liabilities" ,"Total Liabilities & Equity" },
                {"Chase - United" ,"Accured Expenses" ,"Total Current Liabilities" ,"Total Liabilities & Equity" },
                {"Chase Card-Mariott" ,"Accured Expenses" ,"Total Current Liabilities" ,"Total Liabilities & Equity" },
                {"Citizens- 0026" ,"Accured Expenses" ,"Total Current Liabilities" ,"Total Liabilities & Equity" },
                {"Shareholder Loan" ,"Accured Expenses" ,"Total Current Liabilities" ,"Total Liabilities & Equity" },

                {"Net Income" ,"Company Retained Earnings" ,"Total Company Equity" ,"Total Liabilities & Equity" },
                {"Retained Earnings" ,"Company Retained Earnings" ,"Total Company Equity" ,"Total Liabilities & Equity" },
                {"Owner's Pay & Personal Expenses" ,"Company Retained Earnings" ,"Total Company Equity" ,"Total Liabilities & Equity" },
                {"Shareholder Distributions" ,"Company Retained Earnings" ,"Total Company Equity" ,"Total Liabilities & Equity" },
                {"Total Stocks" ,"Total Stocks" ,"Total Company Equity" ,"Total Liabilities & Equity" },
                {"Total Common Stocks" ,"Total Common Stocks" ,"Total Company Equity" ,"Total Liabilities & Equity" }

            }, 
            type table [Name = text, BS_lvl_2 = text, BS_lvl_3 = text, BS_lvl_4 = text]
        ), 

            f=(x,y)=>
                let z = Table.Column(x,y),
                    a = List.Buffer(List.Distinct(z)),
                    f = (r)=>List.PositionOf(a,Record.Field(r,y))
                in  Table.AddColumn(x, y & "_Ind", f),
            
            nms = Table.ColumnNames(from),
            acc = List.Accumulate(nms,from,f)
        in
            acc

//  –ò–µ—Ä–∞—Ä—Ö–∏—è2. –ò–Ω—Ç–µ—Ä–µ—Å–Ω—ã–π –∫–æ–¥
        let
    src = Table.FromRows(
        {
            {"Citizens Bank-Operating" ,"Total Company Cash" ,"Total Current Assets" ,"Total Assets" },
            {"Bill.com Money Out Clearing" ,"Total Company Cash" ,"Total Current Assets" ,"Total Assets" },
            {"Small Business Line (0026) - 3" ,"Total Company Cash" ,"Total Current Assets" ,"Total Assets" },

            {"Undeposited Funds" ,"Total Company Cash" ,"Total Current Assets" ,"Total Assets" },
            {"Accounts Receivable (A/R)" ,"Total Accounts Receivable" ,"Total Current Assets" ,"Total Assets" },
            {"Office furniture & Equipment" ,"Total Fixed Assets" ,"Total Fixed Assets" ,"Total Assets" },
            {"Software" ,"Total Fixed Assets" ,"Total Fixed Assets" ,"Total Assets" },

            {"Uncategorized Asset" ,"Total Other Assets" ,"Total Other Assets" ,"Total Assets" },
            {"Accounts Payable (A/P)" ,"Total Accounts Payable" ,"Total Current Liabilities" ,"Total Liabilities & Equity" },


            {"Chase Card-1916" ,"Credit Card" ,"Total Current Liabilities" ,"Total Liabilities & Equity" },
            {"Chase Card-4331" ,"Credit Card" ,"Total Current Liabilities" ,"Total Liabilities & Equity" },
            {"Chase Card-8512" ,"Credit Card" ,"Total Current Liabilities" ,"Total Liabilities & Equity" },


            {"Accrued 401K Employee Contribution" ,"Accured Expenses" ,"Total Current Liabilities" ,"Total Liabilities & Equity" },
            {"Accrued Expenses" ,"Accured Expenses" ,"Total Current Liabilities" ,"Total Liabilities & Equity" },
            {"Accrued Owner's Salary" ,"Accured Expenses" ,"Total Current Liabilities" ,"Total Liabilities & Equity" },
            {"Accrued Payroll" ,"Accured Expenses" ,"Total Current Liabilities" ,"Total Liabilities & Equity" },

            {"Balboa Capital Loan" ,"Accured Expenses" ,"Total Current Liabilities" ,"Total Liabilities & Equity" },
            {"Barclay Card" ,"Accured Expenses" ,"Total Current Liabilities" ,"Total Liabilities & Equity" },
            {"Chase - United" ,"Accured Expenses" ,"Total Current Liabilities" ,"Total Liabilities & Equity" },
            {"Chase Card-Mariott" ,"Accured Expenses" ,"Total Current Liabilities" ,"Total Liabilities & Equity" },
            {"Citizens- 0026" ,"Accured Expenses" ,"Total Current Liabilities" ,"Total Liabilities & Equity" },
            {"Shareholder Loan" ,"Accured Expenses" ,"Total Current Liabilities" ,"Total Liabilities & Equity" },

            {"Net Income" ,"Company Retained Earnings" ,"Total Company Equity" ,"Total Liabilities & Equity" },
            {"Retained Earnings" ,"Company Retained Earnings" ,"Total Company Equity" ,"Total Liabilities & Equity" },
            {"Owner's Pay & Personal Expenses" ,"Company Retained Earnings" ,"Total Company Equity" ,"Total Liabilities & Equity" },
            {"Shareholder Distributions" ,"Company Retained Earnings" ,"Total Company Equity" ,"Total Liabilities & Equity" },
            {"Total Stocks" ,"Total Stocks" ,"Total Company Equity" ,"Total Liabilities & Equity" },
            {"Total Common Stocks" ,"Total Common Stocks" ,"Total Company Equity" ,"Total Liabilities & Equity" }

                }, 
                type table [Name = text, BS_lvl_2 = text, BS_lvl_3 = text, BS_lvl_4 = text]
            ), 

            addSort = List.Accumulate(Table.ColumnNames(src), src, 
                (s, c) => Table.AddColumn(s, 
                    c & "_Ind", 
                    (r) => List.PositionOf(Table.Column(src, c), Record.Field(r, c)), 
                    Int64.Type
                )
            )
            in
                addSort

//  —Ä–∞–∑–≤–µ—Ä–Ω—É—Ç—å —Å–ø–∏—Å–∫–∏ + —Ä–∞–∑–≤–µ—Ä–Ω—É—Ç—å —Ç–∞–±–ª–∏—Ü—ã 
    let
        // –ò—Å—Ö–æ–¥–Ω–∞—è —Ç–∞–±–ª–∏—Ü–∞ —Å —á–µ—Ç—ã—Ä—å–º—è –∫–æ–ª–æ–Ω–∫–∞–º–∏, —Å–æ–¥–µ—Ä–∂–∞—â–∏–º–∏ —Å–ø–∏—Å–∫–∏
        Source = 
            Table.FromRows(
                {
                    {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}, {10, 11, 12}}
                }, 
                {"Column1", "Column2", "Column3", "Column4"}
            ),
        
        // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –∫–∞–∂–¥—É—é –∫–æ–ª–æ–Ω–∫—É, —Å–æ–¥–µ—Ä–∂–∞—â—É—é —Å–ø–∏—Å–∫–∏, –≤ –æ—Ç–¥–µ–ª—å–Ω—ã–µ —Å—Ç—Ä–æ–∫–∏
        ExpandedTable = Table.FromColumns(
            List.Transform(Table.ToColumns(Source), each _{0}), // –ò–∑–≤–ª–µ–∫–∞–µ–º —Å–ø–∏—Å–∫–∏ –∏–∑ —è—á–µ–µ–∫
            List.Transform({1..Table.ColumnCount(Source)}, each "x" & Text.From(_)) // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –Ω–∞–∑–≤–∞–Ω–∏–π –∫–æ–ª–æ–Ω–æ–∫: x1, x2, x3, x4
        )
    in
        ExpandedTable

    // –ï–°–õ–ò –¢–ê–ë–õ–ò–¢–¶–´ –¢–û 
        ExpandedTable = Table.FromColumns(
            List.Transform(Table.ToColumns(Source), each _{0} [–ù–∞–∑–≤–∞–Ω–∏–µ –∫–æ–ª–æ–Ω–∫–∏]),
            List.Transform({1..Table.ColumnCount(Source)}, each "x" & Text.From(_))
        )

//  –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Ç–æ–ª—å–∫–æ —Ç–∞–±–ª–∏—Ü—ã –∏–∑ —Å–ø–∏—Å–∫–∞
    = List.Select(
        Record.FieldValues(Tables), 
        each Value.Is(_, type table) // —Ç–æ–ª—å–∫–æ —Ç–∞–∫ —Ä–∞–±–æ—Ç–∞–µ—Ç –ø—Ä–æ–≤–µ—Ä–∫–∞ —Ç–∞–±–ª–∏—Ü—ã
    )

//  todo –ü–†–ê–í–ò–õ–¨–ù–´–ô –°–õ–û–í–ê–†–¨
//  –ü–æ—ç—Ç–æ–º—É –≤–æ—Ç —Ç–∞–∫ —Å—Ç–æ–∏—Ç –ø–∏—Å–∞—Ç—å –Ω–∞ –ú!! –û—Ç –ú–∏—Ö–∞–∏–ª–∞
        let
            base = Excel.CurrentWorkbook(){[Name="dimCost2"]}[Content], // —Å–ª–æ–≤–∞—Ä—å
            from = Excel.CurrentWorkbook(){[Name="Sales2"]}[Content],   // –∏—Å—Ö–æ–¥–Ω–∏–∫

            dict =  Record.FromList(
                        base[Cost], 
                        List.Transform(base[Service ID],Text.From)
                    ),
            
            to   =  Table.AddColumn(from,"Cost", 
                        (x)=> Record.FieldOrDefault(dict, Text.From(x[Service ID]), 0)
                    )
        in
            to


SelectRow_  = //todo –≤–µ—Ä—Å–∏—è —Å –∞—Ä–≥—É–º–µ–Ω—Ç–∞–º–∏ –Ω–æ–≤—ã–º–∏ –æ—Ç 30.01.2025 #3.1 —Ñ–∏–ª—å—Ç—Ä—É–µ–º —Å—Ç—Ä–æ–∫–∏ –≤ –ø–æ–¥—Ç–∞–±–ª–∏—Ü–∞—Ö –ø–æ "–°—Ç–∞—Ç—å—è_ID" –≤ rep.BAL3 –∏ –¥—Ä –Ω–∞ —à–∞–≥–µ Load (–¥–ª—è –æ—Ç—á–µ—Ç–æ–≤ –∫–æ—Ç–æ—Ä—ã–µ –∏–º–µ—é—Ç –Ω–æ–º–µ—Ä —Å—Ç—Ä–æ–∫–∏)
            LoadFolder_ = // #1 –ø–æ–¥–∫–ª—é—á–∞–µ–º—Å—è –∫ –ü–ê–ü–ö–ï, –ø–æ–ª—É—á–∞–µ–º —Å–ø–∏—Å–æ–∫ —Ñ–∞–π–ª–æ–≤ XLSX —Å –ø–æ–¥–ø–∞–ø–∫–∞–º–∏, —á–∏—Å—Ç–∏–º (–§–û–†–ú–ò–†–£–ï–ú –ò–°–¢–û–ß–ù–ò–ö)
                    /* 
                        –û–ø–∏—Å–∞–Ω–∏–µ:
                            1. –ø–æ–¥–∫–ª—é—á–∞–µ–º—Å—è –∫ –ø–∞–ø–∫–µ —Å —Ñ–∞–π–ª–∞–º–∏ –ø–æ –∏–º–µ–Ω–∏ –¥–∞—Ç–∞—Å–µ—Ç–∞ –∏–ª–∏ –ø–æ –ø–æ–ª–Ω–æ–º—É –ø—É—Ç–∏
                            2. –≤—ã–±–∏—Ä–∞–µ–º –Ω–æ–º–µ—Ä —à–∞–≥–∞ –∑–∞–≥—Ä—É–∑–∫–∏. –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é –≤—ã–≥—Ä—É–∂–∞–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–π —à–∞–≥
                            3. —á–∏—Å—Ç–∏–º –ø–∞–ø–∫—É –æ—Ç –≤—Ä–µ–º–µ–Ω–Ω—ã—Ö –∏ —Å–∫—Ä—ã—Ç—ã—Ö —Ñ–∞–π–ª–æ–≤, –æ—Å—Ç–∞–≤–ª—è–µ–º —Ñ–∞–π–ª—ã .xlsx, –ø—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –±–∏–Ω–∞—Ä–Ω–∏–∫–∏
                            4. –≤ –∫–Ω–∏–≥–∞—Ö excel –æ—Å—Ç–∞–≤–ª—è–µ–º —Ç–æ–ª—å–∫–æ –ª–∏—Å—Ç—ã (Sheet)
                        
                        –ê—Ä–≥—É–º–µ–Ω—Ç—ã:
                            optional options as record
                                –ù–∞–ø—Ä–∏–º–µ—Ä [–î–∞—Ç–∞C–µ—Ç–ò–º—è = "Homel", –ù–æ–º–µ—Ä–®–∞–≥–∞ = null]
                        
                        –ü—Ä–∏–º–µ—Ä:	
                            = R[func][LoadFolder_]
                                ([–î–∞—Ç–∞C–µ—Ç = "BKS", –†–∞—Å—à–∏—Ä–µ–Ω–∏–µ = "xlsx", –ù–æ–º–µ—Ä–®–∞–≥–∞ = 5, –ü—É—Ç—å = null])
                                
                            = F[LoadFolder_]
                                ([–î–∞—Ç–∞C–µ—Ç–ò–º—è = "Homel"])					// –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç—Å—è –ø–æ—Å–ª–µ–¥–Ω–∏–π —à–∞–≥
                                ([–î–∞—Ç–∞C–µ—Ç–ò–º—è = "Homel", –ù–æ–º–µ—Ä–®–∞–≥–∞ = null])	// –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç—Å—è –ø–æ—Å–ª–µ–¥–Ω–∏–π —à–∞–≥
                                ([–î–∞—Ç–∞C–µ—Ç–ò–º—è = "Homel", –ù–æ–º–µ—Ä–®–∞–≥–∞ = 3])		// –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç—Å—è —Ç—Ä–µ—Ç–∏–π —à–∞–≥
                                ([–î–∞—Ç–∞C–µ—Ç–ò–º—è = "Homel", –ù–æ–º–µ—Ä–®–∞–≥–∞ = 123])	// –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç—Å—è –Ω–∞–¥–ø–∏—Å—å –æ–± –æ—à–∏–±–∫–µ
                        
                        –£–ª—É—á—à–µ–Ω–∏—è:
                            1 //! Folder.Contents ‚Äì —Å–æ–±–∏—Ä–∞–µ–º –¥–∞–Ω–Ω—ã–µ –∏–∑ –ø–∞–ø–∫–∏, –Ω–æ –≤—ã–±–æ—Ä–æ—á–Ω–æ
                            1. –ï—Å–ª–∏ –¥–∞—Ç–∞—Å–µ—Ç –Ω–µ –≤—ã–±—Ä–∞–Ω, —Ç–æ –º–µ–Ω—è–µ–º –Ω–∞–ø—Ä–∏–º–µ—Ä –Ω–∞ Homel 
                            2. –°–¥–µ–ª–∞—Ç—å –º–∞–∫–µ—Ç—ã —Ç–∞–±–ª–∏—Ü –≤—Å–µ—Ö –æ—Ç—á–µ—Ç–æ–≤ –¥–ª—è –∑–∞–º–µ–Ω—ã, –µ—Å–ª–∏ –Ω–∏—á–µ–≥–æ –Ω–µ—Ç –∏–ª–∏ –Ω–µ –≤—ã–±—Ä–∞–Ω–æ.
                            3. –ú–∞–∫–µ—Ç—ã —Ç–∞–±–ª–∏—Ü —Å –¥–∞–Ω–Ω—ã–º–∏ –ø–æ –£—Å–ª–æ–≤–Ω–æ–π –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏–∏. –ï–µ –Ω–∞–¥–æ —Å–æ–∑–¥–∞—Ç—å
                            4. –≠—Ç–æ –º–æ–≥—É—Ç –±—ã—Ç—å –¥–∞–Ω–Ω—ã–µ –∏–∑ –æ–¥–Ω–æ–≥–æ —Ñ–∞–π–ª–∞ XlSX —Å –¥–∞–Ω–Ω—ã–º–∏ –≤—Å–µ—Ö –æ—Ç—á–µ—Ç–æ–≤
                            5. –î–∞–Ω–Ω—ã–µ —Ä–∞–∑–Ω—ã—Ö –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏–π –º–æ–∂–Ω–æ —Å–æ–≤–º–µ—Å—Ç–∏—Ç—å, —á—Ç–æ–±—ã –∑–∞–ø–æ–ª–Ω–∏—Ç—å –±–∞–∑—É –∏ –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏–∏
                        */
                    [
                        func   = (optional options as record) => [ 	
                            // 	–ê–†–ì–£–ú–ï–ù–¢–´ –®–∞–≥ 1. –ó–Ω–∞—á–µ–Ω–∏—è –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
                                GetValue        = // —Ñ—É–Ω–∫—Ü–∏—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è —Ç–∏–ø–∞ –æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω—ã—Ö –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤
                                    (options as record, fieldName as text, typeConverter as function) =>
                                        let value = Record.FieldOrDefault(options, fieldName, null)
                                        in  if List.Contains({null,0,""},value) then null else typeConverter(value),

                                defaultOptions	= // –∑–Ω–∞—á–µ–Ω–∏—è –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é - –ø—É—Å—Ç–∞—è –∑–∞–ø–∏—Å—å ([?]) –∏–ª–∏ –∑–∞–ø–æ–ª–Ω–µ–Ω–Ω–∞—è?
                                    [   DATASET     = "", // —á—Ç–æ —Å –∂—Ç–∏–º –¥–µ–ª–∞—Ç—å?
                                        STEP        = null, 
                                        EXTENSION   = "xlsx",
                                        SUBFOLDERS 	= true, 
                                        PATH        = "D:\" 
                                    ],
                                
                                finalOptions    = // –æ–±—ä–µ–¥–∏–Ω—è–µ–º –æ–ø—Ü–∏–∏
                                    if options = null
                                    then defaultOptions 
                                    else Record.Combine({defaultOptions, options}),
                                                        
                            //  –ê–†–ì–£–ú–ï–ù–¢–´ –®–∞–≥ 2. –§–æ—Ä–º–∏—Ä—É–µ–º —Å–ø–∏—Å–æ–∫ –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤ (+ –≤ –æ–ø–∏—Å–∞–Ω–∏–∏ —Ñ—É–Ω–∫—Ü–∏–∏)
                                DATASET   = GetValue(finalOptions, "–î–∞—Ç–∞c–µ—Ç",    Text.From),   // "BKS"
                                EXTENSION = GetValue(finalOptions, "–†–∞—Å—à–∏—Ä–µ–Ω–∏–µ", Text.From),   // "xlsx"/ –°–ø–∏—Å–∫–æ–º?
                                STEP      = GetValue(finalOptions, "–ù–æ–º–µ—Ä–®–∞–≥–∞",  Number.From), // 1
                                SUBFOLDERS	= GetValue(finalOptions, "SubFolders",	Logical.From),	// –æ–±—Ä–∞–±–æ—Ç–∫–∞ –ø–æ–¥–ø–∞–ø–æ–∫
                                PATH      = GetValue(finalOptions, "–ü—É—Ç—å",       Text.From),   // "1"
                            //  –ü–ï–†–ï–ú–ï–ù–ù–´–ï –®–∞–≥ 3. –§–æ—Ä–º–∏—Ä—É–µ–º –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ —ç—Ç–æ–π —Ñ—É–Ω–∫—Ü–∏–∏
                                parameters	= 
                                    [   path =  // path –∫ –ü–ê–ü–ö–ï (–Ω–µ —Ñ–∞–π–ª—É!) —Å —Ñ–∞–π–ª–∞–º–∏ XLSX //? –¥–∞—Ç–∞—Å–µ—Ç –∏–º—è 
                                            if  PATH <> null 
                                            then    PATH
                                            else    
                                                "G:\=EXCEL BI - –º–æ–∏ –ø—Ä–æ–µ–∫—Ç—ã\2025.01 - –ë—ã—Ç–∫–æ–≤—Å–∫–∞—è\–ò—Å—Ö–æ–¥–Ω–∏–∫\–§–æ—Ä–º–∞ 11,3 (–ë–ö–°, 9 –º–µ—Å—è—Ü–µ–≤)\"
                                                // Text.BeforeDelimiter(R[func][GetParameter]("–§–æ—Ä–º–∞ 3"),"\", {0, 1}) 
                                    ],
                            
                            // 	1. –ø–æ–¥–∫–ª—é—á–∞–µ–º—Å—è –∫ –ø–∞–ø–∫–µ + —Ñ–∏–ª—å—Ç—Ä—É–µ–º –∫–æ–ª–æ–Ω–∫–∏ + –Ω–µ–º–Ω–æ–≥–æ –º–µ–Ω—è–µ–º —Ñ–æ—Ä–º–∞—Ç –∫–æ–ª–æ–Ω–æ–∫
                                from  = Folder.Files( parameters[path] ),
                                nms	  = {"Name","Extension", "Attributes", "Date created", "Content"} & {"Folder Path"},
                                sel	  = Table.SelectColumns(from, nms),
                                trans = Table.TransformColumns(sel, {
                                            {"Date created", (x)=> DateTime.Date(x), type date},
                                            {"Folder Path",  (x)=> Text.AfterDelimiter(x, "\", {2, RelativePosition.FromEnd}), type text}
                                        }),

                            // 	2. —Ñ–∏–ª—å—Ç—Ä—É–µ–º —Ñ–∞–π–ª—ã –≤ –ø–∞–ø–∫–µ //! –º–æ–≥—É—Ç –±—ã—Ç—å –æ—à–∏–±–∫–∏ –≤ —Å—Ç—Ä–æ–∫–∞—Ö - —É–±—Ä–∞—Ç—å —Å–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω–∞—è >260
                                FilteredRows 	= Table.SelectRows(trans, each 
                                    Text.AfterDelimiter([Extension], ".", {0, 1}) = EXTENSION  	// –æ—Å—Ç–∞–≤–ª—è–µ–º —Ç–æ–ª—å–∫–æ .xlsx
                                    and [Attributes][Hidden] = false 		// —É–±–∏—Ä–∞–µ–º —Å–∫—Ä—ã—Ç—ã–µ
                                    and not Text.StartsWith([Name], "~$")   // —É–±–∏—Ä–∞–µ–º –≤—Ä–µ–º–µ–Ω–Ω—ã–µ
                                ),
                            //  3. –ø—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –±–∏–Ω–∞—Ä–Ω–∏–∫–∏ –≤ —Ç–∞–±–ª–∏—Ü—ã + –≤ –ø–æ–¥—Ç–∞–±–ª–∏—Ü–∞—Ö –æ—Å—Ç–∞–≤–ª—è–µ–º —Ç–æ–ª—å–∫–æ –ª–∏—Å—Ç—ã
                                TransformBinary = Table.TransformColumns(FilteredRows,         
                                    {"Content", each let 
                                        TransBinary  = Excel.Workbook(_),
                                        NoPrintAreas = Table.SelectRows(TransBinary, each not Text.Contains([Name], "$")),
                                        OnlySheets   = Table.SelectRows(NoPrintAreas, each [Kind]="Sheet")
                                        in OnlySheets
                                    } 
                                ),
                                
                            //  4. –¥–æ–±–∞–≤–ª—è–µ–º –∫–æ–ª–æ–Ω–∫–∏ –∏ —Ñ–∏–ª—å—Ç—Ä—É–µ–º —Ç–∞–±–ª–∏—Ü—É //* R[func][fxSizeFile] –Ω–∞–¥–æ —É–±—Ä–∞—Ç—å
                                AddTwoColumns = let                      //* –∏ –∑–∞–º–µ–Ω–∏—Ç—å –Ω–∞ Record.ToList(_){3} –≤ Table.AddColumn –∏–∑ —Å–≤–æ–π—Å—Ç–≤
                                    tbl       = TransformBinary,
                                    AddSize   = Table.AddColumn(tbl, "Size", (x)=> R[func][fxSizeFile](x[Attributes][Size]), type text),
                                    AddShName = Table.AddColumn(AddSize, "SheetsName", (x)=> Text.Combine(x[Content][Name],","), type text),
                                    nms	 	  = {"Name", "Content"} & {"Folder Path"} & {"Size", "SheetsName"},
                                    SelCol	  = Table.SelectColumns(AddShName, nms)
                                in  SelCol,

                            //  5. —Ñ–∏–ª—å—Ç—Ä—É–µ–º –∫–æ–ª–æ–Ω–∫–∏
                                SelColumns = 
                                    Table.SelectColumns(AddTwoColumns, 
                                        {"Name", "Content"} & {"Folder Path"} & {"Size"}
                                    ),

                            // 	–≤–æ–∑–≤—Ä–∞—â–∞–µ–º —Ä–∞–∑–Ω—ã–µ —ç—Ç–∞–ø—ã –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ –ø–∞–ø–∫–µ
                                Return = Record.FieldOrDefault(
                                    [	1 = trans, 			 // ...
                                        2 = FilteredRows, 	 // ...
                                        3 = TransformBinary, // ...
                                        4 = AddTwoColumns,   // ...
                                        5 = SelColumns		 // ...
                                    ], 	
                                        if   STEP = null 
                                        then Text.From(5) 		// –ø–æ—Å–ª–µ–¥–Ω–∏–π —à–∞–≥
                                        else Text.From(STEP)	// –∑–∞–¥–∞–Ω–Ω—ã–π —à–∞–≥
                                    , 	
                                        "Error. –ù–µ—Ç —Ç–∞–∫–æ–≥–æ –Ω–æ–º–µ—Ä–∞ —à–∞–≥–∞ –≤ —Ñ—É–Ω–∫—Ü–∏–∏ LoadFolder")
                            ][Return],
                            
                        fnType = [ 
                                optionsType	= 
                                    type [	
                                        –î–∞—Ç–∞C–µ—Ç	    = (type nullable text meta   [Documentation.FieldCaption = "–î–∞—Ç–∞C–µ—Ç–ò–º—è",Documentation.SampleValues = {"Homel"}]),
                                        –†–∞—Å—à–∏—Ä–µ–Ω–∏–µ	= (type nullable text meta   [Documentation.FieldCaption = "–†–∞—Å—à–∏—Ä–µ–Ω–∏–µ",Documentation.SampleValues = {"xlsx"}]),
                                        –ù–æ–º–µ—Ä–®–∞–≥–∞ 	= (type number meta [Documentation.FieldCaption = "–ù–æ–º–µ—Ä–®–∞–≥–∞ (–æ—Ç 1 –¥–æ 5)",Documentation.SampleValues = {"1"}]),
                                        –ü—É—Ç—å	    = (type nullable text meta   [Documentation.FieldCaption = "–ü—É—Ç—å",Documentation.SampleValues = {"D:\"}])
                                    ],

                                optionsMeta	= 
                                    [ 	Documentation.Name = "LoadFolder",
                                        Documentation.LongDescription = "
                                            –ø–æ–¥–∫–ª—é—á–∞–µ–º—Å—è –∫ –ø–∞–ø–∫–µ, –ø–æ–ª—É—á–∞–µ–º —Å–ø–∏—Å–æ–∫ —Ñ–∞–π–ª–æ–≤ XLSX —Å –ø–æ–¥–ø–∞–ø–∫–∞–º–∏, —á–∏—Å—Ç–∏–º —Å–ø–∏—Å–æ–∫. –®–∞–≥–æ–≤ - 5. –ê—Ä–≥—É–º–µ–Ω—Ç–æ–≤ - 4
                                            ",
                                        Documentation.Examples = {
                                            [Description = "", Code = "=F_Form[LoadFolder](""Homel"")",		Result="—Å–ø–∏—Å–æ–∫ —Ñ–∞–π–ª–æ–≤ xls"], 
                                            [Description = "", Code = "=F_Form[LoadFolder](""Homel"", 3)",	Result="—Å–ø–∏—Å–æ–∫ —Ñ–∞–π–ª–æ–≤ xls –Ω–∞ —à–∞–≥–µ 3"], 
                                            [Description = "", Code = "=F_Form[LoadFolder](""Homel"", 123)",Result="—Å–æ–æ–±—â–µ–Ω–∏–µ –æ–± –æ—à–∏–±–∫–µ"]
                                        }
                                    ],

                                return 	    = type function (optional options as optionsType) as table meta optionsMeta
                            ][return],

                        result = Value.ReplaceType(func,fnType)
                    ]  [result],

                Connect_    = // #2 –ø–æ–¥–∫–ª—é—á–∞–µ–º—Å—è –∫ —Ñ–∞–π–ª–∞–º, —á–∏—Å—Ç–∏–º –≤–Ω—É—Ç—Ä—è–Ω–∫—É, –¥–æ–±–∞–≤–ª—è–µ–º 4 —Ç–µ—Ö–∫–æ–ª–æ–Ω–∫–∏

                    [	
                        func   = (optional options as record) => [ 	
                            //	0  c–ø–∏—Å–æ–∫ –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤ —Ñ—É–Ω–∫—Ü–∏–∏ //? —Å–¥–µ–ª–∞—Ç—å –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–µ –∞—Ä–≥—É–º–µ–Ω—Ç—ã + –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é, –µ—Å–ª–∏ –æ–Ω–∏ –Ω–µ –≤–≤–µ–¥–µ–Ω—ã
                                DATASET_NAME = let value = Record.FieldOrDefault(options, "–î–∞—Ç–∞C–µ—Ç–ò–º—è", null) 		in if value = null then null else Text.From(value),
                                REPORT_NAME  = let value = Record.FieldOrDefault(options, "–û—Ç—á–µ—Ç–ò–º—è", null) 		in if List.Contains({null, 0, ""}, value) then null else Text.From(value),
                                FOLDER_MASK  = let value = Record.FieldOrDefault(options, "–ú–∞—Å–∫–∞–ò–º–µ–Ω–∏–ü–∞–ø–∫–∏", null) 	in if List.Contains({null, 0, ""}, value) then null else Text.From(value),
                                SHEET_FILTER = let value = Record.FieldOrDefault(options, "boolfilterSheet", null) 	in if value = null then null else Logical.From(value),
                                STEP         = let value = Record.FieldOrDefault(options, "–ù–æ–º–µ—Ä–®–∞–≥–∞", null) 		in if List.Contains({null, 0, ""}, value) then null else Number.From(value),

                            //	#1 loadFile     –ø–æ–¥–∫–ª—é—á–∞–µ–º—Å—è –∫ –ø–∞–ø–∫–µ —Å —Ñ–∞–π–ª–∞–º–∏ //* —á–µ—Ä–µ–∑ LoadFolder_
                                loadFile = R[func][LoadFolder_]([–î–∞—Ç–∞C–µ—Ç–ò–º—è = DATASET_NAME]),
                            
                            //	#2 transform    –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º —Ñ–∞–π–ª—ã –∏ –≥–æ—Ç–æ–≤–∏–º –∏—Ö –∫ –∞–Ω–∞–ª–∏–∑—É //* DATASET_NAME 
                                // transform = Record.FieldOrDefault([ Homel = Homel ], DATASET_NAME, null),
                                transform   = 	
                                    Record.FieldOrDefault(
                                        [
                                            BKS   = BKS
                                        ],  
                                        DATASET_NAME, null),

                            //	#3 filter       —Ñ–∏–ª—å—Ç—Ä—É–µ–º —Ñ–∞–π–ª—ã –ø–æ form_ID //* REPORT_NAME = –∫–æ–ª–æ–Ω–∫–∞ [form_ID]
                                filter = [
                                    nms = {"Company","DataSet","form_ID","Date"} & {"Content"},
                                    col = Table.SelectColumns(transform, nms),
                                    row = Table.SelectRows(col, each [form_ID] = REPORT_NAME),
                                    to  = try row otherwise "–æ—Ç—á–µ—Ç–∞ """ & REPORT_NAME & """ –≤ –ø–∞–ø–∫–µ c –º–∞—Å–∫–æ–π """ & FOLDER_MASK & """ –Ω–µ—Ç"
                                ][to],
                                
                            //	#r mode         –≤—ã–≥—Ä—É–∂–∞–µ–º —Å —É—á–µ—Ç–æ–º –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ —Ñ—É–Ω–∫—Ü–∏–∏. –ò–¥–µ—Ç –ø–æ—Å–ª–µ–¥–Ω–∏–º —à–∞–≥–æ–º! 
                                mode = 
                                    if REPORT_NAME = null 		// –°–ï–¢ +, –û–¢–ß–ï–¢ -, –®–ê–ì -
                                    then transform				// —Ç–æ #2 -> –≤—ã–≤–æ–¥–∏–º –í–°–ï —Ñ–∞–π–ª—ã –ø–æ—Å–ª–µ —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏–∏ + –º–æ–∂–Ω–æ —à–∞–≥ Connect
                                    else if  STEP = null 		// –°–ï–¢ +, –û–¢–ß–ï–¢ +, –®–ê–ì -
                                        then filter				// —Ç–æ #3 -> –≤—ã–≤–æ–¥–∏–º –æ—Ç—Ñ–∏–ª—å—Ç—Ä–æ–≤–∞–Ω–Ω—ã–µ —Ñ–∞–π–ª—ã
                                        else transform,			// —Ç–æ #2 -> –≤—ã–≤–æ–¥–∏–º –í–°–ï —Ñ–∞–π–ª—ã –ø–æ—Å–ª–µ —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏–∏ + –º–æ–∂–Ω–æ —à–∞–≥ Connect
                            
                            //	1  nms          —Å–ø–∏—Å–æ–∫ –Ω–∞–∑–≤–∞–Ω–∏–π –≤—ã—Ö–æ–¥–Ω—ã—Ö —Å—Ç–æ–ª–±—Ü–æ–≤ —ç—Ç–æ–π —Ñ—É–Ω–∫—Ü–∏–∏ 
                                nms  = 	{"Company", "DataSet", "form_ID"} & 
                                        {"Date"} & 
                                        {"Content"} & 
                                        {"Folder Path"},

                            //  2  BKS          —Å–ø–∏—Å–æ–∫ –¥–∞—Ç–∞—Å–µ—Ç–æ–≤ (—Å –∏–Ω–¥–∏–≤–∏–¥—É–∞–ª—å–Ω–æ) //? —Ç—É—Ç —à–∞–≥–∏ - 5, –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –¥–∞—Ç–∞—Å–µ—Ç–∞ –º–æ–≥—É—Ç –±—ã—Ç—å —Ä–∞–∑–Ω—ã–µ
                                BKS   = [ 
                                    // 	1 –ø–æ–¥–∫–ª—é—á–∞–µ–º—Å—è –∫ –ø–∞–ø–∫–µ
                                        // loadFile = F_Form[LoadFolder]("Drog"),

                                    // 	2 —Ñ–∏–ª—å—Ç—Ä—É–µ–º —Ñ–∞–π–ª—ã –≤ –ø–∞–ø–∫–µ –ø–æ –º–∞—Å–∫–µ –∏–º–µ–Ω–∏ –ø–∞–ø–∫–∏: "" - –æ—Å—Ç–∞–≤–ª—è–µ–º –≤—Å–µ —Ñ–∞–π–ª—ã –ø–æ –≤—Å–µ—Ö –ø–æ–¥–ø–∞–ø–∫–∞—Ö
                                        selectFiles = [
                                            name = Text.Lower(FOLDER_MASK),
                                            lst  = if name = null then {""} else {name},
                                            f 	 = each List.ContainsAny( {Text.Lower([Folder Path])}, lst, Text.Contains),
                                            sel  = Table.SelectRows(loadFile, f) // —Ç–∞–±–ª–∏—Ü—É —à–∞–≥–∞ #1 —Ñ–∏–ª—å—Ç—Ä—É–µ–º –ø–æ –ü–∞–ø–∫–µ
                                        ] [sel],

                                    // 	3 —Ñ–∏–ª—å—Ç—Ä—É–µ–º –ª–∏—Å—Ç—ã –≤ –ø–æ–¥—Ç–∞–±–ª–∏—Ü–∞—Ö (–ø–µ—Ä–µ–Ω–µ—Å—Ç–∏ —à–∞–≥ –ø–æ–∑–¥–Ω–µ–µ)
                                        // todo –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é –æ—Å—Ç–∞–≤–ª—è–µ–º –ª–∏—Å—Ç—ã —Å —Ü–∏—Ñ—Ä–∞–º–∏ –≤ –Ω–∞–∑–≤–∞–Ω–∏–∏
                                        selectSheet = [
                                            fxSheetDigit = each try Value.Is(Number.From([Name]), type number) otherwise null,
                                            fxSheetTotal = each [Name] = "–°–í–û–î –í –†–ê–ó–†–ï–ó–ï",
                                            
                                            to = Table.TransformColumns(selectFiles, {"Content", (x)=> 
                                                    Table.SelectRows(x, 
                                                        if   SHEET_FILTER = null // –µ—Å–ª–∏ –æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–π –ø–∞—Ä–∞–º–µ—Ç—Ä –Ω–µ —É–∫–∞–∑–∞–Ω
                                                        then fxSheetDigit // –æ—Å—Ç–∞–≤–ª—è–µ–º –ª–∏—Å—Ç—ã —Å –Ω–æ–º–µ—Ä–∞–º–∏ –≤ –Ω–∞–∑–≤–∞–Ω–∏–∏, —ç—Ç–æ –∫–æ–¥—ã –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏–π
                                                        else fxSheetTotal // —Å–≤–æ–¥–Ω—ã–π –ª–∏—Å—Ç
                                                    )	
                                                })
                                        ] [to],

                                    // 	4 –¥–æ–±–∞–≤–ª—è–µ–º –∫–æ–ª–æ–Ω–∫–∏ —Å –¥–æ–ø–∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–µ–π
                                        addColumns =
                                            let
                                            // 	–≤—ã—Ç—è–≥–∏–≤–∞–µ–º –¥–∞—Ç—É –∏–∑ —è—á–µ–π–∫–∏ –ê1 –ø–µ—Ä–≤–æ–≥–æ –ª–∏—Å—Ç–∞ —Å –Ω–æ–º–µ—Ä–æ–º –≤ –Ω–∞–∑–≤–∞–Ω–∏–∏ –ø–µ—Ä–≤–æ–≥–æ —Ñ–∞–π–ª–∞ –æ—Ç—á–µ—Ç–∞
                                                // 	fxDate    	=(x)=> Date.From(x[Content][Data]{0}[Column1]{0}),  // –¥–∞—Ç–∞ –∏–∑ –æ—Ç—á–µ—Ç–∞
                                                    fxDate    =(x)=> 
                                                        // –∫–æ–Ω–µ—Ü –≥–æ–¥–∞, —á—Ç–æ–±—ã –≤–µ–∑–¥–µ –æ–¥–∏–Ω–∞–∫–æ–≤–æ –±—ã–ª–æ
                                                        try Date.EndOfYear(Date.From(x[Content][Data]{0}[Column1]{0}))
                                                        otherwise null, // –æ—à–∏–±–∫–∞ –µ—Å–ª–∏ –¥–∞—Ç—ã –Ω–µ—Ç –≤ –æ—Ç—á–µ—Ç–µ
                                                                                    
                                                    fxCompany =(x)=> "BKS",
                                                    fxDataSet =(x)=> 3,
                                            
                                                //	fxReport	—Ñ–æ—Ä–º–∏—Ä—É–µ–º reportName –¥–ª—è –Ω–æ–≤–æ–π –∫–æ–ª–æ–Ω–∫–∏ –ø–æ –ø–µ—Ä–≤—ã–º —Å–∏–º–≤–æ–ª–∞–º –Ω–∞–∑–≤–∞–Ω–∏—è —Ñ–∞–π–ª–∞ //! –≤–∞–∂–Ω—ã–π —à–∞–≥
                                                    fxReport  =(x)=> Record.FieldOrDefault([
                                                        02 	= "f_02",
                                                        03 	= "v_03",
                                                        11 	= "v_11"
                                                    ],  Text.Start(x[Name],2), null),

                                                //  –ø–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–µ —Ä–µ–∂–∏–º–∞ –æ—Ç–∫—É–¥–∞ –±—Ä–∞—Ç—å —Å–¥–µ–ª–∞—Ç—å –≤ —Å–∞–º–æ–π —Ñ—É–Ω–∫—Ü–∏–∏!!! –∞ –Ω–µ —á–µ—Ä–µ–∑ var –¥–∞–ª—å—à–µ
                                                    to  =
                                                       R[func][fxAddMultiColumns](selectSheet, {
                                                            { "Date",    	fxDate, 	type date},
                                                            { "DataSet", 	fxDataSet , Int64.Type},
                                                            { "Company", 	fxCompany, 	type text},
                                                            { "form_ID",  	fxReport, 	type text}
                                                        })
                                            in to,

                                    // 	5 –ø–µ—Ä–µ–≥—Ä—É–ø–ø–∏—Ä—É–µ–º –ª–∏—Å—Ç—ã –∏ —Ñ–∏–ª—å—Ç—Ä—É–µ–º –∫–æ–ª–æ–Ω–∫–∏
                                        reorder 	= Table.ReorderColumns(addColumns, nms),
                                        selectRows	= Table.SelectRows(reorder, each [form_ID] <> null),
                                        selectCol 	= Table.SelectColumns(selectRows, nms),
                                        remove  	= Table.RemoveColumns(selectCol, {"Folder Path"}), 
                                        sort	    = Table.Sort(remove, {
                                                        {"Date", 	Order.Ascending}, 
                                                        {"form_ID",	Order.Ascending}
                                                    }),
                                    
                                    //	  –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –¥–∞–Ω–Ω—ã–µ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ —à–∞–≥–∞ - max 5	
                                        return = Record.FieldOrDefault([
                                                1 = loadFile, 
                                                2 = selectFiles, 
                                                3 = selectSheet,
                                                4 = addColumns,
                                                5 = sort
                                            ], 
                                                if   STEP = null
                                                then Text.From(5) 
                                                else Text.From(STEP)
                                            ,
                                                "–Ω–µ—Ç —Ç–∞–∫–æ–≥–æ —à–∞–≥–∞")
                                    ] [return]			
                            ] [mode],

                        fnType = [ 
                                optionsType	= 
                                    type [	
                                        –î–∞—Ç–∞C–µ—Ç–ò–º—è 		= (type nullable text meta [
                                            Documentation.FieldCaption 	= "–î–∞—Ç–∞C–µ—Ç–ò–º—è (–ò–º—è –¥–∞—Ç–∞—Å–µ—Ç–∞)", 
                                            Documentation.SampleValues 	= {"""Homel+"""},
                                            Documentation.Description 	= "–ò–º—è –Ω–∞–±–æ—Ä–∞ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏"
                                            ]),
                                        –û—Ç—á–µ—Ç–ò–º—è 		= (type nullable text meta [
                                            Documentation.FieldCaption = "–û—Ç—á–µ—Ç–ò–º—è (ID –æ—Ç—á–µ—Ç–∞)", 	 
                                            Documentation.SampleValues = {"""bal"""},
                                            Documentation.Description = "–ò–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä –æ—Ç—á–µ—Ç–∞"
                                            ]),
                                        –ú–∞—Å–∫–∞–ò–º–µ–Ω–∏–ü–∞–ø–∫–∏ = (type nullable text meta [
                                            Documentation.FieldCaption = "–ú–∞—Å–∫–∞–ò–º–µ–Ω–∏–ü–∞–ø–∫–∏ (–ú–∞—Å–∫–∞ –∏–º–µ–Ω–∏ –ø–∞–ø–∫–∏)", 
                                            Documentation.SampleValues = {"""—Å—Ç–∞—Ç"""},
                                            Documentation.Description = "–ú–∞—Å–∫–∞ –¥–ª—è –∏–º–µ–Ω–∏ –ø–∞–ø–∫–∏"
                                            ]),
                                        boolfilterSheet = (type nullable logical meta [
                                            Documentation.FieldCaption = "boolfilterSheet (–§–∏–ª—å—Ç—Ä –ª–∏—Å—Ç–æ–≤)", 
                                            Documentation.SampleValues = {true},
                                            Documentation.Description = "–ü—Ä–∏–º–µ–Ω–∏—Ç—å –ª–∏ —Ñ–∏–ª—å—Ç—Ä –∫ –ª–∏—Å—Ç–∞–º"
                                            ]),
                                        –ù–æ–º–µ—Ä–®–∞–≥–∞ 		= (type nullable number meta [
                                            Documentation.FieldCaption = "–ù–æ–º–µ—Ä–®–∞–≥–∞ (–ù–æ–º–µ—Ä —à–∞–≥–∞ –∑–∞–ø—Ä–æ—Å–∞: Homel 1-5)", 
                                            Documentation.SampleValues = {"1"},
                                            Documentation.Description = "–ù–æ–º–µ—Ä —à–∞–≥–∞ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –∑–∞–ø—Ä–æ—Å–∞"
                                            ])
                                    ],

                                optionsMeta	= 
                                    [ 	
                                        Documentation.Name = "Connect",
                                        Documentation.LongDescription = 
                                            "	<b>–ü–æ–¥–∫–ª—é—á–∞–µ–º—Å—è –∫ —Ñ–∞–π–ª–∞–º, —á–∏—Å—Ç–∏–º –≤–Ω—É—Ç—Ä—è–Ω–∫—É, –¥–æ–±–∞–≤–ª—è–µ–º 4 —Ç–µ—Ö–∫–æ–ª–æ–Ω–∫–∏ </b> <br>
                                                = F[Connect]( [–î–∞—Ç–∞C–µ—Ç–ò–º—è = ""Homel""] ) <br>
                                                = F[Connect]( [–î–∞—Ç–∞C–µ—Ç–ò–º—è = ""Homel"", –û—Ç—á–µ—Ç–ò–º—è = ""opu""] ) <br>
                                                = F[Connect]( [–î–∞—Ç–∞C–µ—Ç–ò–º—è = ""Homel"", –û—Ç—á–µ—Ç–ò–º—è = ""opu"", –ù–æ–º–µ—Ä–®–∞–≥–∞ = 1]) <br>
                                                = F[Connect]( [–î–∞—Ç–∞C–µ—Ç–ò–º—è = ""Homel"", –û—Ç—á–µ—Ç–ò–º—è = null,    –ù–æ–º–µ—Ä–®–∞–≥–∞ = null, –ú–∞—Å–∫–∞–ò–º–µ–Ω–∏–ü–∞–ø–∫–∏ = ""–±—É—Ö"", boolfilterSheet = null)]
                                            ",
                                        Documentation.Examples = 
                                            {
                                                [
                                                    Description = "", 
                                                    Code 		= "=F_Form[Connect](""Homel"")()",
                                                    Result		= "–≤—Å–µ –æ–±—Ä–∞–±–æ—Ç–∞–Ω–Ω—ã–µ —Ñ–∞–π–ª—ã –≤ –ø–∞–ø–∫–µ"
                                                ], 
                                                [	Description = "", 
                                                    Code 		= "=F_Form[Connect](""Homel"",""bal"")()",
                                                    Result		= "–≤—Å–µ –æ—Ç—á–µ—Ç—ã —Å ID = bal –≤ –ø–∞–ø–∫–µ"
                                                ], 
                                                [	Description = "", 
                                                    Code 		= "=F_Form[Connect](""Homel"",""null"",""—Å—Ç–∞—Ç"")",
                                                    Result		= "–≤—Å–µ –æ–±—Ä–∞–±–æ—Ç–∞–Ω–Ω—ã–µ —Ñ–∞–π–ª—ã –≤ –ø–∞–ø–∫–µ + –º–∞—Å–∫–∞ –∏–º–µ–Ω–∏ –ø–æ–¥–ø–∞–ø–∫–∏"
                                                ], 
                                                [	Description = "", 
                                                    Code 		= "=F_Form[Connect](""Homel"")(1)",
                                                    Result		= "–≤—Å–µ –æ—Ç—á–µ—Ç—ã –≤ –ø–∞–ø–∫–µ –ø–æ—Å–ª–µ –æ–±—â–µ–π —á–∏—Å—Ç–∫–∏, —à–∞–≥ 1 (–º–∞–∫—Å 5)"
                                                ]
                                            }       
                                    ],

                                return 	    = type function (optional options as optionsType) as table meta optionsMeta // –º–æ–∂–Ω–æ –±–µ–∑ "meta optionsMeta"
                            ]  [return],
                        
                        result = Value.ReplaceType(func, fnType)
                    ]  [result],
                        
     
            //	–†–ê–ë–û–¢–ê –° XLSX –∏ CSV 
                LoadFolder = // #1 –ø–æ–¥–∫–ª—é—á–∞–µ–º—Å—è –∫ –ø–∞–ø–∫–µ, –ø–æ–ª—É—á–∞–µ–º —Å–ø–∏—Å–æ–∫ —Ñ–∞–π–ª–æ–≤ XLSX —Å –ø–æ–¥–ø–∞–ø–∫–∞–º–∏, —á–∏—Å—Ç–∏–º  (–§–û–†–ú–ò–†–£–ï–ú –ò–°–¢–û–ß–ù–ò–ö  )
                    /* 
                        –û–ø–∏—Å–∞–Ω–∏–µ:
                            0. "Homel" - —ç—Ç–æ –∑–Ω–∞—á–µ–Ω–∏–µ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ –î–∞—Ç–∞C–µ—Ç–ò–º—è (DataSetName –≤ param)
                            1. –ø–æ–¥–∫–ª—é—á–∞–µ–º—Å—è –∫ –ø–∞–ø–∫–µ —Å —Ñ–∞–π–ª–∞–º–∏ –ø–æ –∏–º–µ–Ω–∏ –¥–∞—Ç–∞—Å–µ—Ç–∞ –∏–ª–∏ –ø–æ –ø–æ–ª–Ω–æ–º—É –ø—É—Ç–∏
                            2. –≤—ã–±–∏—Ä–∞–µ–º –Ω–æ–º–µ—Ä —à–∞–≥–∞ –∑–∞–≥—Ä—É–∑–∫–∏. –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é –≤—ã–≥—Ä—É–∂–∞–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–π —à–∞–≥
                            3. —á–∏—Å—Ç–∏–º –ø–∞–ø–∫—É –æ—Ç –≤—Ä–µ–º–µ–Ω–Ω—ã—Ö –∏ —Å–∫—Ä—ã—Ç—ã—Ö —Ñ–∞–π–ª–æ–≤, –æ—Å—Ç–∞–≤–ª—è–µ–º —Ñ–∞–π–ª—ã .xlsx –∏–ª–∏ .csv, –ø—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –±–∏–Ω–∞—Ä–Ω–∏–∫–∏
                            4. –≤ –∫–Ω–∏–≥–∞—Ö excel –æ—Å—Ç–∞–≤–ª—è–µ–º —Ç–æ–ª—å–∫–æ –ª–∏—Å—Ç—ã (Sheet), –≤ csv –ø–æ—Å–ª–µ —Å–∫—Ä–∏–ø—Ç–∞ –ø–æ—Ç–æ–Ω–∞ –æ–¥–∏–Ω –ª–∏—Å—Ç –±–µ—Ä–µ—Ç—Å—è, –ø–µ—Ä–≤—ã–π –≤–∏–¥–∏–º—ã–π
                        
                        –ü—Ä–∏–º–µ—Ä:	
                            = R[func][LoadFolder] ([–î–∞—Ç–∞C–µ—Ç–ò–º—è = "Homel", –¢–∏–ø–§–∞–π–ª–∞ = "csv", –ù–æ–º–µ—Ä–®–∞–≥–∞ = 7])
                            –í–∞—Ä–∏–∞–Ω—Ç—ã:
                                ([–î–∞—Ç–∞C–µ—Ç–ò–º—è = "Homel"])					// –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç—Å—è –ø–æ—Å–ª–µ–¥–Ω–∏–π —à–∞–≥ –æ—à–∏–±–∫–∞ –µ—â–µ –∏–∑ –∑–∞ –¢–∏–ø–§–∞–π–ª–∞
                                ([–î–∞—Ç–∞C–µ—Ç–ò–º—è = "Homel", –ù–æ–º–µ—Ä–®–∞–≥–∞ = null])	// –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç—Å—è –ø–æ—Å–ª–µ–¥–Ω–∏–π —à–∞–≥
                                ([–î–∞—Ç–∞C–µ—Ç–ò–º—è = "Homel", –ù–æ–º–µ—Ä–®–∞–≥–∞ = 3])		// –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç—Å—è —Ç—Ä–µ—Ç–∏–π —à–∞–≥
                                ([–î–∞—Ç–∞C–µ—Ç–ò–º—è = "Homel", –ù–æ–º–µ—Ä–®–∞–≥–∞ = 123])	// –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç—Å—è –Ω–∞–¥–ø–∏—Å—å –æ–± –æ—à–∏–±–∫–µ
                        
                        –£–ª—É—á—à–µ–Ω–∏—è:
                            1. –ï—Å–ª–∏ –¥–∞—Ç–∞—Å–µ—Ç –Ω–µ –≤—ã–±—Ä–∞–Ω, —Ç–æ –º–µ–Ω—è–µ–º –Ω–∞–ø—Ä–∏–º–µ—Ä –Ω–∞ Homel 
                            2. –°–¥–µ–ª–∞—Ç—å –º–∞–∫–µ—Ç—ã —Ç–∞–±–ª–∏—Ü –≤—Å–µ—Ö –æ—Ç—á–µ—Ç–æ–≤ –¥–ª—è –∑–∞–º–µ–Ω—ã, –µ—Å–ª–∏ –Ω–∏—á–µ–≥–æ –Ω–µ—Ç –∏–ª–∏ –Ω–µ –≤—ã–±—Ä–∞–Ω–æ.
                            3. –ú–∞–∫–µ—Ç—ã —Ç–∞–±–ª–∏—Ü —Å –¥–∞–Ω–Ω—ã–º–∏ –ø–æ –£—Å–ª–æ–≤–Ω–æ–π –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏–∏. –ï–µ –Ω–∞–¥–æ —Å–æ–∑–¥–∞—Ç—å
                            4. –≠—Ç–æ –º–æ–≥—É—Ç –±—ã—Ç—å –¥–∞–Ω–Ω—ã–µ –∏–∑ –æ–¥–Ω–æ–≥–æ —Ñ–∞–π–ª–∞ XlSX —Å –¥–∞–Ω–Ω—ã–º–∏ –≤—Å–µ—Ö –æ—Ç—á–µ—Ç–æ–≤
                            5. –î–∞–Ω–Ω—ã–µ —Ä–∞–∑–Ω—ã—Ö –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏–π –º–æ–∂–Ω–æ —Å–æ–≤–º–µ—Å—Ç–∏—Ç—å, —á—Ç–æ–±—ã –∑–∞–ø–æ–ª–Ω–∏—Ç—å –±–∞–∑—É –∏ –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏–∏
                        */
                    [
                        func   = (optional options as record) => [ 	
                            //	0. —Ñ–æ—Ä–º–∏—Ä—É–µ–º —Å–ø–∏—Å–æ–∫ –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤ //? –î–∞—Ç–∞C–µ—Ç–ò–º—è - –∏–º—è –¥–∞—Ç–∞—Å–µ—Ç–∞ –∏–∑ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤!
                                GetValue  = // —Ñ—É–Ω–∫—Ü–∏—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è —Ç–∏–ø–∞ –æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω—ã—Ö –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤
                                    (options as record, fieldName as text, typeConverter as function) =>
                                        let value  = Record.FieldOrDefault(options, fieldName, null),
                                            result = if List.Contains({null, 0, ""}, value) then null else typeConverter(value)
                                        in  result,

                                DataSetName = GetValue(options, "–î–∞—Ç–∞C–µ—Ç–ò–º—è", Text.From),
                                FileType    = GetValue(options, "–¢–∏–ø–§–∞–π–ª–∞", Text.From),
                                STEP     	= GetValue(options, "–ù–æ–º–µ—Ä–®–∞–≥–∞", Number.From),

                            //	1. path				—Ñ–æ—Ä–º–∏—Ä—É–µ–º path –∫ –ø–∞–ø–∫–µ —Å —Ñ–∞–π–ª–∞–º–∏ XLSX –∏–ª–∏ CSV (–∏–∑ —É—á–µ–±–Ω—ã–µ –ø–ª–∞–Ω—ã –≤–∑—è—Ç—å —Å–ø–æ—Å–æ–± —É–∫–∞–∑–∞–Ω–∏—è –ø—É—Ç–µ–π, —Å —Ç–∞–±–ª–∏—Ü–µ–π)
                                path = 
                                        if FileType = "csv"  then Value.Metadata(param) [BKS] [pathCSV]
                                    else if FileType = "xlsx" then Value.Metadata(param) [BKS] [pathXLSX]
                                    else Value.Metadata(param) [BKS] [pathXLSX],

                                pathFolder =  "G:\=EXCEL BI - –º–æ–∏ –ø—Ä–æ–µ–∫—Ç—ã\2025.01 - –ë—ã—Ç–∫–æ–≤—Å–∫–∞—è\–ò—Å—Ö–æ–¥–Ω–∏–∫\–§–æ—Ä–º–∞ 11,3 (–ë–ö–°, 9 –º–µ—Å—è—Ü–µ–≤)",
                                    // Record.FieldOrDefault(
                                    // 		path, // [ Homel = path ], 
                                    // 		DataSetName, 
                                    // 		if  Text.Contains(DataSetName,"\")	  	  // –µ—Å–ª–∏ –∏–º—è —Å–æ–¥–µ—Ä–∂–∏—Ç "\" (–∫–∞–∫ —á–∞—Å—Ç—å –ø—É—Ç–∏ –∫ –ø–∞–ø–∫–µ) —á—Ç–æ —Ç–æ –Ω–µ —Ç–æ
                                    // 			then DataSetName					  // —Ç–æ —ç—Ç–æ –ø—É—Ç—å –∫ –ø–∞–ø–∫–µ (–¥–ª—è –¥–∞—Ç–∞—Å–µ—Ç–æ–≤ –Ω–µ –∏–∑ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤)
                                    // 			else "Error. –û—à–∏–±–∫–∞ –≤ –∏–º–µ–Ω–∏ –¥–∞—Ç–∞—Å–µ—Ç–∞" // —Ç–æ –æ—à–∏–±–∫–∞ 	
                                    // 	),
                            
                            // 	2. from				–ø–æ–¥–∫–ª—é—á–∞–µ–º—Å—è –∫ –ø–∞–ø–∫–µ 
                                from  = Folder.Files(pathFolder),
                            
                            //  3. Trans			—Ñ–∏–ª—å—Ç—Ä—É–µ–º –∫–æ–ª–æ–Ω–∫–∏: –º–µ–Ω—è–µ–º —Ñ–æ—Ä–º–∞—Ç –∫–æ–ª–æ–Ω–æ–∫ 
                                nms	  = {"Name","Extension", "Attributes", "Date created", "Content"} & {"Folder Path"},
                                Sel	  = Table.SelectColumns(from, nms),
                                Trans = Table.TransformColumns(Sel, {
                                            {"Date created", (x)=> DateTime.Date(x), type date},
                                            {"Folder Path",  (x)=> Text.AfterDelimiter(x, "\", {2, RelativePosition.FromEnd}), type text}
                                        }),

                            // 	4. FilteredRows		—Ñ–∏–ª—å—Ç—Ä—É–µ–º —Å—Ç—Ä–æ–∫–∏ : –æ—Å—Ç–∞–≤–ª—è–µ–º —Ñ–∞–π–ª—ã –Ω—É–∂–Ω–æ–≥–æ —Ñ–æ—Ä–º–∞—Ç–∞, —É–±–∏—Ä–∞–µ–º —Å–∫—Ä—ã—Ç—ã–µ –∏ –≤—Ä–µ–º–µ–Ω–Ω—ã–µ —Ñ–∞–π–ª—ã
                                FilteredRows 	= Table.SelectRows(Trans, each 
                                        Text.AfterDelimiter([Extension], ".") = FileType // –æ—Å—Ç–∞–≤–ª—è–µ–º —Ç–æ–ª—å–∫–æ .xlsx
                                        and [Attributes][Hidden] = false 				 // —É–±–∏—Ä–∞–µ–º —Å–∫—Ä—ã—Ç—ã–µ
                                        and not Text.StartsWith([Name], "~$")			 // —É–±–∏—Ä–∞–µ–º –≤—Ä–µ–º–µ–Ω–Ω—ã–µ
                                ),

                            //  5. TransformBinary	–ø—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –±–∏–Ω–∞—Ä–Ω–∏–∫–∏ –≤ —Ç–∞–±–ª–∏—Ü—ã, —Ñ–∏–ª—å—Ç—Ä—É–µ–º —Å—Ç—Ä–æ–∫–∏ –≤ –ø–æ–¥—Ç–∞–±–ª–∏—Ü–∞—Ö, –æ—Å—Ç–∞–≤–ª—è–µ–º –æ–¥–∏–Ω –ª–∏—Å—Ç
                                TransformBinary = [
                                    //  fXLS    –ø–æ–¥–ª—é—á–∞–µ–º—Å—è –∫ –ø–∞–ø–∫–µ (–æ—Å—Ç–∞–≤–ª—è–µ–º XLS, —Ñ–∏–ª—å—Ç—Ä—É–µ–º, –æ—Å—Ç–∞–≤–ª—è–µ–º —Ç–æ–ª—å–∫–æ –ª–∏—Å—Ç—ã, –æ—Å—Ç–∞–≤–ª—è–µ–º –ª–∏—Å—Ç –≤ –∫–æ—Ç–æ—Ä–æ–º –æ—Ç—á–µ—Ç)
                                        fXLS = 	[ files  = 	
                                                    Table.TransformColumns(FilteredRows, {"Content", (x)=> 
                                                                let Binary 	= 	Excel.Workbook(x),
                                                                    Select	= 	Table.SelectRows(Binary,  each 
                                                                                    not Text.Contains([Name], "$")	// –Ω–µ—Ç –¥–∏–∞–ø–∞–∑–æ–Ω—ã
                                                                                    and [Kind]="Sheet"				// —Ç–æ–ª—å–∫–æ –ª–∏—Å—Ç—ã
                                                                                    and Text.Length([Name]) = 15	// –≤ –∏–º–µ–Ω–∏ 15 –∑–Ω–∞–∫–æ–≤ = –∫–æ–¥ –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏–∏
                                                                                )
                                                                in	Select 	// [Data]{0} –æ—Å—Ç–∞–≤–ª—è–µ–º –ø–µ—Ä–≤—ã–π –ª–∏—Å—Ç
                                                            })
                                                ][files],
                                    
                                    //  fCSV    –∑–∞–≥—Ä—É–∑–∫–∞ —Ñ–∞–π–ª–æ–≤ –∏–∑ –ø–∞–ø–∫–∏ —Å CSV —Ñ–∞–π–ª–∞–º–∏ (–ø–∞—Ä–∞–º–µ—Ç—Ä Columns=... –ø—Ä–æ–ø—É—Å–∫–∞—é? —Å–µ–ø–µ—Ä–∞—Ç–æ—Ä ",")
                                        fCSV =  [ files	= 	Table.TransformColumns(FilteredRows, 
                                                                {"Content", each Csv.Document(_, [Delimiter=";", Encoding=65001, QuoteStyle=QuoteStyle.Csv]), type table}
                                                            )
                                                ][files],

                                    //  return  –≤–æ–∑–≤—Ä–∞—â–∞–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç –æ–±—Ä–∞–±–æ—Ç–∫–∏
                                        return = Record.FieldOrDefault([
                                                    xlsx = fXLS, 
                                                    csv  = fCSV
                                                ], Text.From(FileType), "Error")
                                ][return],
                                
                            // 	6. AddTwoColumns	–¥–æ–±–∞–≤–ª—è–µ–º –∫–æ–ª–æ–Ω–∫–∏ –∏ —Ñ–∏–ª—å—Ç—Ä—É–µ–º —Ç–∞–±–ª–∏—Ü—É
                                AddTwoColumns = let 
                                    AddSize   = Table.AddColumn(TransformBinary, "Size", (x)=> R[func][fxSizeFile] (x[Attributes][Size]), type text),
                                    AddShName = Table.AddColumn(AddSize, "SheetsName",   (x)=> try Text.Combine(x[Content][Name],",") otherwise null, type text),
                                    SelCol	  = Table.SelectColumns(AddShName, {"Name", "Content"} & {"Size"} & {"Folder Path","SheetsName"})
                                in  SelCol,

                            // 	7. ExpandColumn		—Ä–∞–∑–≤–æ—Ä–∞—á–∏–≤–∞–µ–º –ª–∏—Å—Ç—ã –≤ –ø–æ–¥—Ç–∞–±–ª–∏—Ü–∞—Ö (xlsx) –∏–ª–∏ –æ—Å—Ç–∞–≤–ª—è–µ–º –∫–∞–∫ –µ—Å—Ç—å (csv)
                                ExpandColumn  =	
                                        if FileType = "xlsx" then Table.ExpandTableColumn(AddTwoColumns, "Content", {"Data"}) // –ø–µ—Ä–µ–∏–º–µ–Ω–æ–≤–∞–ª—Å–∞—Å—å –∫–æ–ª–æ–Ω–∫–∞ –≤ Data
                                    else if FileType = "csv"  then Table.RenameColumns(AddTwoColumns, {"Content", "Data"})
                                    else "–Ω–µ—Ç —Ç–∞–∫–æ–≥–æ —Ç–∏–ø–∞ —Ñ–∞–π–ª–∞",
                                SelColumns 	  = Table.SelectColumns(ExpandColumn, {"Folder Path", "Name", "Data"}),

                            // 	–≤–æ–∑–≤—Ä–∞—â–∞–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã —à–∞–≥–æ–≤ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ –ø–∞–ø–∫–µ
                                Return = Record.FieldOrDefault(
                                    [	1 = pathFolder, 	
                                        2 = from, 			
                                        3 = Trans, 			
                                        4 = FilteredRows, 	
                                        5 = TransformBinary,
                                        6 = AddTwoColumns,	
                                        7 = SelColumns
                                    ], 	
                                        if   STEP = null 
                                        then Text.From(7) 		// –ø–æ—Å–ª–µ–¥–Ω–∏–π —à–∞–≥
                                        else Text.From(STEP)	// –∑–∞–¥–∞–Ω–Ω—ã–π —à–∞–≥
                                    , 	
                                        "Error. –ù–µ—Ç —Ç–∞–∫–æ–≥–æ –Ω–æ–º–µ—Ä–∞ —à–∞–≥–∞ –≤ —Ñ—É–Ω–∫—Ü–∏–∏ LoadFolder")
                            ][Return],
                            
                        fnType = [ 
                                optionsType	= 
                                    type [	
                                        –î–∞—Ç–∞C–µ—Ç		= (type nullable text meta [Documentation.FieldCaption = "–î–∞—Ç–∞C–µ—Ç–ò–º—è",Documentation.SampleValues = {"Homel"}]),
                                        –¢–∏–ø–§–∞–π–ª–∞	= (type nullable text meta [Documentation.FieldCaption = "–¢–∏–ø–§–∞–π–ª–∞",Documentation.SampleValues = {"csv"}]),
                                        –ù–æ–º–µ—Ä–®–∞–≥–∞	= (type nullable number meta [Documentation.FieldCaption = "–ù–æ–º–µ—Ä–®–∞–≥–∞ (–æ—Ç 1 –¥–æ 9)",Documentation.SampleValues = {"1"}])
                                    ],

                                optionsMeta	= 
                                    [ 	Documentation.Name = "LoadFolder",
                                        Documentation.LongDescription = "–ø–æ–¥–∫–ª—é—á–∞–µ–º—Å—è –∫ –ø–∞–ø–∫–µ, –ø–æ–ª—É—á–∞–µ–º —Å–ø–∏—Å–æ–∫ —Ñ–∞–π–ª–æ–≤ XLSX —Å –ø–æ–¥–ø–∞–ø–∫–∞–º–∏, —á–∏—Å—Ç–∏–º —Å–ø–∏—Å–æ–∫",
                                        Documentation.Examples = {
                                            [Description = "", Code = "=F_Form[LoadFolder](""Homel"")",Result="—Å–ø–∏—Å–æ–∫ —Ñ–∞–π–ª–æ–≤ xls"], 
                                            [Description = "", Code = "=F_Form[LoadFolder](""Homel"", 3)",Result="—Å–ø–∏—Å–æ–∫ —Ñ–∞–π–ª–æ–≤ xls –Ω–∞ —à–∞–≥–µ 3"], 
                                            [Description = "", Code = "=F_Form[LoadFolder](""Homel"", 123)",Result="—Å–æ–æ–±—â–µ–Ω–∏–µ –æ–± –æ—à–∏–±–∫–µ"]
                                        }
                                    ],

                                return 	    = type function (optional options as optionsType) as table meta optionsMeta
                            ][return],

                        result = Value.ReplaceType(func,fnType)
                    ]  [result],

                Connect    = // #2 –ø–æ–¥–∫–ª—é—á–∞–µ–º—Å—è –∫ —Ñ–∞–π–ª–∞–º, —á–∏—Å—Ç–∏–º –≤–Ω—É—Ç—Ä—è–Ω–∫—É, –¥–æ–±–∞–≤–ª—è–µ–º 4 —Ç–µ—Ö–∫–æ–ª–æ–Ω–∫–∏
                    // = Connect( [–î–∞—Ç–∞C–µ—Ç–ò–º—è = "Homel", –û—Ç—á–µ—Ç–ò–º—è = null, –ú–∞—Å–∫–∞–ò–º–µ–Ω–∏–ü–∞–ø–∫–∏ = "—Å—Ç–∞—Ç", –ù–æ–º–µ—Ä–®–∞–≥–∞ = null, boolfilterSheet = null])
                    // = Connect( [–î–∞—Ç–∞C–µ—Ç–ò–º—è = "Homel", –û—Ç—á–µ—Ç–ò–º—è = "opu", –ù–æ–º–µ—Ä–®–∞–≥–∞ = null])
                    [	
                        func   = (optional options as record) => [ 	
                                //	0  —Ñ–æ—Ä–º–∏—Ä—É–µ–º c–ø–∏—Å–æ–∫ –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤ 
                                    DATASET_NAME = let value = Record.FieldOrDefault(options, "–î–∞—Ç–∞C–µ—Ç–ò–º—è", null) 		in if value = null then null else Text.From(value),
                                    REPORT_NAME  = let value = Record.FieldOrDefault(options, "–û—Ç—á–µ—Ç–ò–º—è", null) 		in if List.Contains({null, 0, ""}, value) then null else Text.From(value),
                                    FOLDER_MASK  = let value = Record.FieldOrDefault(options, "–ú–∞—Å–∫–∞–ò–º–µ–Ω–∏–ü–∞–ø–∫–∏", null) 	in if List.Contains({null, 0, ""}, value) then null else Text.From(value),
                                    SHEET_FILTER = let value = Record.FieldOrDefault(options, "boolfilterSheet", null) 	in if value = null then null else Logical.From(value),
                                    STEP         = let value = Record.FieldOrDefault(options, "–ù–æ–º–µ—Ä–®–∞–≥–∞", null) 		in if value = null then null else Number.From(value),

                                //	#1 –ø–æ–¥–∫–ª—é—á–∞–µ–º—Å—è –∫ –ø–∞–ø–∫–µ —Å —Ñ–∞–π–ª–∞–º–∏ 
                                    loadFile = LoadFolder([–î–∞—Ç–∞C–µ—Ç–ò–º—è = DATASET_NAME]),
                                
                                //	#2 –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º —Ñ–∞–π–ª—ã –∏ –≥–æ—Ç–æ–≤–∏–º –∏—Ö –∫ –∞–Ω–∞–ª–∏–∑—É 
                                    transform = Record.FieldOrDefault([ Homel = Homel ], DATASET_NAME, null),

                                //	#3 —Ñ–∏–ª—å—Ç—Ä—É–µ–º —Ñ–∞–π–ª—ã
                                    filter = [
                                        nms = {"Company","DataSet","form_ID","Date"} & {"Content"},
                                        col = Table.SelectColumns(transform, nms),
                                        row = Table.SelectRows(col, each [form_ID] = REPORT_NAME),
                                        to  = try row otherwise "–æ—Ç—á–µ—Ç–∞ """ & REPORT_NAME & """ –≤ –ø–∞–ø–∫–µ c –º–∞—Å–∫–æ–π """ & FOLDER_MASK & """ –Ω–µ—Ç"
                                    ][to],
                                    
                                //	#r –≤—ã–≥—Ä—É–∂–∞–µ–º —Å —É—á–µ—Ç–æ–º –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ —Ñ—É–Ω–∫—Ü–∏–∏. –ò–¥–µ—Ç –ø–æ—Å–ª–µ–¥–Ω–∏–º —à–∞–≥–æ–º! 
                                    mode = 
                                        if REPORT_NAME = null 		// –°–ï–¢ +, –û–¢–ß–ï–¢ -, –®–ê–ì -
                                        then transform				// —Ç–æ #2 -> –≤—ã–≤–æ–¥–∏–º –í–°–ï —Ñ–∞–π–ª—ã –ø–æ—Å–ª–µ —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏–∏ + –º–æ–∂–Ω–æ —à–∞–≥ Connect
                                        else if  STEP = null 		// –°–ï–¢ +, –û–¢–ß–ï–¢ +, –®–ê–ì -
                                            then filter				// —Ç–æ #3 -> –≤—ã–≤–æ–¥–∏–º –æ—Ç—Ñ–∏–ª—å—Ç—Ä–æ–≤–∞–Ω–Ω—ã–µ —Ñ–∞–π–ª—ã
                                            else transform,			// —Ç–æ #2 -> –≤—ã–≤–æ–¥–∏–º –í–°–ï —Ñ–∞–π–ª—ã –ø–æ—Å–ª–µ —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏–∏ + –º–æ–∂–Ω–æ —à–∞–≥ Connect
                                
                                //	1  —Å–ø–∏—Å–æ–∫ –Ω–∞–∑–≤–∞–Ω–∏–π –≤—ã—Ö–æ–¥–Ω—ã—Ö —Å—Ç–æ–ª–±—Ü–æ–≤ —ç—Ç–æ–π —Ñ—É–Ω–∫—Ü–∏–∏ 
                                    nms  = 	{"Company", "DataSet", "form_ID"} & {"Date"} & {"Content"} & {"Folder Path"},

                                //  2  —Å–ø–∏—Å–æ–∫ –¥–∞—Ç–∞—Å–µ—Ç–æ–≤ (—Å –∫–∞–∂–¥—ã–º —Ä–∞–±–æ—Ç–∞—Ç—å –∏–Ω–¥–∏–≤–∏–¥—É–∞–ª—å–Ω–æ)
                                    Homel = [ 
                                        // 	1 –ø–æ–ª—É—á–∞–µ–º —Å–ø–∏—Å–æ–∫ —Ñ–∞–π–ª–æ–≤ –≤ –ø–∞–ø–∫–µ —Å —É—á–µ—Ç–æ–º –≤—Å–µ—Ö –≤–ª–æ–∂–µ–Ω–Ω–æ—Å—Ç–µ–π
                                            // loadFile = F_Form[LoadFolder]("Homel", null),
                                        
                                        // 	2 —Ñ–∏–ª—å—Ç—Ä—É–µ–º —Ñ–∞–π–ª—ã –≤ –ø–æ–¥—Ç–∞–±–ª–∏—Ü–∞—Ö
                                            selectFiles = [
                                                lst = if   Text.Lower(FOLDER_MASK) = null
                                                    then {""}
                                                    else {FOLDER_MASK},
                                                f = each List.ContainsAny( { Text.Lower([Folder Path]) }, lst, Text.Contains),
                                                sel = Table.SelectRows(loadFile, f)
                                            ] [sel],

                                        // 	3 —Ñ–∏–ª—å—Ç—Ä—É–µ–º –ª–∏—Å—Ç—ã –≤ –ø–æ–¥—Ç–∞–±–ª–∏—Ü–∞—Ö
                                            // –∞ –µ—Å–ª–∏ –Ω–µ—Å–∫–æ–ª—å–∫–æ –ª–∏—Å—Ç–æ–≤ –ø–æ–ø–∞–¥–∞–µ—Ç –≤ —Ç–∞–∫—É—é –≤—ã–±–æ—Ä–∫—É?!
                                            selectSheet =
                                                Table.TransformColumns(selectFiles,{"Content", (x)=>
                                                    let sheet = Table.SelectRows(x, each Text.Length([Name]) = 15) 	// –æ—Å—Ç–∞–≤–ª—è–µ–º –ª–∏—Å—Ç—ã —Å –¥–ª–∏–Ω–æ–π –Ω–∞–∑–≤–∞–Ω–∏—è = 15 –∑–Ω–∞–∫–æ–≤ - –∫–æ–¥ –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏–∏
                                                    in	sheet{0}[Data] 												// –¥–∞–Ω–Ω—ã–µ –ø–µ—Ä–≤–æ–≥–æ –ª–∏—Å—Ç–∞, //! –ù–æ... –º–æ–∂–µ—Ç –±—ã—Ç—å –Ω–µ—Å–∫–æ–ª—å–∫–æ –ª–∏—Å—Ç–æ–≤!
                                                }),

                                        // 	4 –¥–æ–±–∞–≤–ª—è–µ–º –∫–æ–ª–æ–Ω–∫–∏ —Å –¥–æ–ø–∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–µ–π –æ —Ñ–∞–π–ª–µ/–æ—Ç—á–µ—Ç–µ. –ò—Å—Ç–æ—á–Ω–∏–∫ - –¥–∞–Ω–Ω—ã–µ –∏–∑ —Ñ–∞–π–ª–∞
                                            // 	–≤ .xls –¥–∞—Ç–∞ = 01.16, –≤ .xlsx = 01.12.2016 => –≤–æ–∑–Ω–∏–∫–∞–µ—Ç –æ—à–∏–±–∫–∞ => –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –µ–µ —á–µ—Ä–µ–∑ try/otherwise
                                            addColumns =
                                                let
                                                    fxDate =(x)=> // —è—á–µ–π–∫–∞ [A1] - –¥–∞—Ç–∞ –æ—Ç—á–µ—Ç–∞
                                                        try 	  Date.From("01.01.20" & Text.End(x[Content][Column1]{0},2))  // –µ—Å–ª–∏ xls  => 2 end –∑–Ω–∞–∫–∞ –∑–∞—á–µ–Ω–∏—è –≤ —è—á–µ–π–∫–µ —Å –¥–∞—Ç–æ–π (–≤ .xls –¥–∞—Ç–∞ = 01.16)
                                                        otherwise Date.From(x[Content][Column1]{0} + #duration(30, 0, 0, 0)), // –µ—Å–ª–∏ xlsx => + 30 –¥–Ω–µ–π (–≤ .xlsx = 01.12.2016 => –≤–æ–∑–Ω–∏–∫–∞–µ—Ç –æ—à–∏–±–∫–∞ => –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –µ–µ —á–µ—Ä–µ–∑ try/otherwise)
                                                    fxCompany =(x)=> "Homel", 	//Text.From (x[Content][Column1]{2}), // —è—á–µ–π–∫–∞ [A1] - –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏—è - –ì–û–ú–ï–õ–¨–°–ö–û–ï –†–ê–ô–ü–û / –ì–û–ú–ï–õ–¨–°–ö–ò–ô –§–ò–õ–ò–ê–õ
                                                    fxDataSet =(x)=> 2, 		// —è—á–µ–π–∫–∞ [A1] - –∫–æ–¥ –ø—Ä–µ–¥–ø—Ä–∏—è—Ç–∏—è - —Ç—É—Ç –Ω–µ –Ω–∞–¥–æ - Text.From (x[Content][Column1]{1})
                                                    fxReport  =(x)=> Text.Start(x[Content][Column2]{0}, 4), // 4 –ø–µ—Ä–≤—ã–µ –∑–Ω–∞–∫–∞ = –∫–æ–¥ –æ—Ç—á–µ—Ç–∞, –Ω–∞–ø—Ä–∏–º–µ—Ä "0112"
                                                    
                                                    var = false, // true - –±–µ—Ä–µ–º –¥–∞–Ω–Ω—ã–µ —Å –ª–∏—Å—Ç–∞, false - —Ä—É–∫–∞–º–∏ –∑–∞–ø–æ–ª–Ω—è–µ–º
                                                    
                                                    // –ø–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–µ —Ä–µ–∂–∏–º–∞ –æ—Ç–∫—É–¥–∞ –±—Ä–∞—Ç—å —Å–¥–µ–ª–∞—Ç—å –≤ —Å–∞–º–æ–π —Ñ—É–Ω–∫—Ü–∏–∏!!! –∞ –Ω–µ —á–µ—Ä–µ–∑ var –¥–∞–ª—å—à–µ
                                                    to  =
                                                        fxAddMultiColumns(selectSheet,
                                                            {
                                                                { "Date",    	if var then fxDate 	  else fxDate, 			type date},
                                                                { "DataSet", 	if var then fxDataSet else each 2, 			Int64.Type},
                                                                { "Company", 	fxCompany, 	type text},
                                                                { "form_ID",  	if var then fxReport  else fxReport, 		type text}
                                                            }
                                                        )
                                                in to,

                                        // 	5 –º–µ–Ω—è–µ–º –∫–æ–¥ –æ—Ç—á–µ—Ç–∞ –ø–æ –Ω–æ—Ä–º–∞–º –ë–ö–° –Ω–∞ –∫–æ–¥ –æ—Ç—á–µ—Ç–∞ –∏–∑ –º–æ–µ–≥–æ —Å–ø—Ä–∞–≤–æ—á–Ω–∏–∫–∞ —Ñ–æ—Ä–º –æ—Ç—á–µ—Ç–Ω–æ—Å—Ç–∏
                                            //	–≤—ã–±–∏—Ä–∞–µ–º –∏–∑ —Å–ø—Ä–∞–≤–æ—á–Ω–∏–∫–∞ –Ω—É–∂–Ω–æ–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –ï–°–õ–ò –§–ê–ô–õ–û–í –ú–ù–û–ì–û (–∏–ª–∏ –±–µ—Ä–µ–º —Å –ª–∏—Å—Ç–∞, –µ—Å–ª–∏ –æ—Ç—á–µ—Ç –æ–¥–∏–Ω –∏–ª–∏ —Ä—É–∫–∞–º–∏ —Å—Ç–∞–≤–∏–º)
                                            transform = [
                                                f=(txt)=> // –∑–Ω–∞—á–µ–Ω–∏—è –∫–æ–ª–æ–Ω–∫–∏ 1 —Å–ª–æ–≤–∞—Ä—è, –∑–∞–º–µ–Ω—è—é –Ω–∞ –∫–æ–ª–æ–Ω–∫—É 0
                                                    let dict = Table.ToRows(spr[spr.ALL][–°–ø—Ä_–§–æ—Ä–º—ã–û—Ç—á–µ—Ç–Ω–æ—Å—Ç–∏]), // —Å–ø–∏—Å–æ–∫ —Å–ø–∏—Å–∫–æ–≤
                                                        to   = List.First(List.Select(dict, (col)=>col{1}=txt)){0}
                                                    in 	to,
                                                to = Table.TransformColumns(addColumns, {"form_ID", f, type text})
                                            ][to],

                                        // 	6 –ø–µ—Ä–µ–≥—Ä—É–ø–ø–∏—Ä—É–µ–º –ª–∏—Å—Ç—ã –∏ —Ñ–∏–ª—å—Ç—Ä—É–µ–º –∫–æ–ª–æ–Ω–∫–∏
                                            reorder	= Table.ReorderColumns(transform, nms),
                                            select  = Table.SelectColumns(reorder, nms),
                                            remove  = Table.RemoveColumns(select, {"Folder Path"}), 
                                            sort	= Table.Sort(remove, {{"form_ID", Order.Ascending}, {"Date", Order.Ascending}} ),

                                        //	  –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –¥–∞–Ω–Ω—ã–µ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ —à–∞–≥–∞	
                                            Return = Record.FieldOrDefault([
                                                    1 = loadFile, 
                                                    2 = selectFiles, 
                                                    3 = selectSheet,
                                                    4 = addColumns,
                                                    5 = sort
                                                ], 
                                                    if   STEP = null
                                                    then Text.From(5) 
                                                    else Text.From(STEP)
                                                ,
                                                    "–Ω–µ—Ç —Ç–∞–∫–æ–≥–æ —à–∞–≥–∞")
                                        ] [Return]					
                            ] [mode],

                        // –≤–∞—Ä–∏–∞–Ω—Ç 1 —Å –æ—Ç–¥–µ–ª—å–Ω—ã–º —à–∞–≥–æ–º type
                        optionsType1 = 
                            type [
                                –î–∞—Ç–∞C–µ—Ç–ò–º—è 		= (type nullable text meta [
                                    Documentation.FieldCaption = "–ò–º—è –¥–∞—Ç–∞—Å–µ—Ç–∞", 
                                    Documentation.SampleValues = {"""Homel"""},
                                    Documentation.Description = "–ò–º—è –Ω–∞–±–æ—Ä–∞ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏"
                                    ]),
                                –û—Ç—á–µ—Ç–ò–º—è 		= (type nullable text meta [
                                    Documentation.FieldCaption = "ID –æ—Ç—á–µ—Ç–∞", 
                                    Documentation.SampleValues = {"""bal"""},
                                    Documentation.Description = "–ò–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä –æ—Ç—á–µ—Ç–∞"
                                    ]),
                                –ú–∞—Å–∫–∞–ò–º–µ–Ω–∏–ü–∞–ø–∫–∏ = (type nullable text meta [
                                    Documentation.FieldCaption = "–ú–∞—Å–∫–∞ –∏–º–µ–Ω–∏ –ø–∞–ø–∫–∏", 
                                    Documentation.SampleValues = {"""—Å—Ç–∞—Ç"""},
                                    Documentation.Description = "–ú–∞—Å–∫–∞ –¥–ª—è –∏–º–µ–Ω–∏ –ø–∞–ø–∫–∏"
                                    ]),
                                boolfilterSheet = (type nullable logical meta [
                                    Documentation.FieldCaption = "–§–∏–ª—å—Ç—Ä –ª–∏—Å—Ç–æ–≤", 
                                    Documentation.SampleValues = {true},
                                    Documentation.Description = "–ü—Ä–∏–º–µ–Ω–∏—Ç—å –ª–∏ —Ñ–∏–ª—å—Ç—Ä –∫ –ª–∏—Å—Ç–∞–º"
                                    ])
                            ],
                        result1 = Value.ReplaceType(func, type function (optional options as optionsType1) as table),
                        // –≤–∞—Ä–∏–∞–Ω—Ç 2 —Ä–∞–±–æ—á–∏–π
                        fnType2 = 	type function (
                                        optional options as (
                                            type 
                                            [
                                                –î–∞—Ç–∞C–µ—Ç–ò–º—è 		= (type nullable text meta [Documentation.FieldCaption = "–î–∞—Ç–∞C–µ—Ç–ò–º—è (–ò–º—è –¥–∞—Ç–∞—Å–µ—Ç–∞)", Documentation.SampleValues = {"""Homel+"""}]),
                                                –û—Ç—á–µ—Ç–ò–º—è 		= (type nullable text meta [Documentation.FieldCaption = "–û—Ç—á–µ—Ç–ò–º—è (ID –æ—Ç—á–µ—Ç–∞)", 	 Documentation.SampleValues = {"""bal"""}]),
                                                –ú–∞—Å–∫–∞–ò–º–µ–Ω–∏–ü–∞–ø–∫–∏ = (type nullable text meta [Documentation.FieldCaption = "–ú–∞—Å–∫–∞–ò–º–µ–Ω–∏–ü–∞–ø–∫–∏ (–ú–∞—Å–∫–∞ –∏–º–µ–Ω–∏ –ø–∞–ø–∫–∏)", Documentation.SampleValues = {"""—Å—Ç–∞—Ç"""}]),
                                                boolfilterSheet = (type nullable logical meta [Documentation.FieldCaption = "boolfilterSheet (–§–∏–ª—å—Ç—Ä –ª–∏—Å—Ç–æ–≤)", Documentation.SampleValues = {true}]),
                                                –ù–æ–º–µ—Ä–®–∞–≥–∞ 		= (type nullable logical meta [Documentation.FieldCaption = "–ù–æ–º–µ—Ä–®–∞–≥–∞ (–ù–æ–º–µ—Ä —à–∞–≥–∞ –∑–∞–ø—Ä–æ—Å–∞: Homel 1-5)", Documentation.SampleValues = {"1"}])
                                            ]
                                        )
                                    ) as table 
                                        meta [ 	Documentation.Name = "Connect",
                                            Documentation.LongDescription = 
                                            " <b>–ü–æ–¥–∫–ª—é—á–∞–µ–º—Å—è –∫ —Ñ–∞–π–ª–∞–º, —á–∏—Å—Ç–∏–º –≤–Ω—É—Ç—Ä—è–Ω–∫—É, –¥–æ–±–∞–≤–ª—è–µ–º 4 —Ç–µ—Ö–∫–æ–ª–æ–Ω–∫–∏ </b> <br>
                                                = F[Connect]( [–î–∞—Ç–∞C–µ—Ç–ò–º—è = ""Homel""] ) <br>
                                                = F[Connect]( [–î–∞—Ç–∞C–µ—Ç–ò–º—è = ""Homel"", –û—Ç—á–µ—Ç–ò–º—è = ""opu""] ) <br>
                                                = F[Connect]( [–î–∞—Ç–∞C–µ—Ç–ò–º—è = ""Homel"", –û—Ç—á–µ—Ç–ò–º—è = ""opu"", –ù–æ–º–µ—Ä–®–∞–≥–∞ = 1]) <br>
                                                = F_Form[Connect](""Homel"")()			- –≤—Å–µ —Ñ–∞–π–ª—ã –≤ –ø–∞–ø–∫–µ	–ø–æ—Å–ª–µ –æ–±—â–µ–π —á–∏—Å—Ç–∫–∏ <br> 
                                                = F_Form[Connect](""Homel"")(1)			- –≤—Å–µ —Ñ–∞–π–ª—ã –≤ –ø–∞–ø–∫–µ –ø–æ—Å–ª–µ –æ–±—â–µ–π —á–∏—Å—Ç–∫–∏, —à–∞–≥ 1 –∏–∑ 5 <br>
                                                = F_Form[Connect](""Homel"",""bal"")()	- –≤—Å–µ –æ—Ç—á–µ—Ç—ã –¥–∞–Ω–Ω–æ–≥–æ –≤–∏–¥–∞ –≤ –ø–∞–ø–∫–µ	<br>
                                                = F_Form[Connect](""Homel"", null)(1)	- —Ç–æ –∂–µ, –∞–Ω–∞–ª–æ–≥ F_Form[LoadFolder](""Homel"") <br>
                                                = F_Form[Connect](""Homel"",""bal"")(1)	- —Ç–æ –∂–µ <br>
                                                = F_Form[Connect](""Homel"", null, ""—Å—Ç–∞—Ç"")() - –≤—Å–µ –æ–±—Ä–∞–±–æ—Ç–∞–Ω–Ω—ã–µ —Ñ–∞–π–ª—ã –≤ –ø–∞–ø–∫–µ + –º–∞—Å–∫–∞ –∏–º–µ–Ω–∏ –ø–æ–¥–ø–∞–ø–∫–∏ <br>
                                            "
                                            // , Documentation.Examples = 
                                            // {
                                            // 	[Description = "", Code = "=F_Form[Connect](""Homel"")()",Result="–≤—Å–µ –æ–±—Ä–∞–±–æ—Ç–∞–Ω–Ω—ã–µ —Ñ–∞–π–ª—ã –≤ –ø–∞–ø–∫–µ"], 
                                            // 	[Description = "", Code = "=F_Form[Connect](""Homel"",""bal"")()",Result="–≤—Å–µ –æ—Ç—á–µ—Ç—ã —Å ID = bal –≤ –ø–∞–ø–∫–µ"], 
                                            // 	[Description = "", Code = "=F_Form[Connect](""Homel"",""null"",""—Å—Ç–∞—Ç"")",Result="–≤—Å–µ –æ–±—Ä–∞–±–æ—Ç–∞–Ω–Ω—ã–µ —Ñ–∞–π–ª—ã –≤ –ø–∞–ø–∫–µ + –º–∞—Å–∫–∞ –∏–º–µ–Ω–∏ –ø–æ–¥–ø–∞–ø–∫–∏"], 
                                            // 	[Description = "", Code = "=F_Form[Connect](""Homel"")(1)",Result="–≤—Å–µ –æ—Ç—á–µ—Ç—ã –≤ –ø–∞–ø–∫–µ –ø–æ—Å–ª–µ –æ–±—â–µ–π —á–∏—Å—Ç–∫–∏, —à–∞–≥ 1 (–º–∞–∫—Å 5)"]
                                            // }       
                                            ],
                        result2 = 	Value.ReplaceType(func, fnType2)
                    ][result2],

			//	—Å—Ç–∞—Ä—ã–µ ------------------------------------------------------------------------------
			    SelectRow  = // #3 —Ñ–∏–ª—å—Ç—Ä—É–µ–º —Å—Ç—Ä–æ–∫–∏ –≤ –ø–æ–¥—Ç–∞–±–ª–∏—Ü–∞—Ö –ø–æ "–°—Ç–∞—Ç—å—è_ID" –Ω–∞ —à–∞–≥–µ Load (–¥–ª—è –æ—Ç—á–µ—Ç–æ–≤ –∫–æ—Ç–æ—Ä—ã–µ –∏–º–µ—é—Ç –Ω–æ–º–µ—Ä —Å—Ç—Ä–æ–∫–∏) . –ù–∞–¥–æ –¥–æ–∫—É–º–µ–Ω—Ç–∏—Ä–æ–≤–∞—Ç—å —Ñ—É–Ω–∫—Ü–∏—é 
				/* 
					–û–ø–∏—Å–∞–Ω–∏–µ:
						–§—É–Ω–∫—Ü–∏—è –¥–æ–±–∞–≤–ª—è–µ—Ç –∫–æ–ª–æ–Ω–∫—É —Å –æ—Ç—Ñ–∏–ª—å—Ç—Ä–æ–≤–∞–Ω–Ω—ã–º–∏ –ø–æ–¥—Ç–∞–±–ª–∏—Ü–∞–º–∏
					–ü—Ä–∏–º–µ—Ä:
						= 	F_Form[form.SelectRowsID](
								STEP1_Connect,
								{"Column1","Column2","Column3","Column4"},
								{"–°—Ç–∞—Ç—å—è", "–°—Ç—Ä–æ–∫–∞_ID", "–ù–∞ –Ω–∞—á–∞–ª–æ", "–ù–∞ –∫–æ–Ω–µ—Ü"},
								"–°—Ç—Ä–æ–∫–∞_ID",
								10,
								1000
							)
					–£–ª—É—á—à–µ–Ω–∏–µ:
						—Å–¥–µ–ª–∞—Ç—å –ø—Ä–æ–≤–µ—Ä–∫—É —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏—è –¥–ª–∏–Ω —Å–ø–∏—Å–∫–æ–≤ nmsOld –∏ nmsNew
				*/
				[
					func   = (options as record) as table => [ 	
						// 1 —Ñ–æ—Ä–º–∏—Ä—É–µ–º —Å–ø–∏—Å–æ–∫ –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤ 
							tbl  	 = let value = Record.FieldOrDefault(options, "tbl", null)     in if value is table then value else null,
							nmsOld	 = let value = Record.FieldOrDefault(options, "nmsOld", null)  in if value is list then value else {} ,
							nmsNew	 = let value = Record.FieldOrDefault(options, "nmsNew", null)  in if value is list then value else {} ,
							colName  = let value = Record.FieldOrDefault(options, "colName", null) in if List.Contains({null, 0, ""}, value) then null else Text.From(value),
							kodStart = let value = Record.FieldOrDefault(options, "kodStart", null)  in if List.Contains({null, 0, ""}, value) then null else Number.From(value),
							kodEnd	 = let value = Record.FieldOrDefault(options, "kodEnd", null)    in if List.Contains({null, 0, ""}, value) then null else Number.From(value),
					
						// 2 –¥–æ–±–∞–≤–ª—è–µ–º –Ω–æ–≤—É—é –∫–æ–ª–æ–Ω–∫—É –≤ —Ç–∞–±–ª–∏—Ü—É —Å –ø–æ–¥—Ç–∞–±–ª–∏—Ü–∞–º–∏, –≤ –∫–æ—Ç–æ—Ä–æ–π –±—É–¥—É—Ç –æ—Ç—Ñ–∏–ª—å—Ç—Ä–æ–≤–∞–Ω—ã–µ —Å—Ç—Ä–æ–∫–∏ –æ—Ç—á–µ—Ç–∞
							from =	Table.AddColumn(tbl, "Step2", (x)=> [
								//	–ø—Ä–æ–≤–µ—Ä—è—é –Ω–∞–ª–∏—á–∏–µ –∫–æ–ª–æ–Ω–∫–∏. –í –æ–¥–Ω–∏—Ö –æ—Ç—á–µ—Ç–∞—Ö –ø–æ–¥—Ç–∞–±–ª–∏—Ü—ã –≤ "Content", –≤ –¥—Ä—É–≥–∏—Ö, –∫–∞–∫ –≤ –ë–ö–° "Data" –ø–æ—Å–ª–µ —Ä–∞–∑–≤–æ—Ä–æ—Ç–∞ –ª–∏—Å—Ç–æ–≤ —Å –ø—Ä–µ–¥–ø—Ä–∏—è—Ç–∏—è–º–∏
									//!  —Å–¥–µ–ª–∞—Ç—å –≤–∞—Ä–∏–∞–Ω—Ç, –µ—Å–ª–∏ –≥—Ä—É–∑–∏—Ç—å –Ω–∞–¥–æ —Å –ª–∏—Å—Ç–∞ –æ–¥–∏–Ω –æ—Ç—á–µ—Ç, —Ç–∞–º –Ω–µ—Ç –∫–æ–ª–æ–Ω–∫–∏ –¥–∞—Ç–∞ –∏ –∫–æ–Ω—Ç–µ–Ω—Ç
									selCol  = 	if   Table.HasColumns(tbl, "Content")
												then Table.SelectColumns(x[Content], nmsOld)
												else Table.SelectColumns(x[Data], nmsOld),

									rename  = Table.RenameColumns(selCol, List.Zip({nmsOld, nmsNew} )),
									clear   = Table.ClearAll(rename," #(lf)#(00A0)", false, false),

								//	–¥–µ–ª–∞–µ–º –∫–æ–ª–æ–Ω–∫—É —á–∏—Å–ª–æ–≤–æ–π, –µ—Å–ª–∏ —Ç–∞–º –Ω–µ —á–∏—Å–ª–æ –∏ –≤–æ–∑–Ω–∏–∫–∞–µ—Ç –æ—à–∏–±–∫–∞ —Ç–æ –º–µ–Ω—è–µ–º –Ω–∞ null
									tr      = Table.TransformColumns(clear, {colName, try Number.From otherwise null, type number}),

								// 	—É–¥–∞–ª—è–µ–º errors, –∫–æ—Ç–æ—Ä—ã–π –∏–Ω–æ–≥–¥–∞ –ø–æ—è–≤–ª—è–µ—Ç—Å—è, –∫–æ–≥–¥–∞ —Ç–∞–º —Ç–µ–∫—Å—Ç –∏–ª–∏ –µ—â–µ —á–µ–≥–æ
									err     = Table.RemoveRowsWithErrors(tr, {colName}),
									lst     = {null, kodStart, kodEnd},
									f=(x)=> x>=lst{1} and x<=lst{2},

								//	–æ—Å—Ç–∞–≤–ª—è–µ–º —Å—Ç—Ä–æ–∫–∏ –≤ –¥–∏–∞–ø–∞–∑–æ–Ω–µ –Ω–æ–º–µ—Ä–æ–≤ –≤ –∫–æ–ª–æ–Ω–∫–µ "–°—Ç–∞—Ç—å—è_ID"
									selRow  = Table.SelectRows(err, (row)=> f(Record.Field(row, colName) ) )
								]  [selRow]),

						// 3 —É–¥–∞–ª—è–µ–º –∏–ª–∏ —Ç—É –∏–ª–∏ —Ç—É –∫–æ–ª–æ–Ω–∫—É, –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –Ω–∞–ª–∏—á–∏—è –∏—Ö –Ω–∞ –≤—Ö–æ–¥–µ
							to	= Table.RemoveColumns(from, {"Content","Data"}, MissingField.Ignore)
						][to],
					fnType = [ 
							optionsType	= 
								type [	
									tbl	     = (type table meta [Documentation.FieldCaption = "tbl (—Ç–∞–±–ª–∏—Ü–∞), table",Documentation.SampleValues = {"Source"}]),
									nmsOld 	 = (type list meta [ // –µ—Å–ª–∏ type list, —Ç–æ –º–æ–∂–Ω–æ –¥–µ—Ç –≤—ã–±—Ä–∞—Ç—å –∏–∑ —Å–ø–∏—Å–∫–∞ –∏ –ø–æ—Å—Ç–∞–≤–∏—Ç—å –≥–∞–ª–æ—á–∫–∏
													Documentation.FieldCaption 		= "nmsOld (—Å–ø–∏—Å–æ–∫ —Å—Ç–∞—Ä—ã—Ö –∏–º–µ–Ω –∫–æ–ª–æ–Ω–æ–∫)",
													Documentation.FieldDescription 	= "–í—ã–±–µ—Ä–∏—Ç–µ –¥–æ–ø—É—Å—Ç–∏–º—ã–µ –ø–æ–ª—è ", // –∫–∞–∫ –º–æ–∂–Ω–æ —É–≤–∏–¥–µ—Ç—å —ç—Ç–æ—Ç —Ç–µ–∫—Å—Ç?
													Documentation.SampleValues 		= {"{""Column1"",""Column2""}"},
													Documentation.AllowedValues 	= {10,110} // –∫–∞–∫ —Å–¥–µ–ª–∞—Ç—å –ø—Ä–∏ —ç—Ç–æ–º –ø—Ä–æ–∏–∑–≤–æ–ª–ª—å–Ω—ã–π –≤–≤–æ–¥?
												]),
									nmsNew 	 = (type any meta [Documentation.FieldCaption = "nmsNew (—Å–ø–∏—Å–æ–∫ –Ω–æ–≤—ã—Ö –∏–º–µ–Ω –∫–æ–ª–æ–Ω–æ–∫)",Documentation.SampleValues = {"{""Column1"",""Column2""}"}]),
									colName	 = (type nullable text meta [Documentation.FieldCaption = "colName (–∏–º—è –∫–æ–ª–æ–Ω–∫–∏)",Documentation.SampleValues = {"""Column1"""}]),
									kodStart = (type nullable number meta [Documentation.FieldCaption = "kodStart (–Ω–∞—á–∞–ª—å–Ω–∞—è —Å—Ç—Ä–æ–∫–∞)",Documentation.SampleValues = {10}]),
									kodEnd 	 = (type nullable number meta [Documentation.FieldCaption = "kodEnd (–∫–æ–Ω–µ—á–Ω–∞—è —Å—Ç—Ä–æ–∫–∞)",Documentation.SampleValues = {1000}])
								],

							optionsMeta	= 
								[ 	Documentation.Name = "SelectRow",
									Documentation.LongDescription = "...",
									Documentation.Examples = {
										[Description = "", Code = "=...",Result="..."], 
										[Description = "", Code = "=...",Result="..."]
									}
								],

							return 	    = type function (options as optionsType) as table meta optionsMeta
						][return],

					result = Value.ReplaceType(func,fnType)
				]  
					[result],
	

                //  –Ω–∞–¥–æ —Ç–∞–∫: 	1 LoadFolder - –ø–æ–¥–∫–ª—é—á–∞–µ–º—Å—è –∫ –ø–∞–ø–∫–µ –∏ —á–∏—Å—Ç–∏–º —Ç–æ–ª—å–∫–æ —Ñ–∞–π–ª—ã –∏ –≤—Å–µ, —á—Ç–æ —Å –Ω–∏–º–∏ —Å–≤—è–∑–∞–Ω–æ!!!
                // 				2 Connect	 - —á–∏—Å—Ç–∏–º —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ —Ñ–∞–π–ª–æ–≤ (–Ω–æ –∏–Ω–æ–≥–¥–∞ –∏—Ö —Ñ–∞–π–ª–æ–≤ –Ω–∞–¥–æ –≤—ã—Ç—è–≥–∏–≤–∞—Ç—å –∏–Ω—Ñ—É –¥–ª—è —Ç–∞–±–ª–∏—Ü—ã...)



//  –ò—Ç–æ–≥–æ–≤–∞—è —Å—É–º–º–∞ –ø–æ —Å—Ç–æ–ª–±—Ü–∞–º, TotalSum üî•
    // —Å–∞–º–∞—è –ø—Ä–æ—Å—Ç–∞—è + –ú–æ–∂–Ω–æ —á–µ—Ä–µ–∑ List.Select –≤—ã–±–∏—Ä–∞—Ç—å –∏–∑ —Å–ø–∏—Å–∫–∞ —Ä–∞–∑–Ω—ã–µ —Å—Ç—Ä–æ–∫–∏
    fxTotal1 = each List.Sum(List.Skip(Record.ToList(_))),
    
    // –≤–∞—Ä–∏–∞–Ω—Ç 2, —Ç–∞–∫–æ–π –∂–µ, —Ç–∞–∫–∂–µ –º–æ–∂–Ω–æ —á–µ—Ä–µ–∑ List.Select –≤—ã–±–∏—Ä–∞—Ç—å –æ—Ç–¥–µ–ª—å–Ω—ã–µ —Å—Ç–æ–ª–±—Ü—ã –ø–æ –∏–º–µ–Ω–∞–º –ø–æ–ª–µ–π
    fxTotal2 = each List.Sum(Record.ToList(Record.SelectFields(_, List.RemoveFirstN(Table.ColumnNames(from), 1)))),

//  –û—Ç–∫–ª—é—á–µ–Ω–∏–µ –≤ —Å–≤–æ–π—Å–∫–∞—Ö Excel –∞–≤—Ç–æ—à–∏—Ä–∏–Ω–∞ —Å—Ç–æ–ª–±—Ü–∞
    Sub dis_autocolumn()
        Dim wsh As Worksheet
        Dim lobj As ListObject
        For Each wsh In ThisWorkbook.Worksheets
            For Each lobj In wsh.ListObjects
            If lobj.SourceType = xlSrcQuery Then lobj.QueryTable.AdjustColumnWidth = False
            Next lobj
        Next wsh
        MsgBox "–ê–≤—Ç–æ—à–∏—Ä–∏–Ω–∞ –æ—Ç–∫–ª—é—á–µ–Ω–∞."
    End Sub

//	–†–∞–Ω–≥ üìå
	Provide the argument as record: [ RankKind = RankKind.Ordinal ]
		RankKind.Competition
		RankKind.Dense
		RankKind.Ordinal
	https://powerquery.how/table-addrankcolumn/

	Table.AddRankColumn(
		<table>,
		<new column name>,
		<comparison criteria>,
		[<options>}
	)
	
	= Table.AddRankColumn(from,"Rank",{"Sales"})

	Table.AddRankColumn( 
		Source,
		"Revenue Asc",
		{ "Revenue", Order.Ascending },   // Sort column in Ascending order
		[ RankKind = RankKind.Competition ]
	)
	
	Table.AddRankColumn( 
		Source,
		"Revenue Asc",
		{ { "Revenue", Order.Descending }, {"CustomerID", Order.Ascending } },
		[ RankKind = RankKind.Competition ]
	)

//  –õ–æ–∫–∞–ª—å–Ω–∞—è –≥—Ä—É–ø–ø–∏—Ä–æ–≤–∫–∞ GroupKind.Local. –ü—Ä–æ–¥–≤–∏–Ω—É—Ç—ã–π –≤–∞—Ä–∏–∞–Ω—Ç –æ—Ç –ú–∏—Ö–∞–∏–ª–∞ –≤ "Power Query Ru"
    /*
        –ü–æ–º–æ–≥–∏—Ç–µ-–ø–æ–¥—Å–∫–∞–∂–∏—Ç–µ, —á–µ–º –º–æ–∂–µ—Ç–µ.
        –û–≥—Ä–æ–º–Ω–∞—è —Ç–∞–±–ª–∏—Ü–∞, –≤ –∫–æ—Ç–æ—Ä–æ–π –≤ —Å—Ç–æ–ª–±—Ü–µ "–í—Ä–µ–º—è" –µ—Å—Ç—å –∑–Ω–∞—á–µ–Ω–∏—è –∏ –µ—Å—Ç—å null—ã. –ù—É–∂–Ω–æ –¥–∞–Ω–Ω—ã–µ –∏–∑ —Å—Ç–æ–ª–±—Ü–∞ "–ö–∞—Ç–µ–≥–æ—Ä–∏—è" —Å–æ–±—Ä–∞—Ç—å –≤ 2 —Å—Ç–æ–ª–±—Ü–∞:
        1. –µ—Å–ª–∏ –≤–æ "–í—Ä–µ–º—è" –Ω–µ –ø—É—Å—Ç–æ, —Ç–æ –ø–∏—à–µ–º –≤ "–ö–∞—Ç–µ–≥–æ—Ä–∏—è";
        2. –µ—Å–ª–∏ –≤–æ "–í—Ä–µ–º—è" –ø—É—Å—Ç–æ, —Ç–æ –≤—Å—ë, —á—Ç–æ –¥–æ —Å–ª–µ–¥—É—é—â–µ–≥–æ –Ω–µ–ø—É—Å—Ç–æ–≥–æ, —Å–æ–±–∏—Ä–∞–µ–º –≤ —Å—Ç–æ–ª–±–µ—Ü "–ù–∞–∑–≤–∞–Ω–∏–µ".
        –ü—Ä–æ–±–ª–µ–º–∞ —É –º–µ–Ω—è –≤ —Ç–æ–º, —á—Ç–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –Ω–µ–ø—É—Å—Ç—ã—Ö —è—á–µ–µ–∫ –º–æ–∂–µ—Ç –±—ã—Ç—å —Ä–∞–∑–ª–∏—á–Ω—ã–º: –º–æ–∂–µ—Ç –±—ã—Ç—å 0, 1, 2, 3...
        –ï—Å–ª–∏ –Ω–∏ –æ–¥–Ω–æ–π –ø—É—Å—Ç–æ–π —è—á–µ–π–∫–∏ –ø–æ—Å–ª–µ "–í—Ä–µ–º—è", —Ç–æ –≤ "–ù–∞–∑–≤–∞–Ω–∏–µ" –Ω–∏—á–µ–≥–æ –Ω–µ –∏–¥—ë—Ç.
        –†–µ—à–∞–µ–º–æ?
    */
    
    //  –í–∞—Ä–∏–∞–Ω—Ç 4, –∏—Ç–æ–≥–æ–≤—ã–π
        let
            from = Excel.CurrentWorkbook(){[Name="–ò—Å—Ö–æ–¥–Ω–∏–∫"]}[Content],
            nms  = Table.ColumnNames(from),
            f=(x)=>(y)=>  Text.Combine(List.Skip(Table.Column(y,x))," "),
            g=(x)=>(y,z)=>Number.From(Record.Field(z,x)<>null),
            to = Table.Group( from, nms, {"–ù–∞–∑–≤–∞–Ω–∏–µ", f("–ö–∞—Ç–µ–≥–æ—Ä–∏—è")}, GroupKind.Local, g("–°—É–º–º–∞") )
        in
            to

    // –ò—Å—Ç–æ—Ä–∏—è —Ä–∞–±–æ—Ç—ã –º—ã—Å–ª–∏
        //  –í–∞—Ä–∏–∞–Ω—Ç 3
            let from =  Excel.CurrentWorkbook(){[Name="–ò—Å—Ö–æ–¥–Ω–∏–∫"]}[Content],
                to   =  Table.Group(from,    
                            Table.ColumnNames(from),
                            {"–ù–∞–∑–≤–∞–Ω–∏–µ",(x)=>Text.Combine(List.Skip(x[–ö–∞—Ç–µ–≥–æ—Ä–∏—è])," ")},
                            GroupKind.Local,
                            (s,c)=>Number.From(c[–°—É–º–º–∞]<>null)
                        )
            in  to
        
        //  –í–∞—Ä–∏–∞–Ω—Ç 2
            let from =  Excel.CurrentWorkbook(){[Name="–ò—Å—Ö–æ–¥–Ω–∏–∫"]}[Content],
                nms  =  Table.ColumnNames(from),
                nm   =  "–ö–∞—Ç–µ–≥–æ—Ä–∏—è",
                to   =  Table.Group(from,
                            List.RemoveItems(nms,{nm}),
                            {nm,(x)=>Text.Combine(List.Skip(Table.Column(x,nm))," ")},
                            GroupKind.Local,
                            (s,c)=>Number.From(c[–°—É–º–º–∞]<>null)
                        )
            in  to
        //  –í–∞—Ä–∏–∞–Ω—Ç 2
            to =    Table.Group(from, 
                        {"–î–∞—Ç–∞", "–í—Ä–µ–º—è"}, 
                        {
                            {"–ö–∞—Ç–µ–≥–æ—Ä–∏—è",   each [–ö–∞—Ç–µ–≥–æ—Ä–∏—è]{0}},
                            {"–ù–∞–∑–≤–∞–Ω–∏–µ",    each Text.Combine(List.Skip([–ö–∞—Ç–µ–≥–æ—Ä–∏—è])," ")},
                            {"–°—É–º–º–∞",       each [–°—É–º–º–∞]{0}}},
                            GroupKind.Local,
                            (x,y)=>Number.From(y[–í—Ä–µ–º—è]<>null)
                        )


//  —Ä–∞–∑–¥–µ–ª–∏—Ç—å —Å–ª–∏–ø—à–∏–π—Å—è —Ç–µ–∫—Å—Ç –ø–æ –±–æ–ª—å—à–∏–º –±—É–∫–≤–∞–º (–Ω–∞–ø—Ä–∏–º–µ—Ä –∏–º–µ–Ω–∞  –∫–æ–ª–æ–Ω–æ–∫) MonthNameShort -> –≤ Month Name Short
    Table.TransformColumnNames(CreateTable, each [
            SplitTextByTransition = Splitter.SplitTextByCharacterTransition({"a".."z"}, {"A".."Z"})(_), 
            CombineValues         = Text.Combine( SplitTextByTransition, " " ), 
            RemoveUnderscores     = Text.Replace( CombineValues, "_", " ") 
        ][RemoveUnderscores] 
    )

//  –ù–∞—Ä–∞—Å—Ç–∞—é—â–∏–π –∏—Ç–æ–≥
    // –Ω–∞ –≤—Ö–æ–¥–µ —Ç–∞–±–ª–∏—Ü–∞ Month+Sales
        =   Table.FromRecords(
                List.Accumulate(
                    Table.ToRecords(Source), 
                    [List = {}, RT = 0], 
                    (state, current) =>
                        [   
                            List = state[List] & {current & [Running Total = RT]}, 
                            RT = state[RT] + current[Sales]
                        ]
                )[List], 
                Value.Type(
                    Source & #table( type table [Running Total=number], {} )
                )
            )
//  —Ä–∞–∑–±–æ—Ä —Å—Ç—Ä–æ–∫–∏ –Ω–∞ —á–∏—Å–ª–∞ –∏ —Ç–µ–∫—Å—Ç –≤ –æ—Ç–¥–µ–ª—å–Ω—ã–µ –∫–æ–ª–æ–Ω–∫–∏ // —Ñ—É–Ω–∫—Ü–∏—è –≤–æ–∑–≤—Ä–∞—Ç —á–∏—Å–ª–∞ –∏ –±—É–∫–≤
    let
        –ò—Å—Ç–æ—á–Ω–∏–∫ = Excel.CurrentWorkbook(){[Name="–¢–∞–±–ª–∏—Ü–∞1"]}[Content],
        fxDigits = each Text.Combine(
                            List.RemoveNulls(
                                List.Transform(
                                    Text.ToList([column]),
                                    each if Value.Is(Value.FromText(_), type number) then _ else null
                                )
                            )
                        ),
        fxText   = each Text.Combine(List.RemoveNulls(List.Transform(Text.ToList([column]),each if Value.Is(Value.FromText(_), type text) then _ else null)))
        AddedDigits = Table.AddColumn(–ò—Å—Ç–æ—á–Ω–∏–∫, "digits", fxDigits),
        AddedText   = Table.AddColumn(AddedDigits, "text", fxText)
    in
        AddedText

//  –ø–æ–∫–ª—é—á–µ–Ω–∏–µ –∫ stackoverflow.com // Web scraping questions on Stack Overflow - Html.Table scraping
        let
            Url = "https://stackoverflow.com/questions/tagged/powerquery",
            Response = Web.Contents( Url ),
            /*
            The 3rd argument in "columnNameSelectorPairs" is the transformation function.
            by default it uses:

                    each _[TextContent]
            */
            HeaderAsElement = Html.Table(
                Response,
                {
                    { "Link", "a.question-hyperlink", each _ }

                }
            ),

            ElementRecord = Table.ExpandRecordColumn(HeaderAsElement, "Link", {"TextContent", "Attributes"}, {"TextContent", "Attributes"}),
            ExpandedAttributes = Table.ExpandRecordColumn(ElementRecord, "Attributes", {"class", "href"}, {"Class", "Url"})
        in
            ExpandedAttributes

//  –ø—Ä–∏–º–µ—Ä –∫–æ–¥–∞ —Å —Ä–µ–∫—É—Ä—Å–∏–µ–π –∏ –ø—Ä–æ—á–∏–º, –Ω–µ–ø–ª–æ—Ö–æ, –∏–∑—É—á–∏—Ç—å
        let
            TextFromRecurse = (object as any) as text =>
                let
                    scalar = if object is list
                        then "{ " & Text.Combine(
                                List.Transform(
                                    object,
                                    // each "Item,"
                                    each @TextFromRecurse(_)
                                ),
                                ", "
                            ) & "} "
                        else object,

                    output = Text.From(scalar)
                in
                    output,

            CombineVararg =
                Function.From(
                    type function() as list,
                    each TextFromRecurse(_)
                ),

            results = [
                basic = CombineVararg("a", "b", 3, TextEncoding.Utf16),
                nested = CombineVararg("a", "b", 3, {3..6}),
                nested2 = CombineVararg(
                    "a", "b",
                    DateTime.LocalNow(),
                    3, {3..6}
                )

            ]
        in
            results,
//  –ø—Ä–∏–º–µ—Ä –∫–∞–∫–æ–≥–æ —Ç–æ –∫–æ–¥–∞ // –º–Ω–æ–≥–æ –∏–Ω—Ç–µ—Ä–µ—Å–Ω–æ–≥–æ –∫–æ–¥–∞, –∑–∞–ø–∏—Å–∏, –¥–æ–±–∞–≤–ª–µ–Ω–∏–µ –∏ –¥—Ä.
		let
			// toggles hiding extra columns
			UseMinimal = false,         // simplify final table output
			UseFastTest = true,         // skip most tests to quickly test the connection?
										// slow might need a sleep delay/waitfor pattern to play nice
			/*  
                todo:
                    - add delay testing: <https://httpstat.us/200?sleep=2000>
                    - retry pattern: <https://docs.microsoft.com/en-us/power-query/waitretry>
                    - Uri split query string
                    - <https://docs.microsoft.com/en-us/power-query/helperfunctions#urifromparts>
                    - <https://docs.microsoft.com/en-us/power-query/helperfunctions#retrieving-data>
			*/
            
			// every code supported by <https://httpstat.us/>
			ErrorCodes_https_supported      = {100..103} & {200..206} & {300..308} & {400..429} & {431, 451} & {500..507} & {511, 520, 522, 524},
			ErrorCodes_default              = {400..405} & {429,500,503},
			ErrorCodes_ManualStatusHandling = ErrorCodes_default,               // {400,401,403,404,429,500,503},
			ErrorCodes_StatusList           = ErrorCodes_ManualStatusHandling,  // ErrorCodes_ManualStatusHandling
			RequestOptions =  [
				// Timeout = // as duration: default is 100ms
				// IsRetry = true, // true: means ignore cached response
				// ManualStatusHandling =
				ManualStatusHandling = ErrorCodes_ManualStatusHandling

			],
			
            static_UrlList = {
				// test TLS errors
				"https://wrong.host.badssl.com/",
				"https://expired.badssl.com/",
				// non-existing domain
				"http://www.somefakenamedoesnotexist.com",

				// a couple specific HTTP statuses
				"https://httpbin.org/",
				"https://httpstat.us/200",
				"https://httpstat.us/404",
				"https://httpstat.us/403",
				"https://httpstat.us/405"
			},

			dynamic_UrlList =
				List.Transform(
					ErrorCodes_https_supported,
					(_ as any) as text =>
						"https://httpstat.us/" & Text.From( _ )
				),


			urlList =
				if UseFastTest then static_UrlList
				else static_UrlList & dynamic_UrlList,

			responseList = List.Transform(
				urlList,
				(url as text) as any =>
					Web.Contents(
						url,
						RequestOptions
					)
			),


			// Get metadata for a Web.Contents call
			WebRequest_ToRecord = (response as binary) as record  =>
				let
					metaData = Value.Metadata( response ),
					maybeErr = try metaData[Content.Type],

					/*
					Careful:
						Binary.Length( Web.Contents( ...a 403 response ) )

					will throw
						"Expression.Error: Access to the resource if forbidden"

					Note:
						- No error occurs on Value.Metadata() but it will on value calls
						- Exception is high level
							even a 'try' or 'let' block cannot capture it.
							an error record isn't returned if you use a "try"

					403 returns status code null

					*/
					contentLength =
						if ( metaData[Response.Status] = 403 or metaData[Response.Status] = null) 
                        then null
						else Binary.Length( response ),

					r1 = Record.AddField(metaData, "Binary", response, null ),
					r2 = Record.AddField(r1, "Content.Length", contentLength, null ),
					r3 = Record.AddField(r2, "Response.Error", if maybeErr[HasError] then maybeErr[Error] else null, null),
					r4 = Record.AddField(r3, "Url", metaData[Content.Uri]() ),
					r5 = Record.RemoveFields( r4, {"Content.Uri"}, MissingField.UseNull)
				in
					r5,

			metaDataList = List.Transform(
				responseList,
				each WebRequest_ToRecord(_)
			),

			WebRequestList_ToTable = 
                (source as list, optional minimal as nullable logical) as table =>
                        let
                            WebRequest_Table.Type = type table[
                                Url = text,
                                Response.Status = number, // always?
                                Content.Type = text,
                                Content.Length = Int64.Type,
                                Response.Error = record,
                                // Content.Uri = Function.Type, it returns the url, nothing else? or re-invoke original?
                                Content.Name = text, // probably base url
                                Headers = record,
                                Request.Options = record,
                                Binary = binary
                        ],

                        t1 = Table.FromRecords( metaDataList, WebRequest_Table.Type, MissingField.Error),
                        Final = Table.ExpandRecordColumn( t1, "Response.Error", {"Reason", "Message", "Detail"}, {"Error.Reason", "Error.Message", "Error.Detail"}),
                        FinalMinimal = Table.SelectColumns( Final, {"Url", "Response.Status", "Error.Reason", "Error.Message", "Error.Detail"}),
                        result = if minimal then FinalMinimal else Final inresult,

                    FinalTable = WebRequestList_ToTable( responseList, UseMinimal )
                in
                    FinalTable
            ,

//  –ê–†–ì–£–ú–ï–ù–¢–´   –®–∞–≥ 0. –°–ø–∏—Å–æ–∫ –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤ //? –≤ –±–∞–∑—É —Ñ—É–Ω–∫—Ü–∏—é GetValue –¥–ª—è –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤
        (optional options as record) =>
            let
                //	–ê–†–ì–£–ú–ï–ù–¢–´   –®–∞–≥ 0. –°–ø–∏—Å–æ–∫ –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤ //? –≤ –±–∞–∑—É —Ñ—É–Ω–∫—Ü–∏—é GetValue –¥–ª—è –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤
				    GetValue  = // —Ñ—É–Ω–∫—Ü–∏—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è —Ç–∏–ø–∞ –æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω—ã—Ö –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤
                        (options as record, fieldName as text, typeConverter as function) =>
                            let value  = Record.FieldOrDefault(options, fieldName, null),
                                result = if List.Contains({null, 0, ""}, value) then null else typeConverter(value)
                            in  result,

                    FILE_TYPE = GetValue(options, "–¢–∏–ø–§–∞–π–ª–∞", Text.From),
                    VID       = GetValue(options, "–í–∏–¥", Text.From),
                    STEP      = GetValue(options, "–ù–æ–º–µ—Ä–®–∞–≥–∞", Number.From),

//  –ò–ù–î–£–°, —Ä–∞–∑–≤–æ—Ä–æ—Ç –æ–±—ã—á–æ–π —Ç–∞–±–ª–∏—Ü—ã, 3 –ø–æ 3 –∫–æ–ª–æ–Ω–∫–∏
    // https://bajxwr.clicks.mlsend.com/tb/c/eyJ2Ijoie1wiYVwiOjQyMTQyNSxcImxcIjoxNDExNTAyOTM2MzgyNTE4ODksXCJyXCI6MTQxMTUwMzE5NDkxOTQyMzQ4fSIsInMiOiJmZTZjZDczNmJiOTgxOWUxIn0
    let
        Source = 
            #table( 
                {"Column1", "Column2", "Column3", "Column4", "Column5", "Column6", "Column7", "Column8", "Column9"}, 
                { {"India" ,null ,null ,"USA" ,null ,null ,"Aus" ,null ,null}, 
                {"Product" ,"Value" ,"Sh%" ,"Product" ,"Value" ,"Sh%" ,"Product" ,"Value" ,"Sh%"}, 
                {"A" ,"17" ,"0.6" ,"A" ,"19" ,"0.2" ,"A" ,"15" ,"0.48"}, 
                {"B" ,"10" ,"0.1" ,"B" ,"15" ,"0.53" ,"B" ,"15" ,"0.54"}, 
                {"C" ,"17" ,"0.36" ,"C" ,"20" ,"0.24" ,"C" ,"19" ,"0.07"}, 
                {"D" ,"19" ,"0.08" ,"D" ,"20" ,"0.55" ,"D" ,"18" ,"0.66"}, 
                {"E" ,"13" ,"0.49" ,"E" ,"14" ,"0.22" ,"E" ,"18" ,"0.66"} } 
            ), 

  
        // Source =    Excel.CurrentWorkbook(){[Name="Data"]}[Content],
        
        Tables =    List.Transform(
                        List.Split(Table.ToColumns(Table.Skip(Source, 1)), 3),
                        each Table.PromoteHeaders(Table.FromColumns(_))
                    ),
        FirstRow =  Table.FromList(
                        List.RemoveNulls(Record.ToList(Source{0})), 
                        null, 
                        {"Country"}
                    ),
        TWIndex =   Table.AddIndexColumn(FirstRow, "Index", 0, 1, Int64.Type),
        Collapsed = Table.TransformColumns(
                        TWIndex,
                        {"Index", each Tables{_}}   // —Ç—É—Ç —Ñ–∏—à–∫–∞/ –í–º–µ—Å—Ç–æ –∏–Ω–¥–µ–∫—Å–∞ –ø–æ–¥—Å—Ç–∞–≤–ª—è–µ—Ç —Ç–∞–±–ª–∏—Ü—ã –∏–∑ —à–∞–≥–∞ Tables
                    ),
        Expanded =  Table.ExpandTableColumn(Collapsed, "Index", Table.ColumnNames(Tables{0}) )
    in
        Expanded

//  –¥–∂–æ–π–Ω –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö —Ç–∞–±–ª–∏—Ü
        // –≤ —Ç–∞–Ω–∫–µ —Ç–µ–º–∞ "List.Accumulate ‚Äì –∫–∞–∫ –Ω–∞–ø–∏—Å–∞—Ç—å ¬´–ø—É—Å—Ç–æ–π¬ª –≤—Ç–æ—Ä–æ–π –∞—Ä–≥—É–º–µ–Ω—Ç". —Ç—É—Ç —Ñ–∞–π–ª –µ—Å—Ç—å —Å –ø—Ä–∏–º–µ—Ä–æ–º http://www.excelworld.ru/forum/2-49290-1 
        let
            f=(x)=> Excel.CurrentWorkbook(){[Name=x]}[Content],
            tbl = Table.Join(f("–ì–æ—Ä–æ–¥"),{},f("–ì–æ–¥"),{}),    // —Å–æ–µ–¥–∏–Ω—è–µ–º –¥–≤–µ —Ç–∞–±–ª–∏—Ü—ã
            to  = Table.Join(tbl,{},f("–ü—Ä–æ–¥—É–∫—Ç"),{})        // –ø–æ—Ç–æ–º —Ç—Ä–µ—Ç—å—é
        in
            to

        // —Ö–æ—Ç—è –µ—Å–ª–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ –º–Ω–æ–≥–æ —Å–æ–µ–¥–∏–Ω—è–µ–º —Å—Ä–∞–∑—É –≤—Å–µ
        let
            f=(x)=> Excel.CurrentWorkbook(){[Name=x]}[Content], // —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è
            g=(x,y)=>Table.Join(x,{},f(y),{}),                  // —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –∞–∫–∫—É–º—É–ª—è—Ç–æ—Ä–∞
            lst = {"–ì–æ—Ä–æ–¥","–ì–æ–¥","–ü—Ä–æ–¥—É–∫—Ç"},                    // —Å–ø–∏—Å–æ–∫ –∏–º—ë–Ω —Ç–∞–±–ª–∏—Ü (–ø–æ —Å—É—Ç–∏ –∏–º–µ–Ω–∞ –∑–∞–ø—Ä–æ—Å–æ–≤). –¢–∞–±–ª–∏—Ü–∞ –ò–º—è + –ò–Ω–¥–µ–∫—Å
            to  = List.Accumulate(lst,#table({},{{}}),g)        // ... –∏ —Å–æ–±–∏—Ä–∞–µ–º –≤—Å–µ —Ç–∞–±–ª–∏—Ü—ã –≤–º–µ—Å—Ç–µ
        in
            to

        // –≤–∞—Ä–∏–∞–Ω—Ç –ú–∏—Ö–∞–∏–ª–∞
        let
            f=(x)=>Table.SelectRows(Table.SelectColumns(from,x),(y)=>Record.Field(y,x)<>null),
            from = Excel.CurrentWorkbook(){[Name="Table1"]}[Content],
            nms  = Table.ColumnNames(from),
            to   = List.Accumulate(nms,#table({},{{}}),(s,c)=>Table.Join(s,{},f(c),{}))
        in
            to

//  –∫–∞–∫ —Å–æ–∑–¥–∞—Ç—å –ø–∞—Ä–∞–º–µ—Ç—Ä –≤ —Ñ—É–Ω–∫—Ü–∏–∏ –æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–π, –ú–∏—Ö–∞–∏–ª //! –í–∞–∂–Ω–æ
    // —Å–º —Ñ—É–Ω–∫—Ü–∏—é fxExcelGetRowsAttributes —Å –ø—Ä–∏–º–µ—Ä–æ–º
        func=(filebin, optional options)=> ...
	
    //  –≤ –∫–æ–¥–µ
        let sheetsonly = if options[SheetsOnly]?=true then true else false,
            fxUnzip    = if options[Excel2016]?=true then fxUnzip2016 else fxUnzip,

            to  = if sheetsonly then cmb else cmb & wb{[Kind="DefinedName"]}[tmp]

    //  —Å–∏–Ω—Ç–∞–∫—Å–∏—Å –≤ –ø—Ä–∏–º–µ—Ä–µ
        to = F[–§—É–Ω–∫—Ü–∏—è](from, [SheetsOnly = true])

    //  –ü—Ä–∏–º–µ—Ä:
            loadFilesInSite = 
                (optional options) =>
                    filter = 
                        Table.SelectRows(sort2, 
                            if options[AfterDate]? = null                    // –µ—Å–ª–∏ = F2[loadFilesInSite]([AfterDate = null]) 
                            then each true                                   // –Ω–∏—á–µ–≥–æ –Ω–µ —Ñ–∏–ª—å—Ç—Ä—É–µ–º
                            else each [–î–∞—Ç–∞ –∏–∑–º–µ–Ω–µ–Ω–∏—è] > options[AfterDate], // —Ñ–∏–ª—å—Ç—Ä—É–µ–º –ø–æ –¥–∞—Ç–µ
                        )
//! --- –í–∞—Ä–∏–∞–Ω—Ç—ã - GroupKind.Local ---
// 	–Ω–∞ –≤x–æ–¥–µ —Ç–∞–±–ª–∏—Ü–∞ –≤ –æ–¥–∏–Ω —Å—Ç–æ–ª–±–µ—Ü - –•–ª–µ–±, –¥–∞—Ç–∞,–¥–∞—Ç–∞,–¥–∞—Ç–∞, –ú–æ–ª–æ–∫–æ, –¥–∞—Ç–∞,–¥–∞—Ç–∞,–¥–∞—Ç–∞ / –Ω–∞–¥–æ —Å–≥—Ä—É–ø–ø–∏—Ä–æ–≤–∞—Ç—å –¥–∞—Ç—ã –ø–æ –ø—Ä–æ–¥—É–∫—Ç–∞–º
	to = Table.Group(from,
			"Column1",
			{"–î–∞—Ç–∞", (x)=>List.Skip(x[Column1])},
			GroupKind.Local,
			(x,y)=>Number.From(y is text) // –ø—Ä–æ–≤–µ—Ä–∫–∞ —Å—Ç–æ–ª–±—Ü–∞ –Ω–∞ —Ç–µ–∫—Å—Ç–æ–≤—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è
		)

//!  LoadReport2 = 
		/*
			–æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –∫–∞–∂–¥—ã–π —Ñ–∞–π–ª –∏—Å—Ö–æ–¥—è –∏–∑ –≤–∏–¥–∞ –æ—Ç—á–µ—Ç–∞ –∏ –¥–∞—Ç–∞—Å–µ—Ç–∞
		*/
		// (reportName as text, optional datasetName_ as nullable text) =>
		(options as record)  =>
		[
			// 	–∞—Ä–≥—É–º–µ–Ω—Ç—ã
				DATASET_NAME = let value = Record.FieldOrDefault(options, "–î–∞—Ç–∞C–µ—Ç", null) 	in if value = null then null else Text.From(value),
				REPORT_NAME  = let value = Record.FieldOrDefault(options, "–û—Ç—á–µ—Ç", null)   	in if List.Contains({null, 0, ""}, value) then null else Text.From(value),

			// 	functionMap	- –∫–∞—Ä—Ç–∞ —Ñ—É–Ω–∫—Ü–∏–π
				functionMap = [
					Homel   = F_Form[rep.BAL] ("Homel"),
					BKS 	= F_Form[rep.BAL] ("BKS")
				],
			
			//	from		- –æ—Ç—Ñ–∏–ª—å—Ç—Ä–æ–≤–∞–Ω–Ω–∞—è —Ç–∞–±–ª–∏—Ü–∞ —Å –Ω—É–∂–Ω—ã–º–∏ –æ—Ç—á–µ—Ç–∞–º–∏ –ø–æ –∑–∞–¥–∞–Ω–Ω–æ–º—É –¥–∞—Ç–∞—Å–µ—Ç—É
				from = 	F_Form[Connect_] ([–î–∞—Ç–∞C–µ—Ç–ò–º—è = DATASET_NAME, –û—Ç—á–µ—Ç–ò–º—è = REPORT_NAME]),
			
			// 	–ø—Ä–æ–≤–µ—Ä–∫—É —Å–¥–µ–ª–∞—Ç—å –ø–æ –≤–∏–¥—É –æ—Ç—á–µ—Ç–∞! —Ç.–∫. –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –ª—é–±–æ–µ —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ
				to   = 	Table.AddColumn(from, "DataCombine", each 
								 if REPORT_NAME = "bal" then F_Form[rep.BAL3] (_[Content], DATASET_NAME)
							else if REPORT_NAME = "opu" then 1
							else 2
							// let func = Record.FieldOrDefault(functionMap, [Company], (_)=>_)
							// in  func([Content])
						),
			//	—É–¥–∞–ª—è–µ–º —Å—Ç–æ–ª–±–µ—Ü —Å –∏—Å—Ö–æ–¥–Ω–∏–∫–∞–º–∏ + —Ñ–∏–ª—å—Ç—Ä—É–µ–º –ø–æ –∏–º–µ–Ω–∏ –æ—Ç—á–µ—Ç–∞ // ? –º–æ–∂–µ—Ç –ø–æ—Ä–∞–Ω—å—à–µ –¥–µ–ª–∞—Ç—å —ç—Ç–æ, –¥–æ –æ–±—Ä–∞–±–æ—Ç–∫–∏
				del = Table.RemoveColumns(to, {"Content"}),
				// sel = Table.SelectRows(to, each ([form_ID] = REPORT_NAME)),
			
			// 	—Ä–∞—Å–∫—Ä—ã–≤–∞—Ç—å —Ç–∞–±–ª–∏—Ü—ã –Ω–∞–¥–æ —Å–≥—Ä—É–ø–ø–∏—Ä–æ–≤–∞–≤ –∏—Ö –ø–æ –≤–∏–¥—É –æ—Ç—á–µ—Ç–æ–≤
				exp = Table.ExpandTableColumn(del, "Step2", Table.ColumnNames(del[Step2]{0}))
		]  [to],


//?  –ó–∞–ø–∏—Å—å —Å —Ñ—É–Ω–∫—Ü–∏—è–º–∏ –¥–ª—è –∫–∞–∂–¥–æ–π –ø–æ–¥—Ç–∞–±–ª–∏—Ü—ã

    Return = 
        // —ç—Ç–æ (x)=> Record.FieldOrDefault(functionMap, x[Name], (x)=>x) - –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Ñ—É–Ω–∫—Ü–∏—é functionMap –ø–æ Name, 
        // –∫–æ—Ç–æ—Ä–∞—è –ø—Ä–∏–Ω–∏–º–∞–µ—Ç –∫–∞–∫ –∞—Ä–≥—É–º–µ–Ω—Ç ( [Step2] )
        Table.AddColumn(tbl, "Data", each
            let func = Record.FieldOrDefault(functionMap, [Name], (_)=>_)	// —ç—Ç–æ —Ñ—É–Ω–∫—Ü–∏—è, [Name] - —ç—Ç–æ field
            in  func([Content2])	// –ø—Ä–∏–º–µ–Ω–µ–Ω–∏–µ —Ñ—É–Ω–∫—Ü–∏–∏ –∫ —Å—Ç–æ–ª–±—Ü—É —Å –ø–æ–¥—Ç–∞–±–ª–∏—Ü–∞–º–∏ –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç [Name]
        )


        functionMap = [
            –ë–ö–°    = fxBKS,
            –ì–æ–º–µ–ª—å = fxHomel
        ],
        
        //  –ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ —Ñ—É–Ω–∫—Ü–∏–π –∫ –ø–æ–¥—Ç–∞–±–ª–∏—Ü–∞–º
        Return = 
            Table.AddColumn(tbl, "Data+", 
                (x)=> Record.FieldOrDefault(functionMap, x[Name], (x)=>x) (x[Step2])
                // —ç—Ç–æ (x)=> Record.FieldOrDefault(functionMap, x[Name], (x)=>x) - –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Ñ—É–Ω–∫—Ü–∏—é functionMap –ø–æ Name, 
                // –∫–æ—Ç–æ—Ä–∞—è –ø—Ä–∏–Ω–∏–º–∞–µ—Ç –∫–∞–∫ –∞—Ä–≥—É–º–µ–Ω—Ç ( [Step2] )
            )

    //  –ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ —Ñ—É–Ω–∫—Ü–∏–π –∫ –ø–æ–¥—Ç–∞–±–ª–∏—Ü–∞–º
        /*
            –û–ø–∏—Å–∞–Ω–∏–µ	–≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Ñ—É–Ω–∫—Ü–∏—é –∏–∑ –∑–∞–ø–∏—Å–∏ functionMap –ø–æ –∑–Ω–∞—á–µ–Ω–∏—é –≤ –∫–æ–ª–æ–Ω–∫–µ [columnName]
            –ò—Å—Ç–æ—á–Ω–∏–∫	each Record.FieldOrDefault(functionMap, [Name],     (_)=>_) ([Step2]    )
            –ü—Ä–∏–º–µ—Ä		= F[fxFunctionMap] (funcMap, "Name", "Step2")
        */
        fxFunctionMap = 
            (functionMap as record, sName as text, sTable as text) =>
                Table.AddColumn(tbl, "Data+", 
                    each Record.FieldOrDefault( functionMap, Record.Field(_, sName), (_)=>_ ) (Record.Field(_, sTable))
                    
                ),

//  ! –æ–±—Ä–∞—â–µ–Ω–∏–µ –∫ —Å—Ç–æ–ª–±—Ü—É –ø–æ –∏–º–µ–Ω–∏
    f(Record.Field(row, nms{0})
    
    1.  –ò–∑–≤–ª–µ—á–µ–Ω–∏–µ —Å—Ç–æ–ª–±—Ü–∞ –∫–∞–∫ —Å–ø–∏—Å–∫–∞
        
        Table.Column(–ò—Å—Ç–æ—á–Ω–∏–∫, "–ò–º—è–°—Ç–æ–ª–±—Ü–∞")
    
    2.  –î–∏–Ω–∞–º–∏—á–µ—Å–∫–æ–µ –æ–±—Ä–∞—â–µ–Ω–∏–µ –∫ —Å—Ç–æ–ª–±—Ü—É
        
        Table.Column(–ò—Å—Ç–æ—á–Ω–∏–∫, –ü–µ—Ä–µ–º–µ–Ω–Ω–∞—è–°–ò–º—è–°—Ç–æ–ª–±—Ü–∞)
        each Record.Field(_, –ü–µ—Ä–µ–º–µ–Ω–Ω–∞—è–°–ò–º—è–°—Ç–æ–ª–±—Ü–∞)

//  fxAddMultiColumns —Å —Ñ—É–Ω–∫—Ü–∏–µ–π —Å—Ç–æ–ª–±—Ü–∞, —á—Ç–æ–±—ã –Ω–µ –ø–æ–≤—Ç–æ—Ä—è—Ç—å
    add = F[fxAddMultiColumns](ren,
        let f=(x)=> each Record.Field(_, x) & " " & [–ù–∞–∏–º–µ–Ω–æ–≤–∞–Ω–∏–µ]
        in {
            {"1_–ì—Ä—É–ø–ø–∞_–ù–∞–∏–º",       f("1_–ì—Ä—É–ø–ø–∞")},
            {"2_–ö–ª–∞—Å—Å_–ù–∞–∏–º",        f("2_–ö–ª–∞—Å—Å")},
            {"3_–ö–∞—Ç–µ–≥–æ—Ä–∏—è_–ù–∞–∏–º",    f("3_–ö–∞—Ç–µ–≥–æ—Ä–∏—è")},
            {"4_–ü–æ–¥–∫–∞—Ç–µ–≥–æ—Ä–∏—è_–ù–∞–∏–º", f("4_–ü–æ–¥–∫–∞—Ç–µ–≥–æ—Ä–∏—è")}
        }
    )
//  üîπ –ó–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ. –í–æ–∑–º–æ–∂–Ω–æ –ª–∏ —É—Å–∫–æ—Ä–∏—Ç—å –æ–±—Ä–∞–±–æ—Ç–∫—É –∑–∞–ø—Ä–æ—Å–∞ –ø–æ —Å–±–æ—Ä—É –¥–∞–Ω–Ω—ã—Ö –∏–∑ —Ñ–∞–π–ª–æ–≤? –§–∞–π–ª–æ–≤ –º–æ–∂–µ—Ç –±—ã—Ç—å —Ö–æ—Ç—å 100 –∏ –≤–µ—Å—è—Ç –ø–æ 2-4 –ú–±. –í –∫–æ—Ç–æ—Ä—ã—Ö ~10–∫ —Å—Ç—Ä–æ–∫ –∏ —Å—Ç–æ–ª–±—Ü–æ–≤ ~50.
    –í—ã—á–ª–µ–Ω—è—Ç—å –Ω–∏—á–µ–≥–æ –∏–∑ —Ñ–∞–π–ª–æ–≤ –Ω–µ –Ω—É–∂–Ω–æ, –∞ —Å–æ–±—Ä–∞—Ç—å –≤ 1 –±–æ–ª—å—à–æ–π –∏—Å—Ç–æ—á–Ω–∏–∫.
    –î–∏–Ω–∞–º–∏—á–Ω—ã–µ –∑–∞–≥–æ–ª–æ–≤–∫–∏ –º–æ–≥—É—Ç –±—ã—Ç—å, –ø–æ—Ç–æ–º—É –ø—Ä–∏—Ö–æ–¥–∏—Ç—Å—è –≤—ã—Ç–∞—Å–∫–∏–≤–∞—Ç—å.
    –ò –Ω—É–∂–Ω–æ —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å –Ω–∞–∑–≤–∞–Ω–∏–µ —Ñ–∞–π–ª–∞.
    //  –û—Ç–≤–µ—Ç –ú–∏—Ö–∞–∏–ª–∞!
        let
            from = Folder.Files("C:\–ø—É—Ç—å\–ù–æ–≤–∞—è –ø–∞–ø–∫–∞")[[Name],[Content]],
            f=(x)=>Table.AddColumn(Excel.Workbook(x{1}, true)[Data]{0},"Name",(i)=>x{0}),
            to = Table.Combine(Table.ToList(from,f))
        in
            to

    //  –û—Ç–≤–µ—Ç –ó–µ–ª–µ–Ω—Å–∫–æ–≥–æ
        let
            from = Folder.Files("C:\–°–æ–±—Ä–∞—Ç—å –¥–∞–Ω–Ω—ã–µ\–ù–æ–≤–∞—è –ø–∞–ø–∫–∞")[[Name],[Content]],
            to   = Table.FromPartitions("Name", Table.ToList(from, (x)=>{x{0},Excel.Workbook(x{1},true){0}[Data]}))
        in
            to
        

//  –ö–∞–∫ —Å –ø–æ–º–æ—â—å—é PQ –∏–∑ —Ç–µ–∫—Å—Ç–æ–≤–æ–π —Å—Ç—Ä–æ–∫–∏ –≤–∏–¥–∞ : ¬´ –±–ª–∞ –±–ª–∞ –±–ª–∞ 04-10-2024 18:30 –±–ª–∞ –±–ª–∞ ¬ª  –∏–∑–≤–ª–µ—á—å –¥–∞—Ç—É –∏ –≤—Ä–µ–º—è ?
    //  –ø–æ–ª–Ω—ã–π –≤–∞—Ä–∏–∞–Ω—Ç    
        f=(x)=>((a)=>DateTime.From(Text.Range(x,a,Text.PositionOf(x,":")-a+3)))(Text.PositionOf(x,"-")-2)

    //  –µ—Å–ª–∏ –Ω–µ—Ç –ª–∏—à–Ω–∏—Ö –ø—Ä–æ–±–µ–ª–æ–≤ –≤ —Å–∞–º–æ–π –∑–∞–ø–∏—Å–∏ –¥–∞—Ç—ã–≤—Ä–µ–º–µ–Ω–∏ - –º–æ–∂–Ω–æ –ø—Ä–æ—Å—Ç–æ
        f=(x)=> DateTime.From(Text.Range(x,Text.PositionOf(x,"-")-2,16))

//  –í –ø—Ä–∏–µ–º—ã! –ò–º—è –∫–æ–ª–æ–Ω–∫–∏ –æ–ø—Ä–µ–¥–µ–ª—è–µ–º —Ñ—É–Ω–∫—Ü–∏–µ–π //*!
    f=(x)=>Excel.CurrentWorkbook(){[Name=x]}[Content],  
    to = Table.SelectRows( f("–Ø–±–ª–æ–∫–∏"), (x)=>... )

//  –¢–∞–±–ª–∏—Ü—É –≤ –∑–∞–ø–∏—Å—å –∏ –æ–±—Ä–∞—Ç–Ω–æ. 
    let
        from =  Excel.CurrentWorkbook(){[Name="–¢–∞–±–ª–∏—Ü–∞3"]}[Content],
        lst  =  from[Date],
        to   =  Table.FromRecords({
                    [–ù–∞–∏–º–µ–Ω–æ–≤–∞–Ω–∏–µ = "–ø–µ—Ä–∏–æ–¥", –æ—Ç = List.Min(lst), –¥–æ = List.Max(lst)]
                })
    in
        to

//  –í –ø—Ä–∏–µ–º—ã!!! List.PositionOf. –ù–∞—Ö–æ–¥–∏–º –≤ —Ç–µ–∫—Å—Ç–µ —Å–ª–æ–≤–∞ –∏ –æ—Å—Ç–∞–≤–ª—è–µ–º —Ç–æ–ª—å–∫–æ –∏—Ö (–≤—ã–¥–µ–ª—è–µ–º –º–µ—Å—è—Ü—ã)
    –≤ —Ç–∞–Ω–∫–µ –≤–æ–ø—Ä–æ—Å "–ó–∞–±—ã–ª–∞ —Å–∫–∞–∑–∞—Ç—å, —á—Ç–æ –Ω—É–∂–Ω–æ –≤—ã–±—Ä–∞—Ç—å —Ç–æ–ª—å–∫–æ —Ç–µ –ø–µ—Ä–∏–æ–¥—ã, –∫–æ—Ç–æ—Ä—ã–µ —É–∫–∞–∑–∞–Ω—ã –Ω–∞ —Å—Ç—Ä–∞–Ω–∏—Ü–µ "–ü–∞—Ä–∞–º–µ—Ç—Ä—ã" –≤ —Ç–∞–±–ª–∏—Ü–µ "–ü–µ—Ä–∏–æ–¥""
    let
        //  —Å–ø–∏—Å–æ–∫ –º–µ—Å—è—Ü–µ–≤
            lst = List.Buffer(List.Transform({1..12},(x)=>Text.Upper(Date.MonthName(#date(2024,x,1))))), 
        
        //  –≤ —Ç–µ–∫—Å—Ç–µ –Ω–∞—Ö–æ–¥–∏–º –∏–º—è –º–µ—Å—è—Ü–∞ –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –µ–≥–æ –∏–º—è –ø–æ –ø–æ–∑–∏—Ü–∏–∏ –≤ —Å–ø–∏—Å–∫–µ –º–µ—Å—è—Ü–µ–≤ "–†–ê–ó–ú–ï–©–ï–ù–ò–ï . –û–ö–¢–Ø–ë–†–¨ –°–¢–û–ò–ú–û–°–¢–¨ NET, –†–£–ë–õ–ò"
            f=(x)=> lst{
                        List.PositionOf( lst, x, null, (c,v)=>Text.Contains(v,c) )
                    }, 
            
        from =  Excel.CurrentWorkbook(){[Name="–¢–∞–±–ª–∏—Ü–∞1"]}[Content],
        tr   =  Table.TransformColumns(from,{"–ù–∞–∏–º–µ–Ω–æ–≤–∞–Ω–∏–µ",f}),
        nms  =  List.Transform(
                    List.Skip(Table.ColumnNames(tr)),
                    (x)=>{x,(y)=>List.Sum(Table.Column(y,x))}   // —Å–ø–∏—Å–æ–∫ —Å–ø–∏—Å–∫–æ–≤ —Å –∫–æ–ª–æ–Ω–∫–∞/—Ñ—É–Ω–∫—Ü–∏—è
                ),
        to   =  Table.Group(tr,"–ù–∞–∏–º–µ–Ω–æ–≤–∞–Ω–∏–µ",nms) // –≥—Ä—É–ø–ø–∏—Ä—É–µ–º –ø–µ—Ä–≤—É—é –∫–æ–ª–æ–Ω–∫—É –ø–æ –º–µ—Å—è—Ü–∞–º
    in
        to


//  –í Power Query –µ—Å—Ç—å –Ω–µ—Å–∫–æ–ª—å–∫–æ —Å–ø–æ—Å–æ–±–æ–≤ —É–¥–∞–ª–∏—Ç—å –ø—É—Å—Ç—ã–µ —ç–ª–µ–º–µ–Ω—Ç—ã –∏–∑ —Å–ø–∏—Å–∫–∞. –í–æ—Ç –Ω–µ—Å–∫–æ–ª—å–∫–æ –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤: //? –í–∞–∂–Ω–æ

    //  –í–∞—Ä–∏–∞–Ω—Ç 1: –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ List.RemoveNulls
        –§—É–Ω–∫—Ü–∏—è List.RemoveNulls —É–¥–∞–ª—è–µ—Ç –≤—Å–µ null –∑–Ω–∞—á–µ–Ω–∏—è –∏–∑ —Å–ø–∏—Å–∫–∞, –Ω–æ –Ω–µ —É–¥–∞–ª—è–µ—Ç –ø—É—Å—Ç—ã–µ —Å—Ç—Ä–æ–∫–∏.
            let
                SourceList   = {"a", "", "b", null, "c"},
                FilteredList = List.RemoveNulls(SourceList)
            in
                FilteredList
        
        –ü—Ä–∏–º–µ—á–∞–Ω–∏–µ: –≠—Ç–æ—Ç –º–µ—Ç–æ–¥ —É–¥–∞–ª—è–µ—Ç —Ç–æ–ª—å–∫–æ null, –Ω–æ –æ—Å—Ç–∞–≤–ª—è–µ—Ç –ø—É—Å—Ç—ã–µ —Å—Ç—Ä–æ–∫–∏.

    //  –í–∞—Ä–∏–∞–Ω—Ç 2: –§–∏–ª—å—Ç—Ä–∞—Ü–∏—è —á–µ—Ä–µ–∑ List.RemoveMatchingItems
        –ú–æ–∂–Ω–æ –≤—Ä—É—á–Ω—É—é —É–∫–∞–∑–∞—Ç—å —ç–ª–µ–º–µ–Ω—Ç—ã, –∫–æ—Ç–æ—Ä—ã–µ –Ω—É–∂–Ω–æ —É–¥–∞–ª–∏—Ç—å, –≤–∫–ª—é—á–∞—è –ø—É—Å—Ç—ã–µ —Å—Ç—Ä–æ–∫–∏.
        
        let
            SourceList   = {"a", "", "b", null, "c"},
            FilteredList = List.RemoveMatchingItems(SourceList, {null, ""})
        in
            FilteredList

        –ü—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–æ: –ü–æ–∑–≤–æ–ª—è–µ—Ç —è–≤–Ω–æ —É–∫–∞–∑–∞—Ç—å, –∫–∞–∫–∏–µ —ç–ª–µ–º–µ–Ω—Ç—ã –Ω—É–∂–Ω–æ —É–¥–∞–ª–∏—Ç—å.

    //  –í–∞—Ä–∏–∞–Ω—Ç 3: –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ List.Select —Å Text.HasValue
        –ï—Å–ª–∏ –Ω—É–∂–Ω–æ —É–¥–∞–ª–∏—Ç—å —Ç–æ–ª—å–∫–æ –ø—É—Å—Ç—ã–µ —Å—Ç—Ä–æ–∫–∏ –∏ null, –Ω–æ —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å —ç–ª–µ–º–µ–Ω—Ç—ã —Å –Ω–µ–ø—É—Å—Ç—ã–º–∏ –∑–Ω–∞—á–µ–Ω–∏—è–º–∏, –º–æ–∂–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å Text.HasValue.
        
        let
            SourceList   = {"a", "", "b", null, "c"},
            FilteredList = List.Select(SourceList, each Text.HasValue(_))
        in
            FilteredList
        
        –ü—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–æ: –£–¥–æ–±–Ω–æ –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å —Ç–µ–∫—Å—Ç–æ–≤—ã–º–∏ –¥–∞–Ω–Ω—ã–º–∏, —É–¥–∞–ª—è–µ—Ç –∏ null, –∏ –ø—É—Å—Ç—ã–µ —Å—Ç—Ä–æ–∫–∏.

    //  –í–∞—Ä–∏–∞–Ω—Ç 4: –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ List.RemoveItems //! –ú–Ω–µ –ø–æ–Ω—Ä–∞–≤–∏–ª—Å—è. –ò—Å–ø–æ–ª—å–∑—É—é
        –ï—Å–ª–∏ –Ω—É–∂–Ω–æ —É–¥–∞–ª–∏—Ç—å –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–µ —ç–ª–µ–º–µ–Ω—Ç—ã, —Ç–∞–∫–∏–µ –∫–∞–∫ –ø—É—Å—Ç—ã–µ —Å—Ç—Ä–æ–∫–∏ –∏–ª–∏ –¥—Ä—É–≥–∏–µ —Å–ø–µ—Ü–∏—Ñ–∏—á–µ—Å–∫–∏–µ –∑–Ω–∞—á–µ–Ω–∏—è, –º–æ–∂–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å List.RemoveItems.
        
            let
                SourceList   = {"a", "", "b", null, "c"},
                FilteredList = List.RemoveItems(SourceList, {null, ""})
            in
                FilteredList

        –ü—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–æ: –ì–∏–±–∫–æ—Å—Ç—å —É–¥–∞–ª–µ–Ω–∏—è —Å–ø–µ—Ü–∏—Ñ–∏—á–µ—Å–∫–∏—Ö –∑–Ω–∞—á–µ–Ω–∏–π.

    //  –í–∞—Ä–∏–∞–Ω—Ç 5: –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –∫–æ–º–±–∏–Ω–∞—Ü–∏–∏ List.Distinct –∏ List.RemoveNulls
        –ï—Å–ª–∏ –≤–∞–º –Ω—É–∂–Ω–æ —É–¥–∞–ª–∏—Ç—å –¥—É–±–ª–∏–∫–∞—Ç—ã, –ø—É—Å—Ç—ã–µ —Å—Ç—Ä–æ–∫–∏ –∏ null –∑–Ω–∞—á–µ–Ω–∏—è –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ, –º–æ–∂–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∫–æ–º–±–∏–Ω–∞—Ü–∏—é —Ñ—É–Ω–∫—Ü–∏–π.

            let
                SourceList   = {"a", "", "b", null, "c", "", null, "a"},
                DistinctList = List.Distinct(SourceList),
                FilteredList = List.RemoveMatchingItems(DistinctList, {null, ""})
            in
                FilteredList

        –ü—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–æ: –£–¥–∞–ª—è–µ—Ç –¥—É–±–ª–∏–∫–∞—Ç—ã, null –∏ –ø—É—Å—Ç—ã–µ —Å—Ç—Ä–æ–∫–∏.
    
    //! –í–æ—Ç –∫—Ä–∞—Ç–∫–æ–µ —Ä–µ–∑—é–º–µ:
        List.RemoveNulls        ‚Äî –ø—Ä–æ—Å—Ç–æ–π –∏ –±—ã—Å—Ç—Ä—ã–π –≤–∞—Ä–∏–∞–Ω—Ç –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è —Ç–æ–ª—å–∫–æ null –∑–Ω–∞—á–µ–Ω–∏–π.
        List.Select —Å —É—Å–ª–æ–≤–∏—è–º–∏ ‚Äî –±–æ–ª–µ–µ –≥–∏–±–∫–∏–π –≤–∞—Ä–∏–∞–Ω—Ç –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è –∫–∞–∫ null, —Ç–∞–∫ –∏ –ø—É—Å—Ç—ã—Ö —Å—Ç—Ä–æ–∫.


//  —Å–¥–≤–∏–≥ —Å—Ç—Ä–æ–∫ –≤ –æ–¥–Ω–æ–π –∫–æ–ª–æ–Ω–∫–µ –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ –¥—Ä—É–≥–æ–π fxAddOtherRowColumn

    let
        tbl = Table.FromColumns({{"a".."i"},{1..9}},{"a","b"}),
        
        AddOtherRowColumn = 
            (tbl,col,newcol,index) =>
                [   lst = List.Buffer(Table.Column(tbl,col)),
                    add = Table.AddIndexColumn(tbl,newcol,index,1),
                    f   =   if index <0 
                            then (x)=>  if x <0  
                                        then null 
                                        else lst{x}
                            else (x)=>lst{x}?,
                    to = Table.TransformColumns(add,{newcol,f})
                ][to],
         
        to  = AddOtherRowColumn(tbl,"b","c",-1),
        to1 = AddOtherRowColumn(tbl,"b","c",-3),
        to2 = AddOtherRowColumn(tbl,"b","c",2)
    in
        to2

//  –†–∞–∑–¥–µ–ª—è–µ–º –∫–æ–ª–æ–Ω–∫—É –ê–Ω–∞–ª–∏—Ç–∏–∫–∞ –î—Ç –Ω–∞ 3 —á–µ—Ä–µ–∑ –ø–µ—Ä–µ–Ω–æ—Å —Å—Ç—Ä–æ–∫–∏. 1–°
    G:\=EXCEL - 1C\ –†–µ—à–µ–Ω–∏ —É—Ä–æ–≤–Ω–∏ –∞–Ω–∞–ª–∏—Ç–∏–∫–∏
    
    let
        from =  Excel.CurrentWorkbook(){[Name="–ò—Å—Ö–æ–¥–Ω–∞—è"]}[Content],
        gr   =  Table.Group(from, 
                    {"–ü–µ—Ä–∏–æ–¥", "–î–µ–±–µ—Ç", "–ö—Ä–µ–¥–∏—Ç", "–°—É–º–º–∞"}, 
                    {
                        {"–ê–Ω–∞–ª–∏—Ç–∏–∫–∞ –î—Ç", (x)=>x[–ê–Ω–∞–ª–∏—Ç–∏–∫–∞ –î—Ç]},
                        {"–ê–Ω–∞–ª–∏—Ç–∏–∫–∞ –ö—Ç", (x)=>x[–ê–Ω–∞–ª–∏—Ç–∏–∫–∞ –ö—Ç]}
                    }
                ),
        f=(x,y)=>
            Table.SplitColumn(
                x,
                y,
                (x)=>x, List.Max(
                            List.Transform(
                                Table.Column(x,y),
                                List.Count
                            )
                        )
            ),
        
        to = f(f(gr,"–ê–Ω–∞–ª–∏—Ç–∏–∫–∞ –î—Ç"),"–ê–Ω–∞–ª–∏—Ç–∏–∫–∞ –ö—Ç") // –∏–Ω—Ç–µ—Ä–µ—Å–Ω—ã–π –ø—Ä–∏–µ–º
    in
        to

//  –ñ—É—Ä–Ω–∞–ª –æ–ø–µ—Ä–∞—Ü–∏–π 1–°
    G:\=EXCEL - 1C\–ü—Ä–∏–º–µ—Ä PQ.xlsx
    let
        Source = Excel.CurrentWorkbook(){[Name="dataBody"]}[Content],
        PromotedHeaders   = Table.PromoteHeaders(Source, [PromoteAllScalars=true]),
        –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–π1 = Table.RenameColumns(PromotedHeaders, { {"Column7","–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ–î—Ç"},{"Column9","–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ–ö—Ç"}}),
        excludeColumns    = Table.RemoveColumns(–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–π1, List.Select(Table.ColumnNames(–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–π1), (x)=>Text.StartsWith(x,"Column") )),
        GroupedRows = Table.Group(
            excludeColumns, 
            {"–î–∞—Ç–∞"}, 
            {
                {   "tab", 
                        let names = Table.ColumnNames( excludeColumns ) 
                        in each 
                            Table.FromRows( 
                                {   List.Transform( Table.ToColumns(_),
                                        each if List.Count(List.RemoveNulls(_)) < 2
                                            then _{0}
                                            else Text.Combine(_,"|")
                                    )
                                },
                                names
                            ),
                    type table}
            }, 
            0, 
            (a,b) => Number.From( b[–î–∞—Ç–∞] <> null) ),

        to = Table.Combine(GroupedRows[tab])
    in
        to

//  –ø–æ–ª—É—á–µ–Ω–∏–µ –∞—Ç—Ä–∏–±—É—Ç–∏–æ–≤ —É—Ä–æ–≤–Ω—è –≤ –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ö —Å–æ —Å—Ç—Ä—É–∫—Ç—É—Ä–æ–π
        let
            unzip = Expression.Evaluate(Text.FromBinary(Web.Contents("https://raw.githubusercontent.com/buchlotnik/buchlotnik_functions/main/UnZip.pq")),#shared),
            bin   = Binary.Buffer(File.Contents("G:\=EXCEL - 1C\–û—Ç—á–µ—Ç –æ –ø—Ä–æ–¥–∞–∂–∞—Ö (–ú–∏—Ö–∞–∏–ª)\–í—ã–≥—Ä—É–∑–∫–∞ –æ—Ç—á–µ—Ç–∞ 1–° –æ –ø—Ä–æ–¥–∞–∂–∞—Ö - —Ä–µ—à–µ–Ω–∏–µ –ú–∏—Ö–∞–∏–ª–∞.xlsx")),

            xml   = Xml.Document(unzip(bin){[FileName="xl/worksheets/sheet1.xml"]}[Content]){0}[Value]{[Name="sheetData"]}[Value][Attributes],

            val = List.Transform(xml,(x)=>x{[Name="outlineLevel"]}?[Value]?),   // —É—Ä–æ–≤–µ–Ω—å
            nms = List.Transform(xml,(x)=>x{[Name="r"]}?[Value]?),              //  —Å—Ç—Ä–æ–∫–∞

            dict = Record.FromList(val,nms),    // —Å—Ç—Ä–æ–∫–∞ - —É—Ä–æ–≤–µ–Ω—å
            sh   = Excel.Workbook(bin,false){0}[Data], // –¥–∞–Ω–Ω—ã–µ –ª–∏—Å—Ç–∞
            add  = Table.AddIndexColumn(sh, "–£—Ä–æ–≤–µ–Ω—å", Number.From(nms{0}),1),
            to   = Table.TransformColumns(add,{"–£—Ä–æ–≤–µ–Ω—å",(x)=>Record.FieldOrDefault(dict,Text.From(x))}),
            
            from   = Table.RemoveLastN(Table.Skip(Table.PromoteHeaders(Table.LastN(to,(r)=>r[Column3]<>"–¢–û –ß–¢–û –ï–°–¢–¨ ")),2),1),
            f =(x)=> List.ReplaceRange({null,null,null},Number.From(List.Last(x)??0),1,{x{1}})&List.RemoveLastN(List.Skip(x,2),2),
            tbl    = Table.FromList(Table.ToList(from,f),(x)=>x),
            fill   = Table.FillDown(tbl,{"Column1","Column2"}),
            result = Table.SelectRows(fill,(r)=>r[Column3]<>null)
        in
            result

//  –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –∑–∞–¥–∞—Ç—å –ø—É—Ç—å –≤ –ø–∞–ø–∫–µ –∏ –∏–º—è —Ñ–∞–π–ª–∞ - —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏
    –ü—É—Ç—å–ö–ü–∞–ø–∫–µ
        "G:\=EXCEL - 1C" meta [IsParameterQuery=true, Type="Text", IsParameterQueryRequired=true]
    –ò–º—è —Ñ–∞–π–ª–∞
        "–û–±–æ—Ä–æ—Ç–Ω–æ-—Å–∞–ª—å–¥–æ–≤–∞—è –≤–µ–¥–æ–º–æ—Å—Ç—å.xlsx" meta [IsParameterQuery=true, Type="Text", IsParameterQueryRequired=true]
//  –ö–∞–∫ —á–∏—Å—Ç–∏—Ç—å –æ—à–∏–±–∫–∏ 
    ==============================================================================
    Table.ReplaceErrorValues, Table.RemoveRowsWithErrors ‚Äì —á–∏—Å—Ç–∏–º –≤—Ö–æ–¥—è—â–∏–µ –¥–∞–Ω–Ω—ã–µ

    –î–≤–∞–∂–¥—ã –∑–∞ –ø–æ—Å–ª–µ–¥–Ω–∏–µ —Å—É—Ç–∫–∏ –≤—Å–ø–ª—ã–≤–∞–ª –≤–æ–ø—Ä–æ—Å –∫–∞–∫ –ø–æ—Å—Ç—É–ø–∞—Ç—å —Å –æ—à–∏–±–∫–∞–º–∏ –¥–∞–Ω–Ω—ã—Ö –≤ –∏—Å—Ö–æ–¥–Ω–∏–∫–µ. 
    –ò–º–µ—é—Ç—Å—è –≤–≤–∏–¥—É –æ—à–∏–±–∫–∏ –Ω–∞ –ª–∏—Å—Ç–∞—Ö - #–î–ï–õ/0!, #–°–°–´–õ–ö–ê!, #–ù/–î –∏ —Ç.–¥. 
    –ü–æ–Ω—è—Ç–Ω–æ–µ –¥–µ–ª–æ, —á—Ç–æ –Ω–∞–∏–ª—É—á—à–µ–µ —Ä–µ—à–µ–Ω–∏–µ ‚Äì –≤–ª–µ–∑—Ç—å –≤ –∏—Å—Ö–æ–¥–Ω–∏–∫ –∏ –æ—à–∏–±–∫–∏ –∏—Å–ø—Ä–∞–≤–∏—Ç—å. 
    –ù–æ –µ—Å–ª–∏ —É –Ω–∞—Å –¥–æ—Å—Ç—É–ø —Ç–æ–ª—å–∫–æ –Ω–∞ —á—Ç–µ–Ω–∏–µ –∏–ª–∏, –Ω–∞–ø—Ä–∏–º–µ—Ä, –≤ —Ñ–∞–π–ª–µ –ø—Ä–æ—Ç—è–Ω—É—Ç—ã —Ñ–æ—Ä–º—É–ª—ã, 
    –∞ —è—á–µ–π–∫–∏ –Ω–µ –≤—Å–µ –∑–∞–ø–æ–ª–Ω–µ–Ω—ã, —á—Ç–æ –∏ –≤—ã–∑—ã–≤–∞–µ—Ç –æ—à–∏–±–∫–∏ ‚Äì –≤ —Ç–∞–∫–æ–π —Å–∏—Ç—É–∞—Ü–∏–∏ –ø—Ä–∏—Ö–æ–¥–∏—Ç—Å—è –∑–∞–Ω–∏–º–∞—Ç—å—Å—è –æ–±—Ä–∞–±–æ—Ç–∫–æ–π –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ.

    // 1. –ó–∞–º–µ–Ω–∞ - Table.ReplaceErrorValues.

    Table.ReplaceErrorValues(table, {"Column2", null})						// –í—Ç–æ—Ä—ã–º –∞—Ä–≥—É–º–µ–Ω—Ç–æ–º ‚Äì {–∏–º—è —Å—Ç–æ–ª–±—Ü–∞,–Ω–∞ —á—Ç–æ –∑–∞–º–µ–Ω–∏—Ç—å –æ—à–∏–±–∫—É}
    Table.ReplaceErrorValues(table, {{"Column2", null}})
    Table.ReplaceErrorValues(table, {{"Column2", null},{"Column4", null}})
    Table.ReplaceErrorValues(table, {{"Column2", null},{"Column4", 0}})		// –ü—Ä–∏—á—ë–º –≤ —Ä–∞–∑–Ω—ã—Ö —Å—Ç–æ–ª–±—Ü–∞—Ö –∑–Ω–∞—á–µ–Ω–∏–µ –¥–ª—è –∑–∞–º–µ–Ω—ã –º–æ–∂–µ—Ç –±—ã—Ç—å —Ä–∞–∑–Ω—ã–º:
    Table.ReplaceErrorValues(table, List.Transform(Table.ColumnNames(table),(x)=>{x,null}))  // –≤—Å–µ —Å—Ç–æ–ª–±—Ü—ã: –¢.–µ. –ø–æ–ª—É—á–∏–ª–∏ —Å–ø–∏—Å–æ–∫ –≤—Å–µ—Ö —Å—Ç–æ–ª–±—Ü–æ–≤ –∏ –ø—Ä–µ–≤—Ä–∞—Ç–∏–ª–∏ –µ–≥–æ –≤ —Å–ø–∏—Å–æ–∫ —Å–ø–∏—Å–∫–æ–≤ –≤–∏–¥–∞ {–∏–º—è, null}

    // 2. –£–¥–∞–ª–µ–Ω–∏–µ - Table.RemoveRowsWithErrors.

    Table.RemoveRowsWithErrors(table, {"Column2"})	//	—Ö–æ—Ç—è —É–¥–∞–ª—è–µ—Ç –≤—Å—é —Å—Ç—Ä–æ–∫—É —Å –æ—à–∏–±–∫–æ–π.
    Table.RemoveRowsWithErrors(table, {"Column1", "Column2", "Column3"})	//	–î–ª—è –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö —Å—Ç–æ–ª–±—Ü–æ–≤ –≤—Å—ë —Ç–∞–∫–∂–µ –Ω–µ—Å–ª–æ–∂–Ω–æ:
    Table.RemoveRowsWithErrors(table)	// —É–¥–∞–ª–∏—Ç—å —Å—Ç—Ä–æ–∫–∏ —Å –æ—à–∏–±–∫–∞–º–∏ —Å—Ä–∞–∑—É –ø–æ –≤—Å–µ–º —Å—Ç–æ–ª–±—Ü–∞–º? –¢.–µ. –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é –±–µ–∑ –≤—Ç–æ—Ä–æ–≥–æ –∞—Ä–≥—É–º–µ–Ω—Ç–∞ —Ñ—É–Ω–∫—Ü–∏—è –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –≤—Å–µ —Å—Ç–æ–ª–±—Ü—ã 
    ==============================================================================
    ? ?? ‚Äì Field Access –∏ Coalesce ‚Äì –∏–ª–∏ –∑–∞—á–µ–º –∑–∞–¥–∞–≤–∞—Ç—å –≤–æ–ø—Ä–æ—Å—ã –≤ –∫–æ–¥–µ
    
    –í–æ—Ç —Ç–∞–∫ ‚Äì –Ω–∏–∫–∞–∫–∏—Ö try, –Ω–∏–∫–∞–∫–∏—Ö if then else, –ø—Ä–æ—Å—Ç–æ –∑–Ω–∞–∫–∏ –≤–æ–ø—Ä–æ—Å–∞, –ø–æ—Å—Ç–∞–≤–ª–µ–Ω–Ω—ã–µ –≤ –ø—Ä–∞–≤–∏–ª—å–Ω–æ–º –º–µ—Å—Ç–µ.

        {1,2,3,4}{7} 											//–æ—à–∏–±–∫–∞ ‚Äì —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –≤ –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏–∏ –Ω–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ
        [a= "–í–∞—Å—è", b= "–ü–µ—Ç—è", c="–ö–æ–ª—è"][d]						//–æ—à–∏–±–∫–∞ ‚Äì –ø–æ–ª–µ –∑–∞–ø–∏—Å–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ
        Excel.CurrentWorkbook(){[Name="–¢–∞–±–ª–∏—Ü–∞124"]}[Content]	//–æ—à–∏–±–∫–∞, –µ—Å–ª–∏ –Ω–µ—Ç —Ç–∞–∫–æ–π —Ç–∞–±–ª–∏—Ü—ã

    –ü—Ä–æ–±–ª–µ–º–∞ —Ä–µ—à–∞–µ—Ç—Å—è –ø—É—Ç–µ–º –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è ? (–∑–Ω–∞–∫ –≤–æ–ø—Ä–æ—Å–∞):

        {1,2,3,4}{7}? 											//null
        [a = "–í–∞—Å—è", b = "–ü–µ—Ç—è", c = "–ö–æ–ª—è"][d]? 				//null
        Excel.CurrentWorkbook(){[Name="–¢–∞–±–ª–∏—Ü–∞124"]}?[Content]? //null

    –¢.–µ. –ø—Ä–∏ –æ–±—Ä–∞—â–µ–Ω–∏–∏ –∫ —ç–ª–µ–º–µ–Ω—Ç—É —Å–ø–∏—Å–∫–∞ –∏–ª–∏ –ø–æ–ª—é —Ç–∞–±–ª–∏—Ü—ã, –≤ —Å–ª—É—á–∞–µ –∏—Ö –æ—Ç—Å—É—Ç—Å—Ç–≤–∏—è –æ–ø–µ—Ä–∞—Ç–æ—Ä ? –≤–µ—Ä–Ω—ë—Ç –Ω–∞–º null ‚Äì —ç—Ç–æ –ª—É—á—à–µ, —á–µ–º –æ—à–∏–±–∫–∞.

    –ù–æ —á—Ç–æ –µ—Å–ª–∏ –Ω–∞–º –Ω–µ –Ω—É–∂–µ–Ω null? –í–µ–¥—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç –º–æ–∂–µ—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è –¥–∞–ª–µ–µ –≤ —Ä–∞—Å—á—ë—Ç–∞—Ö –∏ –Ω–∞–º –º–æ–∂–µ—Ç –ø–æ–Ω–∞–¥–æ–±–∏—Ç—å—Å—è 0, {}, [], "" 
    (–Ω–æ–ª—å, –ø—É—Å—Ç–æ–π —Å–ø–∏—Å–æ–∫, –ø—É—Å—Ç–∞—è –∑–∞–ø–∏—Å—å, –ø—É—Å—Ç–∞—è —Å—Ç—Ä–æ–∫–∞ –∏ —Ç.–ø.) –∏–ª–∏ –ø—Ä–æ—Å—Ç–æ —Å–ª—É–∂–µ–±–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –≤—Ä–æ–¥–µ ¬´–Ω–µ –Ω–∞–π–¥–µ–Ω–æ¬ª.
    –í–æ —Ç—É—Ç –Ω–∞–º –Ω–∞ –ø–æ–º–æ—â—å –∏ –ø—Ä–∏—Ö–æ–¥–∏—Ç –æ–ø–µ—Ä–∞—Ç–æ—Ä ?? ‚Äì –æ–±—ä–µ–¥–∏–Ω–µ–Ω–∏–µ (coalesce). –í –æ–±—â–µ–º –≤–∏–¥–µ —ç—Ç–æ –≤—ã–≥–ª—è–¥–∏—Ç —Ç–∞–∫:
    x??y    –µ—Å–ª–∏ x –Ω–µ null ‚Äì –±—É–¥–µ—Ç –≤–æ–∑–≤—Ä–∞—â—ë–Ω x, –∏–Ω–∞—á–µ ‚Äì y.    –ù—É –∞ –≤ –Ω–∞—à–µ–º —Å–ª—É—á–∞–µ:

        {1,2,3,4}{7}? ??0 																//0 ‚Äì –Ω–æ–ª—å
        [a= "–í–∞—Å—è", b= "–ü–µ—Ç—è", c="–ö–æ–ª—è"][d]? ?? ""										//–ø—É—Å—Ç–∞—è —Å—Ç—Ä–æ–∫–∞
        Excel.CurrentWorkbook(){[Name="–¢–∞–±–ª–∏—Ü–∞124"]}?[Content]? ??"–¥–∞–Ω–Ω—ã–µ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã"	// –¥–∞–Ω–Ω—ã–µ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã
    
    –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç—Å—è –Ω—É–∂–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ - –≥–ª–∞–≤–Ω–æ–µ –Ω–µ –∑–∞–±—ã—Ç—å –ø–æ—Å—Ç–∞–≤–∏—Ç—å –ø—Ä–æ–±–µ–ª –º–µ–∂–¥—É ? –∏ ?? .

//  –ì—Ä—É–ø–ø–∏—Ä–æ–≤–∫–∞ —Ä–∞–∑–¥–µ–ª–æ–≤ –±–∞–ª–∞–Ω—Å–∞ Table.Group + GroupKind.Local + List.ContainsAny
    –Ω–∞ –≤—ã—Ö–æ–¥–µ –ø–æ–ª—É—á–∞—é—Ç—Å—è —Ç–∞–±–ª–∏—Ü–∞ –∏–∑ –∫–æ–ª–æ–Ω–∫–∏ —Å –ø—è–ø—å—é —Ä–∞–∑–¥–µ–ª–∞–º–∏ –∏ —Å–æ–¥–µ—Ä–∂–∞–Ω–∏–µ–º —ç—Ç–∏—Ö —Ä–∞–∑–¥–µ–ª–æ–≤
    –±–µ–∑ –ø–µ—Ä–≤–æ–π —Å—Ç—Ä–æ–∫–∏ (–æ—Ñ–æ—Ä–º–ª–µ–Ω–∏–µ –±–∞–ª–∞–Ω—Å–∞). –ü–æ—Å–ª–µ–¥–Ω–∏–µ –≤–∫–ª—é—á–∞—Ç—Å—è –≤ –ø–æ—Å–ª–µ–¥–Ω–∏–π —Ä–∞–∑–¥–µ–ª
    =   Table.Skip(
            Table.Group(flt, {"Column1"}, 
                {"tmp", each _},
                GroupKind.Local,
                (s,c)=> Number.From( 
                            List.ContainsAny(
                                {Text.Split(c[Column1]," "){0}}, // —Å—Ä–∞–≤–Ω–µ–Ω–∏–µ compare –ø–æ –ø–µ—Ä–≤–æ–º—É –≤—Ö–æ–∂–¥–µ–Ω–∏—é –¥–æ –ø—Ä–æ–±–µ–ª–∞
                                {"I","II","III","IV","V"}, 
                                Text.Contains
                            )
                        )
            )
        )

//  –°–ø–∏—Å–æ–∫ –Ω–æ–º–µ—Ä–æ–≤ —Å—Ç—Ä–æ–∫ –≤ –∫–æ—Ç–æ—Ä—ã—Ö –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –∏—Å–∫–æ–º—ã–π —Ç–µ–∫—Å—Ç
    = Table.FindText(Table.AddIndexColumn(from, "index"), "–∞–∫—Ç–∏–≤—ã")[index]
// 	–¢–ê–ë–õ–ò–¶–£ –í –ó–ê–ü–ò–°–¨   
    to = Record.FromList(
			Table.ToList(typed, (x)=>List.Skip(x)), // value - —Å–ø–∏—Å–æ–∫ –∑–Ω–∞—á–µ–Ω–∏–π (–±–µ–∑ –ø–µ—Ä–≤–æ–π –∫–æ–ª–æ–Ω–∫–∏)
			Table.ToColumns(typed){0}				// key   - —Å–ø–∏—Å–æ–∫ —É–Ω–∏–∫–∞–ª—å–Ω—ã—Ö –ø–æ–ª–µ–π (–ø–µ—Ä–≤–∞—è –∫–æ–ª–æ–Ω–∫–∞) –∏–ª–∏ –¥—Ä—É–≥–∞—è 
		 )

//  –ë–ª–æ–∫ –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏–∏ –ø–æ –∫–æ–¥–∞ 383, 384 ... —Å—Ç–∞—Ç—å—è –ø–æ –∞–Ω–∞–ª–∏–∑—É –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏–π –ø–æ –†–û–°–°–ò–ò
    #"–§–∏–Ω–∞–ª—å–Ω—ã–π –≤–∏–¥ —Ç–∞–±–ª–∏—Ü—ã" = Table.TransformColumns(#"–í–∏–¥ —Ç–∞–±–ª–∏—Ü—ã —Å –¥–æ–±–∞–≤–ª–µ–Ω–Ω—ã–º –≥–æ–¥–æ–º", 
        {
			{"okved", each Text.Insert( (_), 0, (if #"–ì–æ–¥" <= 2016 then "–û–ö–í–≠–î: "else "–û–ö–í–≠–î2: ") ),type text}
		}
	),

    lst1 = List.Skip(Table.ColumnNames(#"–§–∏–Ω–∞–ª—å–Ω—ã–π –≤–∏–¥ —Ç–∞–±–ª–∏—Ü—ã" ), 8), 
	lst  = List.Range(lst1,0,58),
	f=(x,y)=>List.Accumulate(lst,x,(s,c)=>Record.TransformFields(s,{c,(x)=>Number.From(x)*y})),
	g=(x)=> f(x,Number.Power(10, (Number.FromText(x[#"measure"])-383)*3)),
	
	tbl = Table.ToRecords(#"–§–∏–Ω–∞–ª—å–Ω—ã–π –≤–∏–¥ —Ç–∞–±–ª–∏—Ü—ã"),
	tr  = List.Transform(tbl,g),
	to  = Table.FromRecords(trnsf),
	

// 	= Table.FromList(toList, (x)=>x, Value.Type(Load2) )
    Table.TransformContent = —Ä–∞–±–æ–∞—Ç–µ—Ç
		/*
		
		*/
			(tbl as table, NameColumn as text, Mask as text) =>
		[
			// tbl = selectFiles,
			// NameColumn = "Folder Path",
			// Mask = "—É—Ö",
		
			//  –ü—Ä–µ–≤—Ä–∞—â–∞–µ–º —Ç–∞–±–ª–∏—Ü—É –≤ —Å–ø–∏—Å–æ–∫ —Å–ø–∏—Å–∫–æ–≤ 
				from = Table.ToRows(tbl),

			//  –û–ø—Ä–µ–¥–µ–ª—è–µ–º –∏–Ω–¥–µ–∫—Å—ã –¥–ª—è —Å—Ç–æ–ª–±—Ü–æ–≤ 'Content' –∏ 'Folder Path'
				nms          = Table.ColumnNames(tbl),
				PathIndex    = List.PositionOf(nms, NameColumn),
				ContentIndex = List.PositionOf(nms, "Content"),

			//  –ü—Ä–∏–º–µ–Ω—è–µ–º —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏—é –∫–æ –≤—Å–µ–º —Å—Ç—Ä–æ–∫–∞–º —Å–ø–∏—Å–∫–∞
				TransformedList = 
					List.Transform(from, (x)=>
						let
							path    = x{PathIndex},
							content = x{ContentIndex},
							filteredTable = 
								if   Text.Contains(path, Mask)
								then Table.SelectRows(content, each [Name] = "–°–í–û–î")
								else content
						in
							List.Transform(
								nms, 
								(col) => if col = "Content" 
										then filteredTable
										else x{List.PositionOf(nms, col)}
							)
					),
			// 	–ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º —Å–ø–∏—Å–æ–∫ –æ–±—Ä–∞—Ç–Ω–æ –≤ —Ç–∞–±–ª–∏—Ü—É
				ResultTable = Table.FromRows(TransformedList, nms)
		]  [ResultTable],

	
//  ! –∑–∞–º–µ–Ω–∞ Table –≤ –æ–¥–Ω–æ–º —Å—Ç–æ–ª–±—Ü–µ –ø–æ —É—Å–ª–æ–≤–∏—é –≤ –¥—Ä—É–≥–æ–º
    Table.TransformContent = 
        (tbl as table, NameColumn as text, Mask as text) =>
    [
        // tbl = selectFiles,
        // NameColumn = "Folder Path",
        // Mask = "—É—Ö",
    
        //  –ü—Ä–µ–≤—Ä–∞—â–∞–µ–º —Ç–∞–±–ª–∏—Ü—É –≤ —Å–ø–∏—Å–æ–∫ —Å–ø–∏—Å–∫–æ–≤ 
            from = Table.ToRows(tbl),

        //  –û–ø—Ä–µ–¥–µ–ª—è–µ–º –∏–Ω–¥–µ–∫—Å—ã –¥–ª—è —Å—Ç–æ–ª–±—Ü–æ–≤ 'Content' –∏ 'Folder Path'
            nms          = Table.ColumnNames(tbl),
            PathIndex    = List.PositionOf(nms, nameColumn),
            ContentIndex = List.PositionOf(nms, "Content"),

        //  –ü—Ä–∏–º–µ–Ω—è–µ–º —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏—é –∫–æ –≤—Å–µ–º —Å—Ç—Ä–æ–∫–∞–º —Å–ø–∏—Å–∫–∞
            TransformedList = 
                List.Transform(from, (x)=>
                    let
                        path    = x{PathIndex},
                        content = x{ContentIndex},
                        filteredTable = 
                            if   Text.Contains(path, Mask)
                            then Table.SelectRows(content, each [Name] = "–°–í–û–î")
                            else content
                    in
                        List.Transform(
                            nms, 
                            (col) => if col = "Content" 
                                    then filteredTable
                                    else x{List.PositionOf(nms, col)}
                        )
                ),
        // 	–ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º —Å–ø–∏—Å–æ–∫ –æ–±—Ä–∞—Ç–Ω–æ –≤ —Ç–∞–±–ª–∏—Ü—É
            ResultTable = Table.FromRows(TransformedList, nms)
    ]  [ResultTable],


//      —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å–∫—Ç–≤–æ —Å—Ç–æ–ª–±—Ü–æ–≤
    to  = Table.FromRows(
        List.Transform(
            Table.ToRows(tbl),
            each 
                {   _{0}, 
                    if Text.Contains(_{2}, "—É—Ö") 
                    then Table.SelectRows(_{1}, each [Item] = "–°–í–û–î") 
                    else _{1},
                    _{2},
                    _{3}
                }
        ),
        Table.ColumnNames(tbl)
    )
//      –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–æ–µ –∫–æ–ª–∏—á–µ—Å–∫—Ç–≤–æ —Å—Ç–æ–ª–±—Ü–æ–≤
    let
        // –ü—Ä–∏–º–µ—Ä –∏—Å—Ö–æ–¥–Ω–æ–π —Ç–∞–±–ª–∏—Ü—ã
        Load = Table.FromRecords({
            [ID="1", Name="01_1222 –ë–∞–ª–∞–Ω—Å.xlsx", Content=Table.FromRecords({[Item="1", Value=100], [Item="2", Value=200]})],
            [ID="2", Name="02_1223 –ë–∞–ª–∞–Ω—Å.xlsx", Content=Table.FromRecords({[Item="1", Value=300], [Item="2", Value=400]})]
        }),

        from = Table.ToRows(Load),

        //  –û–ø—Ä–µ–¥–µ–ª—è–µ–º –∏–Ω–¥–µ–∫—Å—ã –¥–ª—è —Å—Ç–æ–ª–±—Ü–æ–≤ 'Name' –∏ 'Content'
            nms          = Table.ColumnNames(Load),
            NameIndex    = List.PositionOf(nms, "Name"),
            PathIndex    = List.PositionOf(nms, "Folder Path"),
            ContentIndex = List.PositionOf(nms, "Content"),

        //  –ü—Ä–∏–º–µ–Ω—è–µ–º —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏—é –∫–æ –≤—Å–µ–º —Å—Ç—Ä–æ–∫–∞–º —Å–ø–∏—Å–∫–∞
            TransformedList = 
                List.Transform(SourceList, each 
                    let
                        name    = _{NameIndex},
                        path    = _{PathIndex},
                        content = _{ContentIndex},
                        filteredTable = 
                            if   Text.Contains(path, "—É—Ö")  // name = "01_1222 –ë–∞–ª–∞–Ω—Å.xlsx"
                            then Table.SelectRows(content, each [Item] = "1")
                            else content
                    in
                        List.Transform(
                            nms, 
                            (col) => if col = "Content" 
                                     then filteredTable
                                     else _{List.PositionOf(nms, col)}
                        )
                ),
        ResultTable = Table.FromRows(TransformedList, nms)
    in
        ResultTable
        
//  –∏–Ω—Ç–µ—Ä–µ—Å–Ω–æ –∑–∞–ø–∏—Å—å —Å–æ —Å–ø–∏—Å–∫–∞–º–∏ —Å = List.Accumulate(Table.ToRows(b),[],(s,c)=>Record.AddField(s,c{0},List.Skip(c))),
    let
        a = #table({"–§–ò–û","–ü—Ä–æ—Ñ–µ—Å—Å–∏—è"},{{"–í–∞—Å—è","–ò–≥—Ä–æ–∫"},{"–ü–µ—Ç—è","–ò–≥—Ä–æ–∫"},{"–ö–æ–ª—è","–¢—Ä–µ–Ω–µ—Ä"},{"–ï–≤–ª–∞–º–ø–∏–π","–í—Ä–∞—á"}}),
        b = #table({"–î–æ–ª–∂–Ω–æ—Å—Ç—å","–û–∫–ª–∞–¥","–ü—Ä–µ–º–∏—è"},{{"–ò–≥—Ä–æ–∫",1000,100},{"–¢—Ä–µ–Ω–µ—Ä",2000,5000},{"–í—Ä–∞—á",100,1}}),
        —Å = List.Accumulate(
                Table.ToRows(b),
                [],
                (s,c)=>Record.AddField(s, c{0}, List.Skip(c))
            ),
        d = (x)=> x & Record.Field(—Å,x{1}),
        e = Table.FromList(Table.ToRows(a),d,{"–§–ò–û","–ü—Ä–æ—Ñ–µ—Å—Å–∏—è","–û–∫–ª–∞–¥","–ü—Ä–µ–º–∏—è"})
    in
        e

//  List.Generate –æ–ø–∏—Å–∞–Ω–≥–∏–µ –ø—Ä–∏–º–µ—Ä—ã //! –ü–û–õ–ï–ó–ù–û
    = List.Generate(()=> 1, (x)=> x <=10, (x)=> x + 1, (x)=> "Column" & Text.From(x) )
    
    = List.Generate(
        () => 1, 
        (x)=> x <=10, 
        (x)=> x + 1, 
        (x)=> "Column" & Text.From(x) 
    )
    
    = List.Generate(
        () => [index = 1],
        each [index] <= 10,
        each [index = [index] + 1],
        each [page = txt & " " & Text.From([index])][page]
    )

    let
        txt = "–°–ø–∏—Å–æ–∫",
        value = 1,      // [–∑–Ω–∞—á–µ–Ω–∏–µ]
        q = 10,         // [–∫–æ–ª–∏—á–µ—Å—Ç–≤–æ],
        source = 
            List.Generate(                          // —Å–æ–∑–¥–∞–µ–º –∑–∞–ø–∏—Å—å —Å –∏—Ç–µ—Ä–∞—Ç–æ—Ä–æ–º, –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —É—Å–ª–æ–≤–∏—è –≤—ã—Ö–æ–¥–∞ –∏–∑ —Ü–∏–∫–ª–∞
                ()=> [i = 1, a = value],            // –ø–µ—Ä–≤–æ–≥–æ —ç–ª–µ–º–µ–Ω—Ç–∞ –≤ –±—É–¥—É—â–µ–º —Å–ø–∏—Å–∫–µ 
                each [i] <= q,                      // –ø—Ä–æ–≤–µ—Ä–∫–∞ —É—Å–ª–æ–≤–∏—è –≤—ã—Ö–æ–¥–∞ –∏–∑ —Ü–∏–∫–ª–∞ 
                each [i = [i] + 1, a = [a] + 1 ],   // —É–≤–µ–ª–∏—á–∏–≤–∞–µ–º –∏—Ç–µ—Ä–∞—Ç–æ—Ä –Ω–∞ 1 –∏ –≥–µ–Ω–µ—Ä–∏—Ä—É–µ–º —Å–ª–µ–¥—É—é—â–∏–π —ç–ª–µ–º–µ–Ω—Ç —Å–ø–∏—Å–∫–∞ –ø–æ —Ñ–æ—Ä–º—É–ª–µ
                each [a]                            // –ø–æ–∫–∞–∑—ã–≤–∞–µ–º —á—Ç–æ –∏–º–µ–Ω–Ω–æ –≤—ã–≤–æ–¥–∏—Ç—å –≤ –±—É–¥—É—â–∏–π —Å–ø–∏—Å–æ–∫
            )
    in
        source

//  ‚ö° –ò—Ç–æ–≥–æ–≤–∞—è —Å—Ç—Ä–æ–∫–∞ //todo –≤–∞–∂–Ω–æ, –ø–æ–ª–µ–∑–Ω–æ, –∫–∞–∫ —Ä–∞–±–æ—Ç–∞–µ—Ç
    //  –í–ê–†–ò–ê–ù–¢ 1. –ß–µ—Ä–µ–∑ Table.InsertRows + —Ä–∞–∑–Ω—ã–µ –ø—Ä–∏–º–µ—Ä—ã. –†–∞–±–æ—Ç–∞–µ—Ç!!!
        let
            from =  
                Table.Buffer(
                    Table.FromColumns(
                            {
                                {1, 2, 3, 4, 5, 6, 7, 8, 9, 10},  // –£—Ä–æ–≤–µ–Ω—å
                                {3000,  6300,  9650,    17500,  21000,  31000,  46000,  69000,  105000,  150000},  // –í–µ—Ç–∫–∞ 1
                                {4500,  9450,  14775,   26250,  31500,  46500,  69000, 103500,  157500,  225000},  // –í–µ—Ç–∫–∞ 2
                                {6000,  12600, 19700,   35000,  42000,  62000,  92000, 136000,  210000,  300000},  // –í–µ—Ç–∫–∞ 3
                                {7500,  15750, 24625,   43750,  52500,  77500, 115000, 172500,  262500,  375000},  // –í–µ—Ç–∫–∞ 4
                                {12000, 25200, 39400,   70000,  64000, 124000, 164000, 276000,  420000,  600000},  // –í–µ—Ç–∫–∞ 5
                                {16500, 34650, 54175,   96250, 115500, 170500, 253000, 379500,  577500,  625000},  // –í–µ—Ç–∫–∞ 6
                                {21000, 44100, 68950,  122500, 147000, 217000, 322000, 463000,  735000, 1050000},  // –í–µ—Ç–∫–∞ 7
                                {25500, 53550, 83725,  146750, 176500, 263500, 391000, 566500,  692500, 1275000},  // –í–µ—Ç–∫–∞ 8
                                {31500, 66150, 103425, 163750, 220500, 325500, 483000, 724500, 1102500, 1575000},  // –í–µ—Ç–∫–∞ 9
                                {37500, 76750, 123125, 216750, 262500, 367500, 575000, 662500, 1312500, 1675000}   // –í–µ—Ç–∫–∞ 10
                            }, 
                                {"–£—Ä–æ–≤–µ–Ω—å"} & List.Transform({1..10}, (x)=>"–í–µ—Ç–∫–∞" & Number.ToText(x))
                    )
                ),
            nms = Table.ColumnNames(from),
            
            //  –≤–∞—Ä–∏–∞–Ω—Ç 1
                lst = List.Transform(
                        nms,
                        (x)=> if x="–£—Ä–æ–≤–µ–Ω—å" then null else List.Sum(Table.Column(from, x))
                    ),

                TotalRow1 = 
                    let TotalRow = Record.FromList(lst, nms),
                    in  Record.TransformFields(TotalRow, {{"–£—Ä–æ–≤–µ–Ω—å", each "–ò—Ç–æ–≥–æ"}}),

            // –≤–∞—Ä–∏–∞–Ω—Ç 1
                TotalRow2 = 
                    [
                        –£—Ä–æ–≤–µ–Ω—å = "–ò—Ç–æ–≥–æ", 
                        –í–µ—Ç–∫–∞1 = List.Sum(Table.Column(from, "–í–µ—Ç–∫–∞1")),
                        –í–µ—Ç–∫–∞2 = List.Sum(Table.Column(from, "–í–µ—Ç–∫–∞2")),
                        –í–µ—Ç–∫–∞3 = "",
                        –í–µ—Ç–∫–∞4 = "",
                        –í–µ—Ç–∫–∞5 = "",
                        –í–µ—Ç–∫–∞6 = "",
                        –í–µ—Ç–∫–∞7 = "",
                        –í–µ—Ç–∫–∞8 = "",
                        –í–µ—Ç–∫–∞9 = "",
                        –í–µ—Ç–∫–∞10 = 10
                    ],

            //  –°–æ–∑–¥–∞–Ω–∏–µ –∏—Ç–æ–≥–æ–≤–æ–π —Å—Ç—Ä–æ–∫–∏ —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º —Ñ—É–Ω–∫—Ü–∏–∏//todo —ç—Ç–æ—Ç –ø–æ–Ω—Ä–∞–≤–∏–ª—Å—è
                TotalRow3 = 
                    Record.FromList(
                        List.Transform(nms, (x)=>
                                if x = "–£—Ä–æ–≤–µ–Ω—å" then "Total"
                            else if x = "–í–µ—Ç–∫–∞1" then List.Sum(Table.Column(from, "–í–µ—Ç–∫–∞1"))
                            else if x = "–í–µ—Ç–∫–∞2" then List.Count(Table.Column(from, "–í–µ—Ç–∫–∞2"))
                            else if x = "–í–µ—Ç–∫–∞9" then List.Max(Table.Column(from, "–í–µ—Ç–∫–∞9"))
                            else ""
                        ),
                        nms
                    ),
            //  –î–æ–±–∞–≤–ª—è–µ–º —Å—Ç—Ä–æ–∫—É: —Ç–∞–±–ª–∏—Ü–∞, –ø–æ–∑–∏—Ü–∏—è, —Å—Ç—Ä–æ–∫–∞
                to = Table.InsertRows( from, Table.RowCount(from), {TotalRow4} )
        in
            to


    //  –í–∞—Ä–∏–∞–Ω—Ç 2. –ß–µ—Ä–µ–∑ List.Zip + List.Transform. –ü—Ä–æ—â–µ
        let
            Source =  Table.FromColumns(
                {
                    {1, 2, 3, 4, 5, 6, 7, 8, 9, 10},  // –£—Ä–æ–≤–µ–Ω—å
                    {3000,  6300,  9650,    17500,  21000,  31000,  46000,  69000,  105000,  150000},  // –í–µ—Ç–∫–∞ 1
                    {4500,  9450,  14775,   26250,  31500,  46500,  69000, 103500,  157500,  225000},  // –í–µ—Ç–∫–∞ 2
                    {6000,  12600, 19700,   35000,  42000,  62000,  92000, 136000,  210000,  300000},  // –í–µ—Ç–∫–∞ 3
                    {7500,  15750, 24625,   43750,  52500,  77500, 115000, 172500,  262500,  375000},  // –í–µ—Ç–∫–∞ 4
                    {12000, 25200, 39400,   70000,  64000, 124000, 164000, 276000,  420000,  600000},  // –í–µ—Ç–∫–∞ 5
                    {16500, 34650, 54175,   96250, 115500, 170500, 253000, 379500,  577500,  625000},  // –í–µ—Ç–∫–∞ 6
                    {21000, 44100, 68950,  122500, 147000, 217000, 322000, 463000,  735000, 1050000},  // –í–µ—Ç–∫–∞ 7
                    {25500, 53550, 83725,  146750, 176500, 263500, 391000, 566500,  692500, 1275000},  // –í–µ—Ç–∫–∞ 8
                    {31500, 66150, 103425, 163750, 220500, 325500, 483000, 724500, 1102500, 1575000},  // –í–µ—Ç–∫–∞ 9
                    {37500, 76750, 123125, 216750, 262500, 367500, 575000, 662500, 1312500, 1675000}   // –í–µ—Ç–∫–∞ 10
                }, 
                    {"–£—Ä–æ–≤–µ–Ω—å"} & List.Transform({1..10}, (x)=>"–í–µ—Ç–∫–∞ " & Number.ToText(x))),

            nms    = Table.ColumnNames(Source),
            group  = Table.Group(Source, {}, 
                        List.Zip({
                            nms, 
                            { each "Total"} & List.Transform(List.Skip(nms), (x)=>each List.Sum(Table.Column(_,x)))
                        })
                    ),
            append = Table.Combine({Source, group})
        in
            append

    //	–í–∞—Ä–∏–∞–Ω—Ç 3. –ß–µ—Ä–µ–∑ List.TransformMany. –°–ª–æ–∂–Ω–µ–µ
        let
            Source = Excel.CurrentWorkbook(){[Name="Table1"]}[Content],
            group = Table.Group(Source, {}, 
                        List.TransformMany(
                            Table.ColumnNames(Source),
                            (x)=>{each 	if x = "letter" 
                                        then "Total" 
                                        else List.Sum(Table.Column(_,x)) },
                        (x,y)=>{x,y})
                        ),
            append = Table.Combine({Source, group})
        in
            append	
    //  –í–∞—Ä–∏–∞–Ω—Ç 4. –ß–∞—Ç GPT
        to = Table.InsertRows(Source, Table.RowCount(Source),
            { Record.FromList(
                    List.Combine({
                        {"–ò–¢–û–ì–û",""},
                        List.Transform(
                            List.Skip(Table.ColumnNames(Source), 2),
                            (col) => List.Sum(Table.Column(Source, col))
                        )
                    }),
                    Table.ColumnNames(Source)
                )
            }
        )
//  –Ω–æ–º–µ—Ä –≤—Ö–æ–∂–¥–µ–Ω–∏—è —ç–ª–µ–º–µ–Ω—Ç–∞ —Å–ø–∏—Å–∫–∞ –ø–æ –∏–º–µ–Ω–∏    
    index = List.PositionOf(Table.ColumnNames(tbl), "–°—Ç—Ä–æ–∫–∞_ID"),
//  DS_CountRows - –æ–±—ä–µ–¥–∏–Ω–µ–Ω–∏–µ –∑–∞–ø—Ä–æ—Å–æ–≤ –ø–æ –∏–º–µ–Ω–∏ –∑–∞–ø—Ä–æ—Å–∞ + –∑–Ω–∞—á–µ–Ω–∏–µ –ø–æ–ª—è // –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ List.Select + List.Transform +Expression.Evaluate
    let
        queryNames = List.Select(Record.FieldNames(#shared), each Text.Contains(_, "DataSet_")),
        columnName = "–°ountRows",
        
        getColumnValues = (queryName as text) =>
            let
                queryTable = Expression.Evaluate(queryName, #shared),
                columnValues = try Table.Column(queryTable, columnName) otherwise null
            in
                columnValues,
        
        columnValuesList = 
            List.Transform(
                queryNames, 
                each [QueryName = _, Values = getColumnValues(_)]
            ),
        
        resultTable = Table.FromRecords(columnValuesList),
        
        to = Table.TransformColumns(resultTable, {"Values", each List.Sum(_), type text})
    in
        to

//  –ø–∞—Ä–∞–º–µ—Ç—Ä as nullable 
    –ï—Å–ª–∏ —É –≤–∞—Å –µ—Å—Ç—å –ø–∞—Ä–∞–º–µ—Ç—Ä —Ñ—É–Ω–∫—Ü–∏–∏ –≤ Power Query, –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω—ã–π 
    –∫–∞–∫ optional n as nullable number, —ç—Ç–æ –æ–∑–Ω–∞—á–∞–µ—Ç, —á—Ç–æ –ø–∞—Ä–∞–º–µ—Ç—Ä 
    –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—Ä–æ–ø—É—â–µ–Ω –∏–ª–∏ –∑–∞–¥–∞–Ω –∫–∞–∫ null. –ö–æ–≥–¥–∞ –∞—Ä–≥—É–º–µ–Ω—Ç –Ω–µ —É–∫–∞–∑–∞–Ω, 
    –æ–Ω –±—É–¥–µ—Ç –∏–º–µ—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ null.

//  –≥—Ä—É–ø–ø–∏—Ä–æ–≤–∫–∞ –∑–Ω–∞—á–µ–Ω–∏–π –ø–æ –¥–∏–∞–ø–∞–∑–æ–Ω—É —Å —à–∞–≥–æ–º
    let from  = tbl,
        Range = Table.AddColumn(from, "Category", each 
                    let value      = [–ù–∞ –Ω–∞—á–∞–ª–æ],
                        step       = 1000
                        rangeStart = Number.RoundDown((value - 1) / step) * step + 1,
                        rangeEnd   = rangeStart + (step - 1)
                    in  Text.From(rangeStart) & "-" & Text.From(rangeEnd)
                ),

        Sort =  Table.AddColumn(Range, "Sort", each 
                    Number.RoundDown(([–ù–∞ –Ω–∞—á–∞–ª–æ] - 1) / 1000) + 1
                ),
        
        group = Table.Group(Sort, {"Category", "Sort"}, 
                    {
                        {"Count",   each Table.RowCount(_), Int64.Type},
                        {"Sum",     each List.Sum([–ù–∞ –Ω–∞—á–∞–ª–æ])}
                    }
                )
    in  group

//  "Attributes" - (x)=> F[fxSizeFile] (Record.Field(x,"Size"))
    {"Attributes", 	 (x)=> F[fxSizeFile] (Record.Field(x,"Size")), type text},

//  –ø–æ–¥–∫–ª—é—á–∞–µ–º—Å—è –∫ –ø–∞–ø–∫–µ - path = Value.Metadata(F_Form[Parameters]) [Mart] [pathXLSX],
    1
//  LoadFolderXLSX = // –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –æ—á–∏—â–µ–Ω–Ω—ã–π —Å–ø–∏—Å–æ–∫ —Ñ–∞–π–ª–æ–≤ CSV  –≤ –ø–∞–ø–∫–µ —Å —É—á–µ—Ç–æ–º –ø–æ–¥–ø–∞–ø–æ–∫
    LoadFolderXLSX = // –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –æ—á–∏—â–µ–Ω–Ω—ã–π —Å–ø–∏—Å–æ–∫ —Ñ–∞–π–ª–æ–≤ CSV  –≤ –ø–∞–ø–∫–µ —Å —É—á–µ—Ç–æ–º –ø–æ–¥–ø–∞–ø–æ–∫
		/*
			–ü—Ä–∏–º–µ—Ä:	= 
		*/
		(path as text) =>
		let
			from = Folder.Files(path),
			
			// —Ñ–∏–ª—å—Ç—Ä—É–µ–º –∫–æ–ª–æ–Ω–∫–∏ –∏ —Å—Ç—Ä–æ–∫–∏ –≤ —Å–ø–∏—Å–∫–µ —Ñ–∞–π–ª–æ–≤
			FilteredRows 		= Table.SelectRows(from, each Text.Start([Extension], 5) = ".xlsx" and [Attributes][Hidden] = false),
			NoTemps   			= Table.SelectRows(FilteredRows, each not Text.StartsWith([Name], "~$")),
			RemovedOtherColumns	= Table.SelectColumns(NoTemps, {"Name", "Content"} & {"Folder Path"}),
						
			// –ø—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –±–∏–Ω–∞—Ä–Ω–∏–∫–∏ –≤ —Ç–∞–±–ª–∏—Ü—ã –∏ —Ñ–∏–ª—å—Ç—Ä—É–µ–º —Å—Ç—Ä–æ–∫–∏ –≤ –ø–æ–¥—Ç–∞–±–ª–∏—Ü–∞—Ö
			TransformBinary   	= Table.TransformColumns(NoTemps,         {"Content", (x)=>Excel.Workbook(x)} ),
			NoPrintAreas 		= Table.TransformColumns(TransformBinary, {"Content", (x)=>Table.SelectRows(x, each not Text.Contains([Name], "$"))} ),
			OnlySheets		   	= Table.TransformColumns(NoPrintAreas,    {"Content", (x)=>Table.SelectRows(x, each [Kind]="Sheet")} ),

			// –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –∫–æ–ª–æ–Ω–∫–∏
			AddColSheetsName	= Table.AddColumn(OnlySheets, "SheetsName", (x)=>Text.Combine(x[Content][Name], ",") ), // —Å–ø–∏—Å–æ–∫ –ª–∏—Å—Ç–æ–≤ —á–µ—Ä–µ–∑ ","
			
			// –≤—ã–≤–æ–¥–∏–º –ø–æ—Å–ª–µ–¥–Ω–∏–µ 2 —É—Ä–æ–≤–Ω—è –Ω–∞–∑–≤–∞–Ω–∏—è –ø–∞–ø–∫–∏
			NameFolder  		= Table.TransformColumns(AddColSheetsName, {
										{"Folder Path", each Text.AfterDelimiter(_, "\", {2, RelativePosition.FromEnd}), type text}}),
			
			SelectColumns		= Table.SelectColumns(NameFolder,{"Name", "Content"} & {"Folder Path"})
		in
			SelectColumns,

//  LoadFolderAll  = // *–≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –ù–ï–æ—á–∏—â–µ–Ω–Ω—ã–π —Å–ø–∏—Å–æ–∫ —Ñ–∞–π–ª–æ–≤ –≤ –ø–∞–ø–∫–µ —Å —É—á–µ—Ç–æ–º –ø–æ–¥–ø–∞–ø–æ–∫
	LoadFolderAll  = // *–≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –ù–ï–æ—á–∏—â–µ–Ω–Ω—ã–π —Å–ø–∏—Å–æ–∫ —Ñ–∞–π–ª–æ–≤ –≤ –ø–∞–ø–∫–µ —Å —É—á–µ—Ç–æ–º –ø–æ–¥–ø–∞–ø–æ–∫
		/*
			–ü—Ä–∏–º–µ—Ä:	= 
		*/
		(path as text) =>
		let
			from = Folder.Files(path),
			
			// —Ñ–∏–ª—å—Ç—Ä—É–µ–º –∫–æ–ª–æ–Ω–∫–∏ –∏ —Å—Ç—Ä–æ–∫–∏ –≤ —Å–ø–∏—Å–∫–µ —Ñ–∞–π–ª–æ–≤
			flt = Table.SelectRows(from, each Text.Start([Extension], 5) = ".xlsx" and [Attributes][Hidden] = false),
			sel	= Table.SelectRows(flt, each not Text.StartsWith([Name], "~$")),
			lst = {"Name","Extension", "Date created", "Content"} & {"Folder Path"},
			rem	= Table.SelectColumns(sel, lst),
			f=(x)=>Text.AfterDelimiter(x, "\", {2, RelativePosition.FromEnd}), // 2 —É—Ä–æ–≤–Ω—è —Å–ø—Ä–∞–≤–∞ –≤ –Ω–∞–∑–≤–∞–Ω–∏–∏ –ø–∞–ø–∫–∏
			tr	= Table.TransformColumns(rem, {{"Folder Path", f, type text}})
		in
			tr,
//  –ü–æ–ª–µ–∑–Ω—ã–π –≤–∞—Ä–∏–∞–Ω—Ç –∑–∞–º–µ–Ω—ã –µ—Å–ª–∏ //! –ß–µ—Ä–µ–∑ List.Transform
    // –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –∏–Ω–¥–µ–∫—Å–∞ –µ–¥–∏–Ω–∏—Ü—ã –∏–∑–º–µ—Ä–µ–Ω–∏—è –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Ä–∞–∑–º–µ—Ä–∞ —Ñ–∞–π–ª–∞ (Number.Power - —Å—Ç–µ–ø–µ–Ω—å)
    // —ç—Ç–æ 
        Index1 = List.NonNullCount(
                    List.Transform(
                        {0..4}, 
                        (i) => if sizeInBytes >= Number.Power(Byte, i) then i else null)
                    ) - 1,

    //  —Ä–∞–≤–Ω–æ —ç—Ç–æ–º—É 
        Index = 
            if      sizeInBytes < Byte   				then 0 
            else if sizeInBytes < Number.Power(Byte, 2) then 1 
            else if sizeInBytes < Number.Power(Byte, 3) then 2 
            else if sizeInBytes < Number.Power(Byte, 4) then 3 
            else 4,

//  Record.FieldOrDefault
    f=(x)=>Record.FieldOrDefault([1 = "–ë—Ä–µ—Å—Ç", 2 = "–í–∏—Ç–µ–±—Å–∫", 3 = "–ì–æ–º–µ–ª—å"], –ö–æ–¥–†–µ–≥–∏–æ–Ω–∞, null),
//  GetPathXLSX = // –ø—É—Ç—å –∫ –∏—Å—Ç–æ—á–Ω–∏–∫—É –¥–∞–Ω–Ω—ã—Ö –Ω–∞–∫—Ç–∏–≤–Ω–æ–≥–æ –¥–∞—Ç–∞—Å–µ–ø—Ç–∞ –Ω–∞ –æ—Å–Ω–æ–≤–µ –º–µ—Ç–∞–¥–∞–Ω–Ω—ã—Ö Parameters
    GetPathXLSX = // –ø—É—Ç—å –∫ –∏—Å—Ç–æ—á–Ω–∏–∫—É –¥–∞–Ω–Ω—ã—Ö –Ω–∞–∫—Ç–∏–≤–Ω–æ–≥–æ –¥–∞—Ç–∞—Å–µ–ø—Ç–∞ –Ω–∞ –æ—Å–Ω–æ–≤–µ –º–µ—Ç–∞–¥–∞–Ω–Ω—ã—Ö Parameters
		/* 
			–û–ø–∏—Å–∞–Ω–∏–µ:
				–ü–æ–ª—É—á–∞–µ–º –º–µ—Ç–∞–¥–∞–Ω–Ω—ã—Ö Parameters –∑–Ω–∞—á–µ–Ω–∏–µ –æ—Ç–¥–µ–ª—å–Ω–æ–≥–æ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞.
				–≠—Ç–æ —Å–≤—è–∑–∞–Ω–æ —Å —Ç–µ–º, —á—Ç–æ –≤ Parameters –≤–æ–∑–≤—Ä–∞—â–∞—é—Ç —Ç–æ–ª—å–∫–æ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –∞–∫—Ç–∏–≤–Ω–æ–≥–æ –¥–∞—Ç–∞—Å–µ—Ç–∞
			
			–†–µ–∑—É–ª—å—Ç–∞—Ç:
				–ø—É—Ç—å –∫ –∏—Å—Ç–æ—á–Ω–∏–∫—É –¥–∞–Ω–Ω—ã—Ö
		*/
		(Key as text) as text =>
		let
			from 	  = Parameters,
			Param	  = "pathXLSX",
			Metadata  = Value.Metadata(from),
			RecordVal = Record.FieldOrDefault(Metadata, Key, null),
			PathXLSX  = 
				if 	 RecordVal <> null and Record.HasFields(RecordVal, Param) 
				then RecordVal[pathXLSX] 
				else null
		in
			PathXLSX,
//  –ø—Ä–æ–≤–µ—Ä–∫–∞ —Ñ—É–Ω–∫—Ü–∏–∏ –µ—Å–ª–∏ –æ–Ω–∞ –ø–æ–ª—è–º–∏ –æ–±—Ä–∞–∑–æ–≤–∞–Ω–∞
    let 
        [   [tblShema], [param], [nms], [path], [load], [reorder], [shema], [result] ]
//  –î–æ–±–∞–≤–∏—Ç—å —Å—Ç—Ä–æ–∫—É
    addColOther = Table.InsertRows(addColumn, 61, {[ID_–°—Ç—Ä–æ–∫–∞ = 800, –°—Ç–∞—Ç—å—è–ò–º—è = "–ü—Ä–æ—á–∏–µ", –°—Ç—Ä–æ–∫–∞–°—Ç–∞—Ç—å—è = "800 –ü—Ä–æ—á–∏–µ"]} )
//  TORG.Query - –ü–û–î–ö–õ–Æ–ß–ï–ù–ò–ï (–Ω–µ —Å–¥–µ–ª–∞–ª –µ—â–µ –∏ –Ω–∞–¥–æ –ª–∏?!//!)
	TORG.Query   = (tbl as table) => Expression.Evaluate( "F_Form[TORG][TORG.Body](tbl)", #shared & [tbl=tbl]),
// 	–î–õ–Ø –ö–û–ü–ò–†–û–í–ê–ù–ò–Ø –í –ü–†–û–ï–ö–¢
	// DataSets  = // 1 —Å–æ–∑–¥–∞–µ–º –±–∞–∑—É –¥–∞–Ω–Ω—ã—Ö –º–æ–∏—Ö –æ—Ç—á–µ—Ç–æ–≤
	// 	let
	// 		sect = Record.ToTable(#shared),
	// 		from = Table.SelectRows(sect, each Text.StartsWith([Name], "DataSet_")),
	// 		SplitColumns = Table.RemoveColumns(Table.SplitColumn(from, "Name", Splitter.SplitTextByDelimiter("_", QuoteStyle.Csv), {"Name.1", "–ê—Ç—Ä–∏–±—É—Ç", "Company"}),{"Name.1"}),
	// 		AddColumn = Table.AddColumn(SplitColumns, "Index", each Record.FieldOrDefault(
	// 						[Mart = 1, Homel = 2, BKS = 3, Drog = 4], 
	// 						[Company], null)),
	// 		Reorder = Table.ReorderColumns(AddColumn,{"Index","Company", "–ê—Ç—Ä–∏–±—É—Ç", "Value"}),
	// 		TextLower = Table.TransformColumns(Reorder,{{"–ê—Ç—Ä–∏–±—É—Ç", Text.Lower, type text}})
	// 	in
	// 		TextLower,
	
	// DataShema = // 2 —Å–æ–∑–¥–∞–µ–º —Å—Ö–µ–º—ã —Ç–∞–±–ª–∏—Ü –æ—Ç—á–µ—Ç–æ–≤ –ø–æ –º–∞—Å–∫–µ. –ù–∞ –≤—ã—Ö–æ–¥–µ –∑–∞–ø–∏—Å—å: Name (–≤–∏–¥ –æ—Ç—á–µ—Ç–∞) + Value (—Ç–∞–±–ª–∏—Ü–∞ —Å–æ —Å—Ö–µ–º–æ–π)
	// 	let
	// 		sect = Record.ToTable(#shared),
	// 		from = Table.SelectRows(sect, each Text.StartsWith([Name], "DataSet_XLS")),
	// 	    tr   = Table.TransformColumns(from, {"Value",each Record.ToTable(_)}),
	// 		exp  = Table.ExpandTableColumn(tr, "Value", {"Name", "Value"}, {"–ò–º—è", "–ó–Ω–∞—á–µ–Ω–∏–µ"}),
	// 		grp  = Table.Group(exp, {"–ò–º—è"}, {{"Value", (x)=> F[fxShema](x[–ó–Ω–∞—á–µ–Ω–∏–µ] {0} )}}), // –ø–µ—Ä–≤–æ–µ –≤—Ö–æ–∂–¥–µ–Ω–∏–µ
	// 		rec  = Record.FromTable(Table.RenameColumns(grp,{{"–ò–º—è", "Name"}}))
	// 	in
	// 		rec,

//  fxLoadReport = // –≤–µ—Ä—Å–∏—è –≤ —Ñ–∞–π–ª–µ 40 –¥–æ –∏–∑–º–µ–Ω–Ω–µ–Ω–∏—è
    fxLoadReport = // –í–∞–∂–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è
		(REPORT_NAME as text, optional DATASET as number )  =>

		let 
				dataSet_Nomer1 = Number.From(Text.Split(prm_DataSet," "){0}),
				dataSet_Vid   = prm_LoadVar,
				TBL           = DataSets,
				TBL_SHEMA 	  = DataShema,
				// DATASET		  = 1,	//"Homel"
				
				dataSet_Nomer =   
					if   DATASET = null
				 	then dataSet_Nomer1
				 	else DATASET,

			// 	–ü—Ä–æ–≤–µ—Ä–∫–∞ 1. –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ –æ—Ç—á–µ—Ç–∞ –≤–æ –≤—Å–µ—Ö –¥–∞—Ç–∞—Å–µ—Ç–∞—Ö (–¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –æ—à–∏–±–∫–∏ –≤–≤–æ–¥–∞ –∏–º–µ–Ω–∏ –æ—Ç—á–µ—Ç–∞)
				fxCheckReport = 
					(list as list, txt as text) as logical => 
						List.Contains(allReport, txt),
    			allReport = List.Distinct(List.Combine(List.Transform(TBL[Value], each[Name]))),
				IsReport  = fxCheckReport(allReport,REPORT_NAME),

			//	–µ—Å–ª–∏ –æ—Ç—á–µ—Ç –µ—Å—Ç—å, —Ç–æ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º —Å–ø–∏—Å–æ–∫ –ø–æ–ª–µ–π –æ—Ç—á–µ—Ç–∞, –µ—Å–ª–∏ –Ω–µ—Ç, —Ç–æ –ø—É—Å—Ç–æ–π —Å–ø–∏—Å–æ–∫
				reportField = 	
					if IsReport
					then Record.Field(TBL_SHEMA, REPORT_NAME)[Header]
					else {},

			// 	–ü—Ä–æ–≤–µ—Ä–∫–∞ 2. –ø—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ –æ—Ç—á–µ—Ç–∞ –≤ –æ–¥–Ω–æ–º –¥–∞—Ç–∞—Å–µ—Ç–µ (–µ—Å—Ç—å –¥–∞–Ω—ã–µ –ø–æ –æ—Ç—á–µ—Ç—É –∏–ª–∏ –Ω–µ—Ç)
					fxCheckData = (inputTable as table, targetName as text) as logical =>
						let
							// –§–∏–ª—å—Ç—Ä–∞—Ü–∏—è –∏—Å—Ö–æ–¥–Ω–æ–π —Ç–∞–±–ª–∏—Ü—ã –ø–æ –∫–æ–ª–æ–Ω–∫–∞–º Vid –∏ Index
							filteredTable = 
								Table.SelectRows(inputTable, each 
									[Index] = dataSet_Nomer and
									[Vid]   = dataSet_Vid
								),

							// –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –Ω–∞–ª–∏—á–∏—è targetName –≤ –ø–æ–¥—Ç–∞–±–ª–∏—Ü–µ
							CheckSubTable = (subTable as table) as logical =>
								List.Contains(Table.Column(subTable, "Name"), targetName),

							// –ü–æ–ª—É—á–∞–µ–º —Å–ø–∏—Å–æ–∫ –≤—Å–µ—Ö –ø–æ–¥—Ç–∞–±–ª–∏—Ü –∏–∑ –æ—Ç—Ñ–∏–ª—å—Ç—Ä–æ–≤–∞–Ω–Ω–æ–π —Ç–∞–±–ª–∏—Ü—ã
							nestedTables = Table.Column(filteredTable, "Value"),

							// –ü—Ä–∏–º–µ–Ω—è–µ–º —Ñ—É–Ω–∫—Ü–∏—é CheckSubTable –∫ –∫–∞–∂–¥–æ–π –ø–æ–¥—Ç–∞–±–ª–∏—Ü–µ –∏ –ø—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ targetName
							result = List.AnyTrue(List.Transform(nestedTables, CheckSubTable))
						in
							result,

				// –ø—Ä–æ–≤–µ—Ä–∫–∞
					IsData = fxCheckData(TBL, REPORT_NAME),

			//	–í–∞—Ä–∏–∞–Ω—Ç 1: —Ç–∞–±–ª–∏—Ü–∞ —Å –¥–∞–Ω–Ω—ã–º–∏ –æ—Ç—á–µ—Ç–∞ (—Ñ–∏–ª—å—Ç—Ä—É–µ–º –¥–∞—Ç–∞—Å–µ—Ç –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ –µ–µ –ø–µ—Ä–≤–æ–π –ø–æ–¥—Å—Ç—Ä–æ–∫–∏ –∏–ª–∏ null
				tableReport = 
					let from = Table.SelectRows(TBL, each [Index]= dataSet_Nomer and [Vid]=dataSet_Vid),
						data = from [Value] {0}, // –≤ –∫–æ–ª–æ–Ω–∫–µ "Value" –ø–µ—Ä–≤–∞—è —Å—Ç—Ä–æ–∫–∞
						to   =  Table.SelectRows(data, each [Name]= REPORT_NAME)[Value]{0}
					in  try to otherwise null,
					 
			//	–í–∞—Ä–∏–∞–Ω—Ç 2: –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –ø—É—Å—Ç—É—é —Ç–∞–±–ª–∏—Ü—É + –Ω–µ—Å–∫–æ–ª—å–∫–æ –∑–∞–ø–æ–ª–Ω–µ–Ω–Ω—ã—Ö —Å—Ç—Ä–æ–∫
				// tableBlank = F_Form[form.BlankTable](REPORT_NAME),
				tableBlank = F_Form[form.BlankTable](TBL_SHEMA, REPORT_NAME),

			//	–í—ã–≥—Ä—É–∂–∞–µ–º —Ç–∞–±–ª–∏—Ü—ã
				res =   if   IsReport = true and IsData = true // –µ—Å–ª–∏ –Ω–∞–π–¥–µ–Ω –æ—Ç—á–µ—Ç —Å —Ç–∞–∫–∏–º–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏ –≤ DataSets
						then tableReport
				 		else tableBlank
	
        in  
            res
       

//  –ü—Ä–æ shared 

    let
        // –ü–æ–ª—É—á–µ–Ω–∏–µ –≤—Å–µ—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –∏–∑ –≥–ª–æ–±–∞–ª—å–Ω–æ–π —Å—Ä–µ–¥—ã
        AllQueries = Record.FieldNames(#shared),
        
        // –§–∏–ª—å—Ç—Ä–∞—Ü–∏—è –∏–º–µ–Ω, –∫–æ—Ç–æ—Ä—ã–µ –Ω–∞—á–∏–Ω–∞—é—Ç—Å—è —Å "data"
        FilteredNames = List.Select(AllQueries, each Text.StartsWith(_, "DataSet_")),
        
        // –ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ —Å–ø–∏—Å–∫–∞ –∏–º–µ–Ω –≤ —Ç–∞–±–ª–∏—Ü—É
        NameTable = Table.FromList(FilteredNames, Splitter.SplitByNothing(), {"Name"}),
        add  = Table.AddColumn(NameTable, "w", each Expression.Evaluate([Name],#shared & [_=_])),
        exp = let 
            exp1 = Table.ExpandTableColumn(add, "w", {"ID", "Value"}, {"ID", "Value"}),
            exp2 = Table.ExpandTableColumn(exp1, "Value", {"Name"}, {"Name.1"}),
            sel  = Table.SelectColumns(exp2,{"ID"})
        in sel,
        –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–π1 = List.Distinct(exp[ID])
    in
        –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–π1

    = Expression.Evaluate("DataSet_1",#shared & [DataSet_1=DataSet_1]) // —Ç–∞–∫ —Ä–∞–±–æ—Ç–∞–µ—Ç
    = List.Distinct(List.Combine(List.Transform(–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–π1[Value], each [ID])))


    –Ø –ø—Ä–æ–≤–µ—Ä—è–ª –Ω–µ –≤ —Å–µ—Ä–≤–∏—Å–µ, –∞ –≤ –¥–µ—Å–∫—Ç–æ–ø–µ - —Ç–∞–º —Ä–∞–±–æ—Ç–∞–µ—Ç.
    –ê –≤–æ—Ç –ø—Ä–æ —Ü–∏–∫–ª–∏—á–Ω–æ—Å—Ç—å —É–ø—É—Å—Ç–∏–ª, –ø–æ—ç—Ç–æ–º—É —á—É—Ç—å –Ω–∞–ø—Ä—è–∂–Ω–µ–µ:
    let
        from = Table.SelectRows(Record.ToTable(#shared),each [Name]<>"–ï–≤–ª–∞–º–ø–∏–π" and Value.Is([Value],Table.Type))[Name],
        lst = List.Transform(from,(z)=>Expression.Evaluate("#(#)""" & z & """",#shared)),
        to = Table.Combine(lst)
    in
        to

    // –∑–µ–ª–µ–Ω—Å–∫–∏–π
        –ï–≤–ª–∞–º–ø–∏–π = 
        let
            from = Table.SelectRows(Record.ToTable(#shared),each [Name]<>"–ï–≤–ª–∞–º–ø–∏–π" and Value.Is([Value],Table.Type))[Value],
            to = Table.Combine(from)
        in
            to
    –•–æ—Ç—è –ø–æ –∏–¥–µ–µ –Ω–µ –¥–æ–ª–∂–µ–Ω.

    –µ—â–µ –ø—Ä–∏–º–µ—Ä –∫–æ–≥–¥–∞ –º–Ω–æ–≥–æ –º–Ω–æ–≥–æ –∑–∞–ø—Ä–æ—Å–æ–≤ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—Ç—å –Ω–∞–¥–æ

    TableAddColumn=(tbl,name,func, optional typ)=>
        [
            rec = Table.ToRecords(tbl),
            nms = Table.ColumnNames(tbl)&{name},
            g=(x)=>Record.FieldValues(x)&{func(x)},
            newtyp = if typ=null then Type.FunctionReturn(Value.Type(func)) else typ,
            newtbl = Table.FromList(rec,g,nms),
            lst  = {Text.Combine(List.Transform(Table.ToRows(Table.Schema(from)[[Name],[TypeName]]),(x)=>Text.Format("#{0}=#{1}, ",x))),name,Table.Schema(#table(type table [n=newtyp],{})){0}[TypeName]},
            txt  = Text.Format("type table[ #{0} #{1} = #{2}]",lst),
            ascr = Expression.Evaluate( txt, #shared),
            to   = Value.ReplaceType(newtbl,ascr)
        ][to]


//  –¥–ª—è –ø—Ä–∏–º–µ—Ä–∞
    DataSet_1 = 
    Table.FromRecords({
            [ID = 1, NestedTable = Table.FromRecords({[Name = "Alice"], [Name = "Bob"]})],
            [ID = 2, NestedTable = Table.FromRecords({[Name = "Charlie"], [Name = "Alice"]})],
            [ID = 3, NestedTable = Table.FromRecords({[Name = "David"], [Name = "Eve"]})]
        })

    DS = 
    let
        from = Table.SelectRows(Record.ToTable(#shared), each Text.StartsWith([Name], "DataSet_")),
        sel  = Table.SelectRows(from, each ([Name] = "DataSet_XLS_Bob")),
        –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–π1 = Table.TransformColumns(sel, {"Value", each _ as table, type table}),
        Value = –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–π1{0}[Value]
    in
        Value

//  IsReport     = // –ø—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞–ª–∏—á–∏—è –æ—Ç—á–µ—Ç–∞. –†–∞–∑–æ–±—Ä–∞—Ç—å, –Ω–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–ª
	IsReport     = //* 
		let 
			IsRep = (tableNames as list )=>
				let
					// –§—É–Ω–∫—Ü–∏—è –¥–ª—è –±–µ–∑–æ–ø–∞—Å–Ω–æ–≥–æ –∏–∑–≤–ª–µ—á–µ–Ω–∏—è —Ç–∞–±–ª–∏—Ü—ã –ø–æ –∏–º–µ–Ω–∏
					GetTable = (tableName as text) as table => 
						try Expression.Evaluate(tableName, #shared) otherwise null,

					// –°–æ–∑–¥–∞–Ω–∏–µ –∑–∞–ø–∏—Å–∏ —Å –ø—Ä–æ–≤–µ—Ä–µ–Ω–Ω—ã–º–∏ –∑–Ω–∞—á–µ–Ω–∏—è–º–∏ —Ç–∞–±–ª–∏—Ü
					rec = Record.FromList(
						List.Transform(tableNames, each GetTable(_)),
						List.Transform({1..List.Count(tableNames)}, each Text.From(_))
					)
				in rec
		in
			IsRep({"opu"}),
//  –¥–æ–±–∞–≤–ª–µ–Ω–∏–µ —Å—Ç—Ä–æ–∫ –≤ –∏–º–µ—é—â—É—é—Å—è —Ç–∞–±–ª–∏—Ü—É !
    –í–æ—Ç –æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è –∫–æ–¥–∞ –¥–ª—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è —Å—Ç—Ä–æ–∫ –≤ —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É—é—â—É—é —Ç–∞–±–ª–∏—Ü—É:

        let
            // –ü—Ä–µ–¥–ø–æ–ª–æ–∂–∏–º, —á—Ç–æ —É –Ω–∞—Å —É–∂–µ –µ—Å—Ç—å —Å—É—â–µ—Å—Ç–≤—É—é—â–∞—è —Ç–∞–±–ª–∏—Ü–∞ existingTable
            existingTable = ...,

            // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –∑–Ω–∞—á–µ–Ω–∏—è –ø–æ–ª—è –∏–ª–∏ null, –µ—Å–ª–∏ –ø–æ–ª–µ –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
            getFieldOrDefault = 
                (rec as record, field as text) as any =>
                    if Record.HasFields(rec, field) then Record.Field(rec, field) else null,

            // –°–æ–∑–¥–∞–Ω–∏–µ —Å–ø–∏—Å–∫–∞ –Ω–æ–≤—ã—Ö –∑–∞–ø–∏—Å–µ–π
            newRecords = List.Transform(dataList, (rec as record) =>
                Record.FromList(
                    List.Transform(nms, each getFieldOrDefault(rec, _)), 
                    nms
                )
            ),
            
            // –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –Ω–æ–≤—ã—Ö —Å—Ç—Ä–æ–∫ –∫ —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–π —Ç–∞–±–ª–∏—Ü–µ
            tableAddedRows = Table.Combine({existingTable, Table.FromRecords(newRecords, nms)})
        in
            tableAddedRows

    –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏, –≤–Ω–µ—Å–µ–Ω–Ω—ã–µ –≤ –∫–æ–¥:
    –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–π —Ç–∞–±–ª–∏—Ü—ã: –ü–µ—Ä–µ–º–µ–Ω–Ω–∞—è existingTable –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è–µ—Ç —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É—é—â—É—é —Ç–∞–±–ª–∏—Ü—É.
    –°–æ–∑–¥–∞–Ω–∏–µ –Ω–æ–≤—ã—Ö –∑–∞–ø–∏—Å–µ–π: newRecords —Å–æ–∑–¥–∞–µ—Ç—Å—è –∏–∑ dataList —Å –ø–æ–º–æ—â—å—é List.Transform –∏ —Ñ—É–Ω–∫—Ü–∏–∏ getFieldOrDefault.
    –û–±—ä–µ–¥–∏–Ω–µ–Ω–∏–µ —Ç–∞–±–ª–∏—Ü: –ò—Å–ø–æ–ª—å–∑—É–µ–º Table.Combine –¥–ª—è –æ–±—ä–µ–¥–∏–Ω–µ–Ω–∏—è —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–π —Ç–∞–±–ª–∏—Ü—ã existingTable –∏ –Ω–æ–≤–æ–π —Ç–∞–±–ª–∏—Ü—ã, —Å–æ–∑–¥–∞–Ω–Ω–æ–π –∏–∑ newRecords.
    –≠—Ç–æ—Ç –∫–æ–¥ –ø–æ–∑–≤–æ–ª—è–µ—Ç –¥–æ–±–∞–≤–ª—è—Ç—å –Ω–æ–≤—ã–µ —Å—Ç—Ä–æ–∫–∏ –∫ —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–π —Ç–∞–±–ª–∏—Ü–µ, –æ–±–µ—Å–ø–µ—á–∏–≤–∞—è –ø—Ä–∏ —ç—Ç–æ–º –æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ –∏ –ø—Ä–æ—Ñ–µ—Å—Å–∏–æ–Ω–∞–ª—å–Ω–æ–µ —Ä–µ—à–µ–Ω–∏–µ.

//  —Å–æ–∑–¥–∞—Ç—å –ø—É—Å—Ç—É—é —Ç–∞–±–ª–∏—Ü—É —Å –Ω–æ–≤—ã–º–∏ —Å—Ç—Ä–æ–∫–∞–º–∏
        // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –∑–Ω–∞—á–µ–Ω–∏—è –ø–æ–ª—è –∏–ª–∏ null, –µ—Å–ª–∏ –ø–æ–ª–µ –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
			getFieldOrDefault = 
                (rec as record, field as text) as any =>
					if Record.HasFields(rec, field) then Record.Field(rec, field) else null,

		// –°–æ–∑–¥–∞–Ω–∏–µ —Ç–∞–±–ª–∏—Ü—ã —Å –¥–∞–Ω–Ω—ã–º–∏
            tableAddedRows2 = Table.FromRecords(
                List.Transform(
                    dataList2, 
                    (rec as record) =>
                        Record.FromList(
                            List.Transform(nms, (x)=> getFieldOrDefault(rec, x)), 
                            nms
                        )
                ),
                nms
            ),
        1 –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ getFieldOrDefault: –í–≤–µ–ª–∏ –≤—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—É—é —Ñ—É–Ω–∫—Ü–∏—é getFieldOrDefault, —á—Ç–æ–±—ã –∏–∑–±–µ–∂–∞—Ç—å –ø–æ–≤—Ç–æ—Ä–Ω–æ–≥–æ –≤—ã–∑–æ–≤–∞ Record.FieldOrDefault –≤ List.Transform. –≠—Ç–æ —É–ª—É—á—à–∞–µ—Ç —á–∏—Ç–∞–µ–º–æ—Å—Ç—å –∏ –Ω–µ–º–Ω–æ–≥–æ —É—Å–∫–æ—Ä—è–µ—Ç –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ.
        
        2 –ó–∞–º–µ–Ω–∞ Table.InsertRows –Ω–∞ Table.FromRecords: –°–æ–∑–¥–∞–Ω–∏–µ —Ç–∞–±–ª–∏—Ü—ã —Å –ø–æ–º–æ—â—å—é Table.FromRecords –∏ —Å—Ä–∞–∑—É –∑–∞–ø–æ–ª–Ω–µ–Ω–∏–µ –µ—ë –¥–∞–Ω–Ω—ã–º–∏ –≤–º–µ—Å—Ç–æ —Å–æ–∑–¥–∞–Ω–∏—è –ø—É—Å—Ç–æ–π —Ç–∞–±–ª–∏—Ü—ã –∏ –ø–æ—Å–ª–µ–¥—É—é—â–µ–≥–æ –∑–∞–ø–æ–ª–Ω–µ–Ω–∏—è. 

// 	form.BlankTable = // 4 —Å–æ–∑–¥–∞–µ–º –ø—É—Å—Ç—É—é —Ç–∞–±–ª–∏—Ü—É –ø–æ –∏–º–µ–Ω–∏ –æ—Ç—á–µ—Ç–∞, —á—Ç–æ–±—ã —Å–≤—è–∑–∏ —Å –∫–∞–ª–µ–Ω–¥–∞—Ä–µ–º –Ω–µ –ø—Ä–æ–ø–∞–¥–∞–ª–∞
	form.BlankTable = // 4 —Å–æ–∑–¥–∞–µ–º –ø—É—Å—Ç—É—é —Ç–∞–±–ª–∏—Ü—É –ø–æ –∏–º–µ–Ω–∏ –æ—Ç—á–µ—Ç–∞, —á—Ç–æ–±—ã —Å–≤—è–∑–∏ —Å –∫–∞–ª–µ–Ω–¥–∞—Ä–µ–º –Ω–µ –ø—Ä–æ–ø–∞–¥–∞–ª–∞
		(	tblShema as record, 	// –ó–∞–ø–∏—Å—å! —Å–æ —Å—Ö–µ–º–∞–º–∏ —Ç–∞–±–ª–∏—Ü –æ—Ç—á–µ—Ç–æ–≤ tableShema
			REPORT_NAME as text		// –∏–º—è –æ—Ç—á–µ—Ç–∞
		) =>
			let
				//  REPORT_NAME = "odds",
				//  tbl = tableShema,
					from = tblShema,

				//	–∏–º–µ–Ω–∞ —Å—Ç–æ–ª–±—Ü–æ–≤ ... –µ—Å–ª–∏ —Å—Ö–µ–º–∞ –≤—Å–µ—Ö –æ—Ç—á–µ—Ç–Ω—ã—Ö —Ç–∞–±–ª–∏—Ü –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∞ Record
					nms  = Record.Field(from, REPORT_NAME)[Header],
				
				//	–∏–º–µ–Ω–∞ —Å—Ç–æ–ª–±—Ü–æ–≤? –ù–∞ –≤—ã—Ö–æ–¥–µ –∂–µ —Ç–∞–±–ª–∏—Ü–∞ ... –µ—Å–ª–∏ —Å—Ö–µ–º–∞ –≤—Å–µ—Ö –æ—Ç—á–µ—Ç–Ω—ã—Ö —Ç–∞–±–ª–∏—Ü –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∞ Table
					nms2  = Table.Column(
								Table.SelectRows(from, each [–ê—Ç—Ä–∏–±—É—Ç] = REPORT_NAME)
								{0}[–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ], 	// –ø–µ—Ä–≤–∞—è —Å—Ç—Ä–æ–∫–∞ –∫–æ–ª–æ–Ω–∫–∏ [–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ] –≤ –æ—Å–Ω–æ–≤–Ω–æ–π —Ç–∞–±–ª–∏—Ü–µ 
								"Name" 				// –∏–º—è –∫–æ–ª–æ–Ω–∫–∏ —Å –Ω–∞–∑–≤–∞–Ω–∏—è–º–∏ –∫–æ–ª–æ–Ω–æ–∫ –≤ –ø–æ–¥—Ç–∞–±–ª–∏—Ü–µ
							),

				//	
					–ü—É—Å—Ç—ã–µ–ö–æ–ª–æ–Ω–∫–∏1 = List.Transform(nms, each {}),              // –ø—É—Å—Ç–∞—è —Ç–∞–±–ª–∏—Ü–∞ - —Å—Ç—Ä–æ–∫ –Ω–µ—Ç
					–ü—É—Å—Ç—ã–µ–ö–æ–ª–æ–Ω–∫–∏2 = List.Repeat( {{""}}, List.Count(nms) ),    // –ø—É—Å—Ç–∞—è —Ç–∞–±–ª–∏—Ü–∞ - —Å—Ç—Ä–æ–∫–∞ –æ–¥–Ω–∞ –ø—É—Å—Ç–∞—è
					
					CreatedTable = Table.FromColumns(–ü—É—Å—Ç—ã–µ–ö–æ–ª–æ–Ω–∫–∏1, nms),      // —Å–æ–∑–¥–∞–µ–º —Ç–∞–±–ª–∏—Ü—É
				
				// 	–¥–æ–±–∞–≤–ª—è–µ–º —Å—Ç—Ä–æ–∫—É —Å –¥–∞—Ç–æ–π, —á—Ç–æ–±—ã –Ω–µ —Ä—É—à–∏–ª–∞—Å—å —Å–≤—è–∑—å —Å –∫–∞–ª–µ–Ω–¥–∞—Ä–µ–º
					–î–∞–Ω–Ω—ã–µ = 
						{
							Record.FromList( 
								List.Transform(nms, each if _ = "Date" then #date(2023, 12, 1) else null ), 
								nms) 
						},

				// 	–±–µ—Ä–µ–º –ø–µ—Ä–≤—ã–µ 5 –∫–æ–ª–æ–Ω–æ–∫
					fromOneRows  = Table.InsertRows(CreatedTable, 0, –î–∞–Ω–Ω—ã–µ),
					from5Columns = Table.SelectColumns(fromOneRows, List.FirstN(Table.ColumnNames(fromOneRows), 5)),
				
				//	–Ω–æ–≤–∞—è —Ç–∞–±–ª–∏—Ü–∞ –∏–∑ —á–µ—Ç—ã—Ä–µ—Ö –∫–æ–ª–æ–Ω–æ–∫. –ú–∏–Ω—É—Å - —Å–±–∏–≤–∞–µ—Ç—Å—è –≥—Ä—É–ø–ø–∏—Ä–æ–≤–∫–∞ –ø–æ–ª–µ–π!
					NewTable = 
						let create = 
								Table.FromRecords({[
									Date = #date(2024, 7, 9),  
									Company = null,
									DataSet = null,
									Report_ID = null
								]}),
							TypedTable = Table.TransformColumnTypes(create, {{"Date", type date}})
						in TypedTable,
				
				// 	—Ç–∏–ø–∏–∑–∏—Ä—É–µ–º —Å—Ç–æ–ª–±—Ü—ã
					// typed = F[form.SetType](fromOneRows, from, REPORT_NAME)
					typed = form.SetType2(fromOneRows, from, REPORT_NAME)	// ??? –Ω–æ–º–µ—Ä 2
			in
				try typed 			//	
				otherwise NewTable,	//
//  form.BlankTable2 = // –≤—Å—Ç–∞–≤–ª—è–µ–º –Ω–æ–≤—É—é —Ç–∞–±–ª–∏—Ü—É, —Å–æ –∑–Ω–∞—á–µ–Ω–∏—è–º–∏ —Å—Ç—Ä–æ–∫ –∏–ª–∏ –ø—É—Å—Ç—É—é (–Ω–µ –¥–æ–±–∞–≤–ª–µ–Ω–∏–µ –≤ –∏–º–µ—é—â—É—é—Å—è)
	form.BlankTable2 = // –≤—Å—Ç–∞–≤–ª—è–µ–º –Ω–æ–≤—É—é —Ç–∞–±–ª–∏—Ü—É, —Å–æ –∑–Ω–∞—á–µ–Ω–∏—è–º–∏ —Å—Ç—Ä–æ–∫ –∏–ª–∏ –ø—É—Å—Ç—É—é (–Ω–µ –¥–æ–±–∞–≤–ª–µ–Ω–∏–µ –≤ –∏–º–µ—é—â—É—é—Å—è)
		(	TBL_SHEMA   as record,	// —Ç–∞–±–ª–∏—Ü–∞ —Å —Ç–∏–ø–∞–º–∏ –∫–æ–ª–æ–Ω–æ–∫ –≤—Å–µ—Ö –æ—Ç—á–µ—Ç–æ–≤
			REPORT_NAME as text
		)=>
			let 
				// 	–∏–º–µ–Ω–∞ –∫–æ–ª–æ–Ω–æ–∫ –æ—Ç—á–µ—Ç–∞
					nms  = Record.Field(TBL_SHEMA, REPORT_NAME)[Header],
				
				// 	–∑–Ω–∞—á–µ–Ω–∏—è —Å—Ç—Ä–æ–∫. –ï—Å–ª–∏ –ø–æ–ª–µ–π —Å —Ç–∞–∫–∏–º–∏ –Ω–∞–∑–≤–∞–Ω–∏—è–º–∏ –Ω–µ—Ç, –æ—à–∏–±–∫–∏ –Ω–µ –±—É–¥–µ—Ç, –¥–∞–Ω–Ω—ã–µ –ø—Ä–æ—Å—Ç–æ –Ω–µ –±—É–¥—É—Ç –¥–æ–±–∞–≤–ª–µ–Ω—ã
					–ó–∞–ø–∏—Å—å1 = [Date = #date(2022, 6, 1), –°—Ç—Ä–æ–∫–∞_ID = 104, –ù–∞ –Ω–∞—á–∞–ª–æ = 354],
					–ó–∞–ø–∏—Å—å2 = [
						Date        = #date(2023, 6, 1), 
						–°—Ç—Ä–æ–∫–∞_ID   = 104, 
						–ó–Ω–∞—á–µ–Ω–∏–µ    = 256, 
						–ê—Ç—Ä–∏–±—É—Ç     = "–ü—Ä–æ—Å—Ä–æ—á–µ–Ω–Ω–∞—è"
					],
				
				// 	—Å–ø–∏—Å–æ–∫ –∑–∞–ø–∏—Å–µ–π = —Å–ø–∏—Å–∫—É —Å—Ç—Ä–æ–∫
					lst = {–ó–∞–ø–∏—Å—å1, –ó–∞–ø–∏—Å—å2},
					lst2 = {},
				
				//	–ø—Ä–∏–º–µ–Ω–µ–Ω–∏–µ —Ñ—É–Ω–∫—Ü–∏–∏ –∫ –∫–∞–∂–¥–æ–π –∑–∞–ø–∏—Å–∏
					tableAddedRows = 
						Table.InsertRows(
							Table.FromColumns(List.Transform(nms, each {}),  nms),
							0, 
							List.Transform(lst, 
								(rec as record) as record =>
									Record.FromList( 
										List.Transform( nms, (x)=> Record.FieldOrDefault(rec, x, null)), 
										nms
									)
							)
						),
				
				// 	–º–µ–Ω—è–µ–º —Ç–∏–ø –≤—Å–µ—Ö –∫–æ–ª–æ–Ω–æ–∫ —Ç–∞–±–ª–∏—Ü—ã –ø–æ —à–∞–±–ª–æ–Ω—É - —Ç–∞–±–ª–∏—Ü–∞ "tableShema"
					typedTable = F[form.SetType2](tableAddedRows, TBL_SHEMA, REPORT_NAME)
			in
				try typedTable 
				otherwise {},	// –µ—Å–ª–∏ –≤ –Ω–∞–∑–≤–∞–Ω–∏–∏ –æ—Ç—á–µ—Ç–∞ –æ—à–∏–±–∫–∞
//  –æ–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–∫–æ–∫ —á–µ—Ä–µ–∑ ?? 
    nms = Record.FieldOrDefault(TBL_SHEMA, REPORT_NAME, null)[Header]? ?? {},
//  tableShemaCSV = // —Å—Ö–µ–º–∞ –≤—Å–µ—Ö –æ—Ç—á–µ—Ç–æ–≤ –ø—É—Ç–µ–º –∏–º–ø–æ—Ä—Ç–∞ –∏–∑ csv //* –ü–µ—Ä–µ—Å—Ç–∞—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è
    tableShemaCSV = // —Å—Ö–µ–º–∞ –≤—Å–µ—Ö –æ—Ç—á–µ—Ç–æ–≤ –ø—É—Ç–µ–º –∏–º–ø–æ—Ä—Ç–∞ –∏–∑ csv //* –ü–µ—Ä–µ—Å—Ç–∞—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è
		let	
			from = F[LoadCSV]( Value.Metadata(Parameters)[Homel][pathCSV] & "\tableSchema.csv" ),
			repl = Table.ReplaceValue(from,"balanc","bal",Replacer.ReplaceText,{"Name"}),
			rec  = Record.FromTable( Table.Group(repl, {"Name"}, {{"Value", (x)=>x}}) )
		in	
			rec,
//  DataSetsMidl = //* –¥–∞—Ç–∞—Å–µ—Ç, –≤ –∑–∞–ø–∏—Å—è—Ö –≤–º–µ—Å—Ç–æ —Ç–∞–±–ª–∏—Ü —Å—Ç–∞–≤–∏–º 1 	
    DataSetsMidl = //* –¥–∞—Ç–∞—Å–µ—Ç, –≤ –∑–∞–ø–∏—Å—è—Ö –≤–º–µ—Å—Ç–æ —Ç–∞–±–ª–∏—Ü —Å—Ç–∞–≤–∏–º 1 	
		let
			from = Table.SelectRows(Record.ToTable(#sections[Section1]), each Text.StartsWith([Name], "DataSet_")),
			fxRec = 
				let
					// –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ —Ç–∏–ø–∞ –¥–∞–Ω–Ω—ã—Ö
					CheckType = (value as any) as number =>
						if Type.Is(Value.Type(value), type table) 
						then 1
						else 0,

					// –§—É–Ω–∫—Ü–∏—è –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∑–∞–ø–∏—Å–µ–π
					ProcessRecord = (rec as record) as record =>
						let
							fields = Record.FieldNames(rec),
							newFields = List.Transform(fields, each {_, CheckType(Record.Field(rec, _))}),
							transformedRecord = Record.FromList(List.Transform(newFields, each _{1}), fields)
						in
							transformedRecord
				in
					ProcessRecord,
//  fxRec2=()=>
			fxRec2=()=>
				let
					// –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ —Ç–∏–ø–∞ –¥–∞–Ω–Ω—ã—Ö
					CheckType = (value as any) as number =>
						if Type.Is(Value.Type(value), type table) 
						then 1
						else 0,

					// –§—É–Ω–∫—Ü–∏—è –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∑–∞–ø–∏—Å–µ–π
					ProcessRecord = (rec as record) as record =>
						let
							fields = Record.FieldNames(rec),
							newFields = List.Transform(fields, each {_, CheckType(Record.Field(rec, _))}),
							transformedRecord = Record.FromList(List.Transform(newFields, each _{1}), fields)
						in
							transformedRecord
				in
					ProcessRecord,

			–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–π1 = Table.TransformColumns(from, {"Value", each fxRec2(_)}),
			
			// –ü–æ–ª—É—á–µ–Ω–∏–µ –≤—Å–µ—Ö –∏–º–µ–Ω –ø–æ–ª–µ–π!!!
			AllFieldNames = List.Buffer(List.Union(List.Transform(–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–π1[Value], Record.FieldNames))),

			exp = Table.ExpandRecordColumn(–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–π1,"Value", AllFieldNames),
			Unpivot = Table.UnpivotOtherColumns(exp, {"Name"}, "–ê—Ç—Ä–∏–±—É—Ç", "–ó–Ω–∞—á–µ–Ω–∏–µ"),
			
			del = let 
				s = Table.SplitColumn(Unpivot, "Name", Splitter.SplitTextByDelimiter("_", QuoteStyle.Csv), {"Name.1", "–í–∏–¥", "Company"}),
				a = Table.RemoveColumns(s,{"Name.1"}),
				b = Table.ReorderColumns(a,{"Company", "–í–∏–¥", "–ê—Ç—Ä–∏–±—É—Ç", "–ó–Ω–∞—á–µ–Ω–∏–µ"}),
				c = Table.ReplaceErrorValues(b, {{"–ó–Ω–∞—á–µ–Ω–∏–µ", -1}}),
				d = Table.TransformColumns(c,{{"–í–∏–¥", Text.Lower, type text}})
			in  d
		in
			del,
	DataSetsOld  = //* –Ω–µ –∏—Å–ø–æ–ª—å–∑—É—é. –ó–∞–º–µ–Ω–∏–ª –Ω–∞ #sections[Section1]
		let
			// —Å–æ–∑–¥–∞–µ–º —Ç–∞–±–ª–∏—Ü—É —Å –¥–∞—Ç–∞—Å–µ—Ç–∞–º–∏ –≤—Å–µ—Ö –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏–π. –ï—Å–ª–∏ –∏—Ö –Ω–µ—Ç, —Ç–æ null
			// —á–µ—Ä–µ–∑ #sections1 –Ω–µ –≤–∏–¥–∏—Ç —Ç–∏–ø –¥–∞–Ω–Ω—ã—Ö Record –≤ PBI –≤ —Ä–µ–∂–∏–º–µ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏–µ —Ç–∞–±–ª–∏—Ü—ã, –ø–æ—ç—Ç–æ–º—É –Ω–µ –º–æ–∂–µ—Ç –≥—Ä—É–∑–∏—Ç—å –¥–∞–Ω–Ω—ã–µ –≤ –º–æ–¥–µ–ª—å. –í Excel –≤—Å–µ –Ω–æ—Ä–º–∞–ª—å–Ω–æ.

			from = #table( type table[Index = number, Name = text, xls = any, csv = any], {
				// {1, "Mart",  DataSet_XLS_Mart,  DataSet_CSV_Mart},
				// {2, "Homel", DataSet_XLS_Homel, DataSet_CSV_Homel},
				// {3, "BKS",   null,   null},
				// {4, "Drog",  DataSet_XLS_Drog,  DataSet_CSV_Drog}
			} ),

			unpivot = Table.UnpivotOtherColumns(from, {"Index", "Name"}, "–ê—Ç—Ä–∏–±—É—Ç", "–ó–Ω–∞—á–µ–Ω–∏–µ")
		in
			unpivot,

	
//  form.BlankTable = // 4 —Å–æ–∑–¥–∞–µ–º –ø—É—Å—Ç—É—é —Ç–∞–±–ª–∏—Ü—É –ø–æ –∏–º–µ–Ω–∏ –æ—Ç—á–µ—Ç–∞, —á—Ç–æ–±—ã —Å–≤—è–∑–∏ —Å –∫–∞–ª–µ–Ω–¥–∞—Ä–µ–º –Ω–µ –ø—Ä–æ–ø–∞–¥–∞–ª–∞
    form.BlankTable = // 4 —Å–æ–∑–¥–∞–µ–º –ø—É—Å—Ç—É—é —Ç–∞–±–ª–∏—Ü—É –ø–æ –∏–º–µ–Ω–∏ –æ—Ç—á–µ—Ç–∞, —á—Ç–æ–±—ã —Å–≤—è–∑–∏ —Å –∫–∞–ª–µ–Ω–¥–∞—Ä–µ–º –Ω–µ –ø—Ä–æ–ø–∞–¥–∞–ª–∞
		(	tblShema as record, 	// –ó–∞–ø–∏—Å—å! —Å–æ —Å—Ö–µ–º–∞–º–∏ —Ç–∞–±–ª–∏—Ü –æ—Ç—á–µ—Ç–æ–≤ tableShema
			REPORT_NAME as text		// –∏–º—è –æ—Ç—á–µ—Ç–∞
		) =>
			let
				//  REPORT_NAME = "odds",
				//  tbl = tableShema,
					from = tblShema,

				//	–∏–º–µ–Ω–∞ —Å—Ç–æ–ª–±—Ü–æ–≤ ... –µ—Å–ª–∏ —Å—Ö–µ–º–∞ –≤—Å–µ—Ö –æ—Ç—á–µ—Ç–Ω—ã—Ö —Ç–∞–±–ª–∏—Ü –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∞ Record
					nms  = Record.Field(from, REPORT_NAME)[Header],
				
				//	–∏–º–µ–Ω–∞ —Å—Ç–æ–ª–±—Ü–æ–≤? –ù–∞ –≤—ã—Ö–æ–¥–µ –∂–µ —Ç–∞–±–ª–∏—Ü–∞ ... –µ—Å–ª–∏ —Å—Ö–µ–º–∞ –≤—Å–µ—Ö –æ—Ç—á–µ—Ç–Ω—ã—Ö —Ç–∞–±–ª–∏—Ü –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∞ Table
					nms2  = Table.Column(
								Table.SelectRows(from, each [–ê—Ç—Ä–∏–±—É—Ç] = REPORT_NAME)
								{0}[–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ], 	// –ø–µ—Ä–≤–∞—è —Å—Ç—Ä–æ–∫–∞ –∫–æ–ª–æ–Ω–∫–∏ [–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ] –≤ –æ—Å–Ω–æ–≤–Ω–æ–π —Ç–∞–±–ª–∏—Ü–µ 
								"Name" 				// –∏–º—è –∫–æ–ª–æ–Ω–∫–∏ —Å –Ω–∞–∑–≤–∞–Ω–∏—è–º–∏ –∫–æ–ª–æ–Ω–æ–∫ –≤ –ø–æ–¥—Ç–∞–±–ª–∏—Ü–µ
							),

				//	
					–ü—É—Å—Ç—ã–µ–ö–æ–ª–æ–Ω–∫–∏1 = List.Transform(nms, each {}),              // –ø—É—Å—Ç–∞—è —Ç–∞–±–ª–∏—Ü–∞ - —Å—Ç—Ä–æ–∫ –Ω–µ—Ç
					–ü—É—Å—Ç—ã–µ–ö–æ–ª–æ–Ω–∫–∏2 = List.Repeat( {{""}}, List.Count(nms) ),    // –ø—É—Å—Ç–∞—è —Ç–∞–±–ª–∏—Ü–∞ - —Å—Ç—Ä–æ–∫–∞ –æ–¥–Ω–∞ –ø—É—Å—Ç–∞—è
					
					CreatedTable = Table.FromColumns(–ü—É—Å—Ç—ã–µ–ö–æ–ª–æ–Ω–∫–∏1, nms),      // —Å–æ–∑–¥–∞–µ–º —Ç–∞–±–ª–∏—Ü—É
				
				// 	–¥–æ–±–∞–≤–ª—è–µ–º —Å—Ç—Ä–æ–∫—É —Å –¥–∞—Ç–æ–π, —á—Ç–æ–±—ã –Ω–µ —Ä—É—à–∏–ª–∞—Å—å —Å–≤—è–∑—å —Å –∫–∞–ª–µ–Ω–¥–∞—Ä–µ–º
					–î–∞–Ω–Ω—ã–µ = 
						{
							Record.FromList( 
								List.Transform(nms, each if _ = "Date" then #date(2023, 12, 1) else null ), 
								nms) 
						},

				// 	–±–µ—Ä–µ–º –ø–µ—Ä–≤—ã–µ 5 –∫–æ–ª–æ–Ω–æ–∫
					fromOneRows  = Table.InsertRows(CreatedTable, 0, –î–∞–Ω–Ω—ã–µ),
					from5Columns = Table.SelectColumns(fromOneRows, List.FirstN(Table.ColumnNames(fromOneRows), 5)),
				
				//	–Ω–æ–≤–∞—è —Ç–∞–±–ª–∏—Ü–∞ –∏–∑ —á–µ—Ç—ã—Ä–µ—Ö –∫–æ–ª–æ–Ω–æ–∫. –ú–∏–Ω—É—Å - —Å–±–∏–≤–∞–µ—Ç—Å—è –≥—Ä—É–ø–ø–∏—Ä–æ–≤–∫–∞ –ø–æ–ª–µ–π!
					NewTable = 
						let create = 
								Table.FromRecords({[
									Date = #date(2024, 7, 9),  
									Company = null,
									DataSet = null,
									Report_ID = null
								]}),
							TypedTable = Table.TransformColumnTypes(create, {{"Date", type date}})
						in TypedTable,
				
				// 	—Ç–∏–ø–∏–∑–∏—Ä—É–µ–º —Å—Ç–æ–ª–±—Ü—ã
					// typed = F[form.SetType](fromOneRows, from, REPORT_NAME)
					typed = form.SetType2(fromOneRows, from, REPORT_NAME)	// ??? –Ω–æ–º–µ—Ä 2
			in
				try typed 			//	
				otherwise NewTable,	//

//  fxLoadReport = // –í–∞–∂–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è
    fxLoadReport = // –í–∞–∂–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è
		/*
			–õ–æ–≥–∏–∫–∞: = –µ—Å–ª–∏ –æ—Ç—á–µ—Ç –≤ –±–∞–∑–µ –µ—Å—Ç—å, —Ç–æ –≤—ã–≤–æ–¥–∏–º –µ–≥–æ, –µ—Å–ª–∏ –Ω–µ—Ç, —Ç–æ –ø—É—Å—Ç—É—é —Ç–∞–±–ª–∏—Ü—É —Å –∑–∞–ø–æ–ª–Ω–µ–Ω–Ω–æ–π –¥–∞—Ç–æ–π –∏ –≤–æ–∑–º–æ–∂–Ω–æ –¥—Ä—É–≥–∏–º–∏ —Ç–µ—Å—Ç–æ–≤—ã–º–∏ –¥–∞–Ω–Ω—ã–º–∏
			–ü—Ä–∏–º–µ—Ä: = fxLoadReport(DataSets,"bal",null)
		*/
		/*
			// res = if to2 <> null then to2 else fxAddBlankTable(reportName)
			// try res otherwise fxAddBlankTable(reportName)
			(reportName as text, optional dataSetNomer as number) =>
			let 
				rec =   if prm_LoadVar ="csv" 
						then DS_CSV 
						else DS_XLS,
				
				// –µ—Å–ª–∏ –Ω–æ–º–µ—Ä —É–∫–∞–∑–∞–Ω, —Ç–æ –µ–≥–æ, –µ—Å–ª–∏ –Ω–µ—Ç, —Ç–æ –±–µ—Ä–µ–º –∏–∑ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤
				dataSet =   if   dataSetNomer = null
							then Parameters[DataSetNomer]
							else dataSetNomer,

				// –æ—á–∏—â–∞–µ–º –∑–∞–ø–∏—Å—å –æ—Ç –æ—à–∏–±–æ–∫ –≤ –∏–º–µ–Ω–∏ –ø–æ–ª—è, –µ—Å–ª–∏ –µ–≥–æ –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç (–Ω–µ—Ç —Ç–∞–∫–æ–≥–æ –∑–∞–ø—Ä–æ—Å–∞)
				cleanRec = 
					Record.FromList(
						List.Transform(
							Record.FieldNames(rec), 
							(x)=> try Record.Field(rec, x) otherwise null
						),
						Record.FieldNames(rec)
					),
						
				// –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –∑–Ω–∞—á–µ–Ω–∏–µ –ø–æ–ª—è (—ç—Ç–æ —Ç–∞–±–ª–∏—Ü–∞) –ø–æ –∫–ª—é—á—É (–∏–º—è –¥–∞—Ç–∞—Å–µ—Ç–∞)
				to1 = Record.FieldOrDefault( cleanRec, reportName, null),
				to2 = Record.FieldOrDefault( to1, Text.From(dataSet), null),
				res =   if   to2 = null 
						then fxAddBlankTable(reportName)
						else to2 
				// res2 = try res otherwise fxAddBlankTable(reportName)
			in 
				res
			*/

		(	tbl as table, 					// 	–¢–ê–ë–õ–ò–¶–ê —Å –¥–∞—Ç–∞—Å–µ—Ç–∞–º–∏		tbl = DataSets,
			reportName as text, 			//	—Ç–µ–∫—Å—Ç–æ–≤–æ–µ –∏–º—è –æ—Ç—á–µ—Ç–∞		reportName ="bal",
			optional dataSetNomer as number	//	–Ω–æ–º–µ—Ä –¥–∞—Ç–∞—Å–µ—Ç–∞				dataSetNomer = Parameters[DataSetNomer],		
		) as table =>
		let 
			//		
				// tbl = F1[DataSets],

			// 	–µ—Å–ª–∏ –Ω–æ–º–µ—Ä –¥–∞—Ç–∞—Å–µ—Ç–∞ —É–∫–∞–∑–∞–Ω, —Ç–æ –≥—Ä—É–∑–∏–º –µ–≥–æ, –µ—Å–ª–∏ –Ω–µ—Ç, —Ç–æ –±–µ—Ä–µ–º –∏–∑ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤
				dataSet =   if   dataSetNomer = null
							then Parameters[DataSetNomer]
							else dataSetNomer,

			//	—É–∞	—Å–¥–µ–ª–∞—Ç—å  –¥–≤–µ —Å—Ç—Ä–æ–∫–∏ //!–í–æ—Ç —Ç—É—Ç —á—Ç–æ —Ç–æ dataSet –ø–æ–º–µ–Ω—è–ª –Ω–∞ prm_DataSet
				to =    try Record.Field(
								Table.SelectRows(tbl, each [Index]=prm_DataSet and [–ê—Ç—Ä–∏–±—É—Ç]=prm_LoadVar ) [Value] {0},
								reportName
							)
						otherwise null,

			//	–ø—É—Å—Ç–∞—è —Ç–∞–±–ª–∏—Ü–∞
				tableZero = F[form.BlankTable](F_Form[tableShema],reportName),
			
			//	—É–∞
				res =   if   to = null // —á—Ç–æ –∑–Ω–∞—á–∏—Ç? –µ—Å–ª–∏ –æ—Ç—á–µ—Ç –ø—É—Å—Ç–æ–π?!
						then tableZero
						else to // –µ—Å–ª–∏ –∏–º—è –æ—Ç—á–µ—Ç–∞ –Ω–∞–π–¥–µ–Ω–æ, –Ω–∞–≤–µ—Ä–Ω–æ–µ —Ç–∞–∫
		in 
			res,
//  –î–æ–±–∞–≤–ª—è–µ–º —Å—Ç—Ä–æ–∫—É –≤ —Ç–∞–±–ª–∏—Ü—É –∏ –∫–æ–ª–æ–Ω–∫—É –ø–æ —É—Å–ª–æ–≤–∏—é
    =   Table.InsertRows(
            –ò—Å—Ç–æ—á–Ω–∏–∫,
            0,  // –Ω–æ–º–µ—Ä —Å—Ç—Ä–æ–∫–∏, –∫—É–¥–∞ –±—É–¥–µ—Ç –¥–æ–±–∞–≤–ª–µ–Ω–∏–µ
            {   // –¥–æ–±–∞–≤–ª—è–µ–º –æ–¥–Ω—É —Å—Ç—Ä–æ–∫—É —Å–æ –∑–Ω–∞—á–µ–Ω–∏–µ–º –∫–æ–ª–æ–Ω–∫–µ "Date". –ß–µ—Ä–µ–∑ "," –µ—Å–ª–∏ –Ω–∞–¥–æ –Ω–µ—Å–∫–æ–ª—å–∫–æ
                Record.FromList(
                    List.Transform(
                        Table.ColumnNames(–ò—Å—Ç–æ—á–Ω–∏–∫),
                        each if _ = "Date" then #date(2023, 12, 1) else null ),
                    Table.ColumnNames(–ò—Å—Ç–æ—á–Ω–∏–∫),
                    
                )
            }
        )

//  –¥–æ—Å—Ç–∞–µ–º —Ç–∞–±–ª–∏—Ü—É –∏–∑ –∑–∞–ø–∏—Å–∏ —Å –∑–∞–ø–∏—Å—è–º–∏, —Ç.–µ. –µ—Å—Ç—å –≤ –∫–æ–ª–æ–Ω–∫–µ –∑–∞–ø–∏—Å—å –∏ –≤ –Ω–µ –≤–ª–æ–∂–µ–Ω—ã –µ—â–µ–∑–∞–ø–∏—Å–∏
    =   Record.Field(
            Table.SelectRows(TextLower, each [Index]=2 and [–ê—Ç—Ä–∏–±—É—Ç]=prm_LoadVar ) [Value]{0}, // –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏–µ –∫–æ–ª–æ–Ω–∫–∏ –∏ —Å—Ç—Ä–æ–∫–∏
            "bal"
        )
//  –≤—Å–µ –∏–º–µ–Ω–∞ –ø–æ–ª–µ–π –≤–æ –≤—Å–µ—Ö Record –∏ table. //!–ò–Ω—Ç–µ—Ä–µ—Å–Ω–æ! –°–ü–ò–°–û–ö –í–°–ï–• –ö–û–õ–û–ù–û–ö –í–û –í–°–ï–• –¢–ê–ë–õ–ò–¶–ê–•
    AllFieldNamesRecord = List.Union(List.Transform(from[Value], Record.FieldNames)),

    AllFieldNamesTables = List.Distinct(List.Combine(List.Transform(TBL[Value], each[Name]))),
    nms = List.Distinct(List.Combine(List.Transform(Table.Column(from, "TableColumn"), each Table.ColumnNames(_))))



//  DataSet_CSV_Mart
        let
            load    = (fileName as text)=>                  F[LoadCSV](Value.Metadata(Parameters)[Mart][pathCSV] & fileName),
            reorder = (tbl as table, reportName as text)=>  F[Reorder.AllColumns](tbl, Record.Field(tableShema, reportName)[Header]),
            shema   = (tbl as table, reportName as text)=>  F_PackForm[fxSetType2](tbl, tableShema, reportName),
            
            from = 
                [   
                    bal  = let name = "bal",  l = load("\f_bal.csv"),  r = reorder(l,name), s = shema(r,name) in s,
                    opu  = let name = "opu",  l = load("\f_opu.csv"),  r = reorder(l,name), s = shema(r,name) in s,
                    odds = let name = "odds", l = load("\f_odds.csv"), r = reorder(l,name), s = shema(r,name) in s
                ]
        in
            from

//  DataSet_XLS_Mart
        let
            loadFolderXLSX = F_PackForm[Connect][Mart],
            from = [
                bal  = F_PackForm[Balans][Balance.Query](loadFolderXLSX),
                opu  = F_PackForm[OPU][OPU.Query](loadFolderXLSX),
                odds = F_PackForm[ODDS][ODDS.Query](loadFolderXLSX)
            ]
        in
            from

//  dataset load
    (reportName as text, optional dataSetNomer as number) =>
    let 
        // –µ—Å–ª–∏ –Ω–æ–º–µ—Ä —É–∫–∞–∑–∞–Ω, —Ç–æ –µ–≥–æ, –µ—Å–ª–∏ –Ω–µ—Ç, —Ç–æ –±–µ—Ä–µ–º –∏–∑ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤
        dataSet =   if   dataSetNomer = null
                    then Parameters[DataSetNomer]
                    else dataSetNomer,


        to = try Record.Field(Table.SelectRows(DS6, each ([Name] = dataSet) and ([Var] = "xls"))[–ó–Ω–∞—á–µ–Ω–∏–µ]{0}, reportName) otherwise null,
        
        res =   if   to = null 
                then fxAddBlankTable(reportName)
                else to
    in 
        res

//  dataset load
    let
        Q = (queryName as text) as any =>
            let
                queryList = #sections[Section1],
                queryExists = Record.HasFields(queryList, queryName)
            in
                if queryExists then Record.Field(queryList, queryName) else null,

        –ò—Å—Ç–æ—á–Ω–∏–∫ = #table(
            type table[Index = number, Name = text, xls = any, csv = any],
            {
                {1, "Mart",  null,  null },
                {2, "Homel", DataSet_XLS_Homel, DataSet_CSV_Homel},
                {3, "Drog",  DataSet_XLS_Drog,  DataSet_CSV_Drog}
            }
        )
    in
        –ò—Å—Ç–æ—á–Ω–∏–∫


//  Table.FromColumns
    = let
                    a = (a) => 
                        List.Transform(
                            Excel.CurrentWorkbook(){[Name = a]}[Content][–°—Ç–æ–ª–±–µ—Ü1], 
                            Text.From
                        )
                in
                    Table.FromColumns({a("–¢–∞–±–ª–∏—Ü–∞4"), a("–¢–∞–±–ª–∏—Ü–∞5")})
                  

//  –∑–∞–ø–æ–ª–Ω–µ–Ω–∏–µ —Ç–∞–±–ª–∏—Ü—ã –≤ –Ω—É–ª—è
    let 
        // –∏–º–µ–Ω–∞ –∫–æ–ª–æ–Ω–æ–∫
        nms  = Record.Field(tableShema,"osr")[Header],
        
        // –∑–Ω–∞—á–µ–Ω–∏—è
        –ó–∞–ø–∏—Å—å1 = [
            Date        = #date(2022, 6, 1), 
            –°—Ç—Ä–æ–∫–∞_ID   = 104, 
            –ó–Ω–∞—á–µ–Ω–∏–µ    = 354, 
            –ê—Ç—Ä–∏–±—É—Ç     = "–ü—Ä–æ—Å—Ä–æ—á–µ–Ω–Ω–∞—è"
        ],
        
        –ó–∞–ø–∏—Å—å2 = [
            Date        = #date(2022, 6, 1), 
            –°—Ç—Ä–æ–∫–∞_ID   = 104, 
            –ó–Ω–∞—á–µ–Ω–∏–µ    = 256, 
            –ê—Ç—Ä–∏–±—É—Ç     = "–ü—Ä–æ—Å—Ä–æ—á–µ–Ω–Ω–∞—è"
        ],
        
        // —Å–ø–∏—Å–æ–∫ –∑–∞–ø–∏—Å–µ–π
        lst = {–ó–∞–ø–∏—Å—å1, –ó–∞–ø–∏—Å—å2},
        
        // –ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ —Ñ—É–Ω–∫—Ü–∏–∏ –∫ –∫–∞–∂–¥–æ–π –∑–∞–ø–∏—Å–∏
        –ó–∞–ø–æ–ª–Ω–µ–Ω–Ω–∞—è–¢–∞–±–ª–∏—Ü–∞ = 
            Table.InsertRows(
                Table.FromColumns(List.Transform(nms, each {}),  nms), 
                0, 
                List.Transform(lst, 
                    (rec as record) as record => Record.FromList( List.Transform( nms, (x)=> Record.FieldOrDefault(rec, x, null)), nms)
                )
            )
    in
        –ó–∞–ø–æ–ª–Ω–µ–Ω–Ω–∞—è–¢–∞–±–ª–∏—Ü–∞

//  wqef
    = (tbl as table, tblShema as table, txt as text)=>
        Table.TransformColumnTypes(tbl, 
            List.Transform(
                Table.ToRecords(Table.SelectRows(tblShema, (x)=> x[Name] = "txt")[[Header],[TypeName]]),
                each { [Header], F[Type.FromText2]([TypeName]) }
            )
        )
        
    let
        –ò—Å—Ç–æ—á–Ω–∏–∫ = Value.Metadata(PathFolder)[List],
        #"–ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–æ –≤ —Ç–∞–±–ª–∏—Ü—É" = Table.FromList(–ò—Å—Ç–æ—á–Ω–∏–∫, Splitter.SplitByNothing(), null, null, ExtraValues.Error),
        #"–î–æ–±–∞–≤–ª–µ–Ω –∏–Ω–¥–µ–∫—Å" = Table.AddIndexColumn(#"–ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–æ –≤ —Ç–∞–±–ª–∏—Ü—É", "DataSet", 1, 1, Int64.Type),
        #"–°—Ç—Ä–æ–∫–∏ —Å –ø—Ä–∏–º–µ–Ω–µ–Ω–Ω—ã–º —Ñ–∏–ª—å—Ç—Ä–æ–º" = Table.SelectRows(#"–î–æ–±–∞–≤–ª–µ–Ω –∏–Ω–¥–µ–∫—Å", each [DataSet] = DataSetNomer),
        #"–ü–µ—Ä–µ–∏–º–µ–Ω–æ–≤–∞–Ω–Ω—ã–µ —Å—Ç–æ–ª–±—Ü—ã" = Table.RenameColumns(#"–°—Ç—Ä–æ–∫–∏ —Å –ø—Ä–∏–º–µ–Ω–µ–Ω–Ω—ã–º —Ñ–∏–ª—å—Ç—Ä–æ–º",{{"Column1", "DataSetPath"}, {"DataSet", "DataSetN"}})
    in
        #"–ü–µ—Ä–µ–∏–º–µ–Ω–æ–≤–∞–Ω–Ω—ã–µ —Å—Ç–æ–ª–±—Ü—ã"
    let
        f4 = (tableNames as list )=>
        let
            // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –±–µ–∑–æ–ø–∞—Å–Ω–æ–≥–æ –∏–∑–≤–ª–µ—á–µ–Ω–∏—è —Ç–∞–±–ª–∏—Ü—ã –ø–æ –∏–º–µ–Ω–∏
            GetTable = (tableName as text) as table => 
                try Expression.Evaluate(tableName, #shared) otherwise null,

            // –°–æ–∑–¥–∞–Ω–∏–µ –∑–∞–ø–∏—Å–∏ —Å –ø—Ä–æ–≤–µ—Ä–µ–Ω–Ω—ã–º–∏ –∑–Ω–∞—á–µ–Ω–∏—è–º–∏ —Ç–∞–±–ª–∏—Ü
            rec = Record.FromList(
                List.Transform(tableNames, each GetTable(_)),
                List.Transform({1..List.Count(tableNames)}, each Text.From(_))
            )
        in rec,

        –ò—Å—Ç–æ—á–Ω–∏–∫ = f4({"f1_–ë–∞–ª–∞–Ω—Å", "f2_–ë–∞–ª–∞–Ω—Å"})
    in
        –ò—Å—Ç–æ—á–Ω–∏–∫
//  fxLoadReport1
    fxLoadReport1 = 
    (rec as record, dataSetNomer)=>
    let
        // –ü—Ä–∏–º–µ—Ä –∑–∞–ø–∏—Å–∏ —Å –±–∞–ª–∞–Ω—Å–∞–º–∏, –≥–¥–µ –≤ –ø–æ–ª–µ 3 –º–æ–∂–µ—Ç –±—ã—Ç—å –æ—à–∏–±–∫–∞
        // rec = [
        //     1 = –∞1_–ë–∞–ª–∞–Ω—Å, 
        //     2 = a2_–ë–∞–ª–∞–Ω—Å, 
        //     3 = error,
        //     4 = a4_–ë–∞–ª–∞–Ω—Å 
        // ],
        
        // –°–ø–∏—Å–æ–∫ –ø–æ–ª–µ–π, –∫–æ—Ç–æ—Ä—ã–µ —Å–æ–¥–µ—Ä–∂–∞—Ç –æ—à–∏–±–∫–∏
        fieldsWithErrors = List.Select(
            Record.FieldNames(rec), 
            each Record.HasFields(rec, _) and (try Record.Field(rec, _) otherwise null) = null),

        // –£–¥–∞–ª–µ–Ω–∏–µ –ø–æ–ª–µ–π —Å –æ—à–∏–±–∫–∞–º–∏ –∏–∑ –∑–∞–ø–∏—Å–∏
        cleanRec = Record.RemoveFields(rec, fieldsWithErrors),

        to = Record.FieldOrDefault( cleanRec, Text.From(dataSetNomer), null)
    in
        to

//  f3
    f3= ( tableNames as list )=>
    let
        // –°–ø–∏—Å–æ–∫ –∏–º–µ–Ω —Ç–∞–±–ª–∏—Ü
        // tableNames = {"f1_–ë–∞–ª–∞–Ω—Å", "f1_–ë–∞–ª–∞–Ω—Å2"},

        // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –±–µ–∑–æ–ø–∞—Å–Ω–æ–≥–æ –∏–∑–≤–ª–µ—á–µ–Ω–∏—è —Ç–∞–±–ª–∏—Ü—ã –ø–æ –∏–º–µ–Ω–∏
        GetTable = (tableName as text) as table =>
            let
                table = try Expression.Evaluate(tableName, #shared) otherwise null
            in
                table,

        // –°–æ–∑–¥–∞–Ω–∏–µ –∑–∞–ø–∏—Å–∏ —Å –ø—Ä–æ–≤–µ—Ä–µ–Ω–Ω—ã–º–∏ –∑–Ω–∞—á–µ–Ω–∏—è–º–∏ —Ç–∞–±–ª–∏—Ü
        balances = Record.FromList(
            List.Transform(tableNames, each GetTable(_)),
            List.Transform({1..List.Count(tableNames)}, each Text.From(_))
        )
    in
        balances

    let
        rec = Record.HasFields([ 1 = f1_–û–ü–£, 2 = a2_–ë–∞–ª–∞–Ω—Å, 4 = a4_–û21–ü–£],1),
        
        // –æ—á–∏—â–∞–µ–º –∑–∞–ø–∏—Å—å –æ—Ç –æ—à–∏–±–æ–∫ –≤ –∏–º–µ–Ω–∏ –ø–æ–ª—è, –µ—Å–ª–∏ –µ–≥–æ –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç (–Ω–µ—Ç —Ç–∞–∫–æ–≥–æ –∑–∞–ø—Ä–æ—Å–∞)
        cleanRec = 
            Record.FromList(
                List.Transform(
                    Record.FieldNames(rec), 
                    (x)=> try Record.Field(rec, x) otherwise null
                ),
                Record.FieldNames(rec)
            ),
        
        // –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –∑–Ω–∞—á–µ–Ω–∏–µ –ø–æ–ª—è (—ç—Ç–æ —Ç–∞–±–ª–∏—Ü–∞) –ø–æ –∫–ª—é—á—É (–Ω–æ–º–µ—Ä)
        to = Record.FieldOrDefault( 
                cleanRec, 
                Text.From(1), 
                null
            )
    in
    to



//  https://gorilla.bi/power-query/records/
    // Output: "The Gorilla wants a Banana"
        Text.Format( 
            "The #[Subject] wants a #[Food].", 
            [ Subject = "Gorilla", Food = "Banana" ] 
        )

// 	–ø—Ä–æ–≤–µ—Ä–∫–∞ —Ñ—É–Ω–∫—Ü–∏–∏ - –ø–æ—Å–ª–µ–¥–Ω–∏–π —à–∞–≥
	let
		FirstAndLastDayOfTheMonth = (date) => 
			 let
				dated         = Date.FromText(date),
				year          = Date.Year(dated),
				month         = Date.Month(dated),
				FirstDateText = Text.From(year)&"-"&Text.From(month)&"-01",
				FirstDate     = Date.FromText(FirstDateText),
				daysInMonth   = Date.DaysInMonth(dated),
				LastDateText  = Text.From(year)&"-"&Text.From(month)&"-"&Text.From(daysInMonth),
				LastDate      = Date.FromText(LastDateText),
				record        = Record.AddField([],"First Date of Month",FirstDate),
				resultset     = Record.AddField(record,"Last Date of Month",LastDate)
			 in
				resultset
	in
		FirstAndLastDayOfTheMonth("30/07/2015")
        
//  –∑–∞–º–µ–Ω–∏—Ç—å –≤ —Ç–∞–±–ª–∏—Ü–µ –≤ –ø–µ—Ä–≤–æ–π –∫–æ–ª–æ–Ω–∫–µ –Ω–æ–º–µ—Ä —Å—Ç—Ä–æ–∫–∏ –Ω–∞ —Å–±–æ—Ä–Ω—ã–π –∫–ª—é—á –∏–∑ 3 –∫–æ–ª–æ–Ω–æ–∫ –≤ –∫–æ–Ω—Ü–µ (—Å—Ç–∞—Ç–æ—Ç—á–µ—Ç)
    let
        //  4 –∫–æ–ª–æ–Ω–∫–∏: –Ω–æ–º–µ—Ä —Å—Ç—Ä–æ–∫–∏ - –°—Ç–∞—Ç—å—è - ID1 - ID2 - ID3
            from = Excel.CurrentWorkbook(){[Name="—Å–ø—Ä_–°—Ç–∞—Ç—å–∏"]}[Content], 
        
        //  –≤—Å—é —Ç–∞–±–ª–∏—Ü—É —Å–æ–±–∏—Ä–∞–µ–º –ø–æ—Å—Ç—Ä–æ—á–Ω–æ: –ø–µ—Ä–≤–∞—è –∫–æ–ª–æ–Ω–∫–∞ (–∫–∞–∫ ID1.ID2.ID3) & –≤—Å–µ –æ—Å—Ç–∞–ª—å–Ω—ã–µ –∫–æ–ª–æ–Ω–∫–∏ –±–µ–∑ –ø–µ—Ä–≤–æ–π –∫–æ–ª–æ–Ω–∫–∏
            f=(x)=>{Text.Combine(List.Transform(List.LastN(x,3),Text.From),".")} & List.Skip(x), 
        
        //  –∏–º—è –Ω–æ–≤–æ–π –ø–µ—Ä–≤–æ–π –∫–æ–ª–æ–Ω–∫–∏ + –∏–º–µ–Ω–∞ –∫–æ–ª–æ–Ω–æ–∫ –∫—Ä–æ–º–µ –ø–µ—Ä–≤–æ–π
            nms = {"–ù–æ–º–µ—Ä"} & List.Skip(Table.ColumnNames(from)), 
        
        //  —Å–æ–±–∏—Ä–∞–µ–º –∫–æ–ª–æ–Ω–∫–∏ –≤–º–µ—Å—Ç–µ
            to = Table.FromList(Table.ToRows(from),f, nms)
    in
    to

//  –ø–æ–¥—Ö–æ–¥ –ú–∏—Ö–∞–∏–ª–∞ —á–µ—Ä–µ–∑ —Å–ø–∏—Å–∫–∏!!!
    let
        from = Excel.CurrentWorkbook(){[Name="–¢–∞–±–ª–∏—Ü–∞1"]}[Content],
        f=(x)=> // —Ñ—É–Ω–∫—Ü–∏—è –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏—è —Ç–∞–±–ª–∏—Ü—ã
            {   x{0},
                Text.Combine(List.RemoveItems(Text.Split(x{1},";"),{x{0}}),";")
            },
        to  = Table.ToList(from,f), // —Ñ–æ—Ä–º–∏—Ä—É–º–µ–º —Å–ø–∏—Å–æ–∫ —Å–ø–∏—Å–∫–æ–≤ –∏–∑ —Ç–∞–±–ª–∏—Ü—ã –ø–æ —Ñ—É–Ω–∫—Ü–∏–∏ –ø–æ—Å—Ç—Ä–æ—á–Ω–æ
        tbl = Table.FromList( // —Ä–∞–∑–≤–æ—Ä–∞—á–∏–≤–∞–µ–º —Å–ø–∏—Å–æ–∫ —Å–ø–∏—Å–∫–æ–≤ –≤ —Ç–∞–±–ª–∏—Ü—É
                to,         // –∫–æ–ª–æ–Ω–∫–∞ —Å —Å–ø–∏—Å–∫–∞–º–∏. –ö–∞–∂–¥—ã–π —Å–ø–∏—Å–æ–∫ –æ—Ç–¥–µ–ª—å–Ω–∞—è —Å—Ç—Ä–æ–∫–∞ –∏—Å–∑—Ö–æ–¥–Ω–æ–π —Ç–∞–±–ª–∏—Ü—ã –ø–æ—Å–ª–µ –ø—Ä–∏–º–µ–Ω–µ–Ω–∏—è —Ñ—É–Ω–∫—Ü–∏–∏
                (x)=>x,     // –±–µ–∑ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–π
                {"a","b"}   // –∏–º–µ–Ω–∞ –∫–æ–ª–æ–Ω–æ–∫
            ) 
    in
    tbl

//  –†–µ–≥—É–ª—è—Ä–Ω—ã–µ –≤—ã—Ä–∞–∂–µ–Ω–∏—è (RegExp) –≤ Power Query

    –ü–æ–∑–≤–æ–ª—é —Å–µ–±–µ –¥–æ–ø–æ–ª–Ω–∏—Ç—å –∫ —á–∞—Å—Ç–∏ —Å—Ç–∞—Ç—å–∏ –∫ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—é —Ä–µ–≥—É–ª—è—Ä–Ω—ã—Ö –≤—ã—Ä–∞–∂–µ–Ω–∏–π –≤ Power Query —á–µ—Ä–µ–∑ javascript.
    –ü–µ—Ä–µ–¥ —Ç–µ–º –∫–∞–∫ –ø–µ—Ä–µ–¥–∞–≤–∞—Ç—å —Ç–µ–∫—Å—Ç –¥–ª—è x, delim –≤ —Ñ—É–Ω–∫—Ü–∏—é —Å–ª–µ–¥—É–µ—Ç, —á—Ç–æ–±—ã –∏–∑–±–µ–∂–∞—Ç—å –æ—à–∏–±–æ–∫ –≤—ã–ø–æ–ª–Ω–∏—Ç—å –∑–∞–º–µ–Ω—ã –≤ —Ç–µ–∫—Å—Ç–µ:
    –°–∞–º—ã–º –ø–µ—Ä–≤—ã–º —Å–∏–º–≤–æ–ª \ –∑–∞–º–µ–Ω–∏—Ç—å –Ω–∞ \\
    —Å —É—á—ë—Ç–æ–º –ø—Ä–∏–º–µ–Ω—ë–Ω–Ω—ã—Ö –∫–∞–≤—ã—á–µ–∫ –¥–ª—è —Ç–µ–∫—Å—Ç–∞ –≤ js ' –Ω–∞ \'
        #(lf) –Ω–∞ \n
        #(cr) –Ω–∞ \r
        #(tab) –Ω–∞ \t
    –ò–ª–∏ –≤—Å—ë —Å—Ä–∞–∑—É —Ñ—É–Ω–∫—Ü–∏–µ–π
    
    let
        getJsSafeText = (pqText) => 
            List.Accumulate(
                {
                    {"\", "\\"}, 
                    {"'", "\'"}, 
                    {"#(tab)", "\t"}, 
                    {"#(lf)", "\n"}, 
                    {"#(cr)", "\r"}
                },
                pqText, 
                (acc, pair) => Text.Replace(acc, pair{0}, pair{1})
            ),
        example = getJsSafeText("'–í –∫–∞–≤—ã—á–∫–∞—Ö'#(lf)–ø–µ—Ä–µ—Ö–æ—Å#(cr)–∏ —Ç–∞–±—É–ª—è—Ü–∏—è#(tab)\—Ç–µ–∫—Å—Ç\")
    in
        example


//  "!" –ø–µ—Ä–µ–∏–º–µ–Ω–æ–≤–∞–Ω–∏–µ –≤ —Å—Ç–æ–ª–±—Ü–µ, —Ç–∞–Ω–∫, "–æ–±—ã—á–Ω—ã–π —Å–ª–æ–≤–∞—Ä—å..."
    let
        tbl  =  Excel.CurrentWorkbook(){[Name="–ö–æ–Ω—Å—Ç—Ä—É–∫—Ü–∏—è"]}[Content],
        from =  Excel.CurrentWorkbook(){[Name="–¢–∞–±–ª–∏—Ü–∞"]}[Content],

        dict =  Record.FromList(
                    tbl[–¢–∏–ø –∫–æ–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏],
                    tbl[–§–æ—Ä–º–∞—Ç]
                ),
        
        f=(x)=>Record.Field(dict,x),
        to   = Table.TransformColumns(from, {"Format",f})
    in
        to

//  –Ω–µ –∑–Ω–∞—é
    AddedColumns = 
            F[fxAddMultiColumns](Join, {
                { "Quarter",         each "Q" & Number.ToText(Date.QuarterOfYear([Year])) & "-" & Text.End(Text.From(Date.Year([Year])),2) },
                { "–°—Ç–∞—Ç—å—è–ö–æ–¥",       each [–ö–æ–¥] & " " & [–ü–æ–∫–∞–∑–∞—Ç–µ–ª—å] },
                { "–£—Ä–æ–≤–µ–Ω—å",         each try List.Count(List.Select(Text.ToList([–ö–æ–¥]), (t)=>t=".")) otherwise 3},
                { "–ö–ª–∞—Å—Å–ö–æ–¥",        each Text.From([–ö–ª–∞—Å—Å]) & " " & [–ü–æ–∫–∞–∑–∞—Ç–µ–ª—å], type text},
                { "–ì—Ä—É–ø–ø–∞–ö–æ–¥",       each Text.From([–ì—Ä—É–ø–ø–∞]) & " " & [–ü–æ–∫–∞–∑–∞—Ç–µ–ª—å], type text},
                { "–ö–∞—Ç–µ–≥–æ—Ä–∏—è–ö–æ–¥",    each Text.From([–ö–∞—Ç–µ–≥–æ—Ä–∏—è]) & " " & [–ü–æ–∫–∞–∑–∞—Ç–µ–ª—å], type text},
                { "–ü–æ–¥–∫–∞—Ç–µ–≥–æ—Ä–∏—è–ö–æ–¥", each Text.From([–ü–æ–¥–∫–∞—Ç–µ–≥–æ—Ä–∏—è]) & " " & [–ü–æ–∫–∞–∑–∞—Ç–µ–ª—å], type text}
            }),
        typed = Table.TransformColumnTypes(AddedColumns,{{"–ó–Ω–∞—á–µ–Ω–∏–µ", type number}, {"–£—Ä–æ–≤–µ–Ω—å", Int64.Type}}),

//  –Ω–∞—Ä–∞—Å—Ç–∞—é—â–∏–π —É–±—Ä–∞—Ç—å
    let
        Source = Table.Skip(Excel.CurrentWorkbook(){[Name="–¢–∞–±–ª–∏—Ü–∞4"]}[Content], 2),
        f = (lst) => List.Generate(
            () => [i = 0, r = lst{0} ?? 0, rt = r],
            (x) => x[i] <= 3,
            (x) => [i = x[i] + 1, r = if lst{i} = null then 0 else lst{i} - x[rt], rt = x[rt] + r],
            (x) => x[r]
        ),
        to_list = Table.ToList(
            Source,
            (x) => {x{0}} & List.Combine(List.Transform(List.Split(List.Skip(x), 4), f))
        ),
        to_table = Table.FromList(to_list, (x) => x, Table.ColumnNames(Source))
    in
        to_table

//?  ------- –ò–ï–†–ê–†–•–ò–Ø -------
//  —á—Ç–æ —Ç–æ —Ç–∞–º –ø—Ä–æ –∏–µ—Ä–∞—Ä—Ö–∏—é
    let
        Source = Excel.CurrentWorkbook(){[Name="Table3"]}[Content],
        #"Added Index" = Table.AddIndexColumn(Source, "Index", 0, 1),
        #"Pivoted Column" = Table.Pivot(Table.TransformColumnTypes(#"Added Index", {{"Level", type text}}, "en-US"), List.Distinct(Table.TransformColumnTypes(#"Added Index", {{"Level", type text}}, "en-US")[Level]), "Level", "Part Number", List.Sum),
        Lookup = Table.FillDown(#"Pivoted Column",{"0", "1", "2", "3", "4", "5", "6", "7", "8", "9"}),
        #"Added Custom1" = Table.AddColumn(#"Added Index", "Custom1", each Table.Column(Lookup, Text.From([Level]-1)){[Index]}),
        #"Added Custom2" = Table.AddColumn(#"Added Custom1", "Custom2", each Table.Column(Lookup, Text.From([Level]-2)){[Index]}),
        #"Added Custom3" = Table.AddColumn(#"Added Custom2", "Custom3", each Table.Column(Lookup, Text.From([Level]-3)){[Index]}),
        #"Added Custom4" = Table.AddColumn(#"Added Custom3", "Custom4", each Table.Column(Lookup, Text.From([Level]-4)){[Index]}),
        #"Added Custom5" = Table.AddColumn(#"Added Custom4", "Custom5", each Table.Column(Lookup, Text.From([Level]-5)){[Index]}),
        #"Added Custom6" = Table.AddColumn(#"Added Custom5", "Custom6", each Table.Column(Lookup, Text.From([Level]-6)){[Index]}),
        #"Added Custom7" = Table.AddColumn(#"Added Custom6", "Custom7", each Table.Column(Lookup, Text.From([Level]-7)){[Index]}),
        #"Added Custom8" = Table.AddColumn(#"Added Custom7", "Custom8", each Table.Column(Lookup, Text.From([Level]-8)){[Index]}),
        #"Added Custom9" = Table.AddColumn(#"Added Custom8", "Custom9", each Table.Column(Lookup, Text.From([Level]-9)){[Index]}),
        #"Removed Columns" = Table.RemoveColumns(#"Added Custom9",{"Index"})
    in #"Removed Columns"


//  NF —Å–∞–º–∞—è —Å—Ç–∞—Ç—å—è –ø—Ä–æ –∏–µ—Ä–∞—Ä—Ö–∏—é –Ω–∞ –¥–∞–∫—Å
    https://www.daxpatterns.com/parent-child-hierarchies/

    https://www.linkedin.com/pulse/rolling-up-hierarchical-data-three-different-ways-ferry-van-der-vorst/

    Using Calculated Columns (DAX)
    Using calculated columns are much simpler to implement, but unlike Power Query, the values are not transferred to tables when the table is copied, but the data is copied in the table where the calculated column resides. It could potentially make referencing the value in other table more complex than when using Power Query (as in Power Query, the data is already available in the table).
    In order for the data to be retrieved, we first need to have a calculated column that defines the hierarchy of the data - in this case the column is called Path:
    Path = PATH('Work Items'[ID],'Work Items'[Parent])
    When creating this, the value on each row would look something similar to this: 10001|1001|103|4, where the left most value before the first | indicates the top level ID and the number furthest to the right the ID of the item itself. The IDs in between make up the structure, so form lowest level (current item) to the top, the structure is based on IDs: 
    4 => 103 => 1001 => 10001, which in this case is Task 4 => Story 3 => Feature 1 => Epic 1 when looking at the titles.
    The structure for retrieval of the data in the calculated column is pretty much the same for all the columns below:
    Identify the ID for the item you want to populate, stored in variable "pid". We don't need to use SELECTEDVALUE as it is assessed against the row in the table.
    Identify the child items that contain the item you want to populate (via PATHCONTAINS in the FILTER as all child items contain the ID of the parent, grandparent, etc in the PATH)
    Find the totals of the effort (using SUM), minimum Start Date (using MIN) or latest End Date (using MAX) 
    So the Calculated Columns are as follows here:
    Effort Calculated Column
    Column - Effort = 
    VAR pid = 'Work Items'[ID] RETURN
    SUMX(FILTER('Work Items',PATHCONTAINS([Path],pid)),[Effort]) 
    Start Date Calculated Column
    Column - Start Date = 
    VAR pid = 'Work Items'[ID] RETURN
    MINX(FILTER('Work Items',PATHCONTAINS([Path],pid)),[Start Date])
    End Date Calculated Column
    Column - End Date = 
    VAR pid = 'Work Items'[ID] RETURN
    MAXX(FILTER('Work Items',PATHCONTAINS([Path],pid)),[End Date])
    Using Measures (DAX)
    Using measures are also simpler to implement, but unlike Power Query, the values are not stored in the tables and the data will be context sensitive against which the data is plotted. So it can be more difficult to validate that the data is correct.
    Similar to Calculated Columns, we also need to have a calculated column that defines the hierarchy of the data (here: Path). 
    The structure for retrieval of the data in the measures is pretty much the same for all the measures below:
    Identify the ID for the item you want to populate, stored in variable "pid"
    Identify the child items that contain the item you want to populate (via PATHCONTAINS as all child items contain the ID of the parent, grandparent, etc in the PATH)
    Find the totals of the effort (using SUM), minimum Start Date (using MIN) or latest End Date (using MAX) 
    ALLSELECTED is used to ensure the data s calculated over all rows and columns
    So the measures for the Effort, Start Date and End Date are as follows:
    Effort Measure
    Measure - Effort =
        VAR pid = SELECTEDVALUE ( 'Work Items'[ID] )
    
    RETURN
        CALCULATE (
            SUM ( 'Work Items'[Effort] ),
            ALLSELECTED ( 'Work Items' ),
            PATHCONTAINS ( 'Work Items'[Path], pid )
        ) 
    Start Date Measure
    Measure - Start Date =
    VAR pid = SELECTEDVALUE ( 'Work Items'[ID] )
    RETURN
        CALCULATE (
            MIN ( 'Work Items'[Start Date] ),
            ALLSELECTED ( 'Work Items' ),
            PATHCONTAINS ( 'Work Items'[Path], pid )
        ) 
    End Date Measure
    Measure - End Date =
    VAR pid = SELECTEDVALUE ( 'Work Items'[ID] )
    RETURN
        CALCULATE (
            MAX ( 'Work Items'[End Date] ),
            ALLSELECTED ( 'Work Items' ),
            PATHCONTAINS ( 'Work Items'[Path], pid )
        ) 


//  –∏–µ—Ä–∞—Ä—Ö–∏—è –ú–∏—à–∞
    let
        from = Excel.CurrentWorkbook(){[Name="–¢–∞–±–ª–∏—Ü–∞1"]}[Content],
        add = Table.AddIndexColumn(from, "Index", 0, 1),
        nms = Table.ColumnNames(add)&{"Desire"},
        f=(x)=>[a=Table.ToColumns(x),
                b=List.Buffer(List.Zip({a{1},a{2}})),
                c=Table.RowCount(x),
                d=(x,y)=>[i=x+1,j=List.FirstN(y,b{x}{0}-1)&{b{x}{1}}],
                e=List.Generate(()=>d(0,List.Repeat({null},6)),
                                (x)=>x[i]<=c,
                                (x)=>d(x[i],x[j]),
                                (x)=>Text.Combine(x[j],".")),
                f=Table.FromColumns(a&{e},nms)][f],
        gr = Table.Group(add, "Category", {"tmp", each f(Table.Sort(_,"Index"))}),
        to = Table.Sort(Table.Combine(gr[tmp]),"Index")
    in
        to

//  level
    Level = [
        name = "–£—Ä–æ–≤–µ–Ω—å",
        a = Table.DuplicateColumn(addColumns, "–ö–æ–¥", name),
        b = Table.ReorderColumns(a, {"–ö–æ–¥", name, "–ù–∞–∏–º–µ–Ω–æ–≤–∞–Ω–∏–µ", "–°–µ–∫—Ü–∏—è", "–ì—Ä—É–ø–ø–∞", "–ö–ª–∞—Å—Å", "–ö–∞—Ç–µ–≥–æ—Ä–∏—è", "–ü–æ–¥–∫–∞—Ç–µ–≥–æ—Ä–∏—è", "–í–∏–¥", "–ü–æ–¥–≤–∏–¥", "–ì—Ä—É–ø–ø–∞–¢–æ–≤–∞—Ä–æ–≤"}),
        c = Table.ReplaceValue(b,".","",Replacer.ReplaceText,{name}),
        d = Table.TransformColumns(c,{{name, Text.Length, Int64.Type}}),
        e = Table.TransformColumns(d, {{name, each _ - 1, type number}}),
        g = Table.RenameColumns(e,{{name, "Level"}})
    ][g]

//  –ò–µ—Ä–∞—Ä—Ö–∏—è
    let
        src      = Source,
        maxLvl   = List.Max ( src[Level] ),
        recs     = List.Buffer ( Table.ToRecords ( src ) ),
        generate = List.Generate (
            () =>  [ i = 0,
                lvlValues = List.ReplaceRange ( List.Repeat ( { { null, null } }, maxLvl ), recs{i}[Level] - 1, 1, { { recs{i}[RowNR], recs{i}[RowNAme] } } )
            ],
            each [i] < List.Count ( recs ),
            each [
                i = [i] + 1,
                lvlValues = List.FirstN ( [lvlValues], recs{i}[Level] - 1 )
                    & { { recs{i}[RowNR], recs{i}[RowNAme] } }
                    & List.Repeat ( { { null, null } }, maxLvl - recs{i}[Level] )
            ],
            each if try recs{[i]}[Level] >= recs{[i] + 1}[Level] otherwise true 
                then List.Combine ( [lvlValues] ) 
                else null
        ),
        toTable = Table.FromRows (
            List.RemoveNulls ( generate ),
            List.Accumulate ( { 1 .. maxLvl }, {}, ( s, c ) => s & { "lvl_" & Text.From ( c ) & "_RowNR", "lvl_" & Text.From ( c ) & "_RowNAme" } )
        )
    in
        toTable

 
//  ! -------------------------------------------------------------------------------------
    a = Record.FieldValues(Source2{x}), //* –ø–æ–ª—É—á–∞–µ–º –∑–Ω–∞—á–µ–Ω–∏—è —Ç–µ–∫—É—â–µ–π —Å—Ç—Ä–æ–∫–∏
        b = Table.ColumnNames(Source2), //? –ø–æ–ª—É—á–∞–µ–º –Ω–∞–∑–≤–∞–Ω–∏—è —Å—Ç–æ–ª–±—Ü–æ–≤ —Ç–∞–±–ª–∏—Ü—ã
        c = #table(2,List.Zip({b,a})),  //! —Å–æ–∑–¥–∞–µ–º —Ç–∞–±–ª–∏—Ü—É

    = Table.FromList(
                        Table.ToRows(–ö–æ–ª–æ–Ω–∫—É–í–Ω–∞—á–∞–ª–æ),
                        (x)=>{Text.Combine(List.Transform(List.LastN(x,3),Text.From),".")} & List.Skip(x), 
                        // –ª—É—á—à–µ –æ—Ç–¥–µ–ª—å–Ω—ã–º —à–∞–≥–æ–º —á–µ—Ä–µ–∑ f=(x)=>{Text.Combine...
                        {"–ù–æ–º–µ—Ä"} & List.Skip(Table.ColumnNames(–ö–æ–ª–æ–Ω–∫—É–í–Ω–∞—á–∞–ª–æ))
                )

    = Table.ReplaceValue(#"–ò–∑–º–µ–Ω–µ–Ω–Ω—ã–π —Ç–∏–ø", 
                        null, // b
                        null, // c
                        (a, b, c) => if List.Contains("–≤ —Ç.—á.", a) = true then "" else a,
                        {"–¢–æ–≤–∞—Ä"})

    = Table.TransformColumns(
        #"–ò–∑–º–µ–Ω–µ–Ω–Ω—ã–π —Ç–∏–ø", 
            {{"–¢–æ–≤–∞—Ä", 
                    each List.ReplaceMatchingItems(
                            {_}, 
                            List.Buffer(List.Zip({ {"–≤ —Ç.—á","130"},{"+++","190"} }))
                    ){0}}} 
        )
//  ! fxCamelCaseHeaders -------------------------------------------------------------------------------------
    fxCamelCaseHeaders =[
        // –§—É–Ω–∫—Ü–∏—è fxCamelCaseHeaders - –ø–æ—Å—Ç–∞–≤–∏—Ç—å –ø—Ä–æ–±–µ–ª –ø–µ—Ä–µ–¥ –∫–∞–∂–¥–æ–π –±–æ–ª—å—à–æ–π –±—É–∫–≤–æ–π
        // https://datachant-com.translate.goog/2018/02/14/split-camelcase-headers-m/?_x_tr_sl=auto&_x_tr_tl=ru&_x_tr_hl=ru
        // –º–æ–¥–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –¥–ª—è –∑–∞–≥–æ–ª–æ–≤–∫–æ–≤ –∏–ª–∏ —Å–∞–º–æ–≥–æ —Ç–µ–∫—Å—Ç–∞
        (Source)=>
            let to_list = List.Buffer(Text.ToList(Source)),
                Transform = List.Transform(to_list, each if Text.Lower(_) = _ then _ else " " & _),
                Reassemble = Text.Combine(Transform)
            in  Reassemble	
        ]
//  ! fxSplitCamelCase
    fxSplitCamelCase = 
        // –µ—Å–ª–∏ –Ω–µ –Ω—É–∂–Ω—ã –ø—Ä–æ–±–µ–ª—ã –∫–æ–≥–¥–∞ –∞–±–±—Ä–µ–≤–∏–∞—Ç—É—Ä–∞, —Ç–æ —Ñ—É–Ω–∫—Ü–∏—è –¥—Ä—É–≥–∞—è
        // to = Table.TransformColumnNames(#"Previous Step", fxSplitCamelCase)
        // –§—É–Ω–∫—Ü–∏—è - fxSplitCamelCase
        (Source) =>
        let    
            res = List.Accumulate(
                Text.ToList(Source),
                [result="", index=0, source=Source],
                fnAccumulator
            ),

        IsUpper = (txt) => txt <> "" and txt = Text.Upper(txt) and txt <> Text.Lower(txt),

        fnAccumulator =
            (state as record, current as text) as record =>
            let
                prevCharacter  = if state[index]=0 then "" else Text.At(state[source], state[index] - 1),
                prevCharacter2 = if state[index]<=1 then "" else Text.At(state[source], state[index] - 2),
                nextCharacter  = if state[index]= Text.Length(state[source]) - 1 then "" else Text.At(state[source], state[index] + 1),
            aggregatedResult = if state[index]=0 or current = "" then current
                    else
                        if  IsUpper(current) and
                            (not IsUpper(prevCharacter) or 
                            (IsUpper(prevCharacter2) and not IsUpper(nextCharacter))) then
                        state[result] & " " & current
                    else
                        state[result] & current,
                
                resultRecord = [result = aggregatedResult, index = state[index]+1, source = state[source]]

            in
                resultRecord
        in
            res[result]
	
//  –§—É–Ω–∫—Ü–∏—è - fxSplitCamelCase –≤–∞—Ä–∏–∞–Ω—Ç2
    // Shared by Sergey Lossev
    (Source) =>
        let
            to_list     = Text.ToList(Source),
            accum_chars = List.Accumulate(to_list, "", (sum, x) => sum & (if x = Text.Upper(x) then " " & x else x)),
            split 		= Text.Split(Text.Trim(accum_chars), " "),
            accum_words = List.Accumulate(split, "", (sum, x) => sum & (if Text.Length(x) = 1 then x else " " & x & " ")),
            replace 	= Text.Trim(Text.Replace(accum_words, "  ", " "))
        in
            replace
	
//  Finally
    /*  FnSplitCamelCase is a very handly custom function. It can also help you to handle CamelCase values in 
	columns ‚Äì not just headers. For example, if you have CamelCase values in Column1, 
	you can click fx after Previous Step in Applied Steps, and paste the following formula:*/
	to = Table.TransformColumns(#"Previous Step",{{"Column1", fxSplitCamelCase, type text}})


	// ---------------------------------------------------------------------------------------	
	// Table_TransformColumnTypes - –∏–∑–º–µ–Ω–µ–Ω–∏–µ —Ç–∏–ø–∞ –≤—Å–µ—Ö —Å—Ç–æ–ª–±—Ü–æ–≤ (–ß–∏—Å—Ç–æ, –î–∞—Ç–∞, –¢–µ–∫—Å—Ç –≤—Å–µ –æ—Å—Ç–∞–ª—å–Ω—ã–µ)
		let
			from = Table.FromRecords({[–ù–∞–∏–º–µ–Ω–æ–≤–∞–Ω–∏–µ="—Ç–∞–ø–∫–∏",–ö–∞—Ç–µ–≥–æ—Ä–∏—è="–æ–±—É–≤—å",–¶–µ–Ω–∞–û–ø—Ç=1000,–¶–µ–Ω–∞–†–æ–∑–Ω=2000,–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ=100,–°—É–º–º–∞–û–ø—Ç=100000,–°—É–º–º–∞–†–æ–∑–Ω=200000,–ü—Ä–æ–¥–∞–≤–µ—Ü="–í–∞—Å—è",–î–∞—Ç–∞–ü–æ—Å—Ç—É–ø–ª–µ–Ω–∏—è=44562,–î–∞—Ç–∞–ü—Ä–æ–¥–∞–∂–∏=44835,–î–∞—Ç–∞–û—Ç–≥—Ä—É–∑–∫–∏=44866,–ü—Ä–∏–º–µ—á–∞–Ω–∏–µ="–æ–±—ã—á–Ω—ã–µ —Ç–∞–ø–∫–∏"]}),
			nms  = Table.ColumnNames(from),
			dlst = List.Select(nms,(i)=>Text.Contains(i,"–î–∞—Ç–∞")),
			nlst = List.Select(nms,(i)=>List.Contains({"–¶–µ–Ω–∞","–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ","–°—É–º–º–∞"},i,(x,y)=>Text.Contains(y,x))),
			tlst = List.Difference(nms,dlst&nlst),
			f=(x,y)=>List.Transform(x,(i)=>{i,y}),
			transflst = f(dlst,Date.Type)&f(nlst,Number.Type)&f(tlst,Text.Type),
			to = Table.TransformColumnTypes(from,transflst)
		in
			to

//  –¢–µ–ª–µ–≥—Ä–∞–º–º. –ß–∞—Ç –ø–æ PQ
    // –§–∞–π–ª –Ø–∫—É—à–µ–≤ (–µ—Å—Ç—å –≤ –ø–∞–ø–∫–µ PQ)
    // –ö–ª—é—á–µ–≤—ã–µ —Å–ª–æ–≤–∞: –≤–∏–¥–∏–º–æ –Ω–µ –ø—Ä–æ—â–µ... —Ç–∏–ø–∞ —Ç–æ–≥–æ (–¥–æ—Ä–∞–±–æ—Ç–∫–∞ –Ω–∞–ø–∏–ª—å–Ω–∏–∫–æ–º –Ω–∞ —Å–æ–≤–µ—Å—Ç–∏ –∑–∞–∫–∞–∑—á–∏–∫–∞):
        let from = Excel.Workbook(File.Contents("C:\Users\muzyk\Desktop\—è–∫—É—à–µ–≤.xlsx"), null, true){0}[Data],
            nms1 = List.Buffer(List.RemoveMatchingItems(Record.FieldValues(from{1}),{"",null})),
            nms2 = List.Buffer(Record.FieldValues(from{2})),
            pos  = List.PositionOf(nms2,"–ê—Ä—Ç–∏–∫—É–ª",Occurrence.All),
            st   = pos{0},
            len  = pos{1}-pos{0},
            num  = len*List.Count(pos),
            nms3 = List.ReplaceRange(nms2,st,num,{"–∫–æ–¥"}&List.Transform(List.Range(nms2,pos{0},pos{1}-pos{0}),(x)=>"new_"&x)),
            g=(x)=>[a = List.ReplaceMatchingItems(List.Range(x,st,num),{{"",null}}),
                    d = Number.RoundDown(List.PositionOf(a,null,Occurrence.First,(x,y)=>x<>y)/len),
                    b = if d>=0 then {nms1{d}}&List.Range(a,d*len,len) else List.Repeat({null},len+1), 
                    c = List.ReplaceRange(x,st,num,b) ][c],
            lst = Table.ToList(Table.Range(from,3),g),
            to  = Table.FromList(lst,(x)=>x,nms3)
        in  to,
    
//  —Ñ—É–Ω–∫—Ü–∏—è–ó–∞–º–µ–Ω—ã
    —Ñ—É–Ω–∫—Ü–∏—è–ó–∞–º–µ–Ω—ã = [
        let func =   
        (
        TableWithTextColumn as table, 
        ColumnNameTextToReplace as text, 
        ReplacementsTable as table, 
        ColumnNameWordToReplace as text, 
        ColumnNameReplaceWith as text
        ) => 
        let
            Source = ReplacementsTable,
            CreateListOfLists = Table.AddColumn(
                Source, 
                "Liste", 
                each ({Record.Field(_, ColumnNameWordToReplace), Record.Field(_, ColumnNameReplaceWith)})
            ),
            Text = TableWithTextColumn,
            TurnTextToList = Table.AddColumn(
                Text, 
                "Custom", 
                each Text.Split(Record.Field(_, ColumnNameTextToReplace), " ")
            ),
            Replacements = Table.AddColumn(
                TurnTextToList, 
                "Changed Text Expected", 
                each Text.Combine(List.ReplaceMatchingItems([Custom], CreateListOfLists[Liste]), " ")
            ),
            Cleanup = Table.RemoveColumns(Replacements, {"Custom"})
        in
            Cleanup ,
        documentation = [
        Documentation.Name =  " Table.ReplaceMultiple.pq ",
        Documentation.Description = " Replaces multiple values at a time in a table column without recursion. ",
        Documentation.LongDescription = "  Replaces multiple values at a time in a table column without recursion: http://www.thebiccountant.com/2016/05/22/multiple-replacements-in-power-bi-and-power-query/ The <code>ReplacementsTable </code> must have the values to be replaced in the 1st column and the new value in the 2nd. ",
        Documentation.Category = " Table.ColumnOperations ",
        Documentation.Source = " http://www.thebiccountant.com/2016/05/22/multiple-replacements-in-power-bi-and-power-query/ . ",
        Documentation.Version = " 2.0 ",
        Documentation.Author = " Imke Feldmann ",
        Documentation.Examples = {[Description =  "  ",
        Code = " let 
            TableWithText = #table( {""Text""}, List.Zip( { {""the cat sat on the mat"" ,""the cat sat next to the dog"" ,""the dog chased the cat"" ,""the dog sat on the mat"" ,""the catamaran sails through the air""} } ) ), 
            ReplacementsTable = #table( {""Word To Replace"", ""Replace With""}, List.Zip( { {""cat"" ,""mat"" ,""dog"" ,""the"" ,""air""}, {""bear"" ,""chair"" ,""dragon"" ,""THE"" ,""water""} } ) ),
        // The query containing the function has to be called ""fnTable_ReplaceMultiple_pq""
            Result = fnTable_ReplaceMultiple_pq ( TableWithText , ""Text"", ReplacementsTable, ""Word To Replace"", ""Replace With"" ) 
        in 
            Result ",
        Result = " Changed Text Expected
        ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
        THE bear sat on THE chair
        THE bear sat next to THE dragon
        THE dragon chased THE bear
        THE dragon sat on THE chair
        THE catamaran sails through THE water "]}]
        
        in  
        Value.ReplaceType(func, Value.ReplaceMetadata(Value.Type(func), documentation)) 
    ],
    test = [ // –∑–∞–º–µ–Ω—ã https://www.thebiccountant.com/2016/05/22/multiple-replacements-in-power-bi-and-power-query/
                let
                //Get table of word replacements
                Replacements = Excel.CurrentWorkbook(){[Name="Replacements"]}[Content],
                
                //Get table containing text to change
                TextToChange = Excel.CurrentWorkbook(){[Name="Text"]}[Content],
                
                //Get list of words to replace
                WordsToReplace = List.Buffer(Replacements[Word To Replace]),
                
                //Get list of words to replace them with
                WordsToReplaceWith = List.Buffer(Replacements[Replace With]),
                
                //A non-recursive function to do the replacements
                ReplacementFunction = (InputText)=> 
                let
                //Use List.Generate() to do the replacements
                DoReplacement = List.Generate(
                                    ()=> [Counter=0, MyText=InputText], 
                                    each [Counter]<=List.Count(WordsToReplaceWith), 
                                    each [Counter=[Counter]+1, 
                                            MyText=Text.Replace(
                                                    [MyText], 
                                                    WordsToReplace{[Counter]}, 
                                                    WordsToReplaceWith{[Counter]})], 
                                    each [MyText]),
                //Return the last item in the list that
                //List.Generate() returns
                GetLastValue = List.Last(DoReplacement)
                in
                GetLastValue,
                //Add a calculated column to call the function on every row in the table
                //containing the text to change
                Output = Table.AddColumn(TextToChange, "Changed Text List.Generate", each ReplacementFunction([Text])),
                #"Removed Columns" = Table.RemoveColumns(Output,{"Text"})
            in
                #"Removed Columns"
    ]		
//  –æ—Ç—á–µ—Ç –º—è—Å–Ω–æ–π –æ—Ç–¥–µ–ª 1–°
    let
        pack = Expression.Evaluate(Text.FromBinary(Web.Contents("https://raw.githubusercontent.com/buchlotnik/buchlotnik_functions/main/buchOfficePack")),#shared),
        file = File.Contents(Excel.CurrentWorkbook(){[Name="adres"]}[Content]{0}[Column1]),
        add = pack[fxExcelGetRowsAttributes](file){[Name="TDSheet"]}[Data],
        tr = Table.ReplaceValue(add,(x)=>x[Attributes],(x)=>if x[Attributes][outlineLevel]?="1" then null else x[Column1],Replacer.ReplaceValue,{"Attributes"}),

        unzip=Expression.Evaluate(Text.FromBinary(Web.Contents("https://raw.githubusercontent.com/buchlotnik/buchlotnik_functions/main/UnZip.pq")),#shared),
        bin = Binary.Buffer(File.Contents( pathToFile )),
        xml=Xml.Document(unzip(bin){[FileName="xl/worksheets/sheet1.xml"]}[Content]){0}[Value]{[Name="sheetData"]}[Value][Attributes],
        val=List.Transform(xml,(x)=>x{[Name="ht"]}?[Value]?),
        nms=List.Transform(xml,(x)=>x{[Name="r"]}?[Value]?),
        dict=Record.FromList(val,nms),
        sh = Excel.Workbook(bin,false){0}[Data],
        add = Table.AddIndexColumn(sh, "–£—Ä–æ–≤–µ–Ω—å", Number.From(nms{0}),1),
        to =
            Table.AddColumn(
                add,
                "–ì—Ä—É–ø–ø–∞",
                ( x ) => if Record.FieldOrDefault( dict, Text.From( x[ –£—Ä–æ–≤–µ–Ω—å ] ) ) = "12.95" then x[ Column1 ] else null,
                type text
            ),

//  –ø—Ä–æ–±–∞ –ø–µ—Ä–∞. –û—Ç—á–µ—Ç–Ω–æ—Å—Ç—å –∏–∑ –∏–Ω—Ç–µ—Ä–Ω–µ—Ç–∞
    let
        // –ø–æ–ª–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ –æ—Ç—á–µ—Ç–Ω–æ—Å—Ç–∏ –Ω–∞ —Å–∞–π—Ç–µ (–ö–æ–Ω—Ç–∞ —Å–ø–∞ –∑–∞ 2022 –≥.)
        URL    = "https://epfr.gov.by/file/111430/content",
        Source = Pdf.Tables(Web.Contents(URL), [Implementation="1.3"]),
        Filter = Table.SelectRows(Source, each ([Kind] = "Page"))[[Id],[Data]],
        
        // –§—É–Ω–∫—Ü–∏—è –æ—á–∏—Å—Ç–∫–∏ –ë–ê–õ–ê–ù–°–ê
        f1=(x)=> let 
                    // —Ñ–∏–ª—å—Ç—É—Ä—É–µ–º —Å—Ç—Ä–æ–∫–∏ –ø–æ –∑–Ω–∞—á–µ–Ω–∏—é –∫–æ–ª–æ–Ω–∫–∏4 - –ø–µ—Ä–≤—ã–π –∑–Ω–∞–∫ —Ü–∏—Ñ—Ä–∞
                    f=(y)=> try List.ContainsAny ( { Text.Start(y[Column4],1) },{"0".."9"},Text.Contains) otherwise null,
                    a = Table.SelectRows(x, f),
                    // —á–∏—Å—Ç–∏–º —Ç–∞–±–ª–∏—Ü—É –∑–∞–≥—Ä—É–∂–µ–Ω–Ω–æ–π —Ñ—É–Ω–∫—Ü–∏–µ–π
                    b = Load("fxClear")(a, "", true, true),
                    c = Table.RenameColumns(b, List.Zip({ Table.ColumnNames(b), {"–°—Ç–∞—Ç—å—è","–°—Ç—Ä–æ–∫–∞","–ù–∞ –Ω–∞—á–∞–ª–æ","–ù–∞ –∫–æ–Ω–µ—Ü"} })),
                    d = Table.SelectRows(c, each Text.Length([–°—Ç—Ä–æ–∫–∞]) = 3),
                    // –º–µ–Ω—è–µ—Ç —Ç–∏–ø –¥–∞–Ω–Ω—ã—Ö –≤ –∫–æ–ª–æ–Ω–∫–∞—Ö 2 –∏ –¥–∞–ª—å—à–µ –Ω–∞ —á–∏—Å–ª–æ–≤—ã–µ
                    n = Table.ColumnNames(d), Skip = 1,
                    t = Table.TransformColumnTypes(d, 
                            { {n{0}, type text} } & List.Transform(List.Skip(n, Skip), (x)=> {x, Int64.Type})),
                    // —É–±–∏—Ä–∞–µ–º –æ—à–∏–±–∫–∏ –≤ –∫–æ–ª–æ–Ω–∫–∞—Ö 2+
                    w = Table.ReplaceErrorValues(t, 
                            List.Transform(List.Skip(n, Skip), (x)=> {x,null})) // {–∏–º—è, null}
                in w ,
                            
        f2=(x)=> Table.Skip(x, 2),
        
        // –∫–æ–ª–æ–Ω–∫–∞ 6
        f3=(x)=> let f=(y)=> try List.ContainsAny ( { Text.Start(y[Column6],1) },{"0".."9"},Text.Contains) and y[Column4] <> "2" otherwise null
                in  Load("fxClear")(Table.SelectRows(x, f),"",1, 1),
        
        to = Table.AddColumn(Filter, "NewColumn", each 
                    if [Id] = "Page001" then f2( [Data] ) // –ë–∞–ª–∞–Ω—Å —Å—Ç—Ä 1
                else if [Id] = "Page002" then f2( [Data] ) // –ë–∞–ª–∞–Ω—Å —Å—Ç—Ä 2
                else if [Id] = "Page003" then f3( [Data] ) // –û—Ç—á–µ—Ç –æ –ø—Ä–∏–±—ã–ª—è—Ö
                else [Data]
        )
    in
        to

//  !!! –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ —Ç–∞–±–ª–∏—Ü Power BI –≤ –ª–æ–∫–∞–ª—å–Ω—É—é –±–∞–∑—É –¥–∞–Ω–Ω—ã—Ö —Å –ø–æ–¥–¥–µ—Ä–∂–∫–æ–π –∏–Ω–∫—Ä–µ–º–µ–Ω—Ç–∞–ª—å–Ω–æ–≥–æ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –ù–∞–∑–∞—Ä–æ–≤
    // –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∑–∞–ø—Ä–æ—Å–æ–≤ –∏ –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏–µ –≤ –ë–í
    https://github.com/meta110/powerbi/blob/master/sqliteproxy/pbi2sqlite.m
    let
        // –ù–æ–≤–∞—è –≤–µ—Ä—Å–∏—è —Ñ–∞–π–ª–∞ –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –∑–¥–µ—Å—å https://github.com/meta110/powerbi/blob/master/sqliteproxy/pbi2sqlite.m

        // –¢–∞–±–ª–∏—Ü–∞ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–π —Ç–∏–ø–æ–≤ –∫–æ–ª–æ–Ω–æ–∫ –≤ SQLite –∏ –æ–±—Ä–∞—Ç–Ω–æ
        // –Ω–∞–ø—Ä–∏–º–µ—Ä, –¥–∞—Ç—ã –º–æ–∂–Ω–æ —Ö—Ä–∞–Ω–∏—Ç—å –≤ –≤–∏–¥–µ —Ü–µ–ª–æ—á–∏—Å–ª–µ–Ω–Ω–æ–≥–æ —Ç–∞–π–º—à—Ç–∞–º–ø–∞ –∏–ª–∏ —Ç–µ–∫—Å—Ç–æ–º
        // –¥–æ–ø—É—Å—Ç–∏–º—ã–µ —Ç–∏–ø—ã https://www.sqlite.org/datatype3.html#storage_classes_and_datatypes
        typeConversion = #table( 
            type table [ Name = text, Type = type, Value = text, Transform = function, Revert = function ], {
            { "Percentage.Type",Percentage.Type,"REAL",   Number.From,    each Percentage.From( _, LOCALE ) },
            { "Int64.Type",     Int64.Type,     "INTEGER",Int64.From,     each Int64.From( _, LOCALE ) },
            { "Date.Type",      Date.Type,      "INTEGER",DateTime2Timestamp, each Date.From( Timestamp2DateTimeZone( _ ) ) },
            { "DateTime.Type",  DateTime.Type,  "INTEGER",DateTime2Timestamp, each DateTime.From( Timestamp2DateTimeZone( _ ) ) },
            { "Text.Type",      Text.Type,      "TEXT",   each _,         each _ },
            { "Duration.Type",  Duration.Type,  "TEXT",   Text.From,      Duration.From },
            { "Currency.Type",  Currency.Type,  "REAL",   Number.From,    each Currency.From( _, LOCALE ) },
            { "List.Type",      List.Type,      "TEXT",   Value.ToText,   Json.Document },
            { "Number.Type",    Number.Type,    "REAL",   Number.From,    each Number.From( _, LOCALE ) },
            { "Any.Type",       Text.Type,      "TEXT",   each _,         each _}
            } ),

        PyScript = "    #(cr)#(lf)import os#(cr)#(lf)import json#(cr)#(lf)import sqlite3#(cr)#(lf)#(cr)#(lf)def test_path(paths):#(cr)#(lf)    try:#(cr)#(lf)        paths = json.loads( paths )#(cr)#(lf)        for path in paths:#(cr)#(lf)            abspath = os.path.abspath( path )#(cr)#(lf)            dirname = os.path.dirname( abspath )#(cr)#(lf)            if ( os.path.exists( dirname ) ):#(cr)#(lf)                return abspath#(cr)#(lf)    except: return False#(cr)#(lf)#(cr)#(lf)class Config(object):#(cr)#(lf)    def __init__(self,df): #df is a pd.DataFrame#(cr)#(lf)        df = df.set_index('Name',drop=True,inplace=False)#(cr)#(lf)        self.abspath = test_path( df.loc['db_path']['Value'] )#(cr)#(lf)        self.cwd = os.getcwd()#(cr)#(lf)        self.table_name = df.loc['table_name']['Value']#(cr)#(lf)        self.schema_name = self.table_name + '_schema'#(cr)#(lf)        try:#(cr)#(lf)            self.key_columns = json.loads(df.loc['key_columns']['Value'])#(cr)#(lf)        except:#(cr)#(lf)            self.key_columns = ''         #(cr)#(lf)        self.raise_error = df.loc['raise_error']['Value'] == 'True'#(cr)#(lf)#(cr)#(lf)#test = Config(config)#(cr)#(lf)#%%#(cr)#(lf)    #(cr)#(lf)def is_table_exists(table):#(cr)#(lf)    '''–ü—Ä–æ–≤–µ—Ä—è—é —á–µ—Ä–µ–∑ –º–∞—Å—Ç–µ—Ä-—Ç–∞–±–ª–∏—Ü—É, —á—Ç–æ –Ω—É–∂–Ω–∞—è —Ç–∞–±–ª–∏—Ü–∞ –µ—Å—Ç—å –≤ –ë–î'''#(cr)#(lf)    with con:#(cr)#(lf)        test = con.execute(f""SELECT * FROM sqlite_master WHERE type='table' AND name='{table}';"").fetchall()#(cr)#(lf)    return len(test) > 0#(cr)#(lf)#(cr)#(lf)#(cr)#(lf)def create_table( table_name, df, table_key ):#(cr)#(lf)    '''–°–æ–∑–¥–∞—é —Ç–∞–±–ª–∏—Ü—É –∏ –Ω–∞—Å—Ç—Ä–∞–∏–≤–∞—é –ø–æ–ª—è'''#(cr)#(lf)    tmpl = '''#(cr)#(lf)        DROP TABLE IF EXISTS ""{table_name}"";    #(cr)#(lf)        CREATE TABLE ""{table_name}"" (#(cr)#(lf)            {fields},#(cr)#(lf)            {key}#(cr)#(lf)        );#(cr)#(lf)    '''#(cr)#(lf)    column_tmpl = '""{name}"" {type}'#(cr)#(lf)    key_tmpl = 'PRIMARY KEY ({table_key})'#(cr)#(lf)    # –∑–∞–ø–æ–ª–Ω—è—é —à–∞–±–ª–æ–Ω –¥–ª—è –∫–æ–ª–æ–Ω–æ–∫#(cr)#(lf)    column_statements = [#(cr)#(lf)        column_tmpl.format( name = key, type = value )#(cr)#(lf)        for key, value in schema[['Name','Value']].values #(cr)#(lf)    ] #(cr)#(lf)    # –∑–∞–∫–∞–≤—ã—á–∏–≤–∞—é –∫–ª—é—á–µ–≤—ã–µ –∫–æ–ª–æ–Ω–∫–∏#(cr)#(lf)    key_statement = key_tmpl.format(#(cr)#(lf)        table_key = ', '.join( [ '""' + key + '""' for key in table_key ] ) )#(cr)#(lf)    #(cr)#(lf)    # –∑–∞–ø–æ–ª–Ω—è—é –∑–∞–ø—Ä–æ—Å#(cr)#(lf)    query = tmpl.format(#(cr)#(lf)        table_name = table_name,#(cr)#(lf)        fields     = ',\n            '.join( sorted( column_statements ) ),#(cr)#(lf)        key        = key_statement#(cr)#(lf)    )#(cr)#(lf)    with con:#(cr)#(lf)        con.executescript(query)#(cr)#(lf)    con.commit()#(cr)#(lf)    #(cr)#(lf)    return query#(cr)#(lf)#(cr)#(lf)#(cr)#(lf)def read_df(table):#(cr)#(lf)    ''' –ó–∞–±–∏—Ä–∞–µ—Ç —Ç–∞–±–ª–∏—Ü—É –∏–∑ –ë–î –≤ –¥–∞—Ç–∞—Ñ—Ä–µ–π–º '''#(cr)#(lf)    with con:#(cr)#(lf)        return pandas.read_sql( f'SELECT * FROM ""{table}""', con )#(cr)#(lf)#(cr)#(lf)#(cr)#(lf)def write_df(table,data):#(cr)#(lf)    ''' –ó–∞–ø–∏—Å—ã–≤–∞–µ—Ç –¥–∞—Ç–∞—Ñ—Ä–µ–π–º –≤ –ë–î '''#(cr)#(lf)    with con:#(cr)#(lf)        return data.to_sql(table,con,index=False, if_exists='replace')#(cr)#(lf)#(cr)#(lf)#(cr)#(lf)def upsert(table,df_columns,keycolumn):#(cr)#(lf)    '''–°—Ç—Ä–æ–∏—Ç UPSERT –∑–∞–ø—Ä–æ—Å'''#(cr)#(lf)    #df_columns = list(df) #list(map(get_ch_field_name, fields)) #(cr)#(lf)    values = 'VALUES({})'.format(','.join(['?' for col in df_columns]))#(cr)#(lf)    columns = ','.join([ '""' + column + '""' for column in df_columns ])#(cr)#(lf)#(cr)#(lf)    for key in keycolumn:    #(cr)#(lf)        df_columns.remove(key) # –º–æ–¥–∏—Ñ–∏—Ü–∏—Ä—É–µ—Ç —Å–∞–º —Å–ø–∏—Å–æ–∫, –ø–æ—ç—Ç–æ–º—É –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç None#(cr)#(lf)    #(cr)#(lf)    update_list = ['""{}"" = EXCLUDED.""{}""'.format(col, col) for col in df_columns]#(cr)#(lf)    update_str = ','.join(update_list)#(cr)#(lf)    insert_stmt = 'INSERT INTO ""{}"" ({}) {} ON CONFLICT ({}) DO UPDATE SET {}'.format(#(cr)#(lf)        table, columns, values, ','.join([ '""' + column + '""' for column in keycolumn]), update_str)#(cr)#(lf)#(cr)#(lf)    return insert_stmt#(cr)#(lf)#(cr)#(lf)#(cr)#(lf)def upload(table, df, keycolumn):#(cr)#(lf)    '''–ó–∞–≥—Ä—É–∂–∞–µ—Ç –¥–∞–Ω–Ω—ã–µ –≤ SQLite'''#(cr)#(lf)    insert_stmt = upsert(table,list(df),keycolumn)#(cr)#(lf)    with con:#(cr)#(lf)        con.executemany(insert_stmt, df.values.tolist())#(cr)#(lf)    #(cr)#(lf)    con.commit()        #(cr)#(lf)#(cr)#(lf)#(cr)#(lf)class Schema(object):#(cr)#(lf)    def __init__(self,df):#(cr)#(lf)        self.exists = not df.empty#(cr)#(lf)        self.schema = df#(cr)#(lf)        self.should_init_db = False#(cr)#(lf)        self.incompatible_fields = False#(cr)#(lf)        if ( self.exists ):#(cr)#(lf)            self.cleaned = df.drop(columns='Position').sort_values('Name').reset_index(drop=True)#(cr)#(lf)#(cr)#(lf)#(cr)#(lf)def update_schema( one: Schema, another: Schema ):#(cr)#(lf)    if ( another.exists and one.exists ):#(cr)#(lf)        if one.cleaned.equals( another.cleaned ):#(cr)#(lf)            one.schema = another.schema#(cr)#(lf)            one.difference = ''#(cr)#(lf)        else:#(cr)#(lf)            one.incompatible_fields = True#(cr)#(lf)            diff = pandas.concat( [ one.cleaned, another.cleaned ] ).drop_duplicates( keep = False )#(cr)#(lf)            one.difference = diff[['Name', 'TypeName']]#(cr)#(lf)    elif ( another.exists ):#(cr)#(lf)        one.schema = another.schema#(cr)#(lf)        one.exists = True#(cr)#(lf)        one.should_init_db = True#(cr)#(lf)#(cr)#(lf)#(cr)#(lf)def prepare_db(table_name, df, key_columns, #(cr)#(lf)             schema_name, schema, raise_error):#(cr)#(lf)    #(cr)#(lf)    existing_schema = read_df( schema_name ) if is_table_exists( schema_name ) else pandas.DataFrame([])#(cr)#(lf)    existing_schema = Schema(existing_schema)#(cr)#(lf)    pretending_schema = Schema(schema)#(cr)#(lf)    update_schema( existing_schema, pretending_schema)#(cr)#(lf)#(cr)#(lf)    if not( existing_schema.exists ):#(cr)#(lf)        raise Exception(f'–î–∞–Ω–Ω—ã–µ –¥–ª—è –∑–∞–≥—Ä—É–∑–∫–∏ –æ—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç. –¢–∞–±–ª–∏—Ü–∞ {table_name} –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –∏ –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å —Å–æ–∑–¥–∞–Ω–∞ –∏–∑-–∑–∞ –æ—Ç—Å—É—Ç—Å—Ç–≤–∏—è –¥–∞–Ω–Ω—ã—Ö. –£–∫–∞–∂–∏—Ç–µ –¥—Ä—É–≥—É—é —Ç–∞–±–ª–∏—Ü—É –∏–ª–∏ –ø–µ—Ä–µ–¥–∞–π—Ç–µ –¥–∞–Ω–Ω—ã–µ –¥–ª—è –∑–∞–≥—Ä—É–∑–∫–∏.')#(cr)#(lf)  #(cr)#(lf)    if ( existing_schema.incompatible_fields ):#(cr)#(lf)        if ( raise_error ):#(cr)#(lf)            raise Exception('–¢–∞–±–ª–∏—Ü–∞ ""{}"" —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –≤ –ë–î, –µ—ë –∫–æ–ª–æ–Ω–∫–∏ –æ—Ç–ª–∏—á–∞—é—Ç—Å—è –æ—Ç –Ω–æ–≤—ã—Ö. –û–±–Ω–∞—Ä—É–∂–µ–Ω—ã –æ—Ç–ª–∏—á–∏—è –Ω–∞–∑–≤–∞–Ω–∏–π –∫–æ–ª–æ–Ω–æ–∫/—Ç–∏–ø–æ–≤: ""\n{}"". –£–∫–∞–∂–∏—Ç–µ –¥—Ä—É–≥—É—é —Ç–∞–±–ª–∏—Ü—É –∏–ª–∏ –æ—Ç–∫–ª—é—á–∏—Ç–µ –ø—Ä–æ–≤–µ—Ä–∫—É, —á—Ç–æ–±—ã –ø–µ—Ä–µ—Å–æ–∑–¥–∞—Ç—å —Ç–∞–±–ª–∏—Ü—É —Å –Ω–æ–≤—ã–º–∏ –¥–∞–Ω–Ω—ã–º–∏.'.format(#(cr)#(lf)                table_name, #(cr)#(lf)                existing_schema.difference.to_csv(index=False,sep=' ',line_terminator='\n',header=False)#(cr)#(lf)                ))#(cr)#(lf)        else:#(cr)#(lf)            existing_schema = pretending_schema#(cr)#(lf)            existing_schema.should_init_db = True#(cr)#(lf)            #(cr)#(lf)    if ( existing_schema.should_init_db ):#(cr)#(lf)        create_table( table_name, df, key_columns )#(cr)#(lf)        write_df( schema_name, schema )#(cr)#(lf)        #(cr)#(lf)    return existing_schema.schema#(cr)#(lf)    #(cr)#(lf)#%%#(cr)#(lf)  #(cr)#(lf)config = Config(config)  #(cr)#(lf)#(cr)#(lf)if not( config.abspath  ):#(cr)#(lf)    raise Exception( '–£–∫–∞–∑–∞–Ω –ø—É—Ç—å –∫ –Ω–µ—Å—É—â–µ—Å—Ç–≤—É—é—â–µ–π –ø–∞–ø–∫–µ. –§–∞–π–ª –ë–î –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å —Å–æ–∑–¥–∞–Ω –∏–ª–∏ –ø—Ä–æ—á–∏—Ç–∞–Ω.' )#(cr)#(lf)#(cr)#(lf)try:#(cr)#(lf)    con = sqlite3.connect( config.abspath )#(cr)#(lf)except:#(cr)#(lf)    raise Exception(f'{config.abspath=}')#(cr)#(lf)#(cr)#(lf)#raise Exception('schema {}'.format(schema))#(cr)#(lf)#(cr)#(lf)schema = prepare_db( config.table_name, df1, config.key_columns, #(cr)#(lf)             config.schema_name, schema, config.raise_error )#(cr)#(lf)     #(cr)#(lf)#(#)(schema.sort_values('Name').reset_index(drop=True).equals(existing_schema.sort_values('Name').reset_index(drop=True))):#(cr)#(lf)if not( df1.empty ):#(cr)#(lf)    upload(config.table_name, df1, config.key_columns)#(cr)#(lf)#(cr)#(lf)result = read_df( config.table_name ) #pandas.DataFrame([ '–î–∞–Ω–Ω—ã–µ –∑–∞–≥—Ä—É–∂–µ–Ω—ã –≤ –ë–î' ])#(cr)#(lf)#(cr)#(lf)con.close()#(cr)#(lf)#(cr)#(lf)config = pandas.DataFrame.from_dict(vars(config),orient='index').reset_index(level=0)",

        // –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ
        LOCALE = "en-US",
        EMPTY_TABLE = #table(1,{}),
        UNIX = #datetimezone( 1970, 1, 1, 0, 0, 0, 0, 0 ),

        // –§—É–Ω–∫—Ü–∏—è –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏—è –æ–±—ä–µ–∫—Ç–∞ PQ –≤ —Ç–µ–∫—Å—Ç
        Value.ToText = each Text.FromBinary( Json.FromValue( _ ) ),
        
        // –§—É–Ω–∫—Ü–∏–∏ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏—è –¥–∞—Ç –≤ timestamp –∏ –æ–±—Ä–∞—Ç–Ω–æ
        DateTime2Timestamp = each Duration.TotalSeconds( DateTimeZone.From(_) - UNIX ),
        Timestamp2DateTimeZone = each UNIX + #duration(0,0,0, Int64.From( _, LOCALE ) ),

    cache = ( 
            DataBasePath as text,
            TableName as text,
            optional Data as nullable table,
            optional KeyColumns as list,
            optional RaiseError as logical
        ) => let
        
        // –ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ –ë–î
        db_path = List.Transform( Text.Split( DataBasePath, "," ), Text.Trim ),
        
        config = [
            db_path    = Value.ToText( db_path ),
            table_name = TableName,
            key_columns = Value.ToText( KeyColumns ),
            raise_error = Text.Proper( Text.From( RaiseError ?? true ) ) 
            ],

        // –ü–æ–¥–≥–æ—Ç–∞–≤–ª–∏–≤–∞—é —Ç–∞–±–ª–∏—Ü—É –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–π
        combineColumns = Table.CombineColumnsToRecord( 
            typeConversion,
            "Value",
            List.RemoveItems( Table.ColumnNames(typeConversion), {"Name"} ) 
            ),

        asRecord = Record.FromTable(combineColumns),

        // –ì–µ–Ω–µ—Ä–∏—Ä—É—é —Ç–∏–ø –∫–æ–ª–æ–Ω–æ–∫
        recordType = Type.ForRecord( 
            Record.RemoveFields( 
                Type.RecordFields( Type.TableRow( Value.Type( typeConversion ) ) ), 
                {"Name"} 
            ), false ),
        
        // —Å—Ç—Ä–æ–∫–∏ —Å –æ—à–∏–±–∫–∞–º–∏
        errRows = Table.SelectRowsWithErrors( Table.AddIndexColumn( Data, "Indx", 1 ) ),

        // –ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ —Å—Ö–µ–º—ã —Ç–∞–±–ª–∏—Ü—ã
        Source = Table.Schema( Data ),

        #"Added Custom" = Table.AddColumn(Source, "SQLType", 
            each Record.Field( asRecord, [TypeName] ), recordType ),
        #"Expanded SQLType" = Table.ExpandRecordColumn(#"Added Custom", "SQLType", {"Value", "Transform"}, {"Value", "Transform"}),
        dataTransformations = Table.ToRows( Table.SelectColumns( #"Expanded SQLType", {"Name", "Transform"} ) ),
        // –≤ –∏–Ω–¥–µ–∫—Å–∞—Ö –Ω–µ –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å null, –∑–∞–º–µ–Ω—è—é –∏—Ö –Ω–∞ 0 - —ç—Ç–æ –Ω–µ –≤—Å–µ–≥–¥–∞ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ. –õ—É—á—à–µ –ø—Ä–æ–≤–µ—Ä—è—Ç—å –∏–Ω–¥–µ–∫—Å–Ω—ã–µ –∫–æ–ª–æ–Ω–∫–∏ –Ω–∞ null –∏ –≤–æ–∑–±—É–∂–¥–∞—Ç—å –æ—à–∏–±–∫—É –ø—Ä–∏ –∏—Ö –Ω–∞–ª–∏—á–∏–∏
        //fix_null = Table.ReplaceValue( Data, null, 0, Replacer.ReplaceValue, KeyColumns ),
        data = Table.TransformColumns( Data, dataTransformations ),
        schema = Table.SelectColumns(#"Expanded SQLType",{"Name", "Position", "TypeName", "Value"}),

        PyParams = [
            df1     =   if Data = null then EMPTY_TABLE else data, 
            schema  =   if Data = null then EMPTY_TABLE else schema, 
            config  =   Record.ToTable(config)
        ],
        
        // –ó–∞–ø—É—Å–∫ Python
        #"Run Python script" = Python.Execute(PyScript,PyParams),
        
        // –ü–æ–∏—Å–∫ –æ—à–∏–±–æ–∫ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è
        run = try #"Run Python script",
        result = if run[HasError] then error run[Error] else run[Value],

        // –†–∞–∑–±–∏—Ä–∞—é —Å—Ö–µ–º—É –¥–∞–Ω–Ω—ã—Ö
        loadedSchema = result{[Name="schema"]}[Value],
        #"Sorted Rows" = Table.Sort(loadedSchema,{{"Position", Order.Ascending}}),
        #"Added Custom1" = Table.AddColumn(#"Sorted Rows", "Values", 
            each Record.Field( asRecord, [TypeName] ), recordType ),
        #"Expanded Values" = Table.ExpandRecordColumn(#"Added Custom1", "Values", {"Revert", "Type"}, {"Revert", "Type"}),
        #"Removed Columns" = Table.RemoveColumns(#"Expanded Values",{"Value", "TypeName", "Position"}),
        fix_empty = Table.TransformColumns( #"Removed Columns", { "Revert", each (t) => if ( t = null or t = "" ) then null else _(t) } ),
        transformations = Table.ToRows( fix_empty ),
        
        // –ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ –∑–∞–≥—Ä—É–∂–µ–Ω–Ω–æ–π —Ç–∞–±–ª–∏—Ü—ã –∫ –∏—Å—Ö–æ–¥–Ω–æ–º—É –≤–∏–¥—É
        loadedTable = result{[Name="result"]}[Value],
        transform = Table.TransformColumns(loadedTable,transformations),
        return = Table.ReorderColumns(transform,#"Sorted Rows"[Name])

        in 	//Source /*
            if Data <> null and KeyColumns = null then error "–£–∫–∞–∂–∏—Ç–µ –∫–ª—é—á–µ–≤—ã–µ –∫–æ–ª–æ–Ω–∫–∏"
            else if Data <> null and not List.ContainsAll( Table.ColumnNames( Data ), KeyColumns ) 
                then error "–ù–∞–∑–≤–∞–Ω–∏—è –∫–ª—é—á–µ–≤—ã—Ö –∫–æ–ª–æ–Ω–æ–∫ –¥–æ–ª–∂–Ω—ã —Å–æ–≤–ø–∞–¥–∞—Ç—å —Å –∫–æ–ª–æ–Ω–∫–∞–º–∏ —Ç–∞–±–ª–∏—Ü—ã"
            else if Data <> null and not Table.IsEmpty( errRows ) then error "–£—Å—Ç—Ä–∞–Ω–∏—Ç–µ –æ—à–∏–±–∫–∏ –≤ –∏—Å—Ö–æ–¥–Ω–æ–π —Ç–∞–±–ª–∏—Ü–µ. –ù–æ–º–µ—Ä–∞ —Å—Ç—Ä–æ–∫, —Å–æ–¥–µ—Ä–∂–∞—â–∏—Ö –æ—à–∏–±–∫–∏: " & Text.Combine( List.Transform( errRows[Indx], Text.From ), "," )
            else return meta ( config ) //*/
    in
        cache        
//  —Ñ—É–Ω–∫—Ü–∏—è pqVLOOKUP
    [   —Ñ—É–Ω–∫—Ü–∏—è pqVLOOKUP
        /* –ü—Ä–∏–º–µ—Ä –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è */
        /* = pqVLOOKUP(2, Head1, 2, null) */

        let pqVLOOKUP = 
            (   lookup_value as any, 
                table_array as table, 
                col_index_number as number, 
                optional approximate_match as logical ) as any =>
            let
                /*Provide optional match if user didn't */
                matchtype = if approximate_match = null
                            then true
                            else approximate_match,

                /*Get name of return column */
                Cols            = Table.ColumnNames(table_array),
                ColTable        = Table.FromList(Cols, Splitter.SplitByNothing(), null, null, ExtraValues.Error),
                ColName_match   = Record.Field(ColTable{0},"Column1"),
                ColName_return  = Record.Field(ColTable{col_index_number - 1},"Column1"),

                /*Find closest match */
                SortData        = Table.Sort(table_array,{{ColName_match, Order.Descending}}),
                RenameLookupCol = Table.RenameColumns(SortData,{{ColName_match, "Lookup"}}),
                RemoveExcess    = Table.SelectRows(RenameLookupCol, each [Lookup] <= lookup_value),
                ClosestMatch    =   if Table.IsEmpty(RemoveExcess)=true 
                                    then "#N/A" 
                                    else Record.Field(RemoveExcess{0},"Lookup"),

                /*What should be returned in case of approximate match? */
                ClosestReturn   =   if Table.IsEmpty(RemoveExcess)=true 
                                    then "#N/A" 
                                    else Record.Field(RemoveExcess{0},ColName_return),

                /*Modify result if we need an exact match */
                Return = 
                    if matchtype=true
                    then ClosestReturn
                    else
                        if lookup_value = ClosestMatch
                        then ClosestReturn
                        else "#N/A"
            in Return
        in pqVLOOKUP
        ]

//  —Ñ—É–Ω–∫—Ü–∏—è fxReplaceDictReWrite
    [   —Ñ—É–Ω–∫—Ü–∏—è fxReplaceDictReWrite
            // –ó–∞–º–µ–Ω–∞ –∑–Ω–∞—á–µ–Ω–∏–π –≤ –∫–æ–ª–æ–Ω–∫–µ –ø–æ —Å–ø—Ä–∞–≤–æ—á–Ω–∏–∫—É —Å –ø–µ—Ä–µ–∑–∞–ø–∏—Å—å—é —Å—Ç–æ–ª–±—Ü–∞
            // –ò—Å—Ç–æ—á–Ω–∏–∫ = fxReplaceDictReWrite(–ü—Ä–æ–∏–∑–≤–æ–¥—Å—Ç–≤–æ, "–ü—Ä–µ–¥–ø—Ä–∏—è—Ç–∏—è", "–ö–æ–¥_–ø—Ä–µ–¥–ø—Ä–∏—è—Ç–∏—è", "–ù–∞–∑–≤–∞–Ω–∏–µ_–∏—Å—Ö–æ–¥–Ω–æ–µ", "–ü—Ä–µ–¥–ø—Ä–∏—è—Ç–∏–µ")

            (   –ò—Å—Ç–æ—á–Ω–∏–∫ as table, 
                –°–ø—Ä–∞–≤–æ—á–Ω–∏–∫ as text, 
                –°–ø—Ä–ö–æ–ª–æ–Ω–∫–∞–ß—Ç–æ as text, 
                –°–ø—Ä–ö–æ–ª–æ–Ω–∫–∞–ù–∞–ß—Ç–æ as text, 
                –ò–º—è–ö–æ–ª–æ–Ω–∫–∏–ò—Å—Ç–æ—á–Ω–∏–∫–∞ as text)=>

            let
                // –¢–∞–±–ª–∏—Ü–∞ –∑–∞–º–µ–Ω—ã: –ò–º—è, –ö–æ–ª–æ–Ω–∫–∞ "–ß—Ç–æ", –ö–æ–ª–æ–Ω–∫–∞ "–ù–∞–ß—Ç–æ" 
                Dict     = Excel.CurrentWorkbook(){[Name=–°–ø—Ä–∞–≤–æ—á–Ω–∏–∫]}[Content],
                BadName  = List.Buffer(Table.ToColumns(Table.SelectColumns(Dict,{–°–ø—Ä–ö–æ–ª–æ–Ω–∫–∞–ß—Ç–æ}))){0},
                GoodName = List.Buffer(Table.ToColumns(Table.SelectColumns(Dict,{–°–ø—Ä–ö–æ–ª–æ–Ω–∫–∞–ù–∞–ß—Ç–æ}))){0},

                // –†–µ–∑—É–ª—å—Ç–∞—Ç –∑–∞–º–µ–Ω—ã
                Result = 
                    Table.TransformColumns(
                        –ò—Å—Ç–æ—á–Ω–∏–∫, 
                        {
                            {–ò–º—è–ö–æ–ª–æ–Ω–∫–∏–ò—Å—Ç–æ—á–Ω–∏–∫–∞, each try GoodName{List.PositionOf(BadName, _)} otherwise _}
                        }
                    )
            in 
                Result
        ]

//  —Ñ—É–Ω–∫—Ü–∏—è - fxReplaceDictNewCol
    [   —Ñ—É–Ω–∫—Ü–∏—è - fxReplaceDictNewCol

        // —Ñ—É–Ω–∫—Ü–∏—è –∑–∞–º–µ–Ω—ã –∑–Ω–∞—á–µ–Ω–∏–π –≤ –∫–æ–ª–æ–Ω–∫–µ —Ç–∞–±–ª–∏—Ü–µ –ø–æ —Å–ø—Ä–∞–≤–æ—á–Ω–∏–∫—É
        // –ò—Å—Ç–æ—á–Ω–∏–∫ - —Ç–∞–±–ª–∏—Ü–∞ –≥–¥–µ –º–µ–Ω—è—Ç—å –∫–∞–∫–æ–π—Ç–æ —Å—Ç–æ–ª–±–µ—Ü
        // –°–ª–æ–≤–∞—Ä—å - –∏–º—è —Ç–∞–±–ª–∏—Ü—ã —Å —É–∫–∞–∑–∞–Ω–∏–µ–º –∫–æ–ª–æ–Ω–∫–∞–º–∏ "–ß—Ç–æ" –∏ "–ù–∞–ß—Ç–æ" –º–µ–Ω—è—Ç—å.
        // –ü—Ä–∏–º–µ—Ä –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è:

        (   –ò—Å—Ç–æ—á–Ω–∏–∫ as table, 
            –ò–º—è–°–ø—Ä–∞–≤–æ—á–Ω–∏–∫–∞ as text, 
            –ò–º—è–ö–æ–ª–æ–Ω–∫–∏–ò—Å—Ç–æ—á–Ω–∏–∫–∞ as text, 
            –ò–º—è–ù–æ–≤–æ–π–ö–æ–ª–æ–Ω–∫–∏ as text
        )=>
            let
                //  –¢–∞–±–ª–∏—Ü–∞ –∑–∞–º–µ–Ω—ã. –ò–∑ –Ω–µ–µ –Ω—É–∂–Ω—ã —Ç–æ–ª—å–∫–æ 2 —Å—Ç–æ–ª–±—Ü–∞ - –ß—Ç–æ –∏ –ù–∞–ß—Ç–æ –∑–∞–º–µ–Ω–∏—Ç—å
                    Dict = Excel.CurrentWorkbook(){[Name=–ò–º—è–°–ø—Ä–∞–≤–æ—á–Ω–∏–∫–∞]}[Content],
                    ColNames = Table.ColumnNames(Dict),

                //  –£–¥–∞–ª—è–µ–º –∫–æ–ª–æ–Ω–∫–∏ –∫—Ä–æ–º–µ –¥–≤—É—Ö: –ß—Ç–æ –º–µ–Ω—è—Ç—å + –ù–∞ —á—Ç–æ –º–µ–Ω—è—Ç—å. –ò–Ω–∞—á–µ –±—É–¥–µ—Ç –æ—à–∏–±–∫–∞ –≤ —Ñ—É–Ω–∫—Ü–∏–∏ List.ReplaceMatchingItems
                    DelColumn  = Table.SelectColumns(Dict, {ColNames{0}, ColNames{1}}),

                //  –§–æ—Ä–º–∏—Ä—É–µ–º —Å–ø–∏—Å–æ–∫ –∑–∞–º–µ–Ω—ã –∏ –±—É—Ñ–µ—Ä–∏–∑–∏—Ä—É–µ–º –µ–≥–æ –¥–ª—è —É—Å–∫–æ—Ä–µ–Ω–∏—è
                    Lookup = List.Buffer(List.Zip(Table.ToColumns(DelColumn))),
                    
                //  –§–æ—Ä–º–∏—Ä—É–µ–º —Å–ø–∏—Å–æ–∫ (ID –ø–æ–∫–∞–∑–∞—Ç–µ–ª—è), –∫–æ—Ç–æ—Ä—ãq –Ω–∞–¥–æ –∑–∞–º–µ–Ω–∏—Ç—å –Ω–∞ –ø—Ä–∞–≤–∏–ª—å–Ω–æ–µ –Ω–∞–∑–≤–∞–Ω–∏–µ
                    Corrected = 
                        List.ReplaceMatchingItems(
                            Table.ToColumns(
                                Table.SelectColumns(–ò—Å—Ç–æ—á–Ω–∏–∫, {–ò–º—è–ö–æ–ª–æ–Ω–∫–∏–ò—Å—Ç–æ—á–Ω–∏–∫–∞} )
                            ){0}, 
                            Lookup
                        ),
                //  –†–µ–∑—É–ª—å—Ç–∞—Ç
                    Result = 
                        Table.FromColumns(
                            Table.ToColumns(–ò—Å—Ç–æ—á–Ω–∏–∫) & {Corrected}, 
                            Table.ColumnNames(–ò—Å—Ç–æ—á–Ω–∏–∫) & {–ò–º—è–ù–æ–≤–æ–π–ö–æ–ª–æ–Ω–∫–∏}
                    )
            in Result
        ]

//  #"04-EM-Table.Join" - –∞–Ω–∞–ª–æ–≥–∏ –í–ü–†
    let
        Source = fSales,
        #"Changed Type" = Table.TransformColumnTypes(Source,{{"Date", type date}, {"–¢–æ–≤–∞—Ä", type text}, {"Units", Int64.Type}}),
        #"04-EM-Table.Join"                 = Table.Join(#"Changed Type","–¢–æ–≤–∞—Ä",dProduct,"Product"),
        #"01-EM-Record.Field-RowColumn"     = Table.AddColumn(#"04-EM-Table.Join", "Price1",                    each Record.Field(dProduct{[Product=[–¢–æ–≤–∞—Ä]]},"Price"), type number),
        #"02-EM-List.PositionOf-ColumnRow"  = Table.AddColumn(#"01-EM-Record.Field-RowColumn", "Price2",        each dProduct[Price]{List.PositionOf(dProduct[Product],[–¢–æ–≤–∞—Ä])},type number),
        #"03-EM-AllSytax-RowColumn"         = Table.AddColumn(#"02-EM-List.PositionOf-ColumnRow", "Price3",     each dProduct{[Product=[–¢–æ–≤–∞—Ä]]}[Price],type number),
        #"05-AM-Table.SelectRows-RowColumn" = Table.AddColumn(#"03-EM-AllSytax-RowColumn", "Discount1",         each List.Last(Table.SelectRows(dDiscount, (IT) => IT[Units] <= [Units])[Discount]), type number),
        #"06-AM-List.Select-ColumnRow"      = Table.AddColumn(#"05-AM-Table.SelectRows-RowColumn", "Discount2", each dDiscount[Discount]{List.Count(let U = [Units] in List.Select(dDiscount[Units], each _ <= U))-1}, type number)
    in
        #"06-AM-List.Select-ColumnRow"

//  —Å–æ–∑–¥–∞–µ–º –ø—É—Å—Ç—É—é —Ç–∞–±–ª–∏—Ü—É –ø–æ –∏–º–µ–Ω–∏ –æ—Ç—á–µ—Ç–∞, —á—Ç–æ–±—ã —Å–≤—è–∑–∏ —Å –∫–∞–ª–µ–Ω–¥–∞—Ä–µ–º –Ω–µ –ø—Ä–æ–ø–∞–¥–∞–ª–∞
    form.BlankTable   = 
		(	tbl as table, 			// —Ç–∞–±–ª–∏—Ü–∞ —Å–æ —Å—Ö–µ–º–∞–º–∏ —Ç–∞–±–ª–∏—Ü –æ—Ç—á–µ—Ç–æ–≤
			REPORT_NAME as text		// –∏–º—è –æ—Ç—á–µ—Ç–∞
		) =>
			let
				//  REPORT_NAME = "odds",
				
				//	–µ—Å–ª–∏ —Å—Ö–µ–º–∞ –≤—Å–µ—Ö –æ—Ç—á–µ—Ç–Ω—ã—Ö —Ç–∞–±–ª–∏—Ü –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∞ Record
					nms  = Record.Field(tbl, REPORT_NAME)[Header],
				
				//	–µ—Å–ª–∏ —Å—Ö–µ–º–∞ –≤—Å–µ—Ö –æ—Ç—á–µ—Ç–Ω—ã—Ö —Ç–∞–±–ª–∏—Ü –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∞ Table
					nms2  = Table.Column(
								Table.SelectRows(tbl, each [–ê—Ç—Ä–∏–±—É—Ç] = REPORT_NAME)
								{0}[–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ], 	// –ø–µ—Ä–≤–∞—è —Å—Ç—Ä–æ–∫–∞ –∫–æ–ª–æ–Ω–∫–∏ [–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ] –≤ –æ—Å–Ω–æ–≤–Ω–æ–π —Ç–∞–±–ª–∏—Ü–µ 
								"Name" 				// –∏–º—è –∫–æ–ª–æ–Ω–∫–∏ —Å –Ω–∞–∑–≤–∞–Ω–∏—è–º–∏ –∫–æ–ª–æ–Ω–æ–∫ –≤ –ø–æ–¥—Ç–∞–±–ª–∏—Ü–µ
							),

				–ü—É—Å—Ç—ã–µ–ö–æ–ª–æ–Ω–∫–∏1 = List.Transform(nms, each {}),              // –ø—É—Å—Ç–∞—è —Ç–∞–±–ª–∏—Ü–∞ - —Å—Ç—Ä–æ–∫ –Ω–µ—Ç
				–ü—É—Å—Ç—ã–µ–ö–æ–ª–æ–Ω–∫–∏2 = List.Repeat( {{""}}, List.Count(nms) ),    // –ø—É—Å—Ç–∞—è —Ç–∞–±–ª–∏—Ü–∞ - —Å—Ç—Ä–æ–∫–∞ –æ–¥–Ω–∞ –ø—É—Å—Ç–∞—è
				
				from = Table.FromColumns(–ü—É—Å—Ç—ã–µ–ö–æ–ª–æ–Ω–∫–∏1, nms),              // —Å–æ–∑–¥–∞–µ–º —Ç–∞–±–ª–∏—Ü—É
				
				// –¥–æ–±–∞–≤–ª—è–µ–º —Å—Ç—Ä–æ–∫—É —Å –¥–∞—Ç–æ–π, —á—Ç–æ–±—ã –Ω–µ —Ä—É—à–∏–ª–∞—Å—å —Å–≤—è–∑—å —Å –∫–∞–ª–µ–Ω–¥–∞—Ä–µ–º
				–î–∞–Ω–Ω—ã–µ = {Record.FromList( 
							List.Transform(nms, 
								each if _ = "Date" 
									then #date(2023, 12, 1) 
									else null 
							), 
						nms) },

				fromOneRows = Table.InsertRows(from, 0, –î–∞–Ω–Ω—ã–µ),
				
				from5Columns = Table.SelectColumns(
								fromOneRows, 
								List.FirstN(Table.ColumnNames(fromOneRows),5) // –±–µ—Ä–µ–º –ø–µ—Ä–≤—ã–µ 5 –∫–æ–ª–æ–Ω–æ–∫
							),
				
				NewTable = 
					let create = 
							Table.FromRecords({[
								Date = #date(2024, 7, 9),  
								Company = null,
								DataSet = null,
								Report_ID = null
							]}),
						TypedTable = Table.TransformColumnTypes(create, {{"Date", type date}})
					in TypedTable,

				form.SetType      = // –¥–æ–±–∞–≤–ª–µ–Ω–∏–µ —Ç–∞–±–ª–∏—Ü—ã –ø–æ—Å–ª–µ –∏–º–ø–æ—Ä—Ç–∞, —Ç–∏–ø–∏–∑–∞—Ü–∏—è —Å—Ç–æ–ª–±—Ü–∞ –ø–æ —Å—Ö–µ–º–µ –≤ —Ç–∞–±–ª–∏—Ü–µ
					(tbl as table, tblShema as record, reportName as text)=>
						let 
							f=(x)=>
								List.Transform(
									Table.ToRecords( // —Å–ø–∏—Å–æ–∫ Record-–æ–≤
										Record.Field(tblShema, reportName) 
											[ [Header], [TypeName] ] // —Ç–∞–±–ª–∏—Ü–∞ –∏–∑ —Å–æ–¥–µ—Ä–∂–∏–º–æ–≥–æ Record —Å –¥–≤—É–º—è –ø–æ–ª—è–º–∏
									),
									each { [Header], F[form.TypeFromText]([TypeName]) }
								),
							to = Table.TransformColumnTypes(fromOneRows, f)
						in to,

				// —Ç–∏–ø–∏–∑–∏—Ä—É–µ–º —Å—Ç–æ–ª–±—Ü—ã
				typed = form.SetType(fromOneRows, tbl, REPORT_NAME)
			in
				// try typed 
				// otherwise NewTable
				typed,        